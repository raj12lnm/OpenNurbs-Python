#if !defined(OPENNURBS_INC_)
#define OPENNURBS_INC_
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

/*
////////////////////////////////////////////////////////////////
//
//   Includes all system headers required to use the openNURBS toolkit.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_SYSTEM_INC_)
#define OPENNURBS_SYSTEM_INC_

// The public release of opennurbs as a source code C++
// library is built with OPENNURBS_PUBLIC_RELEASE
// defined.
#define OPENNURBS_PUBLIC_RELEASE

/* compiler choice */
#if defined(_MSC_VER)

#if defined(OPENNURBS_EXPORTS)
// "OPENNURBS_EXPORTS" is Microsoft's prefered define to indicate
// an opennurbs DLL is being compiled.
#if !defined(ON_DLL_EXPORTS)
#define ON_DLL_EXPORTS
#endif
#if !defined(ON_COMPILING_OPENNURBS)
#define ON_COMPILING_OPENNURBS
#endif
#endif

#if defined(OPENNURBS_IMPORTS)
// "OPENNURBS_IMPORTS" is Microsoft's prefered define to indicate
// an opennurbs DLL is being linked with.
#if !defined(ON_DLL_IMPORTS)
#define ON_DLL_IMPORTS
#endif
#endif

/* using a Microsoft compiler */
#define ON_COMPILER_MSC

#if _MSC_VER >= 1300
#define ON_COMPILER_MSC1300
// If you are using VC7/.NET and are having trouble linking 
// to functions that have whcar_t types in arguments, then
// read the documentation about the wchar_t type and
// the /Zc:wchar_t compiler option.

#if _MSC_VER >= 1400
// Using at least Visual C++ 8.0 (2005)
#define ON_COMPILER_MSC1400


#if _MSC_VER >= 1600
// Using at least Visual C++ 10.0 (2010)
#define ON_COMPILER_MSC1600
#endif

// We are using /W4 wrning levels and disable
// these warnings.  I would prefer to use
// /W3 and enable the level 4 warnings we want,
// but microsoft does not have a way to use pragmas
// to enable specific warnings.

#if defined(ON_COMPILING_OPENNURBS)
#pragma warning(disable:4100) // C4100: 'identifier' : unreferenced formal parameter
#endif

#if !defined(_CRT_SECURE_NO_DEPRECATE)
#define _CRT_SECURE_NO_DEPRECATE
// Visual Studio 2005 issues a C4996 warning for lots of
// standard C runtime functions that take string pointers.
// The _CRT_SECURE_NO_DEPRECATE suppresses these warnings.
// If you are an IT manager type and really care about these
// sorts of things, then comment out the define.
#endif

#endif

#endif

#endif

#if defined(__GNUG_) || defined(__GNUG__) || defined(__GNUC_) || defined(__GNUC__) || defined(_GNU_SOURCE) || defined(__GNU_SOURCE)
/* using Gnu's compiler */
#if !defined(ON_COMPILER_GNU)
#define ON_COMPILER_GNU
#endif
#if !defined(_GNU_SOURCE)
#define _GNU_SOURCE
#endif
#endif

#if defined(sgi) || defined(__sgi)
#define ON_COMPILER_IRIX
#endif

#if defined(sun) || defined(__sun)
#define ON_COMPILER_SUN
#endif

#if defined(_GNU_SOURCE) && defined(__APPLE__)
/* using Apple's OSX Xcode compiler */
#if !defined(ON_COMPILER_XCODE)
#define ON_COMPILER_XCODE
#endif
#endif

#if defined(__BORLANDC__)
/* using Borland's compiler */
#define ON_COMPILER_BORLAND
#endif

// Sun Studio wants a prototype for _finite, give it one
#if defined(ON_COMPILER_SUN)
 int _finite(double);
#endif

/*
// Define ON_NO_WINDOWS if you are compiling on a Windows system but want
// to explicitly exclude inclusion of windows.h.
*/

#if !defined(ON_NO_WINDOWS)

/*
/////////////////////////////////////////////////////////////////////////
//
// Begin Windows system includes - 
*/
#if defined(_WIN32) || defined(WIN32) || defined(_WIN64) || defined(WIN64)

#if defined(_M_X64) && defined(WIN32) && defined(WIN64)
// 23 August 2007 Dale Lear

#if defined(_INC_WINDOWS)
// The user has included Microsoft's windows.h before opennurbs.h,
// and windows.h has nested includes that unconditionally define WIN32.
// Just undo the damage here or everybody that includes opennurbs.h after
// windows.h has to fight with this Microsoft bug.
#undef WIN32
#else
#error do not define WIN32 for x64 builds
#endif

// NOTE _WIN32 is defined for any type of Windows build
#endif

/*
// From windows.h openNURBS only needs definitions of ON_BOOL32, true,
// and false, and a declarations of OutputDebugString(), and
// WideCharToMultiByte().  These 
// defines disable the inclusion of most of the Windows garbage.
*/

#if defined(ON_COMPILER_MSC1600)
// include SKDDDKVer.h When using the v100 platform headers.
// Including SDKDDKVer.h defines the highest available Windows platform.
// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.
//#include <SDKDDKVer.h>
#endif

#if !defined(_WINDOWS_)
/* windows.h has not been read - read just what we need */
#define NOMINMAX
#define WIN32_LEAN_AND_MEAN  /* Exclude rarely-used stuff from Windows headers */
#include <windows.h>
#endif

#if defined(_M_X64) && defined(WIN32) && defined(WIN64)
// 23 August 2007 Dale Lear
//   windows.h unconditionally defines WIN32  This is a bug
//   and the hope is this simple undef will let us continue.
#undef WIN32
#endif

/*
// if ON_OS_WINDOWS is defined, debugging and error
// handing uses some Windows calls and ON_String
// includes resource support.
*/

#if !defined(ON_OS_WINDOWS)
#define ON_OS_WINDOWS
#endif

#if defined(ON_OS_WINDOWS) && !defined(NOGDI)
// ok to use Windows GDI RECT, LOGFONT, ... stucts.
#define ON_OS_WINDOWS_GDI
#endif

#if defined(_MSC_VER)
/* 
  Microsoft's Visual C/C++ requires some functions, including those that
  use vargs to be declared with __cdecl 
  Since this code must also compile with non-Micorosoft compilers, 
  the ON_MSC_CDECL macro is used to insert __cdecl when needed.
*/
#define ON_MSC_CDECL __cdecl

#endif

#endif

#endif

// NOTE: Do not use rand_s() - it crashes Win2000.
//
//#if defined(_MSC_VER) && !defined(_CRT_RAND_S)
//// In order to get high quality random numbers out of
//// Microsoft Visual Studio, you have to define _CRT_RAND_S
//// before including system header files.
//#define _CRT_RAND_S
//#endif

#ifdef __cplusplus
extern "C" {
#endif

#include <stdlib.h>
#include <memory.h>
#if defined(ON_COMPILER_XCODE)
#include <malloc/malloc.h>
#else
#include <stdlib.h>
#endif
#include <string.h>
#include <math.h>
#include <stdio.h>
#include <stdarg.h>
#include <float.h>
#include <time.h>
#include <limits.h>
#include <ctype.h>

/* these are for openindiana (opensolaris fork) */
#if 0
/* limits.h (sys/syslimits.h) should define this, but some don't */
#ifndef NAME_MAX
#  define NAME_MAX 255
#endif

#ifndef isfinite
#  define isfinite(x) (fpclassify(x) & (FP_NORMAL | FP_SUBNORMAL | FP_ZERO))
#endif
#endif

#if defined(ON_COMPILER_IRIX) || defined(ON_COMPILER_SUN)
#include <alloca.h>
#endif

#if !defined(ON_COMPILER_BORLAND)
#include <wchar.h>
#endif

#if defined(ON_OS_WINDOWS)
#include <io.h>
#include <sys/stat.h>
#include <tchar.h>

// ON_CreateUuid calls Windows's ::UuidCreate() which
// is declared in Rpcdce.h and defined in Rpcrt4.lib.
#include <Rpc.h>

#endif

#if defined(ON_COMPILER_GNU)
#include <sys/types.h>
#include <sys/stat.h>
#include <wctype.h>
#include <dirent.h>
#if defined(ON_COMPILER_XCODE)
#include <uuid/uuid.h>
#endif
#endif

#ifdef __cplusplus
} /* extern "C" */
#endif

#include <errno.h>

#if defined (cplusplus) || defined(_cplusplus) || defined(__cplusplus)
// C++ system includes

#if !defined(ON_CPLUSPLUS)
#define ON_CPLUSPLUS
#endif

#include <new> // for declaration of placement versions of new used in onClassArray<>.

#endif

#if !defined(ON_MSC_CDECL)
#define ON_MSC_CDECL
#endif

#if !defined(ON_OS_WINDOWS) && !defined(_GNU_SOURCE) && !defined(ON_COMPILER_XCODE)

/* define wchar_t, true, false, NULL */

#if !defined(true)
#define true true
#endif

#if !defined(false)
#define false false
#endif

#if !defined(NULL)
#define NULL 0
#endif

#if !defined(_WCHAR_T_DEFINED)
// If you are using VC7/.NET and are having trouble linking 
// to functions that have whcar_t types in arguments, then
// read the documentation about the wchar_t type and
// the /Zc:wchar_t compiler option.

// When opennurbs is built on a platform that has no
// wchar_t type, this typedef defines wchar_t to be
// an unsigned 16-bit integer and opennurbs will
// use UTF-16 encoding for wchar_t strings.

#if !defined(ON_COMPILER_MSC) && !defined(ON_COMPILER_GNU) && !defined(ON_COMPILER_SUN)
typedef ON__UINT16 wchar_t;
#endif

#define _WCHAR_T_DEFINED
#endif

#endif


// As 64 bit compilers become more common, the definitions
// of the next 6 typedefs may need to vary with compiler.
// As much as possible, the size of runtime types is left 
// up to the compiler so performance and ease of use can 
// be maximized.  In the rare cases where it is critical 
// to use an integer that is exactly 16 bits, 32 bits 
// or 64 bits, the ON__INT16, ON__INT32, and ON__INT64
// typedefs are used.

#if defined(_M_X64) || defined(_WIN64) || defined(__LP64__)
// 64 bit (8 byte) pointers
#define ON_SIZEOF_POINTER 8
#define ON_64BIT_POINTER
// ON_MAX_SIZET = maximum value of a size_t type
#define ON_MAX_SIZE_T 0xFFFFFFFFFFFFFFFF
#else
// 32 bit (4 byte) pointers
#define ON_SIZEOF_POINTER 4
#define ON_32BIT_POINTER
// ON_MAX_SIZET = maximum value of a size_t type
#define ON_MAX_SIZE_T 0xFFFFFFFF
#endif

// 8 bit integer
typedef char ON__INT8;

// 8 bit unsigned integer
typedef unsigned char ON__UINT8;

// 16 bit integer
typedef short ON__INT16;

// 16 bit unsigned integer
typedef unsigned short ON__UINT16;

// 32 bit integer
typedef int ON__INT32;

// 32 bit unsigned integer
typedef unsigned int ON__UINT32;

#if defined(ON_COMPILER_MSC)

// Microsoft uses __int64

// 64 bit integer
typedef __int64 ON__INT64;

// 64 bit unsigned integer
typedef unsigned __int64 ON__UINT64;

#elif defined(ON_COMPILER_GNU)

// GNU uses long long

// 64 bit integer
typedef long long ON__INT64;

// 64 bit unsigned integer
typedef unsigned long long ON__UINT64;

#elif defined(ON_COMPILER_SUN)

// Don't know for sure what Sun Studio
// uses, try long long

// 64 bit integer
typedef long long ON__INT64;

// 64 bit unsigned integer
typedef unsigned long long ON__UINT64;

#else

#error Verify that long long is a 64 bit integer with your compiler!

// 64 bit integer
typedef long long ON__INT64;

// 64 bit unsigned integer
typedef unsigned long long ON__UINT64;

#endif

// 32 bit boolean (true/false) value
// When we can break the SDK, this will be replaced with "bool", which is 1 byte on windows.
typedef int ON_BOOL32;

// ON_INT_PTR must be an integer type with sizeof(ON_INT_PTR) = sizeof(void*).
#if 8 == ON_SIZEOF_POINTER

#if defined(ON_COMPILER_GNU)
typedef long long ON__INT_PTR;
typedef unsigned long long ON__UINT_PTR;
#else
typedef __int64 ON__INT_PTR;
typedef unsigned __int64 ON__UINT_PTR;
#endif

#elif 4 == ON_SIZEOF_POINTER

typedef int ON__INT_PTR;
typedef unsigned int ON__UINT_PTR;

#else
#error Update OpenNURBS to work with new pointer size.
#endif



// In some functions, performance is slightly increased 
// when the endianess of the CPU is known at compile time.
// If the endianness is not known, it is quickly detected
// at runtime and all opennurbs code still works.
//
// If ON_LITTLE_ENDIAN is defined, then the code will
// is compiled assuming little endian byte order.
//
// If ON_BIG_ENDIAN is defined, then the code will
// is compiled assuming big endian byte order.
//
// If neither is defined, the endianess is determined at
// runtime.
//
// If both are defined, a compile error occures.

#if defined(ON_OS_WINDOWS) && defined(ON_COMPILER_MSC)

#if defined(_M_X64) || defined(_M_IX86)
#if !defined(ON_LITTLE_ENDIAN)
#define ON_LITTLE_ENDIAN
#endif
#endif

#endif

#if defined(ON_COMPILER_XCODE)
/* using Apple's OSX Xcode compiler */

#if (defined(__ppc__) || defined(__ppc64__))
#define ON_BIG_ENDIAN
#elif (defined (__i386__) || defined( __x86_64__ ))
#define ON_LITTLE_ENDIAN
#endif

#endif


#if defined(ON_LITTLE_ENDIAN) && defined(ON_BIG_ENDIAN)
#error At most one of ON_LITTLE_ENDIAN and ON_BIG_ENDIAN can be defined.
#endif


// on_vsnprintf()/on_vsnwprintf() call _vsnprintf()/_vsnwprintf() in Windows
// and something equivalent in other OSs

int on_vsnprintf( char *buffer, size_t count, const char *format, va_list argptr );

int on_vsnwprintf( wchar_t *buffer, size_t count, const wchar_t *format, va_list argptr );


#endif

/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_THREEDM_INC_)
#define OPENNURBS_THREEDM_INC_

/* 3dm defines, structs and typedefs */

/*  Typecode format 4 bytes long

   x xxxxxxxxxxxxxxx,x xxx xxxx xxxx x x xx
  | |               | |               | |  |
   |        |        |                 |
   |        |        |         |       +---  "stuff" bit
   |        |        |         |
   |        |        |         +-- specific codes
   |        |        |
   |        |        +-- RESERVED - DO NOT USE (should be 0) (will be used to control CRC on/off)
   |        |
   |        +-- category:_000 0000 0000 0001  Legacy geometry    TCODE_LEGACY_GEOMETRY
   |                     _000 0000 0000 0010  openNURBS object   TCODE_OPENNURBS_OBJECT
   |                     _000 0000 0000 0100  -- RESERVED - DO NOT USE (should be 0 in any typecode) --
   |                     _000 0000 0000 1000  -- RESERVED - DO NOT USE (should be 0 in any typecode) --
   |                     _000 0000 0001 0000  Geometry           TCODE_GEOMETRY
   |                     _000 0000 0010 0000  Annotation
   |                     _000 0000 0100 0000  Display Attributes TCODE_DISPLAY
   |                     _000 0000 1000 0000  Rendering          TCODE_RENDER
   |                     _000 0001 0000 0000
   |                     _000 0010 0000 0000  Interface          TCODE_INTERFACE
   |                     _000 0100 0000 0000  -- RESERVED - DO NOT USE (should be 0 in any typecode) --
   |                     _000 1000 0000 0000  Tolerances         TCODE_TOLERANCE
   |                     _001 0000 0000 0000  Tables             TCODE_TABLE
   |                     _010 0000 0000 0000  Table record       TCODE_TABLEREC
   |                     _100 0000 0000 0000  User information   TCODE_USER
   |
   +-- format: 0 - data size in header  - data block follows    TCODE_SHORT
               1 - data in header - no data block follows

*/


/*
// The TCODE_COMMENTBLOCK is the first chunk in the file, starts 32 bytes into
// the file, and contains text information terminated with a ^Z.  This ^Z and
// contents of this chunk were expanded in February 2000.  Files written with
// code released earlier than this will not have the ^Z.
//
// The TCODE_ENDOFFILE is the last chunk in the file and the first 4 bytes
// of information in this chunk is an integer that contains the file length.
// This chunk was added in February 2000 and files written with code released
// earlier than this will not have this termination block.
*/
#define TCODE_COMMENTBLOCK        0x00000001
#define TCODE_ENDOFFILE           0x00007FFF
#define TCODE_ENDOFFILE_GOO       0x00007FFE /*
                                             // this typecode is returned when
                                             // a rogue eof marker is found
                                             // Some v1 3dm file writers put
                                             // these markers in a "goo".
                                             // Simply skip these chunks and continue.
                                             */
#define TCODE_LEGACY_GEOMETRY     0x00010000
#define TCODE_OPENNURBS_OBJECT    0x00020000
#define TCODE_GEOMETRY            0x00100000
#define TCODE_ANNOTATION          0x00200000
#define TCODE_DISPLAY             0x00400000
#define TCODE_RENDER              0x00800000
#define TCODE_INTERFACE           0x02000000
#define TCODE_TOLERANCE           0x08000000
#define TCODE_TABLE               0x10000000
#define TCODE_TABLEREC            0x20000000
#define TCODE_USER                0x40000000
#define TCODE_SHORT               0x80000000

#define TCODE_CRC                 0x8000

#define TCODE_ANONYMOUS_CHUNK     (TCODE_USER | TCODE_CRC | 0x0000 )

/* The openNURBS toolkit allows users to write all openNURBS classed that are
// derived from ON_Object using using TCODE_OPENNURBS_CLASS chunks.
// In the .3dm file these TCODE_OPENNURBS_CLASS chunks are always have the
// following format.
*/

/* tables added 17 February 2000 */
#define TCODE_MATERIAL_TABLE   (TCODE_TABLE | 0x0010) /* rendering materials */
#define TCODE_LAYER_TABLE      (TCODE_TABLE | 0x0011) /* layers */
#define TCODE_LIGHT_TABLE      (TCODE_TABLE | 0x0012) /* rendering lights */
#define TCODE_OBJECT_TABLE     (TCODE_TABLE | 0x0013) /* geometry and annotation */
#define TCODE_PROPERTIES_TABLE (TCODE_TABLE | 0x0014) /* model properties:
                                                      //   revision history
                                                      //   notes
                                                      //   preview image
                                                      */
#define TCODE_SETTINGS_TABLE   (TCODE_TABLE | 0x0015) /* file properties including,
                                                      // units, tolerances,
                                                      // annotation defaults,
                                                      // render mesh defaults,
                                                      // current layer,
                                                      // current material,
                                                      // current color,
                                                      // named construction planes,
                                                      // named viewports,
                                                      // current viewports,
                                                      */
#define TCODE_BITMAP_TABLE    (TCODE_TABLE | 0x0016) /* embedded bitmaps */
#define TCODE_USER_TABLE      (TCODE_TABLE | 0x0017) /* user table */

#define TCODE_GROUP_TABLE     (TCODE_TABLE | 0x0018) /* group table */

#define TCODE_FONT_TABLE      (TCODE_TABLE | 0x0019) /* annotation font table */
#define TCODE_DIMSTYLE_TABLE  (TCODE_TABLE | 0x0020) /* annotation dimension style table */

#define TCODE_INSTANCE_DEFINITION_TABLE (TCODE_TABLE | 0x0021) /* instance definition table */

#define TCODE_HATCHPATTERN_TABLE (TCODE_TABLE | 0x0022) /* hatch pattern table */

#define TCODE_LINETYPE_TABLE (TCODE_TABLE | 0x0023) /* linetype table */

#define TCODE_OBSOLETE_LAYERSET_TABLE (TCODE_TABLE | 0x0024) /* obsolete layer set table */

#define TCODE_TEXTURE_MAPPING_TABLE (TCODE_TABLE | 0x0025) /* texture mappings */

#define TCODE_HISTORYRECORD_TABLE (TCODE_TABLE | 0x0026) /* history records */

#define TCODE_ENDOFTABLE          0xFFFFFFFF

/* records in properties table */
#define TCODE_PROPERTIES_REVISIONHISTORY (TCODE_TABLEREC | TCODE_CRC | 0x0021)
#define TCODE_PROPERTIES_NOTES           (TCODE_TABLEREC | TCODE_CRC | 0x0022)
#define TCODE_PROPERTIES_PREVIEWIMAGE    (TCODE_TABLEREC | TCODE_CRC | 0x0023)
#define TCODE_PROPERTIES_APPLICATION     (TCODE_TABLEREC | TCODE_CRC | 0x0024)
#define TCODE_PROPERTIES_COMPRESSED_PREVIEWIMAGE (TCODE_TABLEREC | TCODE_CRC | 0x0025)
#define TCODE_PROPERTIES_OPENNURBS_VERSION (TCODE_TABLEREC | TCODE_SHORT | 0x0026)

/* records in settings table */
#define TCODE_SETTINGS_PLUGINLIST             (TCODE_TABLEREC | TCODE_CRC   | 0x0135)
#define TCODE_SETTINGS_UNITSANDTOLS           (TCODE_TABLEREC | TCODE_CRC   | 0x0031)
#define TCODE_SETTINGS_RENDERMESH             (TCODE_TABLEREC | TCODE_CRC   | 0x0032)
#define TCODE_SETTINGS_ANALYSISMESH           (TCODE_TABLEREC | TCODE_CRC   | 0x0033)
#define TCODE_SETTINGS_ANNOTATION             (TCODE_TABLEREC | TCODE_CRC   | 0x0034)
#define TCODE_SETTINGS_NAMED_CPLANE_LIST      (TCODE_TABLEREC | TCODE_CRC   | 0x0035)
#define TCODE_SETTINGS_NAMED_VIEW_LIST        (TCODE_TABLEREC | TCODE_CRC   | 0x0036)
#define TCODE_SETTINGS_VIEW_LIST              (TCODE_TABLEREC | TCODE_CRC   | 0x0037)
#define TCODE_SETTINGS_CURRENT_LAYER_INDEX    (TCODE_TABLEREC | TCODE_SHORT | 0x0038)
#define TCODE_SETTINGS_CURRENT_MATERIAL_INDEX (TCODE_TABLEREC | TCODE_CRC   | 0x0039)
#define TCODE_SETTINGS_CURRENT_COLOR          (TCODE_TABLEREC | TCODE_CRC   | 0x003A)
#define TCODE_SETTINGS__NEVER__USE__THIS      (TCODE_TABLEREC | TCODE_CRC   | 0x003E)
#define TCODE_SETTINGS_CURRENT_WIRE_DENSITY   (TCODE_TABLEREC | TCODE_SHORT | 0x003C)
#define TCODE_SETTINGS_RENDER                 (TCODE_TABLEREC | TCODE_CRC   | 0x003D)
#define TCODE_SETTINGS_GRID_DEFAULTS          (TCODE_TABLEREC | TCODE_CRC   | 0x003F)
#define TCODE_SETTINGS_MODEL_URL              (TCODE_TABLEREC | TCODE_CRC   | 0x0131)
#define TCODE_SETTINGS_CURRENT_FONT_INDEX     (TCODE_TABLEREC | TCODE_SHORT | 0x0132)
#define TCODE_SETTINGS_CURRENT_DIMSTYLE_INDEX (TCODE_TABLEREC | TCODE_SHORT | 0x0133)
/* added 29 October 2002 as a chunk to hold new and future ON_3dmSettings information */
#define TCODE_SETTINGS_ATTRIBUTES             (TCODE_TABLEREC | TCODE_CRC   | 0x0134)


/* views are subrecords in the settings table */
#define TCODE_VIEW_RECORD            (TCODE_TABLEREC | TCODE_CRC   | 0x003B)
/* subrecords if view record */
#define TCODE_VIEW_CPLANE            (TCODE_TABLEREC | TCODE_CRC   | 0x013B)
#define TCODE_VIEW_VIEWPORT          (TCODE_TABLEREC | TCODE_CRC   | 0x023B)
#define TCODE_VIEW_SHOWCONGRID       (TCODE_TABLEREC | TCODE_SHORT | 0x033B)
#define TCODE_VIEW_SHOWCONAXES       (TCODE_TABLEREC | TCODE_SHORT | 0x043B)
#define TCODE_VIEW_SHOWWORLDAXES     (TCODE_TABLEREC | TCODE_SHORT | 0x053B)
#define TCODE_VIEW_TRACEIMAGE        (TCODE_TABLEREC | TCODE_CRC   | 0x063B)
#define TCODE_VIEW_WALLPAPER         (TCODE_TABLEREC | TCODE_CRC   | 0x073B)
#define TCODE_VIEW_WALLPAPER_V3      (TCODE_TABLEREC | TCODE_CRC   | 0x074B)
#define TCODE_VIEW_TARGET            (TCODE_TABLEREC | TCODE_CRC   | 0x083B)
#define TCODE_VIEW_DISPLAYMODE       (TCODE_TABLEREC | TCODE_SHORT | 0x093B)
#define TCODE_VIEW_NAME              (TCODE_TABLEREC | TCODE_CRC   | 0x0A3B)
#define TCODE_VIEW_POSITION          (TCODE_TABLEREC | TCODE_CRC   | 0x0B3B)

/* added 29 October 2002 as a chunk to hold new and future ON_3dmView information */
#define TCODE_VIEW_ATTRIBUTES        (TCODE_TABLEREC | TCODE_CRC   | 0x0C3B)

/* added 27 June 2008 as a chunk to hold userdata on ON_Viewports saved in named view list */
#define TCODE_VIEW_VIEWPORT_USERDATA (TCODE_TABLEREC | TCODE_CRC   | 0x0D3B)

/* records in bitmap table */
#define TCODE_BITMAP_RECORD (TCODE_TABLEREC | TCODE_CRC | 0x0090) /* bitmap table record derived from ON_Bitmap */

/* records in material table */
#define TCODE_MATERIAL_RECORD (TCODE_TABLEREC | TCODE_CRC | 0x0040) /* material table record derived from ON_Material */

/* records in layer table */
#define TCODE_LAYER_RECORD    (TCODE_TABLEREC | TCODE_CRC | 0x0050) /* layer table record derived from ON_Layer */

/* records in light table */
#define TCODE_LIGHT_RECORD            (TCODE_TABLEREC | TCODE_CRC | 0x0060)    /* light table record derived from ON_Light */
#define TCODE_LIGHT_RECORD_ATTRIBUTES (TCODE_INTERFACE | TCODE_CRC   | 0x0061) /* ON_3dmObjectAttributes chunk */
#define TCODE_LIGHT_RECORD_ATTRIBUTES_USERDATA (TCODE_INTERFACE | 0x0062)      /* ON_3dmObjectAttributes userdata chunk */

#define TCODE_LIGHT_RECORD_END        (TCODE_INTERFACE | TCODE_SHORT | 0x006F)

/* records in user table
     Each user table entery has two top level chunks, a TCODE_USER_TABLE_UUID chunk
     and a TCODE_USER_RECORD chunk.
*/

/* The TCODE_USER_TABLE_UUID chunk
   contains the plug-in id and, if the archive is V5 or later
   and was written by an opennurbs with version >= 200910190,
   a TCODE_USER_TABLE_RECORD_HEADER chunk.
*/
#define TCODE_USER_TABLE_UUID          (TCODE_TABLEREC | TCODE_CRC | 0x0080)
/* the user record header was added in 200910190 and is inside the TCODE_USER_TABLE_UUID chunk */
#define TCODE_USER_TABLE_RECORD_HEADER (TCODE_TABLEREC | TCODE_CRC | 0x0082)
/* information saved by the plug-in is in a TCODE_USER_RECORD chunk */
#define TCODE_USER_RECORD              (TCODE_TABLEREC | 0x0081)


/* records in group table */
#define TCODE_GROUP_RECORD             (TCODE_TABLEREC  | TCODE_CRC   | 0x0073)

/* records in font table */
#define TCODE_FONT_RECORD             (TCODE_TABLEREC  | TCODE_CRC   | 0x0074)

/* records in dimension style table */
#define TCODE_DIMSTYLE_RECORD          (TCODE_TABLEREC  | TCODE_CRC   | 0x0075)

/* records in instance definition table */
#define TCODE_INSTANCE_DEFINITION_RECORD  (TCODE_TABLEREC  | TCODE_CRC   | 0x0076)

/* records in hatch pattern table */
#define TCODE_HATCHPATTERN_RECORD  (TCODE_TABLEREC  | TCODE_CRC   | 0x0077)

/* records in linetye pattern table */
#define TCODE_LINETYPE_RECORD  (TCODE_TABLEREC  | TCODE_CRC   | 0x0078)

/* OBSOLETE records in layer set table */
#define TCODE_OBSOLETE_LAYERSET_RECORD  (TCODE_TABLEREC  | TCODE_CRC   | 0x0079)

/* records in linetye pattern table */
#define TCODE_TEXTURE_MAPPING_RECORD  (TCODE_TABLEREC  | TCODE_CRC   | 0x007A)

/* records in history record pattern table */
#define TCODE_HISTORYRECORD_RECORD  (TCODE_TABLEREC  | TCODE_CRC   | 0x007B)

/* records in object table */
#define TCODE_OBJECT_RECORD            (TCODE_TABLEREC  | TCODE_CRC   | 0x0070)
#define TCODE_OBJECT_RECORD_TYPE       (TCODE_INTERFACE | TCODE_SHORT | 0x0071)   /* ON::object_type value */
#define TCODE_OBJECT_RECORD_ATTRIBUTES (TCODE_INTERFACE | TCODE_CRC   | 0x0072)   /* ON_3dmObjectAttributes chunk */
#define TCODE_OBJECT_RECORD_ATTRIBUTES_USERDATA (TCODE_INTERFACE | 0x0073)        /* ON_3dmObjectAttributes userdata chunk */
#define TCODE_OBJECT_RECORD_HISTORY    (TCODE_INTERFACE | TCODE_CRC   | 0x0074)   /* construction history */
#define TCODE_OBJECT_RECORD_HISTORY_HEADER (TCODE_INTERFACE | TCODE_CRC | 0x0075) /* construction history header*/
#define TCODE_OBJECT_RECORD_HISTORY_DATA   (TCODE_INTERFACE | TCODE_CRC | 0x0076) /* construction history data */
#define TCODE_OBJECT_RECORD_END        (TCODE_INTERFACE | TCODE_SHORT | 0x007F)

/*
/////////////////////////////////////////////////////////////////////////////////////
//
// TCODE_OBJECT_RECORD
//   4 byte length of entire object record
//
//   TCODE_OBJECT_RECORD_TYPE required - used to quickly filter and skip unwanted objects
//     4 byte ON::object_type
//
//   TCODE_OPENNURBS_CLASS
//     4 byte length
//     TCODE_OPENNURBS_CLASS_UUID
//       4 byte length = 20
//       value of ON_ClassId::m_uuid for this class
//       4 byte CRC
//     TCODE_OPENNURBS_CLASS_DATA
//       4 byte length
//       class specific data for geometry or annotation object
//       4 byte CRC
//     TCODE_OPENNURBS_CLASS_USERDATA (1 chunk per piece of user data)
//       4 byte length
//       2 byte chunk version 2.1
//       TCODE_OPENNURBS_CLASS_USERDATA_HEADER
//         4 byte length
//         16 byte value of ON_ClassId::m_uuid for this child class of ON_UserData
//         16 byte value of ON_UserData::m_userdata_uuid
//         4 byte value of ON_UserData::m_userdata_copycount
//         128 byte value of ON_UserData::m_userdata_xform
//         16 byte value of  ON_UserData::m_application_uuid (in ver 2.1 chunks)
//       TCODE_ANONYMOUS_CHUNK
//         4 byte length
//         specific user data
//     TCODE_OPENNURBS_CLASS_END
//
//   TCODE_OBJECT_RECORD_ATTRIBUTES (optional)
//     4 byte length
//     ON_3dmObjectAttributes information
//     4 byte crc
//
//   TCODE_OBJECT_RECORD_ATTRIBUTES_USERDATA (optional)
//     4 byte length
//     TCODE_OPENNURBS_CLASS_USERDATA (1 chunk per piece of user data)
//       4 byte length
//       2 byte chunk version 2.1
//       TCODE_OPENNURBS_CLASS_USERDATA_HEADER
//         4 byte length
//         16 byte value of ON_ClassId::m_uuid for this child class of ON_UserData
//         16 byte value of ON_UserData::m_userdata_uuid
//         4 byte value of ON_UserData::m_userdata_copycount
//         128 byte value of ON_UserData::m_userdata_xform
//         16 byte value of  ON_UserData::m_application_uuid (in ver 2.1 chunks)
//       TCODE_ANONYMOUS_CHUNK
//         4 byte length
//         specific user data
//
//   TCODE_OBJECT_RECORD_HISTORY (optional) construction history
//     4 byte length
//     2 byte chunk version
//     TCODE_OBJECT_RECORD_HISTORY_HEADER
//       4 byte length
//       2 byte chunk version
//       ...
//       4 byte crc
//     TCODE_OBJECT_RECORD_HISTORY_DATA
//       4 byte length
//       2 byte chunk version
//       ...
//       4 byte crc
//
//   TCODE_OBJECT_RECORD_END required - marks end of object record
//
/////////////////////////////////////////////////////////////////////////////////////
*/

#define TCODE_OPENNURBS_CLASS          (TCODE_OPENNURBS_OBJECT               | 0x7FFA)
#define TCODE_OPENNURBS_CLASS_UUID     (TCODE_OPENNURBS_OBJECT | TCODE_CRC   | 0x7FFB)
#define TCODE_OPENNURBS_CLASS_DATA     (TCODE_OPENNURBS_OBJECT | TCODE_CRC   | 0x7FFC)
#define TCODE_OPENNURBS_CLASS_USERDATA (TCODE_OPENNURBS_OBJECT               | 0x7FFD)
#define TCODE_OPENNURBS_CLASS_USERDATA_HEADER (TCODE_OPENNURBS_OBJECT | TCODE_CRC | 0x7FF9)
#define TCODE_OPENNURBS_CLASS_END      (TCODE_OPENNURBS_OBJECT | TCODE_SHORT | 0x7FFF)

/*
/////////////////////////////////////////////////////////////////////////////////////
//
// TCODE_OPENNURBS_CLASS
// length of entire openNURBS class object chunk
//
//   TCODE_OPENNURBS_CLASS_UUID
//   length of uuid (16 byte UUID + 4 byte CRC)
//   16 byte UUID ( a.k.a. GUID ) openNURBS class ID - determines specific openNURBS class
//   4 bytes (32 bit CRC of the UUID)
//
//   TCODE_OPENNURBS_CLASS_DATA
//   length of object data
//   ... data that defines object
//       use ON_classname::Read() to read this data and ON_classname::Write()
//       to write this data
//   4 bytes (32 bit CRC of the object data)
//
//   TCODE_OPENNURBS_CLASS_USERDATA ( 0 or more user data chunks)
//
//   TCODE_OPENNURBS_CLASS_END
//   4 bytes = 0
//
/////////////////////////////////////////////////////////////////////////////////////
*/

/*
/////////////////////////////////////////////////////////////////////////////////////
//
//
//  The TCODEs below were used in the version 1 file format and are needed so that
//  the these files can be read and (optionally) written by the current OpenNURBS
//  toolkit.
//
//
/////////////////////////////////////////////////////////////////////////////////////
*/


#define TCODE_ANNOTATION_SETTINGS (TCODE_ANNOTATION | 0x0001)

#define TCODE_TEXT_BLOCK          (TCODE_ANNOTATION | 0x0004)
#define TCODE_ANNOTATION_LEADER   (TCODE_ANNOTATION | 0x0005)
#define TCODE_LINEAR_DIMENSION    (TCODE_ANNOTATION | 0x0006)
#define TCODE_ANGULAR_DIMENSION   (TCODE_ANNOTATION | 0x0007)
#define TCODE_RADIAL_DIMENSION    (TCODE_ANNOTATION | 0x0008)

/* old RhinoIO toolkit (pre February 2000) defines */
#define TCODE_RHINOIO_OBJECT_NURBS_CURVE   (TCODE_OPENNURBS_OBJECT | 0x0008) /* old CRhinoNurbsCurve   */
#define TCODE_RHINOIO_OBJECT_NURBS_SURFACE (TCODE_OPENNURBS_OBJECT | 0x0009) /* old CRhinoNurbsSurface */
#define TCODE_RHINOIO_OBJECT_BREP          (TCODE_OPENNURBS_OBJECT | 0x000B) /* old CRhinoBrep         */
#define TCODE_RHINOIO_OBJECT_DATA          (TCODE_OPENNURBS_OBJECT | 0xFFFE) /* obsolete - don't confuse with TCODE_OPENNURBS_OBJECT_DATA */
#define TCODE_RHINOIO_OBJECT_END           (TCODE_OPENNURBS_OBJECT | 0xFFFF) /* obsolete - don't confuse with TCODE_OPENNURBS_OBJECT_END */

/* OpenNURBS classes the require a unique tcode */
#define TCODE_OPENNURBS_BUFFER (TCODE_OPENNURBS_OBJECT | TCODE_CRC | 0x0100) /* chunk stores ON_Buffer classes */

/* legacy objects from Rhino 1.x */
#define TCODE_LEGACY_ASM          (TCODE_LEGACY_GEOMETRY | 0x0001)
#define TCODE_LEGACY_PRT          (TCODE_LEGACY_GEOMETRY | 0x0002)
#define TCODE_LEGACY_SHL          (TCODE_LEGACY_GEOMETRY | 0x0003)
#define TCODE_LEGACY_FAC          (TCODE_LEGACY_GEOMETRY | 0x0004)
#define TCODE_LEGACY_BND          (TCODE_LEGACY_GEOMETRY | 0x0005)
#define TCODE_LEGACY_TRM          (TCODE_LEGACY_GEOMETRY | 0x0006)
#define TCODE_LEGACY_SRF          (TCODE_LEGACY_GEOMETRY | 0x0007)
#define TCODE_LEGACY_CRV          (TCODE_LEGACY_GEOMETRY | 0x0008)
#define TCODE_LEGACY_SPL          (TCODE_LEGACY_GEOMETRY | 0x0009)
#define TCODE_LEGACY_PNT          (TCODE_LEGACY_GEOMETRY | 0x000A)

#define TCODE_STUFF               0x0100

#define TCODE_LEGACY_ASMSTUFF     (TCODE_LEGACY_GEOMETRY | TCODE_STUFF | TCODE_LEGACY_ASM)
#define TCODE_LEGACY_PRTSTUFF     (TCODE_LEGACY_GEOMETRY | TCODE_STUFF | TCODE_LEGACY_PRT)
#define TCODE_LEGACY_SHLSTUFF     (TCODE_LEGACY_GEOMETRY | TCODE_STUFF | TCODE_LEGACY_SHL)
#define TCODE_LEGACY_FACSTUFF     (TCODE_LEGACY_GEOMETRY | TCODE_STUFF | TCODE_LEGACY_FAC)
#define TCODE_LEGACY_BNDSTUFF     (TCODE_LEGACY_GEOMETRY | TCODE_STUFF | TCODE_LEGACY_BND)
#define TCODE_LEGACY_TRMSTUFF     (TCODE_LEGACY_GEOMETRY | TCODE_STUFF | TCODE_LEGACY_TRM)
#define TCODE_LEGACY_SRFSTUFF     (TCODE_LEGACY_GEOMETRY | TCODE_STUFF | TCODE_LEGACY_SRF)
#define TCODE_LEGACY_CRVSTUFF     (TCODE_LEGACY_GEOMETRY | TCODE_STUFF | TCODE_LEGACY_CRV)
#define TCODE_LEGACY_SPLSTUFF     (TCODE_LEGACY_GEOMETRY | TCODE_STUFF | TCODE_LEGACY_SPL)
#define TCODE_LEGACY_PNTSTUFF     (TCODE_LEGACY_GEOMETRY | TCODE_STUFF | TCODE_LEGACY_PNT)

/* legacy objects from Rhino 1.x */
#define TCODE_RH_POINT            (TCODE_GEOMETRY | 0x0001)

#define TCODE_RH_SPOTLIGHT        (TCODE_RENDER   | 0x0001)

#define TCODE_OLD_RH_TRIMESH          (TCODE_GEOMETRY | 0x0011)
#define TCODE_OLD_MESH_VERTEX_NORMALS (TCODE_GEOMETRY | 0x0012)
#define TCODE_OLD_MESH_UV             (TCODE_GEOMETRY | 0x0013)
#define TCODE_OLD_FULLMESH            (TCODE_GEOMETRY | 0x0014)


#define TCODE_MESH_OBJECT         (TCODE_GEOMETRY | 0x0015)
#define TCODE_COMPRESSED_MESH_GEOMETRY   (TCODE_GEOMETRY | 0x0017)
#define TCODE_ANALYSIS_MESH       (TCODE_GEOMETRY | 0x0018)

#define TCODE_NAME                (TCODE_INTERFACE | 0x0001)
#define TCODE_VIEW                (TCODE_INTERFACE | 0x0002)
#define TCODE_CPLANE              (TCODE_INTERFACE | 0x0003)

#define TCODE_NAMED_CPLANE        (TCODE_INTERFACE | 0x0004)
#define TCODE_NAMED_VIEW          (TCODE_INTERFACE | 0x0005)
#define TCODE_VIEWPORT            (TCODE_INTERFACE | 0x0006)

#define TCODE_SHOWGRID            (TCODE_SHORT | TCODE_INTERFACE | 0x0007)
#define TCODE_SHOWGRIDAXES        (TCODE_SHORT | TCODE_INTERFACE | 0x0008)
#define TCODE_SHOWWORLDAXES       (TCODE_SHORT | TCODE_INTERFACE | 0x0009)

#define TCODE_VIEWPORT_POSITION   (TCODE_INTERFACE | 0x000A)
#define TCODE_VIEWPORT_TRACEINFO  (TCODE_INTERFACE | 0x000B)
#define TCODE_SNAPSIZE            (TCODE_INTERFACE | 0x000C)
#define TCODE_NEAR_CLIP_PLANE     (TCODE_INTERFACE | 0x000D)
#define TCODE_HIDE_TRACE          (TCODE_INTERFACE | 0x000E)

#define TCODE_NOTES               (TCODE_INTERFACE | 0x000F)
#define TCODE_UNIT_AND_TOLERANCES (TCODE_INTERFACE | 0x0010)

#define TCODE_MAXIMIZED_VIEWPORT  (TCODE_SHORT | TCODE_INTERFACE | 0x0011)
#define TCODE_VIEWPORT_WALLPAPER  (TCODE_INTERFACE | 0x0012)


#define TCODE_SUMMARY             (TCODE_INTERFACE | 0x0013)
#define TCODE_BITMAPPREVIEW       (TCODE_INTERFACE | 0x0014)
#define TCODE_VIEWPORT_DISPLAY_MODE  (TCODE_SHORT | TCODE_INTERFACE | 0x0015)


#define TCODE_LAYERTABLE          (TCODE_SHORT   | TCODE_TABLE    | 0x0001) /* obsolete - do not use */
#define TCODE_LAYERREF            (TCODE_SHORT   | TCODE_TABLEREC | 0x0001)

#define TCODE_XDATA               (TCODE_USER | 0x0001)

#define TCODE_RGB                 (TCODE_SHORT   | TCODE_DISPLAY | 0x0001)
#define TCODE_TEXTUREMAP          (TCODE_DISPLAY | 0x0002)
#define TCODE_BUMPMAP             (TCODE_DISPLAY | 0x0003)
#define TCODE_TRANSPARENCY        (TCODE_SHORT   | TCODE_DISPLAY | 0x0004)
#define TCODE_DISP_AM_RESOLUTION  (TCODE_SHORT   | TCODE_DISPLAY | 0x0005)
#define TCODE_RGBDISPLAY          (TCODE_SHORT   | TCODE_DISPLAY | 0x0006)  /* will be used for color by object */
#define TCODE_RENDER_MATERIAL_ID  (TCODE_DISPLAY | 0x0007)                  /* id for render material */

#define TCODE_LAYER               (TCODE_DISPLAY | 0x0010)

/* obsolete layer typecodes from earlier betas - not used anymore */
#define TCODE_LAYER_OBSELETE_1    (TCODE_SHORT   | TCODE_DISPLAY | 0x0013)
#define TCODE_LAYER_OBSELETE_2    (TCODE_SHORT   | TCODE_DISPLAY | 0x0014)
#define TCODE_LAYER_OBSELETE_3    (TCODE_SHORT   | TCODE_DISPLAY | 0x0015)

/* these were only ever used by AccuModel and never by Rhino */
#define TCODE_LAYERON             (TCODE_SHORT   | TCODE_DISPLAY | 0x0016)
#define TCODE_LAYERTHAWED         (TCODE_SHORT   | TCODE_DISPLAY | 0x0017)
#define TCODE_LAYERLOCKED         (TCODE_SHORT   | TCODE_DISPLAY | 0x0018)


#define TCODE_LAYERVISIBLE        (TCODE_SHORT   | TCODE_DISPLAY | 0x0012)
#define TCODE_LAYERPICKABLE       (TCODE_SHORT   | TCODE_DISPLAY | 0x0030)
#define TCODE_LAYERSNAPABLE       (TCODE_SHORT   | TCODE_DISPLAY | 0x0031)
#define TCODE_LAYERRENDERABLE     (TCODE_SHORT   | TCODE_DISPLAY | 0x0032)


/* use LAYERSTATE ( 0 = LAYER_ON, 1 = LAYER_OFF, 2 = LAYER_LOCKED ) instead of above individual toggles */
#define TCODE_LAYERSTATE          (TCODE_SHORT   | TCODE_DISPLAY | 0x0033)
#define TCODE_LAYERINDEX          (TCODE_SHORT   | TCODE_DISPLAY | 0x0034)
#define TCODE_LAYERMATERIALINDEX  (TCODE_SHORT   | TCODE_DISPLAY | 0x0035)

#define TCODE_RENDERMESHPARAMS    (TCODE_DISPLAY | 0x0020) /* block of parameters for render meshes */



#define TCODE_DISP_CPLINES        (TCODE_SHORT   | TCODE_DISPLAY | 0x0022)
#define TCODE_DISP_MAXLENGTH      (TCODE_DISPLAY | 0x0023)

#define TCODE_CURRENTLAYER        (TCODE_SHORT   | TCODE_DISPLAY | 0x0025 )

#define TCODE_LAYERNAME           (TCODE_DISPLAY | 0x0011)

#define TCODE_LEGACY_TOL_FIT      (TCODE_TOLERANCE | 0x0001)
#define TCODE_LEGACY_TOL_ANGLE    (TCODE_TOLERANCE | 0x0002)

#define TCODE_DICTIONARY          (TCODE_USER | TCODE_CRC   | 0x0010)
#define TCODE_DICTIONARY_ID       (TCODE_USER | TCODE_CRC   | 0x0011)
#define TCODE_DICTIONARY_ENTRY    (TCODE_USER | TCODE_CRC   | 0x0012)
#define TCODE_DICTIONARY_END      (TCODE_USER | TCODE_SHORT | 0x0013)

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

////////////////////////////////////////////////////////////////
//
//   Includes all openNURBS toolkit defines and enums.
//
////////////////////////////////////////////////////////////////

#if !defined(OPENNURBS_DEFINES_INC_)
#define OPENNURBS_DEFINES_INC_

#if defined (cplusplus) || defined(_cplusplus) || defined(__cplusplus) || defined(ON_CPLUSPLUS)
// C++ extern "C" declaration for C linkage

#if !defined(ON_CPLUSPLUS)
#define ON_CPLUSPLUS
#endif
#define ON_EXTERNC extern "C"
#define ON_BEGIN_EXTERNC extern "C" {
#define ON_END_EXTERNC   }

#else

/* C file - no extern declaration required or permitted */

#define ON_EXTERNC
#define ON_BEGIN_EXTERNC
#define ON_END_EXTERNC  

#endif


#if defined(_DEBUG)
/* enable OpenNurbs debugging code */
#if !defined(ON_DEBUG)
#define ON_DEBUG
#endif
#endif

/*
// Declarations in header (.H) files look like
//
//   ON_DECL type function():
//   extern ON_EXTERN_DECL type global_variable;
//   class ON_CLASS classname {};
//   ON_TEMPLATE template class ON_CLASS template<T>;
//
*/

#if defined(OPENNURBS_EXPORTS)
// OPENNURBS_EXPORTS is Microsoft's prefered defined for building an opennurbs DLL.
#if !defined(ON_DLL_EXPORTS)
#define ON_DLL_EXPORTS
#endif
#if !defined(ON_COMPILING_OPENNURBS)
#define ON_COMPILING_OPENNURBS
#endif
#endif

#if defined(OPENNURBS_IMPORTS)
// OPENNURBS_EXPORTS is Microsoft's prefered defined for linking with an opennurbs DLL.
#if !defined(ON_DLL_IMPORTS)
#define ON_DLL_IMPORTS
#endif
#endif

#if defined(ON_DLL_EXPORTS) && defined(ON_DLL_IMPORTS)
#error At most one of ON_DLL_EXPORTS and ON_DLL_IMPORTS can be defined.
#endif

/* export/import */
#if defined(ON_DLL_EXPORTS)

#if !defined(ON_COMPILING_OPENNURBS)
#error When compiling an OpenNURBS DLL, ON_DLL_EXPORTS must be defined
#endif

/* compiling OpenNurbs as a Windows DLL - export classes, functions, templates, and globals */
#define ON_CLASS __declspec(dllexport)
#define ON_DECL __declspec(dllexport)
#define ON_EXTERN_DECL __declspec(dllexport)
#define ON_DLL_TEMPLATE

#elif defined(ON_DLL_IMPORTS)

#if defined(ON_COMPILING_OPENNURBS)
#error When compiling an OpenNURBS DLL, ON_DLL_IMPORTS must NOT be defined
#endif

/* using OpenNurbs as a Windows DLL - import classes, functions, templates, and globals */
#define ON_CLASS __declspec(dllimport)
#define ON_DECL __declspec(dllimport)
#define ON_EXTERN_DECL __declspec(dllimport)
#define ON_DLL_TEMPLATE extern

#else

/* compiling or using OpenNurbs as a static library */
#define ON_CLASS
#define ON_DECL
#define ON_EXTERN_DECL

#if defined(ON_DLL_TEMPLATE)
#undef ON_DLL_TEMPLATE
#endif

#endif


// ON_DEPRECATED is used to mark deprecated functions.
#if defined(ON_COMPILER_MSC)
#define ON_DEPRECATED  __declspec(deprecated)
#else
#define ON_DEPRECATED
#endif

#if defined(PI)
#define ON_PI           PI
#else
#define ON_PI           3.141592653589793238462643
#endif

#define ON_DEGREES_TO_RADIANS ON_PI/180.0
#define ON_RADIANS_TO_DEGREES 180.0/ON_PI

#define ON_SQRT2          1.414213562373095048801689
#define ON_SQRT3          1.732050807568877293527446
#define ON_SQRT3_OVER_2   0.8660254037844386467637230
#define ON_1_OVER_SQRT2   0.7071067811865475244008445
#define ON_SIN_PI_OVER_12 0.2588190451025207623488990
#define ON_COS_PI_OVER_12 0.9659258262890682867497433

#define ON_LOG2         0.6931471805599453094172321
#define ON_LOG10        2.302585092994045684017991

#define ON_ArrayCount(a) (sizeof(a)/sizeof((a)[0]))

#if defined(DBL_MAX)
#define ON_DBL_MAX DBL_MAX
#else
#define ON_DBL_MAX 1.7976931348623158e+308
#endif

#if defined(DBL_MIN)
#define ON_DBL_MIN DBL_MIN
#else
#define ON_DBL_MIN 2.22507385850720200e-308
#endif

// ON_EPSILON = 2^-52
#if defined(DBL_EPSILON)
#define ON_EPSILON DBL_EPSILON
#else
#define ON_EPSILON 2.2204460492503131e-16
#endif
#define ON_SQRT_EPSILON 1.490116119385000000e-8

#if defined(FLT_EPSILON)
#define ON_FLOAT_EPSILON FLT_EPSILON
#else
#define ON_FLOAT_EPSILON 1.192092896e-07
#endif
#define ON_SQRT_FLOAT_EPSILON 3.452669830725202719e-4

/*
// In cases where lazy evaluation of a double value is
// performed, b-rep tolerances being a notable example,
// this value is used to indicate the value has not been
// computed.  This value must be < -1.0e308. and > -ON_DBL_MAX
//
// The reasons ON_UNSET_VALUE is a valid finite number are:
//
//   1) It needs to round trip through fprintf/sscanf.
//   2) It needs to persist unchanged through assigment
/       and not generate exceptions when assigned.
//   3) ON_UNSET_VALUE == ON_UNSET_VALUE needs to be true.
//   4) ON_UNSET_VALUE != ON_UNSET_VALUE needs to be false.
//
// Ideally, it would also have these SNaN attributes
//   * When used in a calculation, a floating point exception
//     occures.
//   * No possibility of a valid calculation would generate
//     ON_UNSET_VALUE.
//   * float f = (float)ON_UNSET_VALUE would create an invalid
//     float and generate an exception.
*/
#define ON_UNSET_VALUE -1.23432101234321e+308

/*
// ON_UNSET_FLOAT is used to indicate a texture coordinate
// value cannot be calculated or is not well defined.  
// In hindsight, this value should have been ON_FLT_QNAN
// because many calculation convert float texture coordinates
// to doubles and the "unset"ness attribute is lost.
*/
#define ON_UNSET_FLOAT -1.234321e+38f


ON_BEGIN_EXTERNC

// IEEE 754 special values
extern ON_EXTERN_DECL const double ON_DBL_QNAN;
extern ON_EXTERN_DECL const double ON_DBL_PINF;
extern ON_EXTERN_DECL const double ON_DBL_NINF;

extern ON_EXTERN_DECL const float  ON_FLT_QNAN;
extern ON_EXTERN_DECL const float  ON_FLT_PINF;
extern ON_EXTERN_DECL const float  ON_FLT_NINF;

/*
Description:
Paramters:
  x - [out] returned value of x is an SNan
            (signalling not a number).
Remarks:
  Any time an SNaN passes through an Intel FPU, the result
  is a QNaN (quiet nan) and the invalid operation excpetion
  flag is set.  If this exception is not masked, then the
  exception handler is invoked.
 
    double x, y;
    ON_DBL_SNAN(&x);
    y = x;     // y = QNAN and invalid op exception occurs
    z = sin(x) // z = QNAN and invalid op exception occurs

  So, if you want to reliably initialize doubles to SNaNs, 
  you must use memcpy() or some other method that does not
  use the Intel FPU.
*/
ON_DECL
void ON_DBL_SNAN( double* x );

ON_DECL
void ON_FLT_SNAN( float* x );

ON_END_EXTERNC

/*
// In cases where lazy evaluation of a color value is
// performed, this value is used to indicate the value 
// has not been computed.
*/
#define ON_UNSET_COLOR 0xFFFFFFFF

/*
// In cases when an absolute "zero" tolerance 
// is required to compare model space coordinates,
// ON_ZERO_TOLERANCE is used.  The value of
// ON_ZERO_TOLERANCE should be no smaller than
// ON_EPSILON and should be several orders of 
// magnitude smaller than ON_SQRT_EPSILON
// 
*/
//#define ON_ZERO_TOLERANCE 1.0e-12
// ON_ZERO_TOLERANCE = 2^-32
#define ON_ZERO_TOLERANCE 2.3283064365386962890625e-10

/*
// In cases when an relative "zero" tolerance is
// required for comparing model space coordinates, 
// (fabs(a)+fabs(b))*ON_RELATIVE_TOLERANCE is used.
// ON_RELATIVE_TOLERANCE should be larger than
// ON_EPSILON and smaller than no larger than 
// ON_ZERO_TOLERANCE*2^-10.
// 
*/
// ON_RELATIVE_TOLERANCE = 2^-42
#define ON_RELATIVE_TOLERANCE 2.27373675443232059478759765625e-13

/*
// Bugs in geometry calculations involving world coordinates 
// values > ON_MAXIMUM_WORLD_COORDINATE_VALUE
// will be a low priority.
*/
// ON_MAXIMUM_VALUE = 2^27
#define ON_MAXIMUM_WORLD_COORDINATE_VALUE 1.34217728e8

/*
// The default test for deciding if a curvature value should be
// treated as zero is 
// length(curvature) <= ON_ZERO_CURVATURE_TOLERANCE.
// ON_ZERO_CURVATURE_TOLERANCE must be set so that
// ON_ZERO_CURVATURE_TOLERANCE >= sqrt(3)*ON_ZERO_TOLERANCE
// so that K.IsTiny() = true implies |K| <= ON_ZERO_CURVATURE_TOLERANCE
*/
#define ON_ZERO_CURVATURE_TOLERANCE 1.0e-8

/* default value for angle tolerances = 1 degree */
#define ON_DEFAULT_ANGLE_TOLERANCE (ON_PI/180.0)
#define ON_DEFAULT_ANGLE_TOLERANCE_COSINE 0.99984769515639123915701155881391
#define ON_MINIMUM_ANGLE_TOLERANCE (ON_DEFAULT_ANGLE_TOLERANCE/10.0)

// pair of integer indices.  This
// is intentionally a struct/typedef
// rather than a class so that it
// can be used in other structs.
struct tagON_2dex
{
  int i;
  int j;
};

typedef struct tagON_2dex ON_2dex;

// triplet of integer indices.  This
// is intentionally a struct/typedef
// rather than a class so that it
// can be used in other structs.
struct tagON_3dex
{
  int i;
  int j;
  int k;
};

typedef struct tagON_3dex ON_3dex;


// quadruplet of integer indices.  This
// is intentionally a struct/typedef
// rather than a class so that it
// can be used in other structs.
struct tagON_4dex
{
  int i;
  int j;
  int k;
  int l;
};

typedef struct tagON_4dex ON_4dex;

union ON_U
{
  char      b[8]; // 8 bytes
  ON__INT64 h;    // 64 bit integer
  ON__INT32 i;    // 32 bit integer
  int       j[2]; // two 32 bit integers
  void*     p;
  double    d;
};

#if defined(ON_CPLUSPLUS)

// OpenNurbs enums
class ON_CLASS ON
{
public:
  /*
  Description:
    Call before using openNURBS to ensure all class definitions
    are linked.
  */
  static void Begin();


  /*
  Description:
    Call when finished with openNURBS.
  Remarks:
    Currently does nothing.
  */
  static void End();

  //////////
  // Version of opennurbs (YYYYMMDDn)
  static
  int Version();

  //////////
  // McNeel subversion revsion used to build opennurbs
  static
  const char* SourceRevision();

  static
  const char* DocumentationRevision();

  static
  const char* SourceBranch();

  static
  const char* DocumentationBranch();


  //// File open/close for DLL use ///////////////////////////////////////////////

  static
  FILE* OpenFile( // like fopen() - needed when OpenNURBS is used as a DLL
          const char* filename,
          const char* filemode
          );

  static
  FILE* OpenFile( // like fopen() - needed when OpenNURBS is used as a DLL
          const wchar_t* filename,
          const wchar_t* filemode
          );

  static
  int CloseFile( // like fclose() - needed when OpenNURBS is used as a DLL
          FILE* // pointer returned by OpenFile()
          );

  static
  int CloseAllFiles(); // like _fcloseall() - needed when OpenNURBS is used as a DLL

  /*
  Description:
    Uses the flavor of fstat that is appropriate for the platform.
  Parameters:
    filename - [in]
    fp - [in]
    filesize - [out] (can be NULL if you do not want filesize)
    create_time - [out] (can be NULL if you do not want last create time)
    lastmodify_time - [out] (can be NULL if you do not want last modification time)
  Returns:
    True if file exists, can be opened for read, and fstat worked.
  */
  static
  bool GetFileStats( const wchar_t* filename,
                     size_t* filesize,
                     time_t* create_time,
                     time_t* lastmodify_time
                    );

  static
  bool GetFileStats( FILE* fp,
                     size_t* filesize,
                     time_t* create_time,
                     time_t* lastmodify_time
                    );

  /*
  Returns true if pathname is a directory.
  */
  static bool IsDirectory( const wchar_t* pathname );
  static bool IsDirectory( const char* utf8pathname );

  /*
  Returns
    If the file is an opennurbs file, the version of the file
    is returned (2,3,4,50,...).
    If the file is not an opennurbs file, 0 is returned.
  */
  static int IsOpenNURBSFile( const wchar_t* pathname );
  static int IsOpenNURBSFile( const char* utf8pathname );
  static int IsOpenNURBSFile( FILE* fp );

  //// Dimension Types ///////////////////////////////////////////////////////////
  enum eAnnotationType
  {
    dtNothing,
    dtDimLinear,
    dtDimAligned,
    dtDimAngular,
    dtDimDiameter,
    dtDimRadius,
    dtLeader,
    dtTextBlock,
    dtDimOrdinate
  };

  static eAnnotationType AnnotationType(int); // convert integer to eAnnotationType enum


  //// Text Display Modes ///////////////////////////////////////////////////////////
  enum eTextDisplayMode
  {
    dtNormal = 0,
    dtHorizontal = 1,
    dtAboveLine = 2,
    dtInLine = 3
  };

  static eTextDisplayMode TextDisplayMode( int);

  // Defines the current working space.
  enum active_space
  {
    no_space    = 0,
    model_space = 1, // 3d modeling or "world" space
    page_space  = 2  // page/layout/paper/printing space
  };

  static active_space ActiveSpace(int); // convert integer to active_space enum



  //// unit_system ///////////////////////////////////////////////////////////////
  enum unit_system
  {
    // The constant enum values are saved in 3dm files 
    // and must never be changed.  The values > 11 were
    // added 5 April 2006.
    no_unit_system =  0, 

    // atomic distances
    angstroms      = 12,  // 1.0e-10 meters

    // SI units
    nanometers     = 13,  // 1.0e-9 meters
    microns        =  1,  // 1.0e-6 meters
    millimeters    =  2,  // 1.0e-3 meters
    centimeters    =  3,  // 1.0e-2 meters
    decimeters     = 14,  // 1.0e-1 meters
    meters         =  4,
    dekameters     = 15,  // 1.0e+1 meters
    hectometers    = 16,  // 1.0e+2 meters
    kilometers     =  5,  // 1.0e+3 meters
    megameters     = 17,  // 1.0e+6 meters
    gigameters     = 18,  // 1.0e+9 meters

    // english distances
    microinches    =  6,  //    2.54e-8 meters (1.0e-6 inches)
    mils           =  7,  //    2.54e-5 meters (0.001 inches)
    inches         =  8,  //    0.0254  meters
    feet           =  9,  //    0.3408  meters (12 inches)
    yards          = 19,  //    0.9144  meters (36 inches)
    miles          = 10,  // 1609.344   meters (5280 feet)

    // printer distances
    printer_point  = 20,  // 1/72 inches (computer points)
    printer_pica   = 21,  // 1/6 inches  (computer picas)

    // terrestrial distances
    nautical_mile  = 22, // 1852 meters 
                         //    Approximately 1 minute of arc on a terrestrial great circle.
                         //    See http://en.wikipedia.org/wiki/Nautical_mile.

    // astronomical distances
    astronomical   = 23, // 1.4959787e+11 // http://en.wikipedia.org/wiki/Astronomical_unit
                         // 1.495979e+11  // http://units.nist.gov/Pubs/SP811/appenB9.htm  
                         //    An astronomical unit (au) is the mean distance from the 
                         //    center of the earth to the center of the sun.
    lightyears     = 24, // 9.4607304725808e+15 // http://en.wikipedia.org/wiki/Light_year
                         // 9.46073e+15 meters  // http://units.nist.gov/Pubs/SP811/appenB9.htm
                         //    A light year is the distance light travels in one Julian year.
                         //    The speed of light is exactly 299792458 meters/second.
                         //    A Julian year is exactly 365.25 * 86400 seconds and is 
                         //    approximately the time it takes for one earth orbit.
    parsecs        = 25, // 3.08567758e+16  // http://en.wikipedia.org/wiki/Parsec
                         // 3.085678e+16    // http://units.nist.gov/Pubs/SP811/appenB9.htm  

    // Custom unit systems
    custom_unit_system = 11 // x meters with x defined in ON_3dmUnitsAndTolerances.m_custom_unit_scale
  };

  static unit_system UnitSystem(int); // convert integer to unit_system enum

  /*
  Description:
    Scale factor for changing unit "standard" systems.
  Parameters:
    us_from - [in]
    us_to - [in] 
  For example:

          100.0 = ON::UnitScale( ON::meters, ON::centimeters ) 
          2.54  = ON::UnitScale( ON::inches, ON::centimeters ) 
          12.0  = ON::UnitScale( ON::feet,   ON::inches ) 

  Remarks:
    If you are using custom unit systems, use the version
    that takes ON_UnitSystem or ON_3dmUnitsAndTolerances 
    parameters.
  */
  static double UnitScale(
      ON::unit_system us_from,
      ON::unit_system us_to
      );
  static double UnitScale(
      const class ON_UnitSystem& us_from, 
      const class ON_UnitSystem& us_to
      );
  static double UnitScale(
      ON::unit_system us_from,
      const class ON_UnitSystem& us_to
      );
  static double UnitScale(
      const class ON_UnitSystem& us_from, 
      ON::unit_system us_to
      );
  static double UnitScale(
      const class ON_3dmUnitsAndTolerances& us_from, 
      const class ON_3dmUnitsAndTolerances& us_to
      );


  /*
  Description:
    Returns the string " : ".  This is the string Rhino uses
    to separate reference model names from the root name for 
    things like layer, block definition, material, linetype,
    dimstyle and font names.  
  See Also:
    ON::NameReferenceDelimiterLength()
    ON::IsNameReferenceDelimiter()
  */
  static const wchar_t* NameReferenceDelimiter();

  /*
  Description:
    Returns the number of characters in the string returned
    by ON::NameReferenceDelimiter().
  See Also:
    ON::NameReferenceDelimiterLength()
    ON::IsNameReferenceDelimiter()
  */
  static unsigned int NameReferenceDelimiterLength();

  /*
  Description:
    Test a string to see if its beginning matches the 
    string returned by ON::NameReferenceDelimiter().
  Parameters:
    s - [in];
      string to test.
  Returns:
    null:
      The beginning of the string does not match ON::NameReferenceDelimiter().
    non-null:
      The beginning of the string matches ON::NameReferenceDelimiter(). The
      returned pointer is the first character in s after the last character
      of the delimiter.  Put another way, if the beginning of s matches
      the string  ON::NameReferenceDelimiter(), then the returned pointer is
      s + ON::NameReferenceDelimiterLength().
  See Also:
    ON::NameReferenceDelimiter()
    ON::NameReferenceDelimiterLength()
  */
  static const wchar_t* IsNameReferenceDelimiter(const wchar_t* s);

  //// distance_display_mode ///////////////////////////////////
  enum distance_display_mode
  {
    decimal     = 0, 
    fractional  = 1,
    feet_inches = 2
  };

  static distance_display_mode DistanceDisplayMode(int); // convert integer to distance_display_mode enum


  //// point_style ///////////////////////////////////////////////////////////////
  enum point_style 
  {
    unknown_point_style   = 0,
    not_rational          = 1,
    homogeneous_rational  = 2,
    euclidean_rational    = 3,
    intrinsic_point_style = 4, // point format used in definition
    point_style_count     = 5
  };

  static point_style PointStyle(int); // convert integer to point_style enum

  //// knot_style ///////////////////////////////////////////////////////////////
  enum knot_style // if a knot vector meets the conditions of two styles,
  {               // then the style with the lowest value is used
    unknown_knot_style     = 0, // unknown knot style
    uniform_knots          = 1, // uniform knots (ends not clamped)
    quasi_uniform_knots    = 2, // uniform knots (clamped ends, degree >= 2)
    piecewise_bezier_knots = 3, // all internal knots have full multiplicity
    clamped_end_knots      = 4, // clamped end knots (with at least 1 interior non-uniform knot)
    non_uniform_knots      = 5, // known to be none of the above
    knot_style_count       = 6
  };

  static knot_style KnotStyle(int); // convert integer to knot_style enum

  //// continuity ////////////////////////////////////////////////////////////////
  enum continuity
  {
    unknown_continuity = 0,

    // These test for parametric continuity.  In particular,
    // all types of ON_Curves are considered infinitely 
    // continuous at the start/end of the evaluation domain.
    C0_continuous =  1, // continuous function
    C1_continuous =  2, // continuous first derivative
    C2_continuous =  3, // continuous first and second derivative
    G1_continuous =  4, // continuous unit tangent
    G2_continuous =  5, // continuous unit tangent and curvature

    // 20 March 2003 Dale Lear added these.
    //
    // Continuity tests using the following enum values
    // are identical to tests using the preceding enum values
    // on the INTERIOR of a curve's domain.  At the END of
    // a curve a "locus" test is performed in place of a 
    // parametric test. In particular, at the END of a domain,
    // all open curves are locus discontinuous.  At the END of
    // a domain, all closed curves are at least C0_locus_continuous.
    // By convention all ON_Curves are considered 
    // locus continuous at the START of the evaluation domain.
    // This convention is not strictly correct, but is was
    // adopted to make iterative kink finding tools easier to
    // use and so that locus discontinuities are reported once
    // at the end parameter of a curve rather than twice.
    C0_locus_continuous =  6, // locus continuous function
    C1_locus_continuous =  7, // locus continuous first derivative
    C2_locus_continuous =  8, // locus continuous first and second derivative
    G1_locus_continuous =  9, // locus continuous unit tangent
    G2_locus_continuous = 10, // locus continuous unit tangent and curvature

    Cinfinity_continuous = 11, // analytic discontinuity
    Gsmooth_continuous = 12    // aesthetic discontinuity
  };

  /*
  Description:
    Convert int to ON::continuity enum value
  */
  static continuity Continuity(int);

  /*
  Description:
    Convert int to ON::continuity enum value and
    convert the locus flavored values to the parametric
    flavored values.
  */
  static continuity ParametricContinuity(int);

  /*
  Description:
    Convert int to ON::continuity enum value and
    convert the higher order flavored values to 
    the corresponding C1 or G1 values needed to
    test piecewise linear curves.
  */
  static continuity PolylineContinuity(int);

  //// curve_style ///////////////////////////////////////////////////////////////
  enum curve_style 
  {
    unknown_curve_style   =  0,
    line                  =  1,
    circle                =  2,
    ellipse               =  3, // with distinct foci (not a circle)
    parabola              =  4,
    hyperbola             =  5,
    planar_polyline       =  6, // not a line segment
    polyline              =  7, // non-planar polyline
    planar_freeform_curve =  8, // planar but none of the above
    freeform_curve        =  9, // known to be none of the above
    curve_style_count     = 10
  };

  static curve_style CurveStyle(int); // convert integer to curve_style enum

  //// surface_style ///////////////////////////////////////////////////////////////
  enum surface_style 
  {
    unknown_surface_style =  0,
    plane                 =  1,
    circular_cylinder     =  2, // portion of right circular cylinder
    elliptical_cylinder   =  3, // portion of right elliptical cylinder
    circular_cone         =  4, // portion of right circular cone
    elliptical_cone       =  5, // portion of right elliptical cone
    sphere                =  6, // portion of sphere
    torus                 =  7, // portion of torus
    surface_of_revolution =  8, // portion of surface of revolution that is none of the above
    ruled_surface         =  9, // portion of a ruled surface this is none of the above
    freeform_surface      = 10, // known to be none of the above
    surface_style_count   = 11
  };

  static surface_style SurfaceStyle(int); // convert integer to surface_style enum

  //// sort_algorithm ///////////////////////////////////////////////////////////////
  enum sort_algorithm
  {
    heap_sort  = 0,
    quick_sort = 1
  };

  static sort_algorithm SortAlgorithm(int); // convert integer to sort_method enum

  //// endian-ness ///////////////////////////////////////////////////////////////
  enum endian {
    little_endian = 0, // least significant byte first or reverse byte order - Intel x86, ...
    big_endian    = 1  // most significant byte first - Motorola, Sparc, MIPS, ...
  };

  static endian Endian(int); // convert integer to endian enum
  static endian Endian();    // returns endian-ness of current CPU

  //// archive modes //////////////////////////////////////////////////////////////
  enum archive_mode
  {
    unknown_archive_mode = 0,
    read      = 1, // all read modes have bit 0x0001 set
    write     = 2, // all write modes have bit 0x0002 set
    readwrite = 3,
    read3dm   = 5,
    write3dm  = 6
  };
  static archive_mode ArchiveMode(int); // convert integer to endian enum


  //// view projections ///////////////////////////////////////////////////////////

  // The x/y/z_2pt_perspective_view projections are ordinary perspective
  // projection. Using these values insures the ON_Viewport member 
  // fuctions properly constrain the camera up and camera direction vectors
  // to preserve the specified perspective vantage.
  enum view_projection
  { 
    unknown_view       = 0,
    parallel_view      = 1,
    perspective_view   = 2
  };

  /*
  Description:
    Converts integer into ON::view_projection enum value.
  Parameters:
    i - [in]
  Returns:
    ON::view_projection enum with same value as i.
    If i is not an ON::view_projection enum value,
    then ON::unknow_view is returned.
  */
  static view_projection ViewProjection(int i);

  /*
  Parameters:
    projection - [in]
  Returns:
    True if projection is ON::perspective_view.
  */
  static bool IsPerspectiveProjection( ON::view_projection projection );


  /*
  Parameters:
    projection - [in]
  Returns:
    True if projection is ON::parallel_view.
  */
  static bool IsParallelProjection( ON::view_projection projection );

  //// view coordinates ///////////////////////////////////////////////////////////

  enum coordinate_system 
  {
    world_cs  = 0, 
    camera_cs = 1, 
    clip_cs   = 2, 
    screen_cs = 3 
  };

  static coordinate_system CoordinateSystem(int); // convert integer to coordinate_system enum

  //// exception types ///////////////////////////////////////////////////////////
	enum exception_type 
  {
    unknown_exception = 0,
		out_of_memory,  
    corrupt_object,               // invalid object encountered - continuing would crash or
                                  // result in corrupt object being saved in archive.
		unable_to_write_archive,      // write operation failed - out of file space/read only mode/...?
		unable_to_read_archive,       // read operation failed - truncated archive/locked file/... ?
		unable_to_seek_archive,       // seek operation failed - locked file/size out of bounds/... ?
		unexpected_end_of_archive,    // truncated archive
		unexpected_value_in_archive   // corrupt archive?
  };
  static exception_type ExceptionType(int); // convert integer to exception_type enum

  //// layer mode ///////////////////////////////////////////////////////////
  // OBSOLETE 
	enum layer_mode 
  {
    normal_layer       = 0, // visible, objects on layer can be selected and changed
    hidden_layer       = 1, // not visible, objects on layer cannot be selected or changed
    locked_layer       = 2, // visible, objects on layer cannot be selected or changed
    layer_mode_count   = 3
  };
  static layer_mode LayerMode(int); // convert integer to layer_mode enum

  //// object mode ///////////////////////////////////////////////////////////
	enum object_mode 
  {
    normal_object    = 0, // object mode comes from layer
    hidden_object    = 1, // not visible, object cannot be selected or changed
    locked_object    = 2, // visible, object cannot be selected or changed
    idef_object      = 3, // object is part of an ON_InstanceDefinition.  The
                          // ON_InstanceDefinition m_object_uuid[] array will
                          // contain this object attribute's uuid.
    object_mode_count = 4
  };
  static object_mode ObjectMode(int); // convert integer to object_mode enum

  //// object display color /////////////////////////////////////////////////////////
	enum object_color_source
  {
    color_from_layer    = 0, // use color assigned to layer
    color_from_object   = 1, // use color assigned to object
    color_from_material = 2, // use diffuse render material color
    color_from_parent   = 3  // for objects with parents (like objects in instance references, use parent linetype)
                             // if no parent, treat as color_from_layer
  };
  static object_color_source ObjectColorSource(int); // convert integer to object_color_source enum

  //// object plot color /////////////////////////////////////////////////////////
	enum plot_color_source
  {
    plot_color_from_layer   = 0, // use plot color assigned to layer
    plot_color_from_object  = 1, // use plot color assigned to object
    plot_color_from_display = 2, // use display color
    plot_color_from_parent  = 3  // for objects with parents (like objects in instance references, use parent plot color)
                                 // if no parent, treat as plot_color_from_layer
  };
  static plot_color_source PlotColorSource(int); // convert integer to plot_color_source enum

  //// object plot weight /////////////////////////////////////////////////////////
	enum plot_weight_source
  {
    plot_weight_from_layer   = 0, // use plot color assigned to layer
    plot_weight_from_object  = 1, // use plot color assigned to object
    plot_weight_from_parent  = 3  // for objects with parents (like objects in instance references, use parent plot color)
                                  // if no parent, treat as plot_color_from_layer
  };
  static plot_weight_source PlotWeightSource(int); // convert integer to plot_color_source enum

  //// object linetype /////////////////////////////////////////////////////////
	enum object_linetype_source
  {
    linetype_from_layer  = 0, // use line style assigned to layer
    linetype_from_object = 1, // use line style assigned to object
    linetype_from_parent = 3  // for objects with parents (like objects in instance references, use parent linetype)
                              // if not parent, treat as linetype_from_layer.
  };
  static object_linetype_source ObjectLinetypeSource(int); // convert integer to object_linetype_source enum

  //// object material /////////////////////////////////////////////////////////
	enum object_material_source
  {
    material_from_layer  = 0, // use material assigned to layer
    material_from_object = 1, // use material assigned to object
    material_from_parent = 3  // for objects with parents, like 
                              // definition geometry in instance
                              // references and faces in polysurfaces,
                              // this value indicates the material
                              // definition should come from the parent.
                              // If the object does not have an 
                              // obvious "parent", then treat
                              // it the same as material_from_layer.
  };
  static object_material_source ObjectMaterialSource(int); // convert integer to object_color_source enum

  //// light style /////////////////////////////////////////////////////////////
  enum light_style
  {
    unknown_light_style      = 0,
    //view_directional_light   = 1, // light location and direction in clip coordinates
    //view_point_light         = 2,
    //view_spot_light          = 3,
    camera_directional_light = 4, // light location and direction in camera coordinates
    camera_point_light       = 5, //   +x points to right, +y points up, +z points towards camera
    camera_spot_light        = 6,
    world_directional_light  = 7, // light location and direction in world coordinates
    world_point_light        = 8, 
    world_spot_light         = 9,
    ambient_light            = 10, // pure ambient light
    world_linear_light       = 11,
    world_rectangular_light  = 12,
    light_style_count        = 13
  };
  static light_style LightStyle(int); // convert integer to light_style enum

  //// curvature style /////////////////////////////////////////////////////////
  enum curvature_style
  {
    unknown_curvature_style = 0,
    gaussian_curvature = 1,
    mean_curvature = 2, // unsigned mean curvature
    min_curvature  = 3, // minimum unsigned radius of curvature
    max_curvature  = 4, // maximum unsigned radius of curvature
    curvature_style_count = 5
  };
  static curvature_style CurvatureStyle(int); // convert integer to curvature_style enum

  //// view display mode /////////////////////////////////////////////////////////////
  enum display_mode
  {
    default_display       = 0, // default display
    wireframe_display     = 1, // wireframe display
    shaded_display        = 2, // shaded display
    renderpreview_display = 3  // render preview display
  };
  static display_mode DisplayMode(int); // convert integer to display_mode enum


  enum view_type
  {
    model_view_type  = 0,       // standard model space 3d view
    page_view_type   = 1,       // a.k.a "paper space", "plot view", etc.
                                // A page view must be orthographic,
                                // the camera frame x,y,z direction must be
                                // world x,y,z (which means the camera direction
                                // is always (0,0,-1)).  
    nested_view_type = 2        // This view is a "model" view that is nested
                                // in another view.  The nesting and parent
                                // information is saved in ON_3dmView.
  };
  static view_type ViewType(int); // convert integer to display_mode enum


  //// texture mapping mode ///////////////////////////////////////////////////
  //
  // OBSOLETE 
  enum texture_mode
  {
    no_texture = 0,        // texture disabled
    modulate_texture = 1,  // modulate with material diffuse color
    decal_texture = 2      // decal
  };
  // OBSOLETE 
  static texture_mode TextureMode(int); // convert integer to texture_mode enum
  // OBSOLETE 
  //
  /////////////////////////////////////////////////////////////////////////////

  //// object_type ///////////////////////////////////////////////////
  enum object_type
  {
    // Use with ON_Object::ObjectType() in situations where
    // using a switch() is better than a long string of if else if ...
    // if ( ON_Curve::Cast() ) ... else if ( ON_Surface::Cast() ) ...
    // ...
    unknown_object_type  =          0,

    point_object         =          1, // some type of ON_Point
    pointset_object      =          2, // some type of ON_PointCloud, ON_PointGrid, ...
    curve_object         =          4, // some type of ON_Curve like ON_LineCurve, ON_NurbsCurve, etc.
    surface_object       =          8, // some type of ON_Surface like ON_PlaneSurface, ON_NurbsSurface, etc.
    brep_object          =       0x10, // some type of ON_Brep
    mesh_object          =       0x20, // some type of ON_Mesh
    layer_object         =       0x40, // some type of ON_Layer
    material_object      =       0x80, // some type of ON_Material
    light_object         =      0x100, // some type of ON_Light
    annotation_object    =      0x200, // some type of ON_Annotation
    userdata_object      =      0x400, // some type of ON_UserData
    instance_definition  =      0x800, // some type of ON_InstanceDefinition
    instance_reference   =     0x1000, // some type of ON_InstanceRef
    text_dot             =     0x2000, // some type of ON_TextDot
    grip_object          =     0x4000, // selection filter value - not a real object type
    detail_object        =     0x8000, // some type of ON_DetailView
    hatch_object         =    0x10000, // some type of ON_Hatch
    morph_control_object =    0x20000, // some type of ON_MorphControl
    loop_object          =    0x80000, // some type of ON_BrepLoop
    polysrf_filter       =   0x200000, // selection filter value - not a real object type
    edge_filter          =   0x400000, // selection filter value - not a real object type
    polyedge_filter      =   0x800000, // selection filter value - not a real object type
    meshvertex_object    = 0x01000000, // some type of ON_MeshVertexRef
    meshedge_object      = 0x02000000, // some type of ON_MeshEdgeRef
    meshface_object      = 0x04000000, // some type of ON_MeshFaceRef
    cage_object          = 0x08000000, // some type of ON_NurbsCage
    phantom_object       = 0x10000000,
    clipplane_object     = 0x20000000,
    beam_object          = 0x40000000, // obsolete - use extrusion_object
    extrusion_object     = 0x40000000, // some type of ON_Extrusion
    
    any_object           = 0xFFFFFFFF

    // Please discuss any changes with Dale Lear
  };

  static object_type ObjectType(int); // convert integer to object_type enum

  //// bitmap_type ///////////////////////////////////////////////////
  enum bitmap_type
  {
    unknown_bitmap_type = 0,
    windows_bitmap = 1,     // BITMAPINFO style
    opengl_bitmap = 2,      // unpacked OpenGL RGB or RGBA
    png_bitmap = 3
  };
  static bitmap_type BitmapType(int); // convert integer to bitmap_type enum

  enum object_decoration
  {
    no_object_decoration = 0,
    start_arrowhead      = 0x08, // arrow head at start
    end_arrowhead        = 0x10, // arrow head at end
    both_arrowhead       = 0x18  // arrow heads at start and end
  };
  static object_decoration ObjectDecoration(int); // convert integer to line_pattern enum

  enum mesh_type
  {
    default_mesh  = 0,
    render_mesh   = 1,
    analysis_mesh = 2,
    preview_mesh  = 3,
    any_mesh      = 4
  };
  static mesh_type MeshType(int); // convert integer to mesh_type enum


  // Types of object snapping.  
  // In situations where more than one type of snap applies, 
  // snaps with higher value take precedence.
  // enum values must be a power of 2.
  // ON_ObjRef saves these values in files.  Do not change
  // the values.  The reason for the gaps between the enum
  // values is to leave room for future snaps with prededence
  // falling between existing snaps
  enum osnap_mode
  {
    os_none          =          0,
    os_near          =          2,
    os_focus         =          8,
    os_center        =       0x20,
    os_vertex        =       0x40,
    os_knot          =       0x80,
    os_quadrant      =      0x200,
    os_midpoint      =      0x800,
    os_intersection  =     0x2000,
    os_end           =    0x20000,
    os_perpendicular =    0x80000,
    os_tangent       =   0x200000,
    os_point         = 0x08000000,
    os_all_snaps     = 0xFFFFFFFF
  };
  static osnap_mode OSnapMode(int); // convert integer to osnap_mode enum


  //// Types of Curves ///////////////////////////////////////////////////////////
  enum eCurveType
  {
    ctCurve, // nothing
    ctArc,
    ctCircle,
    ctLine,
    ctNurbs,
    ctOnsurface,
    ctProxy,
    ctPolycurve,
    ctPolyline
  };


  //// surface_loft_end_condition //////////////////////////////////////////////
  //
  // End condition paramter values for  ON_Curve::CreateCubicLoft() and
  // ON_Surface::CreateCubicLoft().
  enum cubic_loft_end_condition
  {
    cubic_loft_ec_quadratic      = 0,
    cubic_loft_ec_linear         = 1,
    cubic_loft_ec_cubic          = 2,
    cubic_loft_ec_natural        = 3,
    cubic_loft_ec_unit_tangent   = 4,
    cubic_loft_ec_1st_derivative = 5,
    cubic_loft_ec_2nd_derivative = 6,
    cubic_loft_ec_free_cv        = 7
  };

  /*
  Description:
    Convert an integer to cubic_loft_end_condition enum.
  Parameters:
    i - [in]
  Returns:
    corresponding cubic_loft_end_condition enum value.
  Remarks:
    If i does not correspond to a cubic_loft_end_condition
    enum value, then cubic_loft_ec_quadratic is returned.
  */
  static 
  cubic_loft_end_condition CubicLoftEndCondition(int i); 

private:
  // prohibit instantiaion
  //ON();             // no implementation
  //ON( const ON& );  // no implementation
  //~ON();            // no implementation
};


/*
Description:
  Component indices are used to provide a persistent way
  to identify portions of complex objects.

*/
class ON_CLASS ON_COMPONENT_INDEX
{
public:

  // Do not change these values; they are stored in 3dm archives
  // and provide a persistent way to indentify components of
  // complex objects.
  enum TYPE
  {
    invalid_type       =   0,

    brep_vertex        =   1,
    brep_edge          =   2,
    brep_face          =   3,
    brep_trim          =   4,
    brep_loop          =   5,

    mesh_vertex        =  11,
    meshtop_vertex     =  12,
    meshtop_edge       =  13,
    mesh_face          =  14,

    idef_part          =  21,

    polycurve_segment  =  31,

    pointcloud_point   =  41,

    group_member       =  51,


    extrusion_bottom_profile = 61, // 3d bottom profile curves
                                   //   index identifies profile component
    extrusion_top_profile    = 62, // 3d top profile curves
                                   //   index identifies profile component
    extrusion_wall_edge      = 63, // 3d wall edge curve
                                   //   index/2: identifies profile component
                                   //   index%2: 0 = start, 1 = end
    extrusion_wall_surface   = 64, // side wall surfaces
                                   //   index: identifies profile component
    extrusion_cap_surface    = 65, // bottom and top cap surfaces
                                   //   index: 0 = bottom, 1 = top
    extrusion_path           = 66, // extrusion path (axis line)
                                   //   index -1 = entire path, 0 = start point, 1 = endpoint

    dim_linear_point   = 100,
    dim_radial_point   = 101,
    dim_angular_point  = 102,
    dim_ordinate_point = 103,
    dim_text_point     = 104,

    no_type           = 0xFFFFFFFF
  };

  /*
  Description:
    Safe conversion of integer value to TYPE enum.
  Parameters:
    i - [in] integer with value equal to one of the TYPE enums.
  Returns:
    The TYPE enum with the same numeric value 
    or ON_COMPONENT_INDEX::invalid_type if no corresponding enum
    exists.
  */
  static 
  TYPE Type(int i);

  /*
  Description:
    Dictionary compare on m_type, m_index as ints.
  Returns:
    < 0: a < b
    = 0: a = b
    > 0: a > b
  */
  static
  int Compare( const ON_COMPONENT_INDEX* a, const ON_COMPONENT_INDEX* b);

  /*
  Description:
    Sets m_type = invalid_type and m_index = -1.
  */
  ON_COMPONENT_INDEX();

  /*
  Description:
    Sets m_type = type and m_index = index.
  */
  ON_COMPONENT_INDEX(TYPE type,int index);

  bool operator==(const ON_COMPONENT_INDEX& other) const;
  bool operator!=(const ON_COMPONENT_INDEX& other) const;
  bool operator<(const ON_COMPONENT_INDEX& other) const;
  bool operator<=(const ON_COMPONENT_INDEX& other) const;
  bool operator>(const ON_COMPONENT_INDEX& other) const;
  bool operator>=(const ON_COMPONENT_INDEX& other) const;

  void Set(TYPE type,int index);

  /*
  Description:
    Sets m_type = invalid_type and m_index = -1.
  */
  void UnSet();

  /*
  Returns:
    True if m_type is set to a TYPE enum value between
    brep_vertex and polycurve_segment.
  */
  bool IsSet() const;

  /*
  Returns:
    True if m_type is set to one of the mesh or meshtop
    TYPE enum values and m_index >= 0.
  */
  bool IsMeshComponentIndex() const;

  /*
  Returns:
    True if m_type is set to one of the 
    brep TYPE enum values and m_index >= 0.
  */
  bool IsBrepComponentIndex() const;

  /*
  Returns:
    True if m_type = idef_part and m_index >= 0.
  */
  bool IsIDefComponentIndex() const;

  /*
  Returns:
    True if m_type = polycurve_segment and m_index >= 0.
  */
  bool IsPolyCurveComponentIndex() const;

  /*
  Returns:
    True if m_type = group_member and m_index >= 0.
  */
  bool IsGroupMemberComponentIndex() const;

  /*
  Returns:
    True if m_type = extrusion_bottom_profile or extrusion_top_profile
    and m_index >= 0.
  */
  bool IsExtrusionProfileComponentIndex() const;

  /*
  Returns:
    True if m_type = extrusion_path and -1 <= m_index <= 1.
  */
  bool IsExtrusionPathComponentIndex() const;

  /*
  Returns:
    True if m_type = extrusion_wall_edge and m_index >= 0.
  */
  bool IsExtrusionWallEdgeComponentIndex() const;

  /*
  Returns:
    True if m_type = extrusion_wall_surface and m_index >= 0.
  */
  bool IsExtrusionWallSurfaceComponentIndex() const;

  /*
  Returns:
    True if m_type = extrusion_wall_surface or extrusion_wall_edge
    and m_index >= 0.
  */
  bool IsExtrusionWallComponentIndex() const;

  /*
  Returns:
    True if m_type = extrusion_bottom_profile, extrusion_top_profile,
    extrusion_wall_edge, extrusion_wall_surface, extrusion_cap_surface
    or extrusion_path and m_index is reasonable.
  */
  bool IsExtrusionComponentIndex() const;

  /*
  Returns:
    True if m_type = pointcloud_point and m_index >= 0.
  */
  bool IsPointCloudComponentIndex() const;

  /*
  Returns:
    True if m_type = dim_... and m_index >= 0.
  */
  bool IsAnnotationComponentIndex() const;

  TYPE m_type;

  /*
  The interpretation of m_index depends on the m_type value.

    m_type             m_index interpretation (0 based indices)

    no_type            used when context makes it clear what array is being index
    brep_vertex        ON_Brep.m_V[] array index
    brep_edge          ON_Brep.m_E[] array index
    brep_face          ON_Brep.m_F[] array index
    brep_trim          ON_Brep.m_T[] array index
    brep_loop          ON_Brep.m_L[] array index
    mesh_vertex        ON_Mesh.m_V[] array index
    meshtop_vertex     ON_MeshTopology.m_topv[] array index
    meshtop_edge       ON_MeshTopology.m_tope[] array index
    mesh_face          ON_Mesh.m_F[] array index
    idef_part          ON_InstanceDefinition.m_object_uuid[] array index
    polycurve_segment  ON_PolyCurve::m_segment[] array index

    extrusion_bottom_profile  Use ON_Extrusion::Profile3d() to get 3d profile curve
    extrusion_top_profile     Use ON_Extrusion::Profile3d() to get 3d profile curve
    extrusion_wall_edge       Use ON_Extrusion::WallEdge() to get 3d line curve
    extrusion_wall_surface    Use ON_Extrusion::WallSurface() to get 3d wall surface
    extrusion_cap_surface      0 = bottom cap, 1 = top cap
    extrusion_path            -1 = entire path, 0 = start of path, 1 = end of path

    dim_linear_point   ON_LinearDimension2::POINT_INDEX
    dim_radial_point   ON_RadialDimension2::POINT_INDEX
    dim_angular_point  ON_AngularDimension2::POINT_INDEX
    dim_ordinate_point ON_OrdinateDimension2::POINT_INDEX
    dim_text_point     ON_TextEntity2 origin point
  */
  int m_index;
};

#endif

ON_BEGIN_EXTERNC

/*
Description:
  Sets Windows code page used to convert UNICODE (wchar_t) strings
  to multibyte (char) strings and vice verse.
Parameters:
  code_page - [in] code page to use when converting UNICODE strings
       to multibyte strings and vice verse.
Returns:
  previous value of Windows code page.
Remarks:
  For Windows NT/2000/XP, CP_THREAD_ACP will work for all
  locales if your app's thread is correctly configured.
  For Windows 95/98/ME you have to choose the locale.

  Conversions between UNICODE and multibyte strings happens when
  ON_wString converts a char* string to a wchar_t* string and
  when and ON_String converts a wchar_t* string to a char* string.

  All pertinant code is in opennurbs_defines.cpp.

See Also:
  ON_GetStringConversionWindowsCodePage
  on_WideCharToMultiByte
  on_MultiByteToWideChar
  ON_wString::operator=(const char*)
  ON_String::operator=(const wchar_t*)  
*/
ON_DECL
unsigned int ON_SetStringConversionWindowsCodePage( 
                unsigned int code_page 
                );

/*
Description:
  Gets Windows code page used to convert UNICODE (wchar_t) strings
  to multibyte (char) strings and vice verse.
Returns:
  Value of Windows code page used to convert strings.
Remarks:
  For Windows NT/2000/XP, CP_THREAD_ACP will work for all
  locales if your app's thread is correctly configured.
  For Windows 95/98/ME you have to choose the locale.

  Conversions between UNICODE and multibyte strings happens when
  ON_wString converts a char* string to a wchar_t* string and
  when and ON_String converts a wchar_t* string to a char* string.

  All pertinant code is in opennurbs_defines.cpp.

See Also:
  ON_GetStringConversionWindowsCodePage
  on_WideCharToMultiByte
  on_MultiByteToWideChar
  ON_wString::operator=(const char*)
  ON_String::operator=(const wchar_t*)  
*/
ON_DECL
unsigned int ON_GetStringConversionWindowsCodePage();


/*
Description:
  Sets Windows locale id used in case insensitive string
  compares.
Parameters:
  locale_id - [in] Windows locale id to use in case insensitive
                 string compares.
  bWin9X - [in] True if OS is Windows 95/98/ME (which has
                poor UNICODE support).
Returns:
  Previous value of Windows locale id.
Remarks:
  All pertinant code is in opennurbs_defines.cpp.
See Also:
  ON_GetStringConversionWindowsLocaleID
  on_wcsicmp
*/
ON_DECL
unsigned int ON_SetStringConversionWindowsLocaleID( 
                unsigned int locale_id, 
                ON_BOOL32 bWin9X
                );

/*
Description:
  Gets Windows locale id used in case insensitive string
  compares.
Returns:
  Value of Windows locale id used in case insensitive string
  compares.
Remarks:
  All pertinant code is in opennurbs_defines.cpp.
See Also:
  ON_SetStringConversionWindowsLocaleID
  on_wcsicmp
*/
ON_DECL
unsigned int ON_GetStringConversionWindowsLocaleID();

// on_wcsicmp() is a wrapper for case insensitive wide string compare
// and calls one of _wcsicmp() or wcscasecmp() depending on OS.
ON_DECL
int on_wcsicmp( const wchar_t*, const wchar_t* );

// on_wcsupr() calls _wcsupr() or wcsupr() depending on OS
ON_DECL
wchar_t* on_wcsupr(wchar_t*);

// on_wcslwr() calls _wcslwr() or wcslwr() depending on OS
ON_DECL
wchar_t* on_wcslwr(wchar_t*);

// on_wcsrev() calls _wcsrev() or wcsrev() depending on OS
ON_DECL
wchar_t* on_wcsrev(wchar_t*);

// on_stricmp() is a wrapper for case insensitive string compare
// and calls one of _stricmp(), stricmp(), or strcasecmp()
// depending on OS.
ON_DECL
int on_stricmp(const char*, const char*); 

// on_stricmp() is a wrapper for case insensitive string compare
// and calls one of _strnicmp() or strncasecmp()
// depending on OS.
ON_DECL
int on_strnicmp(const char * s1, const char * s2, int n);

// on_strupr() calls _strupr() or strupr() depending on OS
ON_DECL
char* on_strupr(char*);

// on_strlwr() calls _strlwr() or strlwr() depending on OS
ON_DECL
char* on_strlwr(char*);

// on_strrev() calls _strrev() or strrev() depending on OS
ON_DECL
char* on_strrev(char*);

/*
Description:
  Calls ON_ConvertWideCharToUTF8()
*/
ON_DECL
int on_WideCharToMultiByte(
    const wchar_t*, // lpWideCharStr,
    int,            // cchWideChar,
    char*,          // lpMultiByteStr,
    int             // cchMultiByte,
    );

/*
Description:
  Calls ON_ConvertUTF8ToWideChar()
*/
ON_DECL
int on_MultiByteToWideChar(
    const char*, // lpMultiByteStr,
    int,         // cchMultiByte,
    wchar_t*,    // lpWideCharStr,
    int          // cchWideChar
    );

/*
Description:
  Find the locations in a path the specify the drive, directory,
  file name and file extension.
Parameters:
  path - [in]
    UTF-8 encoded string that is a legitimate path to a file.
  drive - [out] (pass null if you don't need the drive)
    If drive is not null and the path parameter begins with 
    an A-Z or a-z followed by a colon ( : ) then the returned
    value of *drive will equal the input value of path.
  dir - [out] (pass null if you don't need the directory)
    If dir is not null and the path parameter contains a
    directory specification, then the returned value of *dir
    will point to the character in path where the directory
    specification begins.
  fname - [out] (pass null if you don't need the file name)
    If fname is not null and the path parameter contains a
    file name specification, then the returned value of *fname
    will point to the character in path where the file name
    specification begins.
  ext - [out] (pass null if you don't need the extension)
    If ext is not null and the path parameter contains a
    file extension specification, then the returned value of
    *ext will point to the '.' character in path where the file
    extension specification begins.
Remarks:
  This function will treat a front slash ( / ) and a back slash
  ( \ ) as directory separators.  Because this function parses
  file names store in .3dm files and the .3dm file may have been
  written on a Windows computer and then read on a another
  computer, it looks for a drive dpecification even when the
  operating system is not Windows.
  This function will not return an directory that does not
  end with a trailing slash.
  This function will not return an empty filename and a non-empty
  extension.
  This function parses the path string according to these rules.
  It does not check the actual file system to see if the answer
  is correct.
See Also:
  ON_String::SplitPath
*/
ON_DECL void on_splitpath(
  const char* path,
  const char** drive,
  const char** dir,
  const char** fname,
  const char** ext
  );

/*
Description:
  Find the locations in a path the specify the drive, directory,
  file name and file extension.
Parameters:
  path - [in]
    UTF-8, UTF-16 or UTF-32 encoded wchar_t string that is a
    legitimate path to a file.
  drive - [out] (pass null if you don't need the drive)
    If drive is not null and the path parameter begins with 
    an A-Z or a-z followed by a colon ( : ) then the returned
    value of *drive will equal the input value of path.
  dir - [out] (pass null if you don't need the directory)
    If dir is not null and the path parameter contains a
    directory specification, then the returned value of *dir
    will point to the character in path where the directory
    specification begins.
  fname - [out] (pass null if you don't need the file name)
    If fname is not null and the path parameter contains a
    file name specification, then the returned value of *fname
    will point to the character in path where the file name
    specification begins.
  ext - [out] (pass null if you don't need the extension)
    If ext is not null and the path parameter contains a
    file extension specification, then the returned value of
    *ext will point to the '.' character in path where the file
    extension specification begins.
Remarks:
  This function will treat a front slash ( / ) and a back slash
  ( \ ) as directory separators.  Because this function parses
  file names store in .3dm files and the .3dm file may have been
  written on a Windows computer and then read on a another
  computer, it looks for a drive dpecification even when the
  operating system is not Windows.
  This function will not return an directory that does not
  end with a trailing slash.
  This function will not return an empty filename and a non-empty
  extension.
  This function parses the path string according to these rules.
  It does not check the actual file system to see if the answer
  is correct.
See Also:
  ON_wString::SplitPath
*/
ON_DECL void on_wsplitpath(
  const wchar_t* path,
  const wchar_t** drive,
  const wchar_t** dir,
  const wchar_t** fname,
  const wchar_t** ext
  );

ON_END_EXTERNC


#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_ERROR_INC_)
#define OPENNURBS_ERROR_INC_

/*
// Macros used to log errors and warnings.  The ON_Warning() and ON_Error()
// functions are defined in opennurbs_error.cpp.
*/

#if defined(__FUNCTION__)
// __FUNCTION__ macro exists
#define ON_ERROR(msg) ON_ErrorEx(__FILE__,__LINE__,__FUNCTION__,msg)
#define ON_WARNING(msg) ON_WarningEx(__FILE__,__LINE__,__FUNCTION__,msg)
#define ON_ASSERT(cond) ON_AssertEx(cond,__FILE__,__LINE__,__FUNCTION__, #cond " is false")
#define ON_ASSERT_OR_RETURN(cond,returncode) do{if (!(cond)) {ON_AssertEx(false,__FILE__,__LINE__,__FUNCTION__, #cond " is false");return(returncode);}}while(0)
#else
// __FUNCTION__ macro does not exist
#define ON_ERROR(msg) ON_Error(__FILE__,__LINE__,msg)
#define ON_WARNING(msg) ON_Warning(__FILE__,__LINE__,msg)
#define ON_ASSERT(cond) ON_Assert(cond,__FILE__,__LINE__, #cond " is false")
#define ON_ASSERT_OR_RETURN(cond,returncode) do{if (!(cond)) {ON_Assert(false,__FILE__,__LINE__, #cond " is false");return(returncode);}}while(0)
#endif


ON_BEGIN_EXTERNC

/*
// All error/warning messages are sent to ON_ErrorMessage().  Replace the
// default handler (defined in opennurbs_error_message.cpp) with something
// that is appropriate for debugging your application.
*/
ON_DECL
void ON_ErrorMessage( 
       int,         /* 0 = warning message, 1 = serious error message, 2 = assert failure */
       const char*  
       ); 

/*
Returns:
  Number of opennurbs errors since program started.
*/
ON_DECL
int     ON_GetErrorCount(void);

/*
Returns:
  Number of opennurbs warnings since program started.
*/
ON_DECL
int     ON_GetWarningCount(void);

/*
Returns:
  Number of math library or floating point errors that have 
  been handled since program started.
*/
ON_DECL
int     ON_GetMathErrorCount(void);

ON_DECL
int     ON_GetDebugErrorMessage(void);

ON_DECL
void    ON_EnableDebugErrorMessage( int bEnableDebugErrorMessage );


ON_DECL
void    ON_Error( const char*, /* sFileName:   __FILE__ will do fine */
                  int,         /* line number: __LINE__ will do fine */
                  const char*, /* printf() style format string */
                  ...          /* printf() style ags */
                  );

ON_DECL
void    ON_ErrorEx( const char*, // sFileName:   __FILE__ will do fine
                  int,           // line number: __LINE__ will do fine
                  const char*,   // sFunctionName: __FUNCTION__ will do fine
                  const char*,   // printf() style format string
                  ...            // printf() style ags
                  );
ON_DECL
void    ON_Warning( const char*, /* sFileName:   __FILE__ will do fine */
                    int,         /* line number: __LINE__ will do fine */
                    const char*, /* printf() style format string */
                    ...          /* printf() style ags */
                  );
ON_DECL
void    ON_WarningEx( const char*, // sFileName:   __FILE__ will do fine
                  int,           // line number: __LINE__ will do fine
                  const char*,   // sFunctionName: __FUNCTION__ will do fine
                  const char*,   // printf() style format string
                  ...            // printf() style ags
                  );

// Ideally - these "assert" functions will be deleted when the SDK can be changed.
ON_DECL
void    ON_Assert( int,         /* if false, error is flagged */
                   const char*, /* sFileName:   __FILE__ will do fine */
                   int,         /* line number: __LINE__ will do fine */
                   const char*, /* printf() style format string */
                   ...          /* printf() style ags */
                  );

ON_DECL
void    ON_AssertEx( int,        // if false, error is flagged
                  const char*,   // sFileName:   __FILE__ will do fine
                  int,           // line number: __LINE__ will do fine
                  const char*,   // sFunctionName: __FUNCTION__ will do fine
                  const char*,   // printf() style format string
                  ...            // printf() style ags
                  );

ON_DECL
void    ON_MathError( 
        const char*, /* sModuleName */
        const char*, /* sErrorType */
        const char*  /* sFunctionName */
        );

ON_END_EXTERNC

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_MEMORY_INC_)
#define OPENNURBS_MEMORY_INC_

#if defined (cplusplus) || defined(_cplusplus) || defined(__cplusplus)
extern "C" {
#endif

ON_DECL
size_t ON_MemoryPageSize();

#define ON_MEMORY_POOL void

ON_DECL
ON_MEMORY_POOL* ON_MainMemoryPool(void);

ON_DECL
ON_MEMORY_POOL* ON_WorkerMemoryPool(void);

ON_DECL
void*  onmalloc( size_t );

ON_DECL
void*  onmalloc_from_pool( ON_MEMORY_POOL*, size_t );

ON_DECL
void*  oncalloc( size_t, size_t );

ON_DECL
void*  oncalloc_from_pool( ON_MEMORY_POOL*, size_t, size_t );

ON_DECL
void   onfree( void* );

ON_DECL
void*  onrealloc( void*, size_t );

ON_DECL
void*  onrealloc_from_pool( ON_MEMORY_POOL*, void*, size_t );

ON_DECL
size_t onmsize( const void* );

ON_DECL
void*  onmemdup( const void*, size_t );

ON_DECL
char*  onstrdup( const char* );

ON_DECL
wchar_t* onwcsdup( const wchar_t* );

ON_DECL
unsigned char* onmbsdup( const unsigned char* );

ON_DECL
size_t onmemoryusecount(
          size_t* malloc_count, 
          size_t* realloc_count, 
          size_t* free_count, 
          size_t* pool_count 
          );

ON_DECL
size_t onmemoryusecountex(
          size_t* malloc_count, 
          size_t* realloc_count, 
          size_t* free_count, 
          size_t* pool_count,
          size_t* malloc_zero_count,
          size_t* free_null_count 
          );

/* define to handle _TCHAR* ontcsdup( const _TCHAR* ) */
#if defined(_UNICODE)
#define ontcsdup onwcsdup
#elif defined(_MBCS)
#define ontcsdup onmbsdup
#else
#define ontcsdup onstrdup
#endif

#if defined (cplusplus) || defined(_cplusplus) || defined(__cplusplus)
}
#endif

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_RANDOM_NUMBER_INC_)
#define OPENNURBS_RANDOM_NUMBER_INC_

ON_BEGIN_EXTERNC

struct ON_RANDOM_NUMBER_CONTEXT
{
  ON__UINT32 mti;     /* mti = 0xFFFFFFFF means mt[] is not initialized */
  ON__UINT32 mt[624]; /* the array for the state vector  */
};


/*
Description:
  Seed a context for on_random_number().
Parameters:
  s - [in]
  rand_context - [out] context to seed.

Remarks:
  on_random_number_seed() does not use any static memory.
Example:
          ON_RAND_CONTEXT rand_context;

          ON__UINT seed = 123;
          on_random_number_seed( seed, &rand_context );

          ON__UINT32 r1 = on_random_number( &rand_context );
          ON__UINT32 r2 = on_random_number( &rand_context );
          ON__UINT32 r3 = on_random_number( &rand_context );
*/
void on_random_number_seed(
        ON__UINT32 s,
        struct ON_RANDOM_NUMBER_CONTEXT* rand_context
        );

/*
Description:
  Get a random number.
Parameters:
  rand_context - [in/out]
    random number context.  The first time rand_context is
    used it must be either initialized by calling on_random_number_seed()
    or rand_context->mti must be set to 0xFFFFFFFF.  Otherwise do not 
    modify randcontext between calls to on_random_number.
Returns:
  A random number.
Remarks:
  on_random_number() does not use any static memory.
Example:
          ON_RAND_CONTEXT rand_context;

          ON__UINT seed = 123;
          on_random_number_seed( seed, &rand_context );

          ON__UINT32 r1 = on_random_number( &rand_context );
          ON__UINT32 r2 = on_random_number( &rand_context );
          ON__UINT32 r3 = on_random_number( &rand_context );
*/
ON__UINT32 on_random_number(
        struct ON_RANDOM_NUMBER_CONTEXT* rand_context
        );


/*
Description:
  Seed the random number generator used by on_rand().
Parameters:
  s - [in]
Remarks:
  on_srand() is not thread safe.  It used static global memory
  that is modified by on_srand() and on_rand().
*/
void on_srand(ON__UINT32 s);

/*
Description:
  Get a random number.
Returns:
  A random number.
Remarks:
  on_rand() is not thread safe.  It used static global memory
  that is modified by on_srand() and on_rand().
*/
ON__UINT32 on_rand(void);


ON_END_EXTERNC


#if defined(ON_CPLUSPLUS)

class ON_CLASS ON_RandomNumberGenerator
{
public:
  ON_RandomNumberGenerator();

  /*
  Description:
    Seed the random number generator.
  Parameters:
    s - [in]
  */
  void Seed( ON__UINT32 s );

  /*
  Returns:
    32 bit unsigned random number [0,0xFFFFFFFF] [0,4294967295]
  */
  ON__UINT32 RandomNumber();

  /*
  Returns:
    double in the interval [0.0 and 1.0]
  */
  double RandomDouble();

  /*
  Returns:
    double in the interval [t0,t1]
  */
  double RandomDouble(double t0, double t1);

  /*
  Description:
    Perform a random permuation on an array.
  Parameters:
    base - [in/out]
      Array of element to permute
    nel - [in]
      number of elements in the array.
    sizeof_element
      size of an element in bytes.
  */
  void RandomPermutation(void* base, size_t nel, size_t sizeof_element );

private:
  struct ON_RANDOM_NUMBER_CONTEXT m_rand_context;
};

#endif


#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_CRC_INC_)
#define OPENNURBS_CRC_INC_

ON_BEGIN_EXTERNC

/*
Description:
  Continues 16 bit CRC calulation to include the buffer.

Parameters:
  current_remainder - [in]
  sizeof_buffer - [in]  number of bytes in buffer
  buffer - [in] 

Example:
  16 bit CRC calculations are typically done something like this:

          const ON__UINT16 crc_seed = 0; // or 1, or your favorite starting value

          // Compute CRC on "good" data
          unsigned ON__UINT16 first_crc = crc_seed;
          first_crc = ON_CRC16( first_crc, size1, buffer1 );
          ...
          first_crc = ON_CRC16( first_crc, sizeN, bufferN );
          unsigned char two_zero_bytes[2] = (0,0);
          first_crc = ON_CRC16( first_crc, 2, two_zero_bytes );

          // make sure 16 bit CRC calculation is valid
          ON__UINT16 check_crc_calculation = ON_CRC16( first_crc, 2, &first_crc );
          if ( check_crc_calculation != 0 ) 
          {
             printf("ON_CRC16() calculated a bogus 16 bit CRC\n");
          }

          // Do something that may potentially change the values in
          // the buffers (like storing them on a faulty disk).

          // Compute CRC on "suspect" data
          ON__UINT16 second_crc = crc_seed;
          second_crc = ON_CRC16( second_crc, size1, buffer1 );
          ...
          second_crc = ON_CRC16( second_crc, sizeN, bufferN );
          if ( 0 != ON_CRC16( second_crc, 2, &first_crc ) ) 
          {
            printf( "The value of at least one byte has changed.\n" );
          }
*/
ON_DECL
ON__UINT16 ON_CRC16(
         ON__UINT16 current_remainder,
         size_t sizeof_buffer,
         const void* buffer
         );

/*
Description:
  Continues 32 bit CRC calulation to include the buffer

  ON_CRC32() is a slightly altered version of zlib 1.3.3's crc32()
  and the zlib "legal stuff" is reproduced below.

  ON_CRC32() and zlib's crc32() compute the same values.  ON_CRC32() 
  was renamed so it wouldn't clash with the other crc32()'s that are 
  out there and the argument order was switched to match that used by
  the legacy ON_CRC16().

Parameters:
  current_remainder - [in]
  sizeof_buffer - [in]  number of bytes in buffer
  buffer - [in] 

Example:
  32 bit CRC calculations are typically done something like this:

          const ON__UINT32 crc_seed = 0; // or 1, or your favorite starting value

          //Compute CRC on "good" data
          ON__UINT32 first_crc = crc_seed;
          first_crc = ON_CRC32( first_crc, size1, buffer1 );
          ...
          first_crc = ON_CRC32( first_crc, sizeN, bufferN );

          // Do something that may potentially change the values in
          // the buffers (like storing them on a faulty disk).

          // Compute CRC on "suspect" data
          ON__UINT32 second_crc = crc_seed;
          second_crc = ON_CRC32( second_crc, size1, buffer1 );
          ...
          second_crc = ON_CRC32( second_crc, sizeN, bufferN );
          if ( second_crc != first_crc ) 
          {
            printf( "The value of at least one byte has changed.\n" );
          }
*/
ON_DECL
ON__UINT32 ON_CRC32(
         ON__UINT32 current_remainder,
         size_t sizeof_buffer,
         const void* buffer
         );

/*
zlib.h -- interface of the 'zlib' general purpose compression library
version 1.1.3, July 9th, 1998

Copyright (C) 1995-1998 Jean-loup Gailly and Mark Adler

This software is provided 'as-is', without any express or implied
warranty.  In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.

Jean-loup Gailly        Mark Adler
jloup@gzip.org          madler@alumni.caltech.edu

The data format used by the zlib library is described by RFCs (Request for
Comments) 1950 to 1952 in the files ftp://ds.internic.net/rfc/rfc1950.txt
(zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).

*/

ON_END_EXTERNC

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_UUID_INC_)
#define OPENNURBS_UUID_INC_

// ON_UUID is a 16 byte universally unique identifier
#if defined(UUID_DEFINED)
typedef UUID ON_UUID;
#elif defined(GUID_DEFINED)
typedef GUID ON_UUID;
#else

#define ON_UUID_DECLARED_AS_CLASS
// For uuids, it is critical that the DataN fields have
// exactly the sizes specified below.  For that reason,
// the ON__UINTnn typedefs are used.
class ON_CLASS ON_UUID
{
public:
  ON__UINT32     Data1;    // 32 bit unsigned integer
  ON__UINT16     Data2;    // 16 bit unsigned integer
  ON__UINT16     Data3;    // 16 bit unsigned integer
  unsigned char  Data4[8]; 

  bool operator==(const ON_UUID& other) const;
  bool operator!=(const ON_UUID& other) const;
};

#endif

ON_BEGIN_EXTERNC

// All bits are zero in ON_nil_uuid and
// ON_UuidCompare( ON_nil_uuid, U ) < 0 if U != ON_nil_uuid.
extern ON_EXTERN_DECL const ON_UUID ON_nil_uuid;

// All bits are one in ON_max_uuid and
// ON_UuidCompare( U, ON_max_uuid ) < 0 if U != ON_max_uuid.
extern ON_EXTERN_DECL const ON_UUID ON_max_uuid;

// Application ids for the versions of Rhino that
// write 3dm files.  All userdata classed defined
// in the core Rhino.exe should use these ids
// as the application id.
// In situations where you want to use the id
// for the current version of Rhino, use
// ON_rhino_id and you won't have to update
// your code when Rhino versions roll.
extern ON_EXTERN_DECL const ON_UUID ON_rhino2_id;
extern ON_EXTERN_DECL const ON_UUID ON_rhino3_id;
extern ON_EXTERN_DECL const ON_UUID ON_rhino4_id;
extern ON_EXTERN_DECL const ON_UUID ON_rhino5_id;
extern ON_EXTERN_DECL const ON_UUID ON_rhino_id;

// Application ids for usedata written by versions
// of opennurbs before userdata had application ids.
extern ON_EXTERN_DECL const ON_UUID ON_v2_userdata_id;
extern ON_EXTERN_DECL const ON_UUID ON_v3_userdata_id;
extern ON_EXTERN_DECL const ON_UUID ON_v4_userdata_id;

// Application id for the versions of openNURBS that
// write userdata in 3dm files.  User data whose class
// definition is in opennurbs should use these
// ids as the user data application id.
// No other user data should use these ids.
// The "extern ON_EXTERN_DECL" prefix on the declarations
// of these ids was a mistake that will be corrected when
// the public SDK can be changed.
// In situations where you want to use the id
// for the current version of opennurbs, use
// ON_opennurbs_id and you won't have to update
// your code when opennurbs versions roll.
extern ON_EXTERN_DECL const ON_UUID ON_opennurbs4_id;
extern ON_EXTERN_DECL const ON_UUID ON_opennurbs5_id;
extern ON_EXTERN_DECL const ON_UUID ON_opennurbs_id;

ON_END_EXTERNC

#if defined(ON_CPLUSPLUS)

/*
Description:
  Creates a new uuid.(&a,&b) compares two uuids.
Parameters:
  new_uuid - [out]
Returns:
  True if successful.
Remarks:
  Only works on Windows.
*/
ON_DECL 
bool ON_CreateUuid( ON_UUID& uuid );

/*
Description:
  This class is used by ON_UuidIndexList.  It is used when
  uuids are used to search for items that can be found by
  an integer index.
*/
class ON_CLASS ON_UuidIndex
{
public:
  ON_UuidIndex();

  /*
  Dictionary compare m_id and then m_i.
  */
  static 
  int CompareIdAndIndex( const ON_UuidIndex* a, const ON_UuidIndex* b );

  /*
  Dictionary compare m_id and then m_i.
  */
  static 
  int CompareIndexAndId( const ON_UuidIndex* a, const ON_UuidIndex* b );

  /*
  Compare m_id and ignore m_i.
  */
  static 
  int CompareId( const ON_UuidIndex* a, const ON_UuidIndex* b );

  /*
  Compare m_i and ignore m_id.
  */
  static 
  int CompareIndex( const ON_UuidIndex* a, const ON_UuidIndex* b );

  // In cases when there is a discrepancy between the m_id and
  // m_i, m_id is assumed to be valid unless comments where this
  // class is used indicate otherwise.
  ON_UUID m_id;
  int m_i;
};

/*
Description:
  ON_UuidCompare(&a,&b) compares two uuids.
Parameters:
  a - [in]
  b - [in]
Returns:
  @untitled table
  -1    a < b
   0    a == b
  +1    a > b
Remarks:
  A NULL pointer is considered < a non-NULL pointer.
*/
ON_DECL 
int ON_UuidCompare( 
        const ON_UUID* a, 
        const ON_UUID* b 
        );

/*
Description:
  ON_UuidCompare(a,b) compares two uuids.
Parameters:
  a - [in]
  b - [in]
Returns:
  @untitled table
  -1    a < b
   0    a == b
  +1    a > b
*/
ON_DECL 
int ON_UuidCompare( 
        const ON_UUID& a, 
        const ON_UUID& b
        );

/*
Description:
  Test uuid to see if it is nil (identically zero).
Parameters:
  uuid - [in]
Returns:
  true if uuid is nil.
*/
ON_DECL
bool ON_UuidIsNil( 
        const ON_UUID& uuid 
        );

/*
Description:
  Test uuid to see if it is not nil (not identically zero).
Parameters:
  uuid - [in]
Returns:
  true if uuid is not nil (non zero)
*/
ON_DECL
bool ON_UuidIsNotNil( 
        const ON_UUID& uuid 
        );

/*
Description:
  Converts a string like
    "{85A08515-f383-11d3-BFE7-0010830122F0}" 
  into a uuid.
  The brackets are optional and are ignored.
  Hyphens can appear anywhere or be missing.
  The hex digits can be upper or lower case.
Parameters:
  s - [in]
Returns:
  uuid.  
  If the string is not a uuid, then ON_nil_uuid is returnd.
*/
ON_DECL 
ON_UUID ON_UuidFromString( const char* s );

/*
Description:
  Converts a string like
    "{85A08515-f383-11d3-BFE7-0010830122F0}" 
  into a uuid.
  The brackets are optional and are ignored.
  Hyphens can appear anywhere or be missing.
  The hex digits can be upper or lower case.
Parameters:
  s - [in]
Returns:
  uuid.  
  If the string is not a uuid, then ON_nil_uuid is returnd.
*/
ON_DECL 
ON_UUID ON_UuidFromString( const wchar_t* s );

/*
Description:
  Converts a uuid to a null termintated ASCII string like 
     "85a08515-f383-11d3-bfe7-0010830122f0". 
Parameters:
  uuid - [in]
  s - [out]  The s[] char array must have length >= 37.  
             The returned char array will have a 36 
             character uuid in s[0..35] and a null in s[36].
Returns:
  The pointer to the array is returned.
*/
ON_DECL 
char* ON_UuidToString( const ON_UUID& uuid, char* s );


/*
Description:
  Converts a uuid to a null termintated UNICODE string like 
     "85a08515-f383-11d3-bfe7-0010830122f0". 
Parameters:
  uuid - [in]
  s - [out]  The s[] wchar_t array must have length >= 37.  
             The returned char array will have a 36 
             character uuid in s[0..35] and a null in s[36].
Returns:
  The pointer to the array is returned.
*/
ON_DECL 
wchar_t* ON_UuidToString( const ON_UUID& uuid, wchar_t* s );

class ON_String;

/*
Description:
  Converts a uuid to a null termintated string like 
     "85a08515-f383-11d3-bfe7-0010830122f0". 
Parameters:
  uuid - [in]
  s - [out]
Returns:
  The pointer to the array is returned.
*/
ON_DECL 
const char* ON_UuidToString( const ON_UUID& uuid, ON_String& s);

class ON_wString;

/*
Description:
  Converts a uuid to a null termintated string like 
     "85a08515-f383-11d3-bfe7-0010830122f0". 
Parameters:
  uuid - [in]
  s - [out]
Returns:
  The pointer to the array is returned.
*/
ON_DECL 
const wchar_t* ON_UuidToString( const ON_UUID& uuid, ON_wString& s);

#endif

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_UNICODE_INC_)
#define OPENNURBS_UNICODE_INC_

ON_BEGIN_EXTERNC

struct ON_UnicodeErrorParameters
{
  /*
  If an error occurs, then bits of error_status are
  set to indicate what type of error occured.

  Error types:
    1: The input parameters were invalid. 
       This error cannot be masked.

    2: The ouput buffer was not large enough to hold the converted
       string. As much conversion as possible is performed in this
       case and the error cannot be masked.

    4: When parsing a UTF-8 or UTF-32 string, the values of two
       consecutive encoding sequences formed a valid UTF-16 
       surrogate pair. 
          
       This error is masked if 0 != (4 & m_error_mask).
       If the error is masked, then the surrogate pair is
       decoded, the value of the resulting unicode code point
       is used, and parsing continues.

    8: An overlong UTF-8 encoding sequence was encountered and 
       the value of the overlong sUTF-8 equence was a valid unicode
       code point. 
          
       This error is masked if 0 != (8 & m_error_mask).
       If the error is masked, then the unicode code point is 
       used and parsing continues.

   16: An illegal UTF-8 encoding sequence occured or an invalid
       unicode code point value resulted from decoding a
       UTF-8 sequence. 

       This error is masked if 0 != (16 & m_error_mask).
       If the error is masked and the value of m_error_code_point is
       a valid unicode code point, then m_error_code_point is used
       and parsing continues.
  */
  unsigned int m_error_status;

  /*
  If 0 != (error_mask & 4), then type 4 errors are masked.
  If 0 != (error_mask & 8), then type 8 errors are masked.
  If 0 != (error_mask & 16) and m_error_code_point is a valid unicode
  code point value, then type 16 errors are masked.
  */
  unsigned int m_error_mask;

  /*
  Unicode code point value to use in when masking type 16 errors.
  If 0 == (error_mask & 16), then this parameter is ignored.
  0xFFFD is a popular choice for the m_error_code_point value.
  */
  ON__UINT32 m_error_code_point;
};


/*
Description:
  Test a value to determine if it is a valid unicode code point value.
Parameters:
  u - [in] value to test
Returns:
  true: u is a valid unicode code point
  false: u is not a valid unicode code point
Remarks:
  Valid unicode code points are 
  (0 <= u && u <= 0xD7FF) || (0xE000 <= u && u <= 0x10FFFF)
*/
ON_DECL
int ON_IsValidUnicodeCodePoint( ON__UINT32 u );

/*
Description:
  Convert an integer to its UTF-8 form.
Parameters:
  u - [in]
    Interger in the CPU's native byte order that can be
    converted to UTF-8 form.
    Valid values are in the interval [0,2147483647].
  sUTF8 - [out]
    sUTF8 is a buffer of 6 ON__UINT8 elements and the UTF-8 form
    is returned in sUTF8[]. The returned value specifies how 
    many elements of sUTF8[] are set.
Returns:
  0: u is too large (>=2^31) to be encode as a UTF-8 string.
     No changes are made to the sUTF8[] values.
  1: the UTF-8 form of u is 1 byte returned in sUTF8[0].
  2: the UTF-8 form of u is 2 byts returned in sUTF8[0],sUTF8[1].
  3: the UTF-8 form of u is 3 bytes returned in sUTF8[0],sUTF8[1],sUTF8[2].
  4: the UTF-8 form of u is 4 bytes returned in sUTF8[0],sUTF8[1],sUTF8[2],sUTF8[3].
  5: the UTF-8 form of u is 5 bytes returned in sUTF8[0],sUTF8[1],sUTF8[2],sUTF8[3],sUTF8[4].
  6: the UTF-8 form of u is 6 bytes returned in sUTF8[0],sUTF8[1],sUTF8[2],sUTF8[3],sUTF8[4],sUTF8[5].
  For return values requiring less than 6 bytes, no changes
  are made to the unused bytes in sUTF8[].
Remarks:
  Any integer in the range 0 to 2^31 - 1 can be encoded as a UTF-8 string.
  When a unicode string is being encoded take steps to ensure that
  u is a valid unicode code point value.  The function ON_IsValidUnicodeCodePoint()
  can be used to determine if u is a valid unicode code point value.
*/
ON_DECL
int ON_EncodeUTF8( ON__UINT32 u, ON__UINT8 sUTF8[6] );

/*
Description:
  Decode a UTF-8 encode string to get a single unicode code point.
Parameters:
  sUTF8 - [in]
    UTF-8 string to convert.

  sUTF8_count - [in]
    number of ON__UINT8 elements in sUTF8[].

   e - [in/out] 
    If e is null, errors are not masked and parsing is performed
    to the point where the first error occurs.
    If e is not null, all errors are reported by setting the appropriate
    e->m_error_status bits and errors are handled as described in the
    definition of the ON_UnicodeErrorParameters struct.

  unicode_code_point - [out]
    The unicode_code_point pointer must not be null.
    If a nonzero value is returned, then *unicode_code_point is
    a valid unicode code point value.
Returns:
  Number of elements of sUTF8 that were parsed.
  0 indicates failure.
*/
ON_DECL
int ON_DecodeUTF8(
    const ON__UINT8* sUTF8,
    int sUTF8_count,
    struct ON_UnicodeErrorParameters* e,
    ON__UINT32* unicode_code_point
    );

/*
Description:
  Convert a 4 byte unicode code point value to its UTF-16 form.
Parameters:
  unicode_code_point - [in]
    4 byte unicode code point value in the CPU's native byte order.
    Valid values are in the interval [0,0xD7FF] or the 
    interval [0xE000,0x10FFFF].
  sUTF16 - [out]
    sUTF16 is buffer of 2 ON__UINT16 elements. If the UTF-16 form
    is a single value, it is returned in sUTF16[0]. If the UTF-16
    is a surrogate pair, the first code unit (high surrogate) 
    is returned sUTF16[0] and the second unit (low surrogate) is
    returned in sUTF16[1].  The returned values are in
    the CPU's native byte order.
Returns:
  0: u is not a valid Unicode code point. No changes are
     made to the w[] values.
  1: u is a valie Unicode code point with a UTF-16 form 
     consisting of the single value returned in w[0].
  2: u is a valid Unicode code point with a UTF-16 form 
     consisting of a surrogate pair returned in w[0] and w[1].
*/
ON_DECL
int ON_EncodeUTF16( ON__UINT32 unicode_code_point, ON__UINT16 sUTF16[2] );

/*
Description:
  Decode a UTF-16 string to get a single unicode code point.
Parameters:
  sUTF16 - [in]
    UTF-16 string to convert.

  sUTF16_count - [in]
    number of ON__UINT16 elements in sUTF16[].

  e - [in/out] 
    If e is null, errors are not masked and parsing is performed
    to the point where the first error occurs.
    If e is not null, all errors are reported by setting the appropriate
    e->m_error_status bits and errors are handled as described in the
    definition of the ON_UnicodeErrorParameters struct.

  unicode_code_point - [out]
    The unicode_code_point pointer must not be null.
    If a nonzero value is returned, then *unicode_code_point is
    a valid unicode code point value in the CPU's native byte order.
Returns:
  Number of elements of sUTF16 that were parsed.
  0 indicates failure.
*/
ON_DECL
int ON_DecodeUTF16(
    const ON__UINT16* sUTF16,
    int sUTF16_count,
    struct ON_UnicodeErrorParameters* e,
    ON__UINT32* unicode_code_point
    );

/*
Description:
  Decode a UTF-16 encode string whose elements have byte order
  opposite the native CPU's to get a single unicode code point.
Parameters:
  sUTF16 - [in]
    UTF-16 string to convert with byte order opposite the
    CPU's native byte order.

  sUTF16_count - [in]
    number of ON__UINT16 elements in sUTF16[].

  e - [in/out] 
    If e is null, errors are not masked and parsing is performed
    to the point where the first error occurs.
    If e is not null, all errors are reported by setting the appropriate
    e->m_error_status bits and errors are handled as described in the
    definition of the ON_UnicodeErrorParameters struct.

  unicode_code_point - [out]
    The unicode_code_point pointer must not be null.
    If a nonzero value is returned, then *unicode_code_point is
    a valid unicode code point value in the CPU's native byte order.
Returns:
  Number of elements of sUTF16 that were parsed.
  0 indicates failure.
*/
ON_DECL
int ON_DecodeSwapByteUTF16(
    const ON__UINT16* sUTF16,
    int sUTF16_count,
    struct ON_UnicodeErrorParameters* e,
    ON__UINT32* unicode_code_point
    );

/*
Description:
  Convert a unicode string from a UTF-8 encoded ON__UINT8 array
  into a UTF-16 encoded ON__UINT16 array.

Parameters:
  sUTF8 - [in]
    UTF-8 string to convert.

  sUTF8_count - [in]
    If sUTF8_count >= 0, then it specifies the number of
    ON__UINT8 elements in sUTF8[] to convert.

    If sUTF8_count == -1, then sUTF8 must be a null terminated
    string and all the elements up to the first null element are
    converted.

  sUTF16 - [out]
    If sUTF16 is not null and sUTF16_count > 0, then the UTF-16
    encoded string is returned in this buffer. If there is room
    for the null terminator, the converted string will be null
    terminated. The null terminator is never included in the count 
    of returned by this function. The converted string is in the 
    CPU's native byte order. No byte order mark is prepended.

  sUTF16_count - [in]
    If sUTF16_count > 0, then it specifies the number of available
    ON__UINT16 elements in the sUTF16[] buffer.
    
    If sUTF16_count == 0, then the sUTF16 parameter is ignored.

  error_status - [out]
    If error_status is not null, then bits of *error_status are
    set to indicate the success or failure of the conversion.  
    When the error_mask parameter is used to used to mask some
    conversion errors, multiple bits may be set.
       0: Successful conversion with no errors.
       1: Invalid input parameters. This error cannot be masked.
       2: The sUTF16 output buffer was not large enough to hold 
          the converted string. This error cannot be masked.
       4: The values of two UTF-8 encoding sequences formed a valid
          UTF-16 surrogate pair. This error can be masked.  If the
          error is masked, then the surrogate pair is added
          to the UTF-16 output string and parsing continues.
       8: An overlong UTF-8 encoding sequence was encountered. 
          The value of the overlong sequence was a valid unicode
          code point. This error can be masked. If the error is masked,
          then the unicode code point is encoded and added to the
          UTF-16 output string and parsing continues.
      16: An illegal UTF-8 encoding sequence occured or an invalid
          unicode code point value resulted from decoding a
          UTF-8 sequence. This error can be masked. If the error is
          masked and error_code_point is a valid unicode code point,
          then its UTF-16 encoding is added to the UTF-16 output
          string and parsing continues.

  error_mask - [in]
    If 0 != (error_mask & 4), then type 4 errors are masked.
    If 0 != (error_mask & 8), then type 8 errors are masked.
    If 0 != (error_mask & 16) and error_code_point is a valid unicode
    code point value, then type 16 errors are masked.

  error_code_point - [in]
    Unicode code point value to use in when masking type 16 errors.
    If 0 == (error_mask & 16), then this parameter is ignored.
    0xFFFD is a popular choice for the error_code_point value.

  sNextUTF8 - [out]
    If sNextUTF8 is not null, then *sNextUTF8 points to the first
    element in the input sUTF8[] buffer that was not converted. 

    If an error occurs and is not masked, then *sNextUTF8 points to
    the element of sUTF8[] where the conversion failed.  If no errors
    occur or all errors are masked, then *sNextUTF8 points to
    sUTF8 + sUTF8_count.

Returns:
  If sUTF16_count > 0, the return value is the number of ON__UINT16
  elements written to sUTF16[].  When the return value < sUTF16_count,
  a null terminator is written to sUTF16[return value].

  If sUTF16_count == 0, the return value is the minimum number of
  ON__UINT16 elements that are needed to hold the converted string.
  The return value does not include room for a null terminator.  
  Increment the return value by one if you want to have an element
  to use for a null terminator.
*/
ON_DECL
int ON_ConvertUTF8ToUTF16(
    const ON__UINT8* sUTF8,
    int sUTF8_count,
    ON__UINT16* sUTF16,
    int sUTF16_count,
    unsigned int* error_status,
    unsigned int error_mask,
    ON__UINT32 error_code_point,
    const ON__UINT8** sNextUTF8
    );

/*
Description:
  Convert a unicode string from a UTF-8 encoded ON__UINT8 array
  into a UTF-32 encoded ON__UINT32 array.

Parameters:
  sUTF8 - [in]
    UTF-8 string to convert.

  sUTF8_count - [in]
    If sUTF8_count >= 0, then it specifies the number of
    ON__UINT8 elements in sUTF8[] to convert.

    If sUTF8_count == -1, then sUTF8 must be a null terminated
    string and all the elements up to the first null element are
    converted.

  sUTF32 - [out]
    If sUTF32 is not null and sUTF32_count > 0, then the UTF-32
    encoded string is returned in this buffer. If there is room
    for the null terminator, the converted string will be null
    terminated. The null terminator is never included in the count 
    of returned by this function. The converted string is in the 
    CPU's native byte order. No byte order mark is prepended.

  sUTF32_count - [in]
    If sUTF32_count > 0, then it specifies the number of available
    ON__UINT32 elements in the sUTF32[] buffer.
    
    If sUTF32_count == 0, then the sUTF32 parameter is ignored.

  error_status - [out]
    If error_status is not null, then bits of *error_status are
    set to indicate the success or failure of the conversion.  
    When the error_mask parameter is used to used to mask some
    conversion errors, multiple bits may be set.
       0: Successful conversion with no errors.
       1: Invalid input parameters. This error cannot be masked.
       2: The sUTF32 output buffer was not large enough to hold 
          the converted string. This error cannot be masked.
       4: The values of two UTF-8 encoding sequences formed a valid
          UTF-16 surrogate pair. This error can be masked.  If the
          error is masked, then the surrogate pair is decoded,
          the code point value is added to the UTF-32 output 
          string and parsing continues.
       8: An overlong UTF-8 encoding sequence was encountered. 
          The value of the overlong sequence was a valid unicode
          code point. This error can be masked. If the error is masked,
          then the unicode code point is added to the UTF-32
          output string and parsing continues.
      16: An illegal UTF-8 encoding sequence occured or an invalid
          unicode code point value resulted from decoding a
          UTF-8 sequence. This error can be masked. If the error is
          masked and error_code_point is a valid unicode code point,
          then its value is added to the UTF-32 output string and 
          parsing continues.

  error_mask - [in]
    If 0 != (error_mask & 4), then type 4 errors are masked.
    If 0 != (error_mask & 8), then type 8 errors are masked.
    If 0 != (error_mask & 16) and error_code_point is a valid unicode
    code point value, then type 16 errors are masked.

  error_code_point - [in]
    Unicode code point value to use in when masking type 16 errors.
    If 0 == (error_mask & 16), then this parameter is ignored.
    0xFFFD is a popular choice for the error_code_point value.

  sNextUTF8 - [out]
    If sNextUTF8 is not null, then *sNextUTF8 points to the first
    element in the input sUTF8[] buffer that was not converted. 

    If an error occurs and is not masked, then *sNextUTF8 points to
    the element of sUTF8[] where the conversion failed.  If no errors
    occur or all errors are masked, then *sNextUTF8 points to
    sUTF8 + sUTF8_count.

Returns:
  If sUTF32_count > 0, the return value is the number of ON__UINT32
  elements written to sUTF32[].  When the return value < sUTF32_count,
  a null terminator is written to sUTF32[return value].

  If sUTF32_count == 0, the return value is the minimum number of
  ON__UINT32 elements that are needed to hold the converted string.
  The return value does not include room for a null terminator.  
  Increment the return value by one if you want to have an element
  to use for a null terminator.
*/
ON_DECL
int ON_ConvertUTF8ToUTF32(
    const ON__UINT8* sUTF8,
    int sUTF8_count,
    ON__UINT32* sUTF32,
    int sUTF32_count,
    unsigned int* error_status,
    unsigned int error_mask,
    ON__UINT32 error_code_point,
    const ON__UINT8** sNextUTF8
    );

/*
Description:
  Convert a unicode string from a UTF-16 encoded ON__UINT16 array
  into a UTF-8 encoded ON__UINT8 array.

Parameters:
  bTestByteOrder - [in]
    If bTestByteOrder is true and the first element of sUTF16[]
    is 0xFEFF, then this element is ignored.

    If bTestByteOrder is true and the first element of sUTF16[]
    is 0xFFFE, then this element is ignored and the subsequent
    elements of sUTF16[] have their bytes swapped before the 
    conversion is calculated.

    In all other cases the first element of sUTF16[] is 
    converted and no byte swapping is performed.

  sUTF16 - [in]
    UTF-16 string to convert.  
    
    If bTestByteOrder is true and the first element of sUTF16[]
    is 0xFEFF, then this element is skipped and it is assumed 
    that sUTF16[] is in the CPU's native byte order.
    
    If bTestByteOrder is true and the first element of sUTF16[]
    is 0xFFFE, then this element is skipped and it is assumed 
    that sUTF16[] is not in the CPU's native byte order and bytes
    are swapped before characters are converted.

    If bTestByteOrder is false or the first character of sUTF16[]
    is neither 0xFEFF nor 0xFFFE, then the sUTF16 string must match
    the CPU's byte order.

  sUTF16_count - [in]
    If sUTF16_count >= 0, then it specifies the number of
    ON__UINT16 elements in sUTF16[] to convert.

    If sUTF16_count == -1, then sUTF16 must be a null terminated
    string and all the elements up to the first null element are
    converted.
    
  sUTF8 - [out]
    If sUTF8 is not null and sUTF8_count > 0, then the UTF-8
    encoded string is returned in this buffer. If there is room
    for the null terminator, the converted string will be null
    terminated. The null terminator is never included in the count 
    of returned by this function. The converted string is in the 
    CPU's native byte order. No byte order mark is prepended.

  sUTF8_count - [in]
    If sUTF8_count > 0, then it specifies the number of available
    ON__UINT8 elements in the sUTF8[] buffer.
    
    If sUTF8_count == 0, then the sUTF8 parameter is ignored.

  error_status - [out]
    If error_status is not null, then bits of *error_status are
    set to indicate the success or failure of the conversion.  
    When the error_mask parameter is used to used to mask some
    conversion errors, multiple bits may be set.
       0: Successful conversion with no errors.
       1: Invalid input parameters. This error cannot be masked.
       2: The sUTF8 output buffer was not large enough to hold 
          the converted string. This error cannot be masked.
      16: An illegal UTF-16 encoding sequence occured or an invalid
          unicode code point value resulted from decoding a
          UTF-16 sequence. This error can be masked. If the error is
          masked and error_code_point is a valid unicode code point,
          then its UTF-8 encoding is added to the UTF-8 output
          string and parsing continues.

  error_mask - [in]
    If 0 != (error_mask & 16) and error_code_point is a valid unicode
    code point value, then type 16 errors are masked.

  error_code_point - [in]
    Unicode code point value to use in when masking type 16 errors.
    If 0 == (error_mask & 16), then this parameter is ignored.
    0xFFFD is a popular choice for the error_code_point value.

  sNextUTF16 - [out]
    If sNextUTF16 is not null, then *sNextUTF16 points to the first
    element in the input sUTF16[] buffer that was not converted. 

    If an error occurs and is not masked, then *sNextUTF16 points to
    the element of sUTF16[] where the conversion failed.  If no errors
    occur or all errors are masked, then *sNextUTF16 points to
    sUTF16 + sUTF16_count.

  If sUTF8_count > 0, the return value is the number of ON__UINT8
  elements written to sUTF8[].  When the return value < sUTF8_count,
  a null terminator is written to sUTF8[return value].

  If sUTF8_count == 0, the return value is the minimum number of
  ON__UINT8 elements that are needed to hold the converted string.
  The return value does not include room for a null terminator.  
  Increment the return value by one if you want to have an element
  to use for a null terminator.
*/
ON_DECL
int ON_ConvertUTF16ToUTF8(
    int bTestByteOrder,
    const ON__UINT16* sUTF16,
    int sUTF16_count,
    ON__UINT8* sUTF8,
    int sUTF8_count,
    unsigned int* error_status,
    unsigned int error_mask,
    ON__UINT32 error_code_point,
    const ON__UINT16** sNextUTF16
    );

/*
Description:
  Convert a unicode string from a UTF-16 encoded ON__UINT16 array
  into a UTF-32 encoded ON__UINT32 array.

Parameters:
  bTestByteOrder - [in]
    If bTestByteOrder is true and the first element of sUTF16[]
    is 0xFEFF, then this element is ignored.

    If bTestByteOrder is true and the first element of sUTF16[]
    is 0xFFFE, then this element is ignored and the subsequent
    elements of sUTF16[] have their bytes swapped before the 
    conversion is calculated.

    In all other cases the first element of sUTF16[] is 
    converted and no byte swapping is performed.

  sUTF16 - [in]
    UTF-16 string to convert.  
    
    If bTestByteOrder is true and the first element of sUTF16[]
    is 0xFEFF, then this element is skipped and it is assumed 
    that sUTF16[] is in the CPU's native byte order.
    
    If bTestByteOrder is true and the first element of sUTF16[]
    is 0xFFFE, then this element is skipped and it is assumed 
    that sUTF16[] is not in the CPU's native byte order and bytes
    are swapped before characters are converted.

    If bTestByteOrder is false or the first character of sUTF16[]
    is neither 0xFEFF nor 0xFFFE, then the sUTF16 string must match
    the CPU's byte order.

  sUTF16_count - [in]
    If sUTF16_count >= 0, then it specifies the number of
    ON__UINT16 elements in sUTF16[] to convert.

    If sUTF16_count == -1, then sUTF16 must be a null terminated
    string and all the elements up to the first null element are
    converted.

  sUTF32 - [out]
    If sUTF32 is not null and sUTF32_count > 0, then the UTF-32
    encoded string is returned in this buffer. If there is room
    for the null terminator, the converted string will be null
    terminated. The null terminator is never included in the count 
    of returned by this function. The converted string is in the 
    CPU's native byte order. No byte order mark is prepended.

  sUTF32_count - [in]
    If sUTF32_count > 0, then it specifies the number of available
    ON__UINT32 elements in the sUTF32[] buffer.
    
    If sUTF32_count == 0, then the sUTF32 parameter is ignored.

  error_status - [out]
    If error_status is not null, then bits of *error_status are
    set to indicate the success or failure of the conversion.  
    When the error_mask parameter is used to used to mask some
    conversion errors, multiple bits may be set.
       0: Successful conversion with no errors.
       1: Invalid input parameters. This error cannot be masked.
       2: The sUTF32 output buffer was not large enough to hold 
          the converted string. This error cannot be masked.
      16: An illegal UTF-16 encoding sequence occured or an invalid
          unicode code point value resulted from decoding a
          UTF-16 sequence. This error can be masked. If the error is
          masked and error_code_point is a valid unicode code point,
          then its value is added to the UTF-32 output string and 
          parsing continues.

  error_mask - [in]
    If 0 != (error_mask & 16) and error_code_point is a valid unicode
    code point value, then type 16 errors are masked.

  error_code_point - [in]
    Unicode code point value to use in when masking type 16 errors.
    If 0 == (error_mask & 16), then this parameter is ignored.
    0xFFFD is a popular choice for the error_code_point value.

  sNextUTF16 - [out]
    If sNextUTF16 is not null, then *sNextUTF16 points to the first
    element in the input sUTF16[] buffer that was not converted. 

    If an error occurs and is not masked, then *sNextUTF16 points to
    the element of sUTF16[] where the conversion failed.  If no errors
    occur or all errors are masked, then *sNextUTF16 points to
    sUTF16 + sUTF16_count.

Returns:
  If sUTF32_count > 0, the return value is the number of ON__UINT32
  elements written to sUTF32[].  When the return value < sUTF32_count,
  a null terminator is written to sUTF32[return value].

  If sUTF32_count == 0, the return value is the minimum number of
  ON__UINT32 elements that are needed to hold the converted string.
  The return value does not include room for a null terminator.  
  Increment the return value by one if you want to have an element
  to use for a null terminator.
*/
ON_DECL
int ON_ConvertUTF16ToUTF32(
    int bTestByteOrder,
    const ON__UINT16* sUTF16,
    int sUTF16_count,
    unsigned int* sUTF32,
    int sUTF32_count,
    unsigned int* error_status,
    unsigned int error_mask,
    ON__UINT32 error_code_point,
    const ON__UINT16** sNextUTF16
    );

/*
Description:
  Convert a unicode string from a UTF-32 encoded ON__UINT32 array
  into a UTF-8 encoded ON__UINT8 array.

Parameters:
  bTestByteOrder - [in]
    If bTestByteOrder is true and the first element of sUTF32[]
    is 0x0000FEFF, then this element is ignored.

    If bTestByteOrder is true and the first element of sUTF32[]
    is 0xFFFE0000, then this element is ignored and the subsequent
    elements of sUTF32[] have their bytes swapped before the 
    conversion is calculated.

    In all other cases the first element of sUTF32[] is 
    converted and no byte swapping is performed.

  sUTF32 - [in]
    UTF-32 string to convert.  
    
    If bTestByteOrder is true and the first element of sUTF32[]
    is 0x0000FEFF, then this element is skipped and it is assumed 
    that sUTF32[] is in the CPU's native byte order.
    
    If bTestByteOrder is true and the first element of sUTF32[]
    is 0xFFFE0000, then this element is skipped and it is assumed 
    that sUTF32[] is not in the CPU's native byte order and bytes
    are swapped before characters are converted.

    If bTestByteOrder is false or the first character of sUTF32[]
    is neither 0x0000FEFF nor 0xFFFE0000, then the sUTF32 string 
    must match the CPU's byte order.

  sUTF32_count - [in]
    If sUTF32_count >= 0, then it specifies the number of
    ON__UINT32 elements in sUTF32[] to convert.

    If sUTF32_count == -1, then sUTF32 must be a null terminated
    string and all the elements up to the first null element are
    converted.
    
  sUTF8 - [out]
    If sUTF8 is not null and sUTF8_count > 0, then the UTF-8
    encoded string is returned in this buffer. If there is room
    for the null terminator, the converted string will be null
    terminated. The null terminator is never included in the count 
    of returned by this function. The converted string is in the 
    CPU's native byte order. No byte order mark is prepended.

  sUTF8_count - [in]
    If sUTF8_count > 0, then it specifies the number of available
    ON__UINT8 elements in the sUTF8[] buffer.
    
    If sUTF8_count == 0, then the sUTF8 parameter is ignored.

  error_status - [out]
    If error_status is not null, then bits of *error_status are
    set to indicate the success or failure of the conversion.  
    When the error_mask parameter is used to used to mask some
    conversion errors, multiple bits may be set.
       0: Successful conversion with no errors.
       1: Invalid input parameters. This error cannot be masked.
       2: The sUTF8 output buffer was not large enough to hold 
          the converted string. This error cannot be masked.
       4: The values of two UTF-32 elements form a valid
          UTF-16 surrogate pair. This error can be masked. If the
          error is masked, then the surrogate pair is converted
          to a valid unicode code point, its UTF-8 encoding is
          added to the UTF-8 output string and parsing continues.
      16: An invalid unicode code point occured in sUTF32[].
          This error can be masked. If the error is masked and
          error_code_point is a valid unicode code point,
          then its UTF-8 encoding is added to the UTF-8 output
          string and parsing continues.

  error_mask - [in]
    If 0 != (error_mask & 4), then type 4 errors are masked.
    If 0 != (error_mask & 16) and error_code_point is a valid unicode
    code point value, then type 16 errors are masked.

  error_code_point - [in]
    Unicode code point value to use in when masking type 16 errors.
    If 0 == (error_mask & 16), then this parameter is ignored.
    0xFFFD is a popular choice for the error_code_point value.

  sNextUTF32 - [out]
    If sNextUTF32 is not null, then *sNextUTF32 points to the first
    element in the input sUTF32[] buffer that was not converted. 

    If an error occurs and is not masked, then *sNextUTF32 points to
    the element of sUTF32[] where the conversion failed.  If no errors
    occur or all errors are masked, then *sNextUTF32 points to
    sUTF32 + sUTF32_count.

Returns:
  If sUTF8_count > 0, the return value is the number of ON__UINT8
  elements written to sUTF8[].  When the return value < sUTF8_count,
  a null terminator is written to sUTF8[return value].

  If sUTF8_count == 0, the return value is the minimum number of
  ON__UINT8 elements that are needed to hold the converted string.
  The return value does not include room for a null terminator.  
  Increment the return value by one if you want to have an element
  to use for a null terminator.
*/
ON_DECL
int ON_ConvertUTF32ToUTF8(
    int bTestByteOrder,
    const ON__UINT32* sUTF32,
    int sUTF32_count,
    ON__UINT8* sUTF8,
    int sUTF8_count,
    unsigned int* error_status,
    unsigned int error_mask,
    ON__UINT32 error_code_point,
    const ON__UINT32** sNextUTF32
    );

/*
Description:
  Convert a unicode string from a UTF-32 encoded ON__UINT32 array
  into a UTF-16 encoded ON__UINT16 array.

Parameters:
  bTestByteOrder - [in]
    If bTestByteOrder is true and the first element of sUTF32[]
    is 0x0000FEFF, then this element is ignored.

    If bTestByteOrder is true and the first element of sUTF32[]
    is 0xFFFE0000, then this element is ignored and the subsequent
    elements of sUTF32[] have their bytes swapped before the 
    conversion is calculated.

    In all other cases the first element of sUTF32[] is 
    converted and no byte swapping is performed.

  sUTF32 - [in]
    UTF-32 string to convert.  
    
    If bTestByteOrder is true and the first element of sUTF32[]
    is 0x0000FEFF, then this element is skipped and it is assumed 
    that sUTF32[] is in the CPU's native byte order.
    
    If bTestByteOrder is true and the first element of sUTF32[]
    is 0xFFFE0000, then this element is skipped and it is assumed 
    that sUTF32[] is not in the CPU's native byte order and bytes
    are swapped before characters are converted.

    If bTestByteOrder is false or the first character of sUTF32[]
    is neither 0x0000FEFF nor 0xFFFE0000, then the sUTF32 string 
    must match the CPU's byte order.

  sUTF32_count - [in]
    If sUTF32_count >= 0, then it specifies the number of
    ON__UINT32 elements in sUTF32[] to convert.

    If sUTF32_count == -1, then sUTF32 must be a null terminated
    string and all the elements up to the first null element are
    converted.

  sUTF16 - [out]
    If sUTF16 is not null and sUTF16_count > 0, then the UTF-16
    encoded string is returned in this buffer. If there is room
    for the null terminator, the converted string will be null
    terminated. The null terminator is never included in the count 
    of returned by this function. The converted string is in the 
    CPU's native byte order. No byte order mark is prepended.

  sUTF16_count - [in]
    If sUTF16_count > 0, then it specifies the number of available
    ON__UINT16 elements in the sUTF16[] buffer.
    
    If sUTF16_count == 0, then the sUTF16 parameter is ignored.

  error_status - [out]
    If error_status is not null, then bits of *error_status are
    set to indicate the success or failure of the conversion.  
    When the error_mask parameter is used to used to mask some
    conversion errors, multiple bits may be set.
       0: Successful conversion with no errors.
       1: Invalid input parameters. This error cannot be masked.
       2: The sUTF16 output buffer was not large enough to hold 
          the converted string. This error cannot be masked.
       4: The values of two UTF-32 elements form a valid
          UTF-16 surrogate pair. This error can be masked. If the
          error is masked, then the surrogate pair is added to
          the UTF-16 output string and parsing continues.
      16: An invalid unicode code point occured in sUTF32[].
          This error can be masked. If the error is masked and
          error_code_point is a valid unicode code point,
          then its UTF-16 encoding is added to the UTF-16 output
          string and parsing continues.

  error_mask - [in]
    If 0 != (error_mask & 4), then type 4 errors are masked.
    If 0 != (error_mask & 16) and error_code_point is a valid unicode
    code point value, then type 16 errors are masked.

  error_code_point - [in]
    Unicode code point value to use in when masking type 16 errors.
    If 0 == (error_mask & 16), then this parameter is ignored.
    0xFFFD is a popular choice for the error_code_point value.

  sNextUnicode - [out]
    If sNextUnicode is not null, then *sNextUnicode points to the first
    byte in the input sNextUnicode[] buffer that was not converted. 

    If an error occurs and is not masked, then this unsigned int
    will be an illegal unicode code point value.

    If an error does not occur, then (*sNextUnicode - sUnicode) 
    is the number of values converted.

Returns:
  If sUTF16_count > 0, the return value is the number of ON__UINT16
  elements written to sUTF16[].  When the return value < sUTF16_count,
  a null terminator is written to sUTF16[return value].

  If sUTF16_count == 0, the return value is the minimum number of
  ON__UINT16 elements that are needed to hold the converted string.
  The return value does not include room for a null terminator.  
  Increment the return value by one if you want to have an element
  to use for a null terminator.
*/
ON_DECL
int ON_ConvertUTF32ToUTF16(
    int bTestByteOrder,
    const ON__UINT32* sUTF32,
    int sUTF32_count,
    ON__UINT16* sUTF16,
    int sUTF16_count,
    unsigned int* error_status,
    unsigned int error_mask,
    ON__UINT32 error_code_point,
    const ON__UINT32** sNextUTF32
    );

/*
Description:
  Convert a wchar_t string using the native platform's most common
  encoding into a unicode string encoded as a UTF-8 char array.

  If 2 = sizeof(wchar_t), then the wchar_t array is assumed to be
  a UTF-16 encoded string. This is the case with current versions
  of Microsoft Windows.

  If 4 = sizeof(wchar)t), then the wchar_t array is assumed to be
  a UTF-32 encoded string. This is the case with current versions
  of Apple OSX.

Parameters:
  bTestByteOrder - [in]
    If bTestByteOrder is true and the first element of sWideChar[]
    is 0xFEFF, then this element is ignored.

    If bTestByteOrder is true and the first element of sWideChar[]
    is 0xFFFE, then this element is ignored and the subsequent
    elements of sWideChar[] have their bytes swapped before the 
    conversion is calculated.

    In all other cases the first element of sWideChar[] is 
    converted and no byte swapping is performed.

  sWideChar - [in]
    wchar_t string to convert.  
    
    If bTestByteOrder is true and the first element of sWideChar[]
    is 0xFEFF, then this element is skipped and it is assumed 
    that sWideChar[] is in the CPU's native byte order.
    
    If bTestByteOrder is true and the first element of sWideChar[]
    is 0xFFFE, then this element is skipped and it is assumed 
    that sWideChar[] is not in the CPU's native byte order and bytes
    are swapped before characters are converted.

    If bTestByteOrder is false or the first character of sWideChar[]
    is neither 0xFEFF nor 0xFFFE, then the sWideChar string must match
    the CPU's byte order.

  sWideChar_count - [in]
    If sWideChar_count >= 0, then it specifies the number of
    wchar_t elements in sWideChar[] to convert.

    If sWideChar_count == -1, then sWideChar must be a null terminated
    string and all the elements up to the first null element are
    converted.
    
  sUTF8 - [out]
    If sUTF8 is not null and sUTF8_count > 0, then the UTF-8
    encoded string is returned in this buffer. If there is room
    for the null terminator, the converted string will be null
    terminated. The null terminator is never included in the count 
    of returned by this function. The converted string is in the 
    CPU's native byte order. No byte order mark is prepended.

  sUTF8_count - [in]
    If sUTF8_count > 0, then it specifies the number of available
    ON__UINT8 elements in the sUTF8[] buffer.
    
    If sUTF8_count == 0, then the sUTF8 parameter is ignored.

  error_status - [out]
    If error_status is not null, then bits of *error_status are
    set to indicate the success or failure of the conversion.  
    When the error_mask parameter is used to used to mask some
    conversion errors, multiple bits may be set.
       0: Successful conversion with no errors.
       1: Invalid input parameters. This error cannot be masked.
       2: The sUTF8 output buffer was not large enough to hold 
          the converted string. This error cannot be masked.
      16: An illegal wchar_t encoding sequence occured or an invalid
          unicode code point value resulted from decoding a
          wchar_t sequence. This error can be masked. If the error is
          masked and error_code_point is a valid unicode code point,
          then its UTF-8 encoding is added to the UTF-8 output
          string and parsing continues.

  error_mask - [in]
    If 0 != (error_mask & 16) and error_code_point is a valid unicode
    code point value, then type 16 errors are masked.

  error_code_point - [in]
    Unicode code point value to use in when masking type 16 errors.
    If 0 == (error_mask & 16), then this parameter is ignored.
    0xFFFD is a popular choice for the error_code_point value.

  sNextWideChar - [out]
    If sNextWideChar is not null, then *sNextWideChar points to the first
    element in the input sWideChar[] buffer that was not converted. 

    If an error occurs and is not masked, then *sNextWideChar points to
    the element of sWideChar[] where the conversion failed.  If no errors
    occur or all errors are masked, then *sNextWideChar points to
    sWideChar + sWideChar_count.

  If sUTF8_count > 0, the return value is the number of ON__UINT8
  elements written to sUTF8[].  When the return value < sUTF8_count,
  a null terminator is written to sUTF8[return value].

  If sUTF8_count == 0, the return value is the minimum number of
  ON__UINT8 elements that are needed to hold the converted string.
  The return value does not include room for a null terminator.  
  Increment the return value by one if you want to have an element
  to use for a null terminator.
*/
ON_DECL
int ON_ConvertWideCharToUTF8(
    int bTestByteOrder,
    const wchar_t* sWideChar,
    int sWideChar_count,
    char* sUTF8,
    int sUTF8_count,
    unsigned int* error_status,
    unsigned int error_mask,
    ON__UINT32 error_code_point,
    const wchar_t** sNextWideChar
    );

/*
Description:
  Convert a UTF-8 encoded char string to wchar_t string using
  the native platform's most common encoding.

  If 2 = sizeof(wchar_t), then UTF-16 encoding is used for the
  output string. This is the case with current versions of
  Microsoft Windows.

  If 4 = sizeof(wchar_t), then UTF-32 encoding is used for the
  output string. This is the case with current versions of
  Apple OSX.

Parameters:
  sUTF8 - [in]
    UTF-8 string to convert.

  sUTF8_count - [in]
    If sUTF8_count >= 0, then it specifies the number of
    ON__UINT8 elements in sUTF8[] to convert.

    If sUTF8_count == -1, then sUTF8 must be a null terminated
    string and all the elements up to the first null element are
    converted.

  sWideChar - [out]
    If sWideChar is not null and sWideChar_count > 0, then the
    output string is returned in this buffer. If there is room
    for the null terminator, the converted string will be null
    terminated. The null terminator is never included in the count 
    of returned by this function. The converted string is in the 
    CPU's native byte order. No byte order mark is prepended.

  sWideChar_count - [in]
    If sWideChar_count > 0, then it specifies the number of available
    wchar_t elements in the sWideChar[] buffer.
    
    If sWideChar_count == 0, then the sWideChar parameter is ignored.

  error_status - [out]
    If error_status is not null, then bits of *error_status are
    set to indicate the success or failure of the conversion.  
    When the error_mask parameter is used to used to mask some
    conversion errors, multiple bits may be set.
       0: Successful conversion with no errors.
       1: Invalid input parameters. This error cannot be masked.
       2: The sWideChar output buffer was not large enough to hold 
          the converted string. This error cannot be masked.
       4: The values of two UTF-8 encoding sequences formed a valid
          UTF-16 surrogate pair. This error can be masked.  If the
          error is masked, then the surrogate pair is added
          to the UTF-16 output string and parsing continues.
       8: An overlong UTF-8 encoding sequence was encountered. 
          The value of the overlong sequence was a valid unicode
          code point. This error can be masked. If the error is masked,
          then the unicode code point is encoded and added to the
          UTF-16 output string and parsing continues.
      16: An illegal UTF-8 encoding sequence occured or an invalid
          unicode code point value resulted from decoding a
          UTF-8 sequence. This error can be masked. If the error is
          masked and error_code_point is a valid unicode code point,
          then its encoding is added to the output string and parsing
          continues.

  error_mask - [in]
    If 0 != (error_mask & 4), then type 4 errors are masked.
    If 0 != (error_mask & 8), then type 8 errors are masked.
    If 0 != (error_mask & 16) and error_code_point is a valid unicode
    code point value, then type 16 errors are masked.

  error_code_point - [in]
    Unicode code point value to use in when masking type 16 errors.
    If 0 == (error_mask & 16), then this parameter is ignored.
    0xFFFD is a popular choice for the error_code_point value.

  sNextUTF8 - [out]
    If sNextUTF8 is not null, then *sNextUTF8 points to the first
    element in the input sUTF8[] buffer that was not converted. 

    If an error occurs and is not masked, then *sNextUTF8 points to
    the element of sUTF8[] where the conversion failed.  If no errors
    occur or all errors are masked, then *sNextUTF8 points to
    sUTF8 + sUTF8_count.

Returns:
  If sWideChar_count > 0, the return value is the number of wchar_t
  elements written to sWideChar[].  When the return value < sWideChar_count,
  a null terminator is written to sWideChar[return value].

  If sWideChar_count == 0, the return value is the minimum number of
  wchar_t elements that are needed to hold the converted string.
  The return value does not include room for a null terminator.  
  Increment the return value by one if you want to have an element
  to use for a null terminator.
*/
ON_DECL
int ON_ConvertUTF8ToWideChar(
    const char* sUTF8,
    int sUTF8_count,
    wchar_t* sWideChar,
    int sWideChar_count,
    unsigned int* error_status,
    unsigned int error_mask,
    ON__UINT32 error_code_point,
    const char** sNextUTF8
    );

ON_END_EXTERNC

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/
#if !defined(OPENNURBS_FSP_INC_)
#define OPENNURBS_FSP_INC_

class ON_CLASS ON_FixedSizePool
{
public:
  ON_FixedSizePool();
  ~ON_FixedSizePool();
  
  /*
  Description:
    Create a fixed size memory pool.
  Parameters:
    sizeof_element - [in] 
      number of bytes in each element. This parameter must be greater than zero.
      In general, use sizeof(element type).  If you pass a "raw" number as 
      sizeof_element, then be certain that it is the right size to insure the 
      fields in your elements will be properly aligned.
    element_count_estimate - [in] (0 = good default)
      If you know how many elements you will need, pass that number here.
      It is better to slightly overestimate than to slightly underestimate.
      If you do not have a good estimate, then use zero.
    block_element_capacity - [in] (0 = good default)
      If block_element_capacity is zero, Create() will calculate a block
      size that is efficent for most applications.  If you are an expert
      user and want to specify the number of elements per block,
      then pass the number of elements per block here.  When 
      block_element_capacity > 0 and element_count_estimate > 0, the first 
      block will have a capacity of at least element_count_estimate; in this
      case do not ask for extraordinarly large amounts of contiguous heap.
  Remarks:
    You must call Create() on an unused ON_FixedSizePool or call Destroy()
    before calling create.
  Returns:
    True if successful and the pool can be used.
  */
  bool Create( 
    size_t sizeof_element,
    size_t element_count_estimate,
    size_t block_element_capacity
    );

  /*
  Returns:
    Size of the elements in this pool.
  */
  size_t SizeofElement() const;

  /*
  Returns:
    A pointer to sizeof_element bytes.  The memory is zeroed.
  */
  void* AllocateElement();
  
  /*
  Description:
    Return an element to the pool.
  Parameters:
    p - [in]
      A pointer returned by AllocateElement().
      It is critical that p be from this pool and that
      you return a pointer no more than one time.
  Remarks:
    If you find the following remarks confusing, but you really want to use
    ReturnElement(), then here are some simple guidelines.
      1) SizeofElement() must be >= 16
      2) SizeofElement() must be a multiple of 8.
      3) Do not use FirstElement() and NextElement() to iterate through
         the pool.

    If 1 to 3 don't work for you, then you need to understand the following
    information before using ReturnElement().

    ON_FixedMemoryPool uses the first sizeof(void*) bytes of the
    returned element for bookkeeping purposes.  Therefore, if you
    are going to use ReturnElement(), then SizeofElement() must be 
    at least sizeof(void*).  If you are using a platform that requires
    pointers to be aligned on sizeof(void*) boundaries, then
    SizeofElement() must be a multiple of sizeof(void*).
    If you are going to use ReturnElement() and then use FirstElement()
    and NextElement() to iterate through the list of elements, then you
    need to set a value in the returned element to indicate that it
    needs to be skipped during the iteration.  This value cannot be
    located in the fist sizeof(void*) bytes of the element.  If the 
    element is a class with a vtable, you cannot call a virtual 
    function on a returned element because the vtable pointer is 
    trashed when ReturnElement() modifies the fist sizeof(void*) bytes.
  */
  void ReturnElement(void* p);

  /*
  Description:
    Return all allocated elements to the pool. No heap is freed and
    the pool remains initialized and ready for AllocateElement()
    to be called.
  */
  void ReturnAll();

  /*
  Description:
    Destroy the pool and free all the heap. The pool cannot be used again
    until Create() is called.
  */
  void Destroy();

  /*
  Returns:
    Number of active elements. (Elements that have been returned are not active.)
  */
  size_t ActiveElementCount() const;

  /*
  Returns:
    Total number of elements = number of active elements + number of returned elements.
  */
  size_t TotalElementCount() const;

  /*
  Description:
    Get the first element when iterating through the list of elements.
  Parameters:
    element_index - [in]
      If you use the version of FirstElement() that has an 
      element_index parameter, then the iteration begins at
      that element.
  Example:
    The loop will iteratate through all the elements returned from
    AllocateElement(), including any that have be returned to the pool
    using ReturnElement().

          // iterate through all elements in the pool
          // This iteration will go through TotalElements() items.
          for ( void* p = FirstElement(); 0 != p; p = NextElement() )
          {
            // If you are not using ReturnElement(), then you may process
            // "p" immediately. If you have used ReturnElement(), then you
            // must check some value in p located after the first sizeof(void*)
            // bytes to see if p is active.
            if ( p is not active )
              continue;

            ... process p
          }

  Returns:
    The first element when iterating through the list of elements.
  Remarks:
    FirstElement() and NextElement() will return elements that have 
    been returned to the pool using ReturnElement().  If you use 
    ReturnElement(), then be sure to mark the element so it can be
    identified and skipped.

    Do not make any calls to FirstBlock() or NextBlock() when using
    FirstElement() and NextElement() to iteratate through elements.

    If you need iterate through a fixed size pool and another
    function may also be in the middle of iterating the pool
    as well, then use ON_FixedSizePoolIterator.  In particular,
    if you have multiple concurrent threads iterating the same 
    fixed size pool, then use ON_FixedSizePoolIterator.
  */
  void* FirstElement();
  void* FirstElement( size_t element_index );

  /*
  Description:
    Get the next element when iterating through the list of elements.
  Example:
    See the FirstElement() documentation.
  Returns:
    The next element when iterating through the list of elements.
  Remarks:
    FirstElement() and NextElement() will return elements that have 
    been returned to the pool using ReturnElement().  If you use 
    ReturnElement(), then be sure to mark the element so it can be
    identified and skipped.

    Do not make any calls to FirstBlock() or NextBlock() when using
    FirstElement() and NextElement() to iteratate through elements.

    If you need iterate through a fixed size pool and another
    function may also be in the middle of iterating the pool
    as well, then use ON_FixedSizePoolIterator.  In particular,
    if you have multiple concurrent threads iterating the same 
    fixed size pool, then use ON_FixedSizePoolIterator.
  */
  void* NextElement();

  /*
  Description:
    Get a pointer to the first element in the first block.
  Parameters:
    block_element_count - [out] (can be null)
      If not null, the number of elements allocated from the
      first block is returned in block_element_count.
      Note that if you have used ReturnElement(), some
      of these elemements may have been returned.
  Example:
    The loop will iteratate through all the blocks.

          // iterate through all blocks in the pool
          size_t block_element_count = 0;
          for ( void* p = FirstBlock(&block_element_count); 
                0 != p; 
                p = NextBlock(&block_element_count) 
              )
          {
            ElementType* e = (ElementType*)p;
            for ( size_t i = 0; 
                  i < block_element_count; 
                  i++, e = ((const char*)e) + SizeofElement() 
                )
            {
              ...
            }
          }

  Returns:
    The first block when iterating the list of blocks.
  Remarks:
    The heap for a fixed size memory pool is simply a linked
    list of blocks. FirstBlock() and NextBlock() can be used
    to iterate through the list of blocks.

    Do not make any calls to FirstElement() or NextElement() when using
    FirstBlock() and NextBlock() to iteratate through blocks.

    If you need iterate through a fixed size pool and another
    function may also be in the middle of iterating the pool
    as well, then use ON_FixedSizePoolIterator.  In particular,
    if you have multiple concurrent threads iterating the same 
    fixed size pool, then use ON_FixedSizePoolIterator.
  */
  void* FirstBlock( size_t* block_element_count );

  /*
  Description:
    Get the next block when iterating through the blocks.
  Parameters:
    block_element_count - [out] (can be null)
      If not null, the number of elements allocated from the
      block is returned in block_element_count.  Note that if
      you have used ReturnElement(), some of these elemements
      may have been returned.
  Example:
    See the FirstBlock() documentation.
  Returns:
    The next block when iterating through the blocks.
  Remarks:
    Do not make any calls to FirstElement() or NextElement() when using
    FirstBlock() and NextBlock() to iteratate through blocks.

    If you need iterate through a fixed size pool and another
    function may also be in the middle of iterating the pool
    as well, then use ON_FixedSizePoolIterator.  In particular,
    if you have multiple concurrent threads iterating the same 
    fixed size pool, then use ON_FixedSizePoolIterator.
  */
  void* NextBlock( size_t* block_element_count );

  /*
  Description:
    Get the i-th elment in the pool.
  Parameters:
    element_index - [in]
  Returns:
    A pointer to the i-th element.  The first element has index = 0
    and is the element returned by the first call to AllocateElement().
    The last element has index = ElementCount()-1.
    If i is out of range, null is returned.
  Remarks:
    It is faster to use FirstElement() and NextElement() to iterate
    through the entire list of elements.  This function is relatively
    efficient when there are a few large blocks in the pool
    or element_index is small compared to the number of elements
    in the first few blocks.

    If ReturnElement() is not used or AllocateElement() calls to
    are made after any use of ReturnElement(), then the i-th 
    element is the one returned by the (i+1)-th call to 
    AllocateElement().
  */
  void* Element(size_t element_index) const;

public:
  // Expert user functions below for situations where you
  // need to specify the heap used for this pool.

  /*
  Description:
    Expert user function to specify which heap is used.
  */
  void SetHeap( ON_MEMORY_POOL* heap );

  /*
  Description:
    Expert user function.
  Returns:
    Heap used by this pool.  A null pointer means the default
    heap is being used.
  */
  ON_MEMORY_POOL* Heap();

  /*
  Description:
    Expert user function to call when the heap used by this pool
    is no longer valid.  This call zeros all fields and does not
    call any heap functions.  After calling EmergencyDestroy(), 
    the destructor will not attempt to free any heap.
  */
  void EmergencyDestroy();

private:
  friend class ON_FixedSizePoolIterator;

  void* m_first_block;

  // ReturnElement() adds to the m_al_element stack.
  // AllocateElement() will use the stack before using m_al_element_array[]
  void* m_al_element_stack;

  // used by the iterators
  void* m_qwerty_it_block;
  void* m_qwerty_it_element;

  void* m_al_block; // current element allocation block.
  // m_al_element_array[] is in m_al_block and has length m_al_count.
  void* m_al_element_array;
  size_t m_al_count;
  size_t m_sizeof_element;
  size_t m_block_element_count;  // block element count
  size_t m_active_element_count; // number of active elements
  size_t m_total_element_count;  // total number of elements (active + returned)
  ON_MEMORY_POOL* m_heap;
  
private:
  // returns capacity of elements in existing block
  size_t BlockElementCapacity( const void* block ) const;

  // returns number of allocated of elements in existing block
  size_t BlockElementCount( const void* block ) const;
private:
  // prohibit copy construction and operator=.
  ON_FixedSizePool(const ON_FixedSizePool&);
  ON_FixedSizePool& operator=(const ON_FixedSizePool&);
};

class ON_CLASS ON_FixedSizePoolIterator
{
public:
  ON_FixedSizePoolIterator( const class ON_FixedSizePool& fsp );

  const class ON_FixedSizePool& m_fsp;

  /*
  Description:
    Get the first element when iterating through the list of elements.
  Parameters:
    element_index - [in]
      If you use the version of FirstElement() that has an 
      element_index parameter, then the iteration begins at
      that element.
  Example:
    The loop will iteratate through all the elements returned from
    AllocateElement(), including any that have be returned to the pool
    using ReturnElement().

          // iterate through all elements in the pool
          // This iteration will go through TotalElements() items.
          for ( void* p = FirstElement(); 0 != p; p = NextElement() )
          {
            // If you are not using ReturnElement(), then you may process
            // "p" immediately. If you have used ReturnElement(), then you
            // must check some value in p located after the first sizeof(void*)
            // bytes to see if p is active.
            if ( p is not active )
              continue;

            ... process p
          }

  Returns:
    The first element when iterating through the list of elements.
  Remarks:
    FirstElement() and NextElement() will return elements that have 
    been returned to the pool using ReturnElement().  If you use 
    ReturnElement(), then be sure to mark the element so it can be
    identified and skipped.

    Do not make any calls to FirstBlock() or NextBlock() when using
    FirstElement() and NextElement() to iteratate through elements.
  */
  void* FirstElement();
  void* FirstElement( size_t element_index );

  /*
  Description:
    Get the next element when iterating through the list of elements.
  Example:
    See the FirstElement() documentation.
  Returns:
    The next element when iterating through the list of elements.
  Remarks:
    FirstElement() and NextElement() will return elements that have 
    been returned to the pool using ReturnElement().  If you use 
    ReturnElement(), then be sure to mark the element so it can be
    identified and skipped.

    Do not make any calls to FirstBlock() or NextBlock() when using
    FirstElement() and NextElement() to iteratate through elements.
  */
  void* NextElement();

  /*
  Description:
    Get a pointer to the first element in the first block.
  Parameters:
    block_element_count - [out] (can be null)
      If not null, the number of elements allocated from the
      first block is returned in block_element_count.
      Note that if you have used ReturnElement(), some
      of these elemements may have been returned.
  Example:
    The loop will iteratate through all the blocks.

          // iterate through all blocks in the pool
          size_t block_element_count = 0;
          for ( void* p = FirstBlock(&block_element_count); 
                0 != p; 
                p = NextBlock(&block_element_count) 
              )
          {
            ElementType* e = (ElementType*)p;
            for ( size_t i = 0; 
                  i < block_element_count; 
                  i++, e = ((const char*)e) + SizeofElement() 
                )
            {
              ...
            }
          }

  Returns:
    The first block when iterating the list of blocks.
  Remarks:
    The heap for a fixed size memory pool is simply a linked
    list of blocks. FirstBlock() and NextBlock() can be used
    to iterate through the list of blocks.

    Do not make any calls to FirstElement() or NextElement() when using
    FirstBlock() and NextBlock() to iteratate through blocks.
  */
  void* FirstBlock( size_t* block_element_count );

  /*
  Description:
    Get the next block when iterating through the blocks.
  Parameters:
    block_element_count - [out] (can be null)
      If not null, the number of elements allocated from the
      block is returned in block_element_count.  Note that if
      you have used ReturnElement(), some of these elemements
      may have been returned.
  Example:
    See the FirstBlock() documentation.
  Returns:
    The next block when iterating through the blocks.
  Remarks:
    Do not make any calls to FirstElement() or NextElement() when using
    FirstBlock() and NextBlock() to iteratate through blocks.
  */
  void* NextBlock( size_t* block_element_count );

private:
  void* m_it_block;
  void* m_it_element;

  // no implementation (you can use a copy construtor)
  ON_FixedSizePoolIterator& operator=(const ON_FixedSizePoolIterator&);
};


template <class T> class ON_SimpleFixedSizePool : private ON_FixedSizePool
{
public:
  // construction ////////////////////////////////////////////////////////

  ON_SimpleFixedSizePool();
  ~ON_SimpleFixedSizePool();
  
  /*
  Description:
    Create a fixed size memory pool.
  Parameters:
    element_count_estimate - [in] (0 = good default)
      If you know how many elements you will need, pass that number here.
      It is better to slightly overestimate than to slightly underestimate.
      If you do not have a good estimate, then use zero.
    block_element_count - [in] (0 = good default)
      If block_element_count is zero, Create() will calculate a block
      size that is efficent for most applications.  If you are an expert
      user and want to specify the number of blocks, then pass the number
      of elements per block here.  When block_element_count > 0 and
      element_count_estimate > 0, the first block will be large enough
      element_count_estimate*sizeof(T) bytes; in this case do not
      ask for extraordinarly large amounts of contiguous heap.
  Remarks:
    You must call Create() on an unused ON_FixedSizePool or call Destroy()
    before calling create.
  Returns:
    True if successful and the pool can be used.
  */
  bool Create( 
    size_t element_count_estimate,
    size_t block_element_count
    );

  /*
  Returns:
    Size of the elements in this pool.
  */
  size_t SizeofElement() const;

  /*
  Returns:
    A pointer to sizeof_element bytes.  The memory is zeroed.
  */
  T* AllocateElement();
  
  /*
  Description:
    Return an element to the pool.
  Parameters:
    p - [in]
      A pointer returned by AllocateElement().
      It is critical that p be from this pool and that
      you return a pointer no more than one time.
  Remarks:
    If you find the following remarks confusing, but you really want to use
    ReturnElement(), then here are some simple guidelines.
      1) SizeofElement() must be >= 16
      2) SizeofElement() must be a multiple of 8.
      3) Do not use FirstElement() and NextElement() to iterate through
         the pool.

    If 1 to 3 don't work for you, then you need to understand the following
    information before using ReturnElement().

    ON_FixedMemoryPool uses the first sizeof(void*) bytes of the
    returned element for bookkeeping purposes.  Therefore, if you
    are going to use ReturnElement(), then SizeofElement() must be 
    at least sizeof(void*).  If you are using a platform that requires
    pointers to be aligned on sizeof(void*) boundaries, then
    SizeofElement() must be a multiple of sizeof(void*).
    If you are going to use ReturnElement() and then use FirstElement()
    and NextElement() to iterate through the list of elements, then you
    need to set a value in the returned element to indicate that it
    needs to be skipped during the iteration.  This value cannot be
    located in the fist sizeof(void*) bytes of the element.  If the 
    element is a class with a vtable, you cannot call a virtual 
    function on a returned element because the vtable pointer is 
    trashed when ReturnElement() modifies the fist sizeof(void*) bytes.
  */
  void ReturnElement(T* p);

  /*
  Description:
    Return all allocated elements to the pool. No heap is freed and
    the pool remains initialized and ready for AllocateElement()
    to be called.
  */
  void ReturnAll();

  /*
  Description:
    Destroy the pool and free all the heap. The pool cannot be used again
    until Create() is called.
  */
  void Destroy();

  /*
  Returns:
    Number of active elements. (Elements that have been returned are not active.)
  */
  size_t ActiveElementCount() const;

  /*
  Returns:
    Total number of elements = number of active elements + number of returned elements.
  */
  size_t TotalElementCount() const;

  /*
  Description:
    Get the next element when iterating through the active elements.
  Example:
    The loop will iteratate through all the elements returned from
    AllocateElement(), including any that have be returned to the pool
    using ReturnElement().

          // iterate through all elements in the pool
          for ( T* p = FirstElement(); 0 != p; p = NextElement() )
          {
            // If you are not using ReturnElement(), then you may process
            // "p" immediately. If you have used ReturnElement(), then you
            // must check some value in p located after the first sizeof(void*)
            // bytes to see if p is active.
            if ( p is not active )
              continue;

            ... process p
          }

  Returns:
    The next element when iterating through the active elements.
  Remarks:
    NextElement() will return elements that have been returned to
    the pool using ReturnElement().  If you use ReturnElement(),
    be sure to mark the element so it can be identified and skipped.
  */
  T* FirstElement();

  /*
  Description:
    Get the next element when iterating through the active elements.
  Example:
    See the FirstElement() documentation.
  Returns:
    The next element when iterating through the active elements.
  Remarks:
    NextElement() will return elements that have been returned to
    the pool using ReturnElement().  If you use ReturnElement(),
    be sure to mark the element so it can be identified and skipped.
  */
  T* NextElement();

  /*
  Description:
    Get a pointer to the first element in the first block.
  Example:
    The loop will iteratate through all the blocks.

          // iterate through all blocks in the pool
          size_t block_element_count = 0;
          for ( T* p = FirstBlock(&block_element_count); 
                0 != p; 
                p = NextBlock(&block_element_count) 
              )
          {
            // a[] is an array of length block_element_count
          }

  Returns:
    The next block when iterating the list of blocks.
  Remarks:
    Do not make any calls to FirstElement() or NextElement() when using
    FirstBlock() and NextBlock() to iteratate through blocks.
  */
  T* FirstBlock( size_t* block_element_count );

  /*
  Description:
    Get the next block when iterating through the blocks.
  Example:
    See the FirstBlock() documentation.
  Returns:
    The next block when iterating through the blocks.
  Remarks:
    Do not make any calls to FirstElement() or NextElement() when using
    FirstBlock() and NextBlock() to iteratate through blocks.
  */
  T* NextBlock( size_t* block_element_count );


  /*
  Description:
    Get the i-th elment in the pool.
  Parameters:
    element_index - [in]
  Returns:
    A pointer to the i-th element.  The first element has index = 0
    and is the element returned by the first call to AllocateElement().
    The last element has index = ElementCount()-1.
    If i is out of range, null is returned.
  Remarks:
    It is faster to use FirstElement() and NextElement() to iterate
    through the entire list of elements.  This function is relatively
    efficient when there are a few large blocks in the pool
    or element_index is small compared to the number of elements
    in the first few blocks.

    If ReturnElement() is not used or AllocateElement() calls to
    are made after any use of ReturnElement(), then the i-th 
    element is the one returned by the (i+1)-th call to 
    AllocateElement().
  */
  T* Element(size_t element_index) const;

public:
  // Expert user functions below for situations where you
  // need to specify the heap used for this pool.

  /*
  Description:
    Expert user function to specify which heap is used.
  */
  void SetHeap( ON_MEMORY_POOL* heap );

  /*
  Description:
    Expert user function.
  Returns:
    Heap used by this pool.  A null pointer means the default
    heap is being used.
  */
  ON_MEMORY_POOL* Heap();

  /*
  Description:
    Expert user function to call when the heap used by this pool
    is no longer valid.  This call zeros all fields and does not
    call any heap functions.  After calling EmergencyDestroy(), 
    the destructor will not attempt to free any heap.
  */
  void EmergencyDestroy();

private:
  // prohibit copy construction and operator=.
  ON_SimpleFixedSizePool(const ON_SimpleFixedSizePool<T>&);
  ON_SimpleFixedSizePool<T>& operator=(const ON_SimpleFixedSizePool<T>&);
};

// definitions of the template functions are in a different file
// so that Microsoft's developer studio's autocomplete utility
// will work on the template functions.
#include "opennurbs_fsp_defs.h"

#endif

/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(ON_STRING_INC_)
#define ON_STRING_INC_



/*
Description:
  Sort an index array.
Parameters
  method - [in]
    ON::quick_sort (best in general) or ON::heap_sort.
    Use ON::heap_sort only after doing meaningful performance
    testing using optimized release builds that demonstrate
    ON::heap_sort is significantly better.
  index - [out] 
    Pass in an array of count integers.  The returned
    index[] is a permutation of (0,1,..,count-1)
    such that compare(B[index[i]],B[index[i+1]) <= 0
    where B[i] = base + i*sizeof_element
  base - [in]
    array of count elements
  count - [in]
    number of elements in the index[] and base[] arrays
  sizeof_element - [in]
    number of bytes between consecutive elements in the
    base[] array.
  compare - [in]
    Comparison function a la qsort().
*/
ON_DECL
void ON_Sort( 
        ON::sort_algorithm method,
        int* index,
        const void* base,
        size_t count,
        size_t sizeof_element,
        int (*compare)(const void*,const void*) // int compar(const void*,const void*)
        );

/*
Description:
  Sort an index array using a compare function
  that takes an additional pointer that can be used to
  pass extra informtation.
Parameters
  method - [in]
    ON::quick_sort (best in general) or ON::heap_sort.
    Use ON::heap_sort only after doing meaningful performance
    testing using optimized release builds that demonstrate
    ON::heap_sort is significantly better.
  index - [out] 
    Pass in an array of count integers.  The returned
    index[] is a permutation of (0,1,..,count-1)
    such that compare(B[index[i]],B[index[i+1]) <= 0
    where B[i] = base + i*sizeof_element
  base - [in]
    array of count elements
  count - [in]
    number of elements in the index[] and base[] arrays
  sizeof_element - [in]
    number of bytes between consecutive elements in the
    base[] array.
  compare - [in]
    Comparison function a la qsort().  The context parameter
    is pass as the third argument.
  context - [in]
    pointer passed as the third argument to compare().
*/
ON_DECL
void ON_Sort( 
        ON::sort_algorithm method,
        int* index,
        const void* base,
        size_t count,
        size_t sizeof_element,
        int (*compare)(const void*,const void*,void*), // int compar(const void* a,const void* b, void* ptr)
        void* context
        );

/*
Description:
  Various sorts. When in doubt, use ON_qsort().
  ON_qsort - quick sort.
  ON_hsort = hearp sort.
Parameters
  base - [in]
    array of count elements
  count - [in]
    number of elements in the index[] and base[] arrays
  sizeof_element - [in]
    number of bytes between consecutive elements in the
    base[] array.
  compare - [in]
    Comparison function a la qsort().  The context parameter
    is pass as the third argument.
  context - [in]
    pointer passed as the third argument to compare().
Remarks:
  As a rule, use quick sort unless extensive tests in your case
  prove that heap sort is faster. 
  
  This implementation of quick sort is generally faster than 
  heap sort, even when the input arrays are nearly sorted.
  The only common case when heap sort is faster occurs when
  the arrays are strictly "chevron" (3,2,1,2,3) or "carat" 
  (1,2,3,2,1) ordered, and in these cases heap sort is about
  50% faster.  If the "chevron" or "caret" ordered arrays 
  have a little randomness added, the two algorithms have 
  the same speed.
*/
ON_DECL
void ON_hsort( 
        void* base,
        size_t count,
        size_t sizeof_element,
        int (*compare)(const void*,const void*)
        );

ON_DECL
void ON_qsort( 
        void* base,
        size_t count,
        size_t sizeof_element,
        int (*compare)(const void*,const void*)
        );

ON_DECL
void ON_hsort( 
        void* base,
        size_t count,
        size_t sizeof_element,
        int (*compare)(void*,const void*,const void*),
        void* context
        );

ON_DECL
void ON_qsort( 
        void* base,
        size_t count,
        size_t sizeof_element,
        int (*compare)(void*,const void*,const void*),
        void* context
        );

/*
Description:
  Sort an array of doubles in place.
Parameters:
  sort_algorithm - [in]  
    ON::quick_sort (best in general) or ON::heap_sort
    Use ON::heap_sort only if you have done extensive testing with
    optimized release builds and are confident heap sort is 
    significantly faster in your case.
  a - [in / out] 
    The values in a[] are sorted so that a[i] <= a[i+1].
    a[] cannot contain NaNs.
  nel - [in]
    length of array a[]
*/
ON_DECL
void ON_SortDoubleArray( 
        ON::sort_algorithm sort_algorithm,
        double* a,
        size_t nel
        );

/*
Description:
  Sort an array of ints in place.
Parameters:
  sort_algorithm - [in]  
    ON::quick_sort (best in general) or ON::heap_sort
    Use ON::heap_sort only if you have done extensive testing with
    optimized release builds and are confident heap sort is 
    significantly faster in your case.
  a - [in / out] 
    The values in a[] are sorted so that a[i] <= a[i+1].
  nel - [in]
    length of array a[]
*/
ON_DECL
void ON_SortIntArray(
        ON::sort_algorithm sort_algorithm,
        int* a,
        size_t nel
        );

/*
Description:
  Sort an array of unsigned ints in place.
Parameters:
  sort_algorithm - [in]  
    ON::quick_sort (best in general) or ON::heap_sort
    Use ON::heap_sort only if you have done extensive testing with
    optimized release builds and are confident heap sort is 
    significantly faster in your case.
  a - [in / out] 
    The values in a[] are sorted so that a[i] <= a[i+1].
  nel - [in]
    length of array a[]
*/
ON_DECL
void ON_SortUnsignedIntArray(
        ON::sort_algorithm sort_algorithm,
        unsigned int* a,
        size_t nel
        );

/*
Description:
  Sort an array of unsigned null terminated char strings in place.
Parameters:
  sort_algorithm - [in]  
    ON::quick_sort (best in general) or ON::heap_sort
    Use ON::heap_sort only if you have done extensive testing with
    optimized release builds and are confident heap sort is 
    significantly faster in your case.
  a - [in / out] 
    The values in a[] are sorted so that strcmp(a[i],a[i+1]) <= 0.
  nel - [in]
    length of array a[]
*/
ON_DECL
void ON_SortStringArray(
        ON::sort_algorithm sort_algorithm,
        char** a,
        size_t nel
        );

ON_DECL
const int* ON_BinarySearchIntArray( 
          int key, 
          const int* base, 
          size_t nel
          );

ON_DECL
const unsigned int* ON_BinarySearchUnsignedIntArray( 
          unsigned int key, 
          const unsigned int* base, 
          size_t nel
          );

ON_DECL
const double* ON_BinarySearchDoubleArray( 
          double key, 
          const double* base, 
          size_t nel
          );



/*
  This class is intended to be used to determine if a file's
  contents have changed.
*/
class ON_CLASS ON_CheckSum
{
public:
  ON_CheckSum();
  ~ON_CheckSum();

  static const ON_CheckSum UnsetCheckSum;

  // zeros all fields.
  void Zero();

  /*
  Returns:
    True if checksum is set.
  */
  bool IsSet() const;

  // C++ default operator=, operator==,
  // and copy constructor work fine.

  /*
  Descripton:
    Set check sum values for a buffer
  Parameters:
    size - [in] 
      number of bytes in buffer
    buffer - [in]  
    time - [in]
      last modified time in seconds since Jan 1, 1970, UCT
  Returns:
    True if checksum is set.
  */
  bool SetBufferCheckSum( 
    size_t size, 
    const void* buffer,
    time_t time
   );

  /*
  Descripton:
    Set check sum values for a file.
  Parameters:
    fp - [in] pointer to a file opened with ON:FileOpen(...,"rb")
  Returns:
    True if checksum is set.
  */
  bool SetFileCheckSum( 
    FILE* fp
   );

  /*
  Descripton:
    Set check sum values for a file.
  Parameters:
    filename - [in] name of file.
  Returns:
    True if checksum is set.
  */
  bool SetFileCheckSum( 
    const wchar_t* filename
   );

  /*
  Description:
    Test buffer to see if it has a matching checksum.
  Paramters:
    size - [in]   size in bytes
    buffer - [in]
  Returns:
    True if the buffer has a matching checksum.
  */
  bool CheckBuffer( 
    size_t size, 
    const void* buffer
    ) const;

  /*
  Description:
    Test buffer to see if it has a matching checksum.
  Paramters:
    fp - [in] pointer to file opened with ON::OpenFile(...,"rb")
    bSkipTimeCheck - [in] if true, the time of last
       modification is not checked.
  Returns:
    True if the file has a matching checksum.
  */
  bool CheckFile( 
    FILE* fp,
    bool bSkipTimeCheck = false
    ) const;

  /*
  Description:
    Test buffer to see if it has a matching checksum.
  Paramters:
    filename - [in]
    bSkipTimeCheck - [in] if true, the time of last
       modification is not checked.
  Returns:
    True if the file has a matching checksum.
  */
  bool CheckFile( 
    const wchar_t* filename,
    bool bSkipTimeCheck = false
    ) const;

  bool Write(class ON_BinaryArchive&) const;
  bool Read(class ON_BinaryArchive&);

  void Dump(class ON_TextLog&) const;

public:
  size_t     m_size;   // bytes in the file.
  time_t     m_time;   // last modified time in seconds since Jan 1, 1970, UCT
  ON__UINT32 m_crc[8]; // crc's
};

/////////////////////////////////////////////////////////////////////////////
// 
// ON_String is a char (a.k.a single byte or ascii) string
//
// ON_wString is a wide char (a.k.a double byte or unicode) string
//

class ON_String;  // char (a.k.a single byte or ascii) string
class ON_wString; // wide character (a.k.a double byte or unicode) string

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class ON_CLASS ON_String
{
public:

// Constructors
  ON_String();
  ON_String( const ON_String& );

  ON_String( const char* );
  ON_String( const char*, int /*length*/ );        // from substring

  ON_String( const unsigned char* );


  // construct a UTF-8 string string from a UTF-16 string.
  ON_String( const wchar_t* src );  // src = UTF-16 string
  ON_String( const wchar_t* src, int length ); // from a UTF-16 substringstring

  ON_String( const ON_wString& src ); // src = UTF-16 string

#if defined(ON_OS_WINDOWS)
  // Windows support
	bool LoadResourceString( HINSTANCE, UINT); // load from Windows string resource
										                         // 2047 chars max
#endif

  void Create();
  void Destroy(); // releases any memory and initializes to default empty string
  void EmergencyDestroy();

  /*
  Description:
    Enables reference counting.  I limited cases, this is useful 
    for large strings or strings that are frequently passed around.
    Reference counted strings must be carefully managed in
    when multi-threading is used.
  Parameters:
    If EnableReferenceCounting()
    is not called, then the string will not be referanceThe default is to not use
    reference counted strings.
  */
  void EnableReferenceCounting( bool bEnable );

  /*
  Returns:
    True if the string is reference counted.
  */
  bool IsReferenceCounted() const;


  // Attributes & Operations
	// as an array of characters
	int Length() const;
	bool IsEmpty() const; // returns true if length == 0 
  void Empty();   // sets length to zero - if possible, memory is retained

	char& operator[](int);
	char operator[](int) const;
  char GetAt(int) const;
	void SetAt(int, char);
	operator const char*() const;  // as a C string

	// overloaded assignment
	ON_String& operator=(const ON_String&);
	ON_String& operator=(char);
	ON_String& operator=(const char*);
	ON_String& operator=(unsigned char);
	ON_String& operator=(const unsigned char*);
	ON_String& operator=(const wchar_t* src); // src = UTF-16 string, result is a UTF-8 string
	ON_String& operator=(const ON_wString& src);  // src = UTF-16 string, result is a UTF-8 string

  // operator+()
  ON_String operator+(const ON_String&) const;
  ON_String operator+(char) const;
  ON_String operator+(unsigned char) const;
  ON_String operator+(const char*) const;
  ON_String operator+(const unsigned char*) const;

	// string comparison 
  bool operator==(const ON_String&) const;
  bool operator==(const char*)const ;
  bool operator!=(const ON_String&)const ;
  bool operator!=(const char*)const ;
  bool operator<(const ON_String&)const ;
  bool operator<(const char*)const ;
  bool operator>(const ON_String&)const ;
  bool operator>(const char*)const ;
  bool operator<=(const ON_String&)const ;
  bool operator<=(const char*)const ;
  bool operator>=(const ON_String&)const ;
  bool operator>=(const char*)const ;

  // string concatenation
  void Append( const char*, int ); // append specified number of characters
  void Append( const unsigned char*, int ); // append specified number of characters
	const ON_String& operator+=(const ON_String&);
	const ON_String& operator+=(char);
	const ON_String& operator+=(unsigned char);
	const ON_String& operator+=(const char*);
	const ON_String& operator+=(const unsigned char*);

	// string comparison 
  // If this < string, returns < 0.
  // If this = string, returns 0.
  // If this < string, returns > 0.
	int Compare( const char* ) const;
	int Compare( const unsigned char* ) const;

	int CompareNoCase( const char* ) const;
	int CompareNoCase( const unsigned char* ) const;

  // Description:
  //   Simple case sensitive wildcard matching. A question mark (?) in the
  //   pattern matches a single character.  An asterisk (*) in the pattern
  //   mathes zero or more occurances of any character.
  //
  // Parameters:
  //   pattern - [in] pattern string where ? and * are wild cards.
  //
  // Returns:
  //   true if the string mathes the wild card pattern.
	bool WildCardMatch( const char* ) const;
	bool WildCardMatch( const unsigned char* ) const;

  // Description:
  //   Simple case insensitive wildcard matching. A question mark (?) in the
  //   pattern matches a single character.  An asterisk (*) in the pattern
  //   mathes zero or more occurances of any character.
  //
  // Parameters:
  //   pattern - [in] pattern string where ? and * are wild cards.
  //
  // Returns:
  //   true if the string mathes the wild card pattern.
	bool WildCardMatchNoCase( const char* ) const;
	bool WildCardMatchNoCase( const unsigned char* ) const;

  /*
  Description:
    Replace all substrings that match token1 with token2
  Parameters:
    token1 - [in]
    token2 - [in]
  Returns:
    Number of times token1 was replaced with token2.
  */
  int Replace( const char* token1, const char* token2 );

	// simple sub-string extraction
	ON_String Mid(
    int, // index of first char
    int  // count
    ) const;
	ON_String Mid(
    int // index of first char
    ) const;
	ON_String Left(
    int // number of chars to keep
    ) const;
	ON_String Right(
    int // number of chars to keep
    ) const;

	// upper/lower/reverse conversion
	void MakeUpper();
	void MakeLower();
	void MakeReverse();
  void TrimLeft(const char* = NULL);
  void TrimRight(const char* = NULL);
  void TrimLeftAndRight(const char* = NULL);

  // remove occurrences of chRemove
	int Remove( const char chRemove);

	// searching (return starting index, or -1 if not found)
	// look for a single character match
	int Find(char) const;
	int ReverseFind(char) const;



	// simple formatting
	void ON_MSC_CDECL Format( const char*, ...);
	void ON_MSC_CDECL Format( const unsigned char*, ...);

	// Low level access to string contents as character array
	void ReserveArray(size_t); // make sure internal array has at least
                          // the requested capacity.
	void ShrinkArray();     // shrink internal storage to minimum size
  void SetLength(size_t);    // set length (<=capacity)
  char* Array();
  const char* Array() const;

  /*
  Returns:
    Total number of bytes of memory used by this class.
    (For use in ON_Object::SizeOf() overrides.
  */
  unsigned int SizeOf() const;

  ON__UINT32 DataCRC(ON__UINT32 current_remainder) const;

  /*
  Description:
    Find the locations in a path the specify the drive, directory,
    file name and file extension.
  Parameters:
    path - [in]
      path to split
    drive - [out] (pass null if you don't need the drive)
      If drive is not null and the path parameter contains a Windows 
      drive specification, then the returned value of *drive will
      either be empty or the Windows drive letter followed by
      the trailing colon.
    dir - [out] (pass null if you don't need the directory)
      If dir is not null and the path parameter contains a
      directory specification, then the returned value of *dir
      will be the directory specification including the trailing
      slash.
    fname - [out] (pass null if you don't need the file name)
      If fname is not null and the path parameter contains a
      file name specification, then the returned value of *fname
      will be the file name.
    ext - [out] (pass null if you don't need the extension)
      If ext is not null and the path parameter contains a
      file extension specification, then the returned value of
      *ext will be the file extension including the initial
      '.' character.
  Remarks:
    This function will treat a front slash ( / ) and a back slash
    ( \ ) as directory separators.  Because this function parses
    file names store in .3dm files and the .3dm file may have been
    written on a Windows computer and then read on a another
    computer, it looks for a drive dpecification even when the
    operating system is not Windows.
    This function will not return an directory that does not
    end with a trailing slash.
    This function will not return an empty filename and a non-empty
    extension.
    This function parses the path string according to these rules.
    It does not check the actual file system to see if the answer
    is correct.
  See Also:
    on_splitpath
  */
  static void SplitPath( 
    const char* path,
    ON_String* drive,
    ON_String* dir,
    ON_String* fname,
    ON_String* ext
    );

// Implementation
public:
	~ON_String();

protected:
	char* m_s; // pointer to ref counted string array
             // m_s - 12 bytes points at the string's ON_aStringHeader

	// implementation helpers
	struct ON_aStringHeader* Header() const;
	void CreateArray(int);
  void CopyArray();
  void CopyToArray( const ON_String& );
  void CopyToArray( int, const char* );
  void CopyToArray( int, const unsigned char* );
  void CopyToArray( int, const wchar_t* );
  void AppendToArray( const ON_String& );
  void AppendToArray( int, const char* );
  void AppendToArray( int, const unsigned char* );
	static int Length(const char*);  // handles NULL pointers without crashing
	static int Length(const unsigned char*);  // handles NULL pointers without crashing
};


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// ON_wString
//

class ON_CLASS ON_wString
{
public:

// Constructors
  ON_wString();
  ON_wString( const ON_wString& );

  ON_wString( const ON_String& src ); // src = UTF-8 string

  ON_wString( const char* src ); // src = nul; terminated UTF-8 string
  ON_wString( const char* src, int /*length*/ );  // from UTF-8 substring

  ON_wString( const unsigned char* src); // src = nul; terminated UTF-8 string

  ON_wString( const wchar_t* );
  ON_wString( const wchar_t*, int /*length*/ );        // from substring
  ON_wString( wchar_t, int = 1 /* repeat count */ );
  
#if defined(ON_OS_WINDOWS)
  // Windows support
	bool LoadResourceString(HINSTANCE, UINT); // load from string resource
										                        // 2047 characters max
#endif

  void Create();
  void Destroy(); // releases any memory and initializes to default empty string
  void EmergencyDestroy();

  /*
  Description:
    Enables reference counting.  I limited cases, this is useful 
    for large strings or strings that are frequently passed around.
    Reference counted strings must be carefully managed in
    when multi-threading is used.
  Parameters:
    If EnableReferenceCounting()
    is not called, then the string will not be referanceThe default is to not use
    reference counted strings.
  */
  void EnableReferenceCounting( bool bEnable );

  /*
  Returns:
    True if the string is reference counted.
  */
  bool IsReferenceCounted() const;

// Attributes & Operations
	// as an array of characters
	int Length() const;
	bool IsEmpty() const;
  void Empty();   // sets length to zero - if possible, memory is retained

	wchar_t& operator[](int);
	wchar_t operator[](int) const;
  wchar_t GetAt(int) const;
	void SetAt(int, char);
	void SetAt(int, wchar_t);
	operator const wchar_t*() const;  // as a UNICODE string

	// overloaded assignment
	const ON_wString& operator=(const ON_wString&);
	const ON_wString& operator=(const ON_String& src); // src = UTF-8 string
	const ON_wString& operator=(char);
	const ON_wString& operator=(const char* src); // src = UTF-8 string
	const ON_wString& operator=(unsigned char);
	const ON_wString& operator=(const unsigned char* src); // src = UTF-8 string
  const ON_wString& operator=(wchar_t);
  const ON_wString& operator=(const wchar_t*);

	// string concatenation
  void Append( const char* sUTF8, int ); // append specified number of elements from a UTF-8 string
  void Append( const unsigned char* sUTF8, int ); // append specified number of elements from a UTF-8 string
  void Append( const wchar_t*, int ); // append specified number of elements
	const ON_wString& operator+=(const ON_wString&);
	const ON_wString& operator+=(const ON_String& sUTF8); // append UTF-8 string
	const ON_wString& operator+=(char);
	const ON_wString& operator+=(unsigned char);
	const ON_wString& operator+=(wchar_t);
	const ON_wString& operator+=(const char* sUTF8); // append UTF-8 string
	const ON_wString& operator+=(const unsigned char* sUTF8); // append UTF-8 string
	const ON_wString& operator+=(const wchar_t*);

  // operator+()
  ON_wString operator+(const ON_wString&) const;
  ON_wString operator+(const ON_String& sUTF8) const; // concatinate with a UTF-8 string
  ON_wString operator+(char) const;
  ON_wString operator+(unsigned char) const;
  ON_wString operator+(wchar_t) const;
  ON_wString operator+(const char* sUTF8) const; // concatinate with a UTF-8 string
  ON_wString operator+(const unsigned char* sUTF8) const; // concatinate with a UTF-8 string
  ON_wString operator+(const wchar_t*) const;

	// string comparison 
  bool operator==(const ON_wString&) const;
  bool operator==(const wchar_t*) const;
  bool operator!=(const ON_wString&) const;
  bool operator!=(const wchar_t*) const;
  bool operator<(const ON_wString&) const;
  bool operator<(const wchar_t*) const;
  bool operator>(const ON_wString&) const;
  bool operator>(const wchar_t*) const;
  bool operator<=(const ON_wString&) const;
  bool operator<=(const wchar_t*) const;
  bool operator>=(const ON_wString&) const;
  bool operator>=(const wchar_t*) const;

	// string comparison 
  // If this < string, returns < 0.
  // If this == string, returns 0.
  // If this < string, returns > 0.
	int Compare( const char* sUTF8 ) const; // compare to UTF-8 string
	int Compare( const unsigned char* sUTF8 ) const; // compare to UTF-8 string
	int Compare( const wchar_t* ) const;

	int CompareNoCase( const char* sUTF8) const; // compare to UTF-8 string
	int CompareNoCase( const unsigned char* sUTF8) const; // compare to UTF-8 string
	int CompareNoCase( const wchar_t* ) const;

  // Description:
  //   Simple case sensitive wildcard matching. A question mark (?) in the
  //   pattern matches a single character.  An asterisk (*) in the pattern
  //   mathes zero or more occurances of any character.
  //
  // Parameters:
  //   pattern - [in] pattern string where ? and * are wild cards.
  //
  // Returns:
  //   true if the string mathes the wild card pattern.
	bool WildCardMatch( const wchar_t* ) const;

  // Description:
  //   Simple case insensitive wildcard matching. A question mark (?) in the
  //   pattern matches a single character.  An asterisk (*) in the pattern
  //   mathes zero or more occurances of any character.
  //
  // Parameters:
  //   pattern - [in] pattern string where ? and * are wild cards.
  //
  // Returns:
  //   true if the string mathes the wild card pattern.
	bool WildCardMatchNoCase( const wchar_t* ) const;

  /*
  Description:
    Replace all substrings that match token1 with token2
  Parameters:
    token1 - [in]
    token2 - [in]
  Returns:
    Number of times toke1 was replaced with token2
  */
  int Replace( const wchar_t* token1, const wchar_t* token2 );
  int Replace( wchar_t token1, wchar_t token2 );

  /*
  Description:
    Replaces all characters in the string whose values are
    not '0-9', 'A-Z', or 'a-z' with a percent sign followed
    by a 2 digit hex value.
  */
  void UrlEncode();

  /*
  Description:
    Replaces all %xx where xx a two digit hexadecimal number,
    with a single character. Returns false if the orginal
    string contained 
  */
  bool UrlDecode();

  /*
  Description:
    Replace all white-space characters with the token.
    If token is zero, the string will end up with
    internal 0's
  Parameters:
    token - [in]
    whitespace - [in] if not null, this is a 0 terminated
      string that lists the characters considered to be 
      white space.  If null, then (1,2,...,32,127) is used.
  Returns:
    Number of whitespace characters replaced.
  See Also:
    ON_wString::RemoveWhiteSpace
  */
  int ReplaceWhiteSpace( wchar_t token, const wchar_t* whitespace = 0 );

  /*
  Description:
    Removes all white-space characters with the token.
  Parameters:
    whitespace - [in] if not null, this is a 0 terminated
      string that lists the characters considered to be 
      white space.  If null, then (1,2,...,32,127) is used.
  Returns:
    Number of whitespace characters removed.
  See Also:
    ON_wString::ReplaceWhiteSpace
  */
  int RemoveWhiteSpace( const wchar_t* whitespace = 0 );

  // simple sub-string extraction
	ON_wString Mid(
    int, // index of first char
    int  // count
    ) const;
	ON_wString Mid(
    int // index of first char
    ) const;
	ON_wString Left(
    int // number of chars to keep
    ) const;
	ON_wString Right(
    int // number of chars to keep
    ) const;

	// upper/lower/reverse conversion
	void MakeUpper();
	void MakeLower();
	void MakeReverse();
  void TrimLeft(const wchar_t* = NULL);
  void TrimRight(const wchar_t* = NULL);
  void TrimLeftAndRight(const wchar_t* = NULL);

  /*
  Description:
    Remove all occurrences of c.
  */
	int Remove( wchar_t c);

	// searching (return starting index, or -1 if not found)
	// look for a single character match
  int Find(char) const;
  int Find(wchar_t) const;
  int ReverseFind(char) const;
  int ReverseFind(wchar_t) const;

  int Find(const char*) const;
  int Find(const wchar_t*) const;

	// simple formatting - be careful with %s in format string
	void ON_MSC_CDECL Format( const char*, ...);
	void ON_MSC_CDECL Format( const unsigned char*, ...);
	void ON_MSC_CDECL Format( const wchar_t*, ...);

	// Low level access to string contents as character array
	void ReserveArray(size_t); // make sure internal array has at least
                          // the requested capacity.
	void ShrinkArray();     // shrink internal storage to minimum size
  void SetLength(size_t); // set length (<=capacity)
  wchar_t* Array();
  const wchar_t* Array() const;

  /*
  Returns:
    Total number of bytes of memory used by this class.
    (For use in ON_Object::SizeOf() overrides.
  */
  unsigned int SizeOf() const;

  /*
  Returns:
    CRC of the string.
  */
  ON__UINT32 DataCRC(ON__UINT32 current_remainder) const;

  /*
  Returns:
    CRC of the lower case version of the string. Useful
    for case insensitive CRCs and hash codes.
  */
  ON__UINT32 DataCRCLower(ON__UINT32 current_remainder) const;

  /*
  Description:
    Find the locations in a path the specify the drive, directory,
    file name and file extension.
  Parameters:
    path - [in]
      path to split
    drive - [out] (pass null if you don't need the drive)
      If drive is not null and the path parameter contains a Windows 
      drive specification, then the returned value of *drive will
      either be empty or the Windows drive letter followed by
      the trailing colon.
    dir - [out] (pass null if you don't need the directory)
      If dir is not null and the path parameter contains a
      directory specification, then the returned value of *dir
      will be the directory specification including the trailing
      slash.
    fname - [out] (pass null if you don't need the file name)
      If fname is not null and the path parameter contains a
      file name specification, then the returned value of *fname
      will be the file name.
    ext - [out] (pass null if you don't need the extension)
      If ext is not null and the path parameter contains a
      file extension specification, then the returned value of
      *ext will be the file extension including the initial
      '.' character.
  Remarks:
    This function will treat a front slash ( / ) and a back slash
    ( \ ) as directory separators.  Because this function parses
    file names store in .3dm files and the .3dm file may have been
    written on a Windows computer and then read on a another
    computer, it looks for a drive dpecification even when the
    operating system is not Windows.
    This function will not return an directory that does not
    end with a trailing slash.
    This function will not return an empty filename and a non-empty
    extension.
    This function parses the path string according to these rules.
    It does not check the actual file system to see if the answer
    is correct.
  See Also:
    on_splitpath
    on_wsplitpath
  */
  static void SplitPath( 
    const char* path,
    ON_wString* drive,
    ON_wString* dir,
    ON_wString* fname,
    ON_wString* ext
    );

  static void SplitPath( 
    const wchar_t* path,
    ON_wString* drive,
    ON_wString* dir,
    ON_wString* fname,
    ON_wString* ext
    );
// Implementation
public:
	~ON_wString();

protected:
	wchar_t* m_s; // pointer to ref counted string array
                // m_s - 12 bytes points at the string's ON_wStringHeader

	// implementation helpers
	struct ON_wStringHeader* Header() const;
	void CreateArray(int);
  void CopyArray();
  void CopyToArray( const ON_wString& );
  void CopyToArray( int, const char* );
  void CopyToArray( int, const unsigned char* );
  void CopyToArray( int, const wchar_t* );
  void AppendToArray( const ON_wString& );
  void AppendToArray( int, const char* );
  void AppendToArray( int, const unsigned char* );
  void AppendToArray( int, const wchar_t* );
	static int Length(const char*);  // handles NULL pointers without crashing
	static int Length(const unsigned char*);  // handles NULL pointers without crashing
	static int Length(const wchar_t*); // handles NULL pointers without crashing
};

class ON_CLASS ON_UnitSystem
{
public:
  ON_UnitSystem();   // default constructor units are millimeters.
  ~ON_UnitSystem();

  ON_UnitSystem(ON::unit_system);
  ON_UnitSystem& operator=(ON::unit_system);

  bool operator==(const ON_UnitSystem&);
  bool operator!=(const ON_UnitSystem&);

  bool IsValid() const;

  void Default(); // millimeters = default unit system

  bool Read( class ON_BinaryArchive& );
  bool Write( class ON_BinaryArchive& ) const;
  void Dump( class ON_TextLog& ) const;

  ON::unit_system m_unit_system;

  // The m_custom_unit_... settings apply when m_unit_system = ON::custom_unit_system
  double m_custom_unit_scale;      // 1 meter = m_custom_unit_scale custom units
  ON_wString m_custom_unit_name;   // name of custom units

  // Custom units example:
  //    1 Nautical league = 5556 meters
  //    So, if you wanted your unit system to be nautical leagues
  //    your ON_UnitSystem would be
  //      m_unit_system       = ON::custom_unit_system
  //      m_custom_unit_scale = 1.0/5556.0 = 0.0001799856...
  //      m_custom_unit_name  = "Nautical leagues"
};


#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_COMPRESS_INC_)
#define OPENNURBS_COMPRESS_INC_

typedef bool (*ON_StreamCallbackFunction)( void* context, ON__UINT32 size, const void* buffer );

class ON_CLASS ON_CompressStream
{
public:
  ON_CompressStream();
  virtual ~ON_CompressStream();

  /*
  Description:
    ON_CompressStream delivers the compressed stream by calling
    a compressed stream output handler function.  There are two
    options for specifying the compressed stream output handler
    function.
      1. Overriding the virtual Out() function.
      2. Providing a callback function.
    SetCallback() is used to specify a callback function to handle
    the compressed stream and to specify a context pointer to be 
    passed to either option of the handler.
  Parameters:
    callback_function - [in]
      Function to call with sections of the compressed stream.
      If callback_function is null, then the virtual Out() 
      function will be called. When callback_function 
      is specified, it must return true if the compression 
      calculation should continue and false to cancel the 
      compression calculation.
    callback_context - [in]
      This value is passed as the first argument when calling 
      callback_function or the virutal Out() function.
  Returns:
    True if successful.
  Remarks:
    Once compression has started, it would be unusual to
    intentionally change the compressed stream output handler,
    but you can do this if you need to.    
  */
  bool SetCallback( 
    ON_StreamCallbackFunction callback_function,
    void* callback_context
    );

  /*
  Returns:
    Current value of the callback function for handling
    the compressed stream.  If the callback function is
    null, the the virtual Out() function is used to
    handle
  */
  ON_StreamCallbackFunction CallbackFunction() const;

  /*
  Returns:
    Current value of the context pointer passed as the first
    argument to the compressed stream output handler function.
  */
  void* CallbackContext() const;
  
  /*
  Description:
    Call Begin() one time to initialize the compression
    calculation.  Then call In() one or more times 
    to submit the uncompressed stream to the compression calculation.  
    When you reach the end of the uncompressed stream, call 
    End().
  Returns:
    true if successful, false if an error occured.
  */
  bool Begin();

  /*
  Description:
    Call In() one or more times to compress a stream of uncompressed
    bytes.  After the last call to In(), call End().  Calling In()
    may generate zero or more calls to the output stream handler.
  Parameters:
    in_buffer_size - [in]
      number of bytes in in_buffer
    in_buffer - [in]
  Returns:
    true if successful, false if an error occured.
  */
  bool In( 
    ON__UINT64 in_buffer_size, 
    const void* in_buffer 
    );

  /*
  Description:
    If an explicit compressed stream output handler is not specified
    ( CallbackFunction() returns null ), then the virtual Out() 
    function is called to handle the compressed output stream.
    As the input stream is compressed, one or more calls to Out()
    will occur.
  Returns:
    True to continue compressing and false to cancel the compression
    calculation.
  Remarks:
    In general, it is probably going to be easier to test and debug
    your code if you ignore the callback_context parameter and add 
    a member variable to your derived class to make additional
    information accessable to your Out function.
  */
  virtual bool Out( 
    void* callback_context, 
    ON__UINT32 out_buffer_size, 
    const void* out_buffer 
    );

  /*
  Description:
    After the last call to In(), call End().  
    Calling End() may generate zero or more 
    calls to the output stream handler.
  Returns:
    true if successful, false if an error occured.
  */
  bool End();

  /*
  Returns:
    Then the returned value is the total number bytes in the input
    stream. The size is updated every time In() is called before 
    any calls are made to the output stream handler.  If the 
    calculation is finished ( End() has been called ), then the
    returned value is the total number of bytes in the entire 
    input stream.
  */
  ON__UINT64 InSize() const;

  /*
  Returns:
    Then the returned value is the total number bytes in the output
    stream. The size is incremented immediately after each call to
    the output stream handler.  If the compression calculation is 
    finished ( End() has been called ), then the returned value is
    the total number of bytes in the entire output stream.
  */
  ON__UINT64 OutSize() const;

  /*
  Returns:
    Then the returned value is the 32-bit crc of the input stream.
    The crc is updated every time In() is called before any calls
    are made to the output stream handler.  If the compression 
    calculation is finished ( End() has been called ), then the
    returned value is the 32-bit crc of the entire input stream.
  */
  ON__UINT32 InCRC() const;

  /*
  Returns:
    Then the returned value is the 32bit crc of the output stream.
    The crc is updated immediately after each call to the output
    stream handler.  If the calculation is finished ( End() has 
    been called ), then the returned value is the 32-bit crc of
    the entire output stream.
  */
  ON__UINT32 OutCRC() const;

private:
  ON_StreamCallbackFunction m_out_callback_function;
  void* m_out_callback_context;
  ON__UINT64 m_in_size;
  ON__UINT64 m_out_size;
  ON__UINT32 m_in_crc;
  ON__UINT32 m_out_crc;
  void* m_implementation;
  void* m_reserved;

  void ErrorHandler();

private:
  // prohibit use - no implementation
  ON_CompressStream(const ON_CompressStream&);
  ON_CompressStream& operator=(const ON_CompressStream&);
};


class ON_CLASS ON_UncompressStream
{
public:
  ON_UncompressStream();
  virtual ~ON_UncompressStream();

  /*
  Description:
    ON_UncompressStream delivers the uncompressed stream by calling
    an uncompressed stream output handler function.  There are two
    options for specifying the uncompressed stream output handler
    function.
      1. Overriding the virtual Out() function.
      2. Providing a callback function.
    SetCallback() is used to specify a callback function to handle
    the uncompressed stream and to specify a context pointer to be 
    passed to either option of the handler.
  Parameters:
    callback_function - [in]
      Function to call with sections of the uncompressed stream.
      If callback_function is null, then the virtual Out() 
      function will be called. When callback_function 
      is specified, it must return true if the uncompression 
      calculation should continue and false to cancel the 
      uncompression calculation.
    callback_context - [in]
      This value is passed as the first argument when calling 
      callback_function or the virutal Out() function.
  Returns:
    True if successful.
  Remarks:
    Once uncompression has started, it would be unusual to
    intentionally change the uncompressed stream output handler,
    but you can do this if you need to.    
  */
  bool SetCallback( 
    ON_StreamCallbackFunction callback_function,
    void* callback_context
    );

  /*
  Returns:
    Current value of the callback function for handling
    the uncompressed stream.  If the callback function is
    null, the the virtual UncompressedStreamOut() function
    is used.
  */
  ON_StreamCallbackFunction CallbackFunction() const;

  /*
  Returns:
    Current value of the context pointer passed as the first
    argument to the uncompressed stream output handler function.
  */
  void* CallbackContext() const;
  
  /*
  Description:
    Call BeginUnompressStream() one time to initialize the compression
    calculation.  Then call In() one or more times 
    to submit the compressed stream to the uncompression calculation.  
    When you reach the end of the compressed stream, call 
    End().
  Returns:
    true if successful, false if an error occured.
  */
  bool Begin();

  /*
  Description:
    Call In() one or more times to uncompress a stream of compressed
    bytes.  After the last call to In(), call End(). Calling End()
    may generate zero or more calls to the output stream handler.
  Parameters:
    in_buffer_size - [in]
      number of bytes in in_buffer
    in_buffer - [in]
  Returns:
    true if successful, false if an error occured.
  */
  bool In(
    ON__UINT64 in_buffer_size,
    const void* in_buffer
    );

  /*
  Description:
    If an explicit uncompressed stream handler is not specified
    ( CallbackFunction() returns null ), then the virtual Out() 
    function is called to handle the uncompressed output stream.
    As the input stream is uncompressed, one or more calls to Out()
    will occur.
  Returns:
    True to continue uncompressing and false to cancel the 
    uncompression calculation.
  Remarks:
    In general, it is probably going to be easier to test and debug
    your code if you ignore the callback_context parameter and add 
    a member variable to your derived class to make additional
    information accessable to your Out function.
  */
  virtual bool Out( 
    void* callback_context, 
    ON__UINT32 out_buffer_size, 
    const void* out_buffer 
    );

  /*
  Description:
    After the last call to In(), call End().  
    Calling End() may generate zero or more 
    calls to the output stream handler.
  Returns:
    true if successful, false if an error occured.
  */
  bool End();

  /*
  Returns:
    Then the returned value is the total number bytes in the input
    stream. The size is updated every time In() is called before 
    any calls are made to the output stream handler.  If the 
    calculation is finished ( End() has been called ), then the
    returned value is the total number of bytes in the entire 
    input stream.
  */
  ON__UINT64 InSize() const;

  /*
  Returns:
    Then the returned value is the total number bytes in the output
    stream. The size is incremented immediately after each call to
    the output stream handler.  If the compression calculation is 
    finished ( End() has been called ), then the returned value is
    the total number of bytes in the entire output stream.
  */
  ON__UINT64 OutSize() const;

  /*
  Returns:
    Then the returned value is the 32-bit crc of the input stream.
    The crc is updated every time In() is called before any calls
    are made to the output stream handler.  If the compression 
    calculation is finished ( End() has been called ), then the
    returned value is the 32-bit crc of the entire input stream.
  */
  ON__UINT32 InCRC() const;

  /*
  Returns:
    Then the returned value is the 32bit crc of the output stream.
    The crc is updated immediately after each call to the output
    stream handler.  If the calculation is finished ( End() has 
    been called ), then the returned value is the 32-bit crc of
    the entire output stream.
  */
  ON__UINT32 OutCRC() const;

private:
  ON_StreamCallbackFunction m_out_callback_function;
  void* m_out_callback_context;
  ON__UINT64 m_in_size;
  ON__UINT64 m_out_size;
  ON__UINT32 m_in_crc;
  ON__UINT32 m_out_crc;
  void* m_implementation;
  void* m_reserved;

  void ErrorHandler();

private:
  // prohibit use - no implementation
  ON_UncompressStream(const ON_UncompressStream&);
  ON_UncompressStream& operator=(const ON_UncompressStream&);
};

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_BASE64_INC_)
#define OPENNURBS_BASE64_INC_

//////////////////////////////////////////////////////////////////////////////////////////

class ON_CLASS ON_Base64EncodeStream
{
public:
  ON_Base64EncodeStream();
  virtual ~ON_Base64EncodeStream();

  /*
  Description:
    ON_Base64EncodeStream delivers the base64 encoded stream by
    calling a base64 encoded stream output handler function. 
    There are two options for specifying the base64 encoded stream
    output handler function.
      1. Overriding the virtual Out() function.
      2. Providing a callback function.
    SetCallback() is used to specify a callback function to handle
    the base64 encoded stream and to specify a context pointer to be 
    passed to either option of the handler.
  Parameters:
    callback_function - [in]
      Function to handle sections of the base64 encoded stream.
      If callback_function is null, then the virtual Out() 
      function will be called. When callback_function 
      is specified, it must return true if the base64 encoding 
      calculation should continue and false to cancel the 
      base64 encoding calculation.
    callback_context - [in]
      This value is passed as the first argument when calling 
      callback_function or the virutal Out() function.
  Returns:
    True if successful.
  Remarks:
    Once base64 encoding has started, it would be unusual to
    intentionally change the base64 encoded stream output handler,
    but you can do this if you need to.    
  */
  bool SetCallback( 
    ON_StreamCallbackFunction callback_function,
    void* callback_context
    );

  /*
  Returns:
    Current value of the callback function for handling
    the base64 encoded stream.  If the callback function is
    null, the the virtual Out() function is used to
    handle the output stream.
  */
  ON_StreamCallbackFunction CallbackFunction() const;

  /*
  Returns:
    Current value of the context pointer passed as the first
    argument to the base64 encoded stream output handler function.
  */
  void* CallbackContext() const;
  
  /*
  Description:
    Call Begin() one time to initialize the base64 encoding
    calculation.  Then call In() one or more times 
    to submit the unencoded stream to the base64 encoding
    calculation. When you reach the end of the unencoded
    stream, call End().
  Returns:
    true if successful, false if an error occured.
  */
  bool Begin();


  /*
  Description:
    Call In() one or more times to base64 encode a stream of bytes.
    After the last call to In(), call End().  Calling In() will
    result in at least in_buffer_size/57 and at most 
    (in_buffer_size+56)/57 calls to to the output stream handler.
  Parameters:
    in_buffer_size - [in]
      number of bytes in in_buffer
    in_buffer - [in]
  Returns:
    true if successful, false if an error occured.
  */
  bool In(
    ON__UINT64 in_buffer_size,
    const void* in_buffer
    );

  /*
  Description:
    If an explicit base 64 encoded stream output handler is not
    specified ( CallbackFunction() returns null ), then the 
    virtual Out() function is called to handle the base 64 encoded
    output stream.  As the input stream is encoded, one or more
    calls to Out() will occur.

    With a possible exception of the last call to Out(), when Out()
    is called, 57 input bytes have been encoded into 76 output 
    characters with ASCII codes A-Z, a-z, 0-9, +, /.
  Parameters:
    callback_context - [in]
      context pointer set by calling SetCallback().  Typically
      the context pointer is not used by a virtual override
      because the context can be added as member variables
      of the derived class, but it is available if needed.
    out_buffer_size - [in]
      number of non-null characters in out_buffer.
    out_buffer - [in]
      A null terminated ASCII string that is a base 64 encoding.
      out_buffer[0...(out_buffer_size-1)] are ASCII characters with
      values characters with ASCII codes A-Z, a-z, 0-9, +, /
      and out_buffer[out_buffer_size] = 0.    
  Returns:
    True to continue base 64 encodeing and false to cancel the
    encoding calculation.
  */
  virtual bool Out( 
    void* callback_context, 
    ON__UINT32 out_buffer_size, 
    const char* out_buffer 
    );

  /*
  Description:
    After the last call to In(), call End().  Calling End() may
    generate one call to the output stream handler with the value
    of out_buffer_size = 4 to 76.
  Returns:
    true if successful, false if an error occured.
  */
  bool End();
  
  /*
  Returns:
    Then the returned value is the total number bytes in the input
    stream. The size is updated every time In() is called before 
    any calls are made to the output stream handler.  If the 
    calculation is finished ( End() has been called ), then the
    returned value is the total number of bytes in the entire 
    input stream.
  */
  ON__UINT64 InSize() const;

  /*
  Returns:
    Then the returned value is the total number characters in the
    output stream. The size is incremented immediately after each
    call to the output stream handler.  If the base64 encoding
    calculation is finished ( End() has been called ), then the
    returned value is the total number of bytes in the entire 
    output stream.
  */
  ON__UINT64 OutSize() const;

  /*
  Returns:
    Then the returned value is the 32-bit crc of the input stream.
    The crc is updated every time In() is called before any calls
    are made to the output stream handler.  If the base64 encoding 
    calculation is finished ( End() has been called ), then the
    returned value is the 32-bit crc of the entire input stream.
  */
  ON__UINT32 InCRC() const;

  /*
  Returns:
    Then the returned value is the 32bit crc of the output stream.
    The crc is updated immediately after each call to the output
    stream handler.  If the calculation is finished ( End() has 
    been called ), then the returned value is the 32-bit crc of
    the entire output stream.
  */
  ON__UINT32 OutCRC() const;
    
private:
  ON_StreamCallbackFunction m_out_callback_function;
  void* m_out_callback_context;
  ON__UINT64 m_in_size;
  ON__UINT64 m_out_size;
  ON__UINT32 m_in_crc;
  ON__UINT32 m_out_crc;
  void* m_implementation;
  void* m_reserved;

  void ErrorHandler();
  
private:
  // prohibit use - no implementation
  ON_Base64EncodeStream(const ON_Base64EncodeStream&);
  ON_Base64EncodeStream& operator=(const ON_Base64EncodeStream&);
};

//////////////////////////////////////////////////////////////////////////////////////////

class ON_CLASS ON_DecodeBase64
{
public:
  ON_DecodeBase64();
  virtual ~ON_DecodeBase64();

  void Begin();

  // Decode will generate zero or more callbacks to the
  // virtual Output() function.  If the base 64 encoded information
  // is in pieces, you can call Decode() for each piece.  For example,
  // if your encoded information is in a text file, you might call
  // Decode() for every line in the file.  Decode() returns 0 if
  // there is nothing in base64str to decode or if it detects an
  // error that prevents any further decoding.  The function Error()
  // can be used to determine if an error occured.  Otherwise,
  // Decode() returns a pointer to the location in the string where
  // it stopped decoding because it detected a character, like a null
  // terminator, an end of line character, or any other character
  // that could not be part of the base 64 encoded information.
  const char* Decode(const char* base64str);
  const char* Decode(const char* base64str, size_t base64str_count);
  const wchar_t* Decode(const wchar_t* base64str);
  const wchar_t* Decode(const wchar_t* base64str, size_t base64str_count);

  // You must call End() when Decode() returns 0 or when you have
  // reached the end of your encoded information.  End() may
  // callback to Output() zero or one time.  If all the information
  // passed to Decode() was successfully decoded, then End()
  // returns true.  If something was not decoded, then End()
  // returns false.
  bool End();

  // Override the virtual Output() callback function to process the 
  // decoded output.  Each time Output() is called there are m_output_count
  // bytes in the m_output[] array.
  // Every call to Decode() can result in zero, one, or many callbacks
  // to Output().  Calling End() may result in zero or one callbacks
  // to Output().
  virtual void Output();

  // m_decode_count = total number of input base64 characters
  // that Decode() has decoded.
  unsigned int m_decode_count; 

  int  m_output_count; // 0 to 512
  unsigned char m_output[512];

  // Call if your Output() function detects an error and
  // wants to stop further decoding.
  void SetError();

  // Returns true if an error occured during decoding because
  // invalid input was passed to Decode().
  bool Error() const;

private:
  int m_status; // 1: error - decoding stopped
                // 2: '=' encountered as 3rd char in Decode()
                // 3: successfully parsed "**=="
                // 4: successfully parsed "***="
                // 5: End() successfully called.

  // cached encoded input from previous call to Decode() 
  int m_cache_count;
  int m_cache[4];

  void DecodeHelper1(); // decodes "**==" quartet into 1 byte
  void DecodeHelper2(); // decodes "***=" quartet into 2 bytes
};


/////////////////////////////////////////////////////////////////////


/*
class ON_CLASS ON_EncodeBase64
{
public:
  ON_EncodeBase64();
  virtual ~ON_EncodeBase64();

  void Begin();

  // Calling Encode will generate at least
  // sizeof_buffer/57 and at most (sizeof_buffer+56)/57
  // calls to Output().  Every callback to Output() will
  // have m_output_count = 76.
  void Encode(const void* buffer, size_t sizeof_buffer);

  // Calling End may generate a single call to Output()
  // If it does generate a single call to Output(),
  // then m_output_count will be between 1 and 76.
  void End(); // may generate a single call to Output().

  // With a single exception, when Output() is called,
  // 57 input bytes have been encoded into 76 output
  // characters with ASCII codes A-Z, a-z, 0-9, +, /.
  // m_output_count will be 76
  // m_output[0...(m_output_count-1)] will be the base 64
  // encoding.
  // m_output[m_output_count] = 0.
  // The Output() function can modify the values of m_output[]
  // and m_output_count anyway it wants.
  virtual void Output();

  // Total number of bytes passed to Encode().
  int m_encode_count;

  // When the virtual Output() is called, there are m_output_count (1 to 76)
  // characters of base64 encoded output in m_output[].  The remainder of 
  // the m_output[] array is zero.  The Output function may modify the
  // contents of m_output[] any way it sees fit.
  int  m_output_count;
  char m_output[80];
  
private:
  // input waiting to be encoded
  // At most 56 bytes can be waiting to be processed in m_input[].
  unsigned int  m_unused2; // Here for alignment purposes. Never used by opennurbs.
  unsigned int  m_input_count;
  unsigned char m_input[64];

  void EncodeHelper1(const unsigned char*, char*);
  void EncodeHelper2(const unsigned char*, char*);
  void EncodeHelper3(const unsigned char*, char*);
  void EncodeHelper57(const unsigned char*);
};
*/

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_COLOR_INC_)
#define OPENNURBS_COLOR_INC_

///////////////////////////////////////////////////////////////////////////////
//
// Class ON_Color
// 
class ON_CLASS ON_Color
{
public:
	// Constructors & Conversions -     also default copy and assignment	

  static const ON_Color UnsetColor; // 0xFFFFFFFF

  // Default is R = 0, G = 0, B = 0, A = 0
	ON_Color();

  // Sets A = 0
	ON_Color(
    int red,   // ( 0 to 255 )
    int green, // ( 0 to 255 )
    int blue   // ( 0 to 255 )
    );

	ON_Color(
    int red,   // ( 0 to 255 )
    int green, // ( 0 to 255 )
    int blue,  // ( 0 to 255 )
    int alpha  // ( 0 to 255 )  (0 = opaque, 255 = transparent)
    );

  // Construct from Windows COLORREF
	ON_Color(unsigned int);

	// Conversion to Windows COLORREF
  operator unsigned int() const;	

  /*
  Description:
    Call this function when the color is needed in a 
    Windows COLORREF format with alpha = 0;
  Returns
    A Windows COLOREF with alpha = 0.
  */
  unsigned int WindowsRGB() const;

  // < 0 if this < arg, 0 ir this==arg, > 0 if this > arg
  int Compare( const ON_Color& ) const; 

	int Red()   const; // ( 0 to 255 )
	int Green() const; // ( 0 to 255 )
	int Blue()  const; // ( 0 to 255 )
  int Alpha() const; // ( 0 to 255 ) (0 = opaque, 255 = transparent)

	double FractionRed()   const; // ( 0.0 to 1.0 )
	double FractionGreen() const; // ( 0.0 to 1.0 )
	double FractionBlue()  const; // ( 0.0 to 1.0 )
	double FractionAlpha() const; // ( 0.0 to 1.0 ) (0.0 = opaque, 1.0 = transparent)

  void SetRGB(
    int red,   // red in range 0 to 255
    int green, // green in range 0 to 255
    int blue   // blue in range 0 to 255
    );

  void SetFractionalRGB(
    double red,   // red in range 0.0 to 1.0
    double green, // green in range 0.0 to 1.0
    double blue   // blue in range 0.0 to 1.0
    );

  void SetAlpha(
    int alpha // alpha in range 0 to 255 (0 = opaque, 255 = transparent)
    );

  void SetFractionalAlpha(
    double alpha // alpha in range 0.0 to 1.0 (0.0 = opaque, 1.0 = transparent)
    );

  void SetRGBA(
    int red,   // red in range 0 to 255
    int green, // green in range 0 to 255
    int blue,  // blue in range 0 to 255
    int alpha  // alpha in range 0 to 255 (0 = opaque, 255 = transparent)
    );

  // input args
  void SetFractionalRGBA(
    double red,   // red in range 0.0 to 1.0
    double green, // green in range 0.0 to 1.0
    double blue,  // blue in range 0.0 to 1.0
    double alpha  // alpha in range 0.0 to 1.0 (0.0 = opaque, 1.0 = transparent)
    );

  // Hue() returns an angle in the range 0 to 2*pi 
  //
  //           0 = red, pi/3 = yellow, 2*pi/3 = green, 
  //           pi = cyan, 4*pi/3 = blue,5*pi/3 = magenta,
  //           2*pi = red
  double Hue() const;

  // Returns 0.0 (gray) to 1.0 (saturated)
  double Saturation() const;

  // Returns 0.0 (black) to 1.0 (white)
  double Value() const;

  void SetHSV( 
         double h, // hue in radians 0 to 2*pi
         double s, // satuation 0.0 = gray, 1.0 = saturated
         double v // value     
         );

private:
  // m_color is in Windows COLORREF format.
  //
  //  0xaabbggrr,  rr= red component 0-255, etc. (little endian order)
  //               aa=0 means opaque, aa=255 means transparent.
	unsigned int m_color;
};

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_LINESTYLE_INC_)
#define OPENNURBS_LINESTYLE_INC_


///////////////////////////////////////////////////////////////////////////////
//
// Class ON_DisplayMaterialRef
// 

/*
Description:
  Objects can have per viewport display properties
  that override a viewport's default display
  properties.  These overrides are stored on 
  ON_3dmObjectAttributes as a list of 
  ON_DisplayMaterialRefs.
  
Example:
  For example, by default a viewport
  might display objects using a wireframe, but
  one special object may need to be shaded.
  In this case the special object would have
  a display material ref with the "wireframe"
  viewport's id and the id of a display material
  that specified shading.
*/
class ON_CLASS ON_DisplayMaterialRef
{
public:
  /*
  Description:
    Default constructor sets both ids to nil.
  */
  ON_DisplayMaterialRef();
  int Compare(const ON_DisplayMaterialRef& other) const;
  bool operator==(const ON_DisplayMaterialRef& other) const;
  bool operator!=(const ON_DisplayMaterialRef& other) const;
  bool operator<(const ON_DisplayMaterialRef& other) const;
  bool operator<=(const ON_DisplayMaterialRef& other) const;
  bool operator>(const ON_DisplayMaterialRef& other) const;
  bool operator>=(const ON_DisplayMaterialRef& other) const;

  // C++ default destructor, copy constructor and operator=
  // work fine.

  ON_UUID m_viewport_id;          // identifies the ON_Viewport
                                  //   If nil, then the display material
                                  //   will be used in all viewports
                                  //   that are not explictly referenced
                                  //   in other ON_DisplayMaterialRefs.

  ON_UUID m_display_material_id;  // id used to find display attributes

  // For Rhino V4 the per detail visibility attribute is implemented
  // through a display material reference on an object. This is ONLY
  // for for detail viewports and only for V4. Keep this uuid around
  // so the per detail attributes in future versions of Rhino can be
  // implemented a different way.
  // {1403A7E4-E7AD-4a01-A2AA-41DAE6BE7ECB}
  static const ON_UUID m_invisible_in_detail_id;
};


//////////////////////////////////////////////////////////////////////
// class ON_LinetypeSegment

class ON_CLASS ON_LinetypeSegment
{
public:
  ON_LinetypeSegment();

  bool operator==( const ON_LinetypeSegment& src) const;
  bool operator!=( const ON_LinetypeSegment& src) const;

  // For a curve to be drawn starting at the start point
  // and ending at the endpoint, the first segment
  // in the pattern must be a stLine type
  enum eSegType
  {
    stLine,
    stSpace
  };

  void Dump( class ON_TextLog& ) const;

  // do not add read/write functions to this class

  double m_length; // length in millimeters on printed output
  eSegType m_seg_type;
};

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

////////////////////////////////////////////////////////////////
//
//   defines double precision point, vector, and array classes
//
////////////////////////////////////////////////////////////////
#if !defined(ON_POINT_INC_)
#define ON_POINT_INC_

class ON_BoundingBox;
class ON_Xform;
class ON_Line;
class ON_Plane;

class ON_2dPoint;
class ON_3dPoint;
class ON_4dPoint;

class ON_2dVector;
class ON_3dVector;

class ON_2fVector;
class ON_3fVector;

class ON_Interval;

////////////////////////////////////////////////////////////////
//
//   ON_Interval
//
class ON_CLASS ON_Interval
{
public:

  static const ON_Interval EmptyInterval; // (ON_UNSET_VALUE,ON_UNSET_VALUE)

  ////////
  // The default constructor creates an empty interval (ON_UNSET_VALUE,ON_UNSET_VALUE)
  ON_Interval();

  ON_Interval(double t0,double t1);

  ~ON_Interval();

  bool operator!=(const ON_Interval&) const;
  bool operator==(const ON_Interval&) const;

  // Interval = [m_t[0], m_t[1]]
  double m_t[2];

  /*
  Description:
    Sets interval to (ON_UNSET_VALUE,ON_UNSET_VALUE)
  See Also:
    ON_Interval::Set
  */
  void Destroy();

  /*
  Description:
    Sets interval to [t0,t1]
  Parameters:
    t0 - [in]
    t1 - [in]
  See Also:
    ON_Interval::ON_Interval( double, double )
  */
  void Set(
    double t0, 
    double t1
    );

  /*
  Description:
    Convert normalized parameter to interval value, or pair of values.
  Parameters:
    normalized_parameter - [in] 
  Returns:
    Interval parameter
    min*(1.0-normalized_parameter) + max*normalized_parameter
  See Also:
    ON_Interval::NormalizedParameterAt
  */
  double ParameterAt (
    double normalized_parameter
    ) const; 
  ON_Interval ParameterAt (
    ON_Interval normalized_interval
    ) const; 
  
  /*
  Description:
    Convert interval value, or pair of values, to normalized parameter.
  Parameters:
    interval_parameter - [in] value in interval
  Returns:
    Normalized parameter x so that 
    min*(1.0-x) + max*x = interval_parameter.
  See Also:
    ON_Interval::ParameterAt
  */
  double NormalizedParameterAt (
    double interval_parameter
    ) const;
  ON_Interval NormalizedParameterAt (
    ON_Interval interval_parameter
    ) const;

  double& operator[](int); // returns (index<=0) ? m_t[0] : m_t[1]
  double operator[](int) const; // returns (index<=0) ? m_t[0] : m_t[1]
  double& operator[](unsigned int); // returns (index<=0) ? m_t[0] : m_t[1]
  double operator[](unsigned int) const; // returns (index<=0) ? m_t[0] : m_t[1]

  double Min() const; // returns smaller of m_t[0] and m_t[1]
  double Max() const; // returns larger of m_t[0] and m_t[1]
  double Mid() const; // returns 0.5*(m_t[0] + m_t[1])
  double Length() const;

  bool IsIncreasing() const; // returns true if m_t[0] < m_t[1]
  bool IsDecreasing() const; // returns true if m_t[0] > m_t[0];
  bool IsInterval() const;   // returns truc if m_t[0] != m_t[1]
  bool IsSingleton() const;  // returns true if m_t[0] == m_t[1] != ON_UNSET_VALUE
  bool IsEmptyInterval() const;   // returns true if m_t[0] == m_t[1] == ON_UNSET_VALUE
  bool IsValid() const;      // returns ON_IsValid(m_t[0]) && ON_IsValid(m_t[1])

  // OBSOLETE - Use IsEmptyInterval()
  bool IsEmptySet() const;   // returns true if m_t[0] == m_t[1] == ON_UNSET_VALUE

	bool MakeIncreasing();		// returns true if resulting interval IsIncreasing() 

  /*
  Returns:
    @untitled table
     0      this is idential to other
    -1      this[0] < other[0]
    +1      this[0] > other[0]
    -1      this[0] == other[0] and this[1] < other[1]
    +1      this[0] == other[0] and this[1] > other[1]
  */
  int Compare( const ON_Interval& other ) const;

  /* 
  Description:
    Test a value t to see if it is inside the interval.
  Parameters:
    t - [in] value to test
    bTestOpenInterval - [in] 
        If false, t is tested to see if it satisfies min <= t <= max.
        If true, t is tested to see if it satisfies min < t < max.
  Returns:
    true if t is in the interval and false if t is not
    in the interval.
  */
  bool Includes(
    double t,
    bool bTestOpenInterval = false
    ) const;

  /* 
  Description:
    Test an interval to see if it is contained in this interval.
  Parameters:
    other - [in] interval to test
    bProperSubSet - [in] if true, then the test is for a proper subinterval.
  Returns:
    If bProperSubSet is false, then the result is true when
    this->Min() <= other.Min() and other.Max() <= this->Max().
    If bProperSubSet is true, then the result is true when
    this->Min() <= other.Min() and other.Max() <= this->Max()
    and at least one of the inequalites is strict.
  */
  bool Includes( 
    const ON_Interval& other,
    bool bProperSubSet = false
    ) const;

  /*
  Description:
    Changes interval to [-m_t[1],-m_t[0]].
  */
  void Reverse();

  /*
  Description:
    Swaps m_t[0] and m_t[1].
  */
  void Swap();

  //////////
  // If the intersection is not empty, then 
  // intersection = [max(this.Min(),arg.Min()), min(this.Max(),arg.Max())]
  // Intersection() returns true if the intersection is not empty.
  // The interval [ON_UNSET_VALUE,ON_UNSET_VALUE] is considered to be
  // the empty set interval.  The result of any intersection involving an
  // empty set interval or disjoint intervals is the empty set interval.
  bool Intersection( // this = this intersect arg
         const ON_Interval&
         );

  //////////
  // If the intersection is not empty, then 
  // intersection = [max(argA.Min(),argB.Min()), min(argA.Max(),argB.Max())]
  // Intersection() returns true if the intersection is not empty.
  // The interval [ON_UNSET_VALUE,ON_UNSET_VALUE] is considered to be
  // the empty set interval.  The result of any intersection involving an
  // empty set interval or disjoint intervals is the empty set interval.
  bool Intersection( // this = intersection of two args
         const ON_Interval&, 
         const ON_Interval&
         );

  //////////
  // The union of an empty set and an increasing interval is the increasing
  // interval.  The union of two empty sets is empty. The union of an empty
  // set an a non-empty interval is the non-empty interval.
  // The union of two non-empty intervals is
  // union = [min(this.Min(),arg.Min()), max(this.Max(),arg.Max()),]
  // Union() returns true if the union is not empty.
  bool Union( // this = this union arg
         const ON_Interval&
         );

  bool Union( // this = this union arg
         double t
         );

  bool Union( // this = this union arg
         int count,
         const double* t
         );

  //////////
  // The union of an empty set and an increasing interval is the increasing
  // interval.  The union of two empty sets is empty. The union of an empty
  // set an a non-empty interval is the non-empty interval.
  // The union of two non-empty intervals is
  // union = [min(argA.Min(),argB.Min()), max(argA.Max(),argB.Max()),]
  // Union() returns true if the union is not empty.
  bool Union( // this = union of two args
         const ON_Interval&, 
         const ON_Interval&
         );
};

////////////////////////////////////////////////////////////////
//
//   ON_2dPoint
//
class ON_CLASS ON_2dPoint
{
public:
  double x, y;

  static const ON_2dPoint Origin;     // (0.0,0.0)
  static const ON_2dPoint UnsetPoint; // (ON_UNSET_VALUE,ON_UNSET_VALUE)

  // use implicit destructor, copy constructor
  ON_2dPoint();                         // x,y not initialized
  ON_2dPoint(double x,double y);
  ON_2dPoint(const ON_3dPoint& );       // from 3d point
  ON_2dPoint(const ON_4dPoint& );       // from 4d point
  ON_2dPoint(const ON_2dVector& );      // from 2d vector
  ON_2dPoint(const ON_3dVector& );      // from 3d vector
  ON_2dPoint(const double*);            // from double[2] array

  ON_2dPoint(const class ON_2fPoint&);  // from 2f point
  ON_2dPoint(const class ON_3fPoint&);  // from 3f point
  ON_2dPoint(const class ON_4fPoint&);  // from 4f point
  ON_2dPoint(const class ON_2fVector&); // from 2f point
  ON_2dPoint(const class ON_3fVector&); // from 3f point
  ON_2dPoint(const float*);             // from float[2] array

  // (double*) conversion operators
  operator double*();
  operator const double*() const;

  // use implicit operator=(const ON_2dPoint&)
  ON_2dPoint& operator=(const ON_3dPoint&);
  ON_2dPoint& operator=(const ON_4dPoint&);
  ON_2dPoint& operator=(const ON_2dVector&);
  ON_2dPoint& operator=(const ON_3dVector&);
  ON_2dPoint& operator=(const double*); // point = double[2] support

  ON_2dPoint& operator=(const ON_2fPoint&);
  ON_2dPoint& operator=(const ON_3fPoint&);
  ON_2dPoint& operator=(const ON_4fPoint&);
  ON_2dPoint& operator=(const ON_2fVector&);
  ON_2dPoint& operator=(const ON_3fVector&);
  ON_2dPoint& operator=(const float*);  // point = float[2] support

  ON_2dPoint& operator*=(double);
  ON_2dPoint& operator/=(double);
  ON_2dPoint& operator+=(const ON_2dPoint&);  // Adding this was a mistake - cannot remove without breaking SDK
  ON_2dPoint& operator+=(const ON_2dVector&);
  ON_2dPoint& operator+=(const ON_3dVector&); // Adding this was a mistake - cannot remove without breaking SDK
  ON_2dPoint& operator-=(const ON_2dPoint&);  // Adding this was a mistake - cannot remove without breaking SDK
  ON_2dPoint& operator-=(const ON_2dVector&);
  ON_2dPoint& operator-=(const ON_3dVector&); // Adding this was a mistake - cannot remove without breaking SDK

  ON_2dPoint  operator*(int) const;
  ON_2dPoint  operator/(int) const;
  ON_2dPoint  operator*(float) const;
  ON_2dPoint  operator/(float) const;
  ON_2dPoint  operator*(double) const;
  ON_2dPoint  operator/(double) const;

  ON_2dPoint  operator+(const ON_2dPoint&) const;
  ON_2dPoint  operator+(const ON_2dVector&) const;
  ON_2dVector operator-(const ON_2dPoint&) const;
  ON_2dPoint  operator-(const ON_2dVector&) const;
  ON_3dPoint  operator+(const ON_3dPoint&) const;
  ON_3dPoint  operator+(const ON_3dVector&) const;
  ON_3dVector operator-(const ON_3dPoint&) const;
  ON_3dPoint  operator-(const ON_3dVector&) const;

  ON_2dPoint  operator+(const ON_2fPoint&) const;
  ON_2dPoint  operator+(const ON_2fVector&) const;
  ON_2dVector operator-(const ON_2fPoint&) const;
  ON_2dPoint  operator-(const ON_2fVector&) const;
  ON_3dPoint  operator+(const ON_3fPoint&) const;
  ON_3dPoint  operator+(const ON_3fVector&) const;
  ON_3dVector operator-(const ON_3fPoint&) const;
  ON_3dPoint  operator-(const ON_3fVector&) const;

  double operator*(const ON_2dPoint&) const; // dot product for points acting as vectors
  double operator*(const ON_2dVector&) const; // dot product for points acting as vectors
  double operator*(const ON_4dPoint&) const;
  ON_2dPoint operator*(const ON_Xform&) const;

  bool operator==(const ON_2dPoint&) const;
  bool operator!=(const ON_2dPoint&) const;

  // dictionary order comparisons
  bool operator<=(const ON_2dPoint&) const;
  bool operator>=(const ON_2dPoint&) const;
  bool operator<(const ON_2dPoint&) const;
  bool operator>(const ON_2dPoint&) const;

  // index operators mimic double[2] behavior
  double& operator[](int);
  double operator[](int) const;
  double& operator[](unsigned int);
  double operator[](unsigned int) const;

  /*
  Returns:
    False if any coordinate is infinte, a nan, or ON_UNSET_VALUE.
  */
  bool IsValid() const;

  /*
  Returns:
    True if every coordinate is ON_UNSET_VALUE.
  */
  bool IsUnsetPoint() const;

  // set 2d point value
  void Set(double x,double y);

  double DistanceTo( const ON_2dPoint& ) const;

  int MaximumCoordinateIndex() const;
  double MaximumCoordinate() const; // absolute value of maximum coordinate

  int MinimumCoordinateIndex() const;
  double MinimumCoordinate() const; // absolute value of minimum coordinate

  void Zero(); // set all coordinates to zero;

  // These transform the point in place. The transformation matrix acts on
  // the left of the point; i.e., result = transformation*point
  void Transform( 
        const ON_Xform&
        );

  void Rotate( // rotatation in XY plane
        double angle,              // angle in radians
        const ON_2dPoint& center   // center of rotation
        );

  void Rotate( // rotatation in XY plane
        double sin_angle,          // sin(angle)
        double cos_angle,          // cos(angle)
        const ON_2dPoint& center   // center of rotation
        );
};

ON_DECL
ON_2dPoint operator*(int, const ON_2dPoint&);

ON_DECL
ON_2dPoint operator*(float, const ON_2dPoint&);

ON_DECL
ON_2dPoint operator*(double, const ON_2dPoint&);

////////////////////////////////////////////////////////////////
//
//   ON_3dPoint
//
class ON_CLASS ON_3dPoint
{
public:
  double x, y, z;

  static const ON_3dPoint Origin;     // (0.0,0.0,0.0)
  static const ON_3dPoint UnsetPoint; // (ON_UNSET_VALUE,ON_UNSET_VALUE,ON_UNSET_VALUE)

  // use implicit destructor, copy constructor
  ON_3dPoint();                         // x,y,z not initialized
  ON_3dPoint(double x,double y,double z);
  ON_3dPoint(const ON_2dPoint& );       // from 2d point
  ON_3dPoint(const ON_4dPoint& );       // from 4d point
  ON_3dPoint(const ON_2dVector& );      // from 2d vector
  ON_3dPoint(const ON_3dVector& );      // from 3d vector
  ON_3dPoint(const double*);            // from double[3] array

  ON_3dPoint(const class ON_2fPoint&);  // from 2f point
  ON_3dPoint(const class ON_3fPoint&);  // from 3f point
  ON_3dPoint(const class ON_4fPoint&);  // from 4f point
  ON_3dPoint(const class ON_2fVector&); // from 2f point
  ON_3dPoint(const class ON_3fVector&); // from 3f point
  ON_3dPoint(const float*);             // from float[3] array

  // (double*) conversion operators
  operator double*();
  operator const double*() const;

  // use implicit operator=(const ON_3dPoint&)
  ON_3dPoint& operator=(const ON_2dPoint&);
  ON_3dPoint& operator=(const ON_4dPoint&);
  ON_3dPoint& operator=(const ON_2dVector&);
  ON_3dPoint& operator=(const ON_3dVector&);
  ON_3dPoint& operator=(const double*); // point = double[3] support

  ON_3dPoint& operator=(const class ON_2fPoint&);
  ON_3dPoint& operator=(const class ON_3fPoint&);
  ON_3dPoint& operator=(const class ON_4fPoint&);
  ON_3dPoint& operator=(const class ON_2fVector&);
  ON_3dPoint& operator=(const class ON_3fVector&);
  ON_3dPoint& operator=(const float*);  // point = float[3] support

  ON_3dPoint& operator*=(double);
  ON_3dPoint& operator/=(double);
  ON_3dPoint& operator+=(const ON_3dPoint&);  // Adding this was a mistake - cannot remove without breaking SDK
  ON_3dPoint& operator+=(const ON_3dVector&);
  ON_3dPoint& operator-=(const ON_3dPoint&);  // Adding this was a mistake - cannot remove without breaking SDK
  ON_3dPoint& operator-=(const ON_3dVector&);

  ON_3dPoint  operator*(int) const;
  ON_3dPoint  operator/(int) const;
  ON_3dPoint  operator*(float) const;
  ON_3dPoint  operator/(float) const;
  ON_3dPoint  operator*(double) const;
  ON_3dPoint  operator/(double) const;

  ON_3dPoint  operator+(const ON_3dPoint&) const;
  ON_3dPoint  operator+(const ON_3dVector&) const;
  ON_3dVector operator-(const ON_3dPoint&) const;
  ON_3dPoint  operator-(const ON_3dVector&) const;
  ON_3dPoint  operator+(const ON_2dPoint&) const;
  ON_3dPoint  operator+(const ON_2dVector&) const;
  ON_3dVector operator-(const ON_2dPoint&) const;
  ON_3dPoint  operator-(const ON_2dVector&) const;

  ON_3dPoint  operator+(const ON_3fPoint&) const;
  ON_3dPoint  operator+(const ON_3fVector&) const;
  ON_3dVector operator-(const ON_3fPoint&) const;
  ON_3dPoint  operator-(const ON_3fVector&) const;
  ON_3dPoint  operator+(const ON_2fPoint&) const;
  ON_3dPoint  operator+(const ON_2fVector&) const;
  ON_3dVector operator-(const ON_2fPoint&) const;
  ON_3dPoint  operator-(const ON_2fVector&) const;

  double operator*(const ON_3dPoint&) const; // dot product for points acting as vectors
  double operator*(const ON_3dVector&) const; // dot product for points acting as vectors
  double operator*(const ON_4dPoint&) const;
  ON_3dPoint operator*(const ON_Xform&) const;

  bool operator==(const ON_3dPoint&) const;
  bool operator!=(const ON_3dPoint&) const;

  // dictionary order comparisons
  bool operator<=(const ON_3dPoint&) const;
  bool operator>=(const ON_3dPoint&) const;
  bool operator<(const ON_3dPoint&) const;
  bool operator>(const ON_3dPoint&) const;

  // index operators mimic double[3] behavior
  double& operator[](int);
  double operator[](int) const;
  double& operator[](unsigned int);
  double operator[](unsigned int) const;

  /*
  Returns:
    False if any coordinate is infinte, a nan, or ON_UNSET_VALUE.
  */
  bool IsValid() const;

  /*
  Returns:
    True if every coordinate is ON_UNSET_VALUE.
  */
  bool IsUnsetPoint() const;

  // set 3d point value
  void Set(double x,double y,double z);

  double DistanceTo( const ON_3dPoint& ) const;

  int MaximumCoordinateIndex() const;
  double MaximumCoordinate() const; // absolute value of maximum coordinate
  
  int MinimumCoordinateIndex() const;
  double MinimumCoordinate() const; // absolute value of minimum coordinate

  double Fuzz( double tolerance = ON_ZERO_TOLERANCE ) const; // tolerance to use when comparing 3d points

  void Zero(); // set all coordinates to zero;

  // These transform the point in place. The transformation matrix acts on
  // the left of the point; i.e., result = transformation*point
  void Transform( 
        const ON_Xform&
        );

  void Rotate( 
        double angle,             // angle in radians
        const ON_3dVector& axis,  // axis of rotation
        const ON_3dPoint& center  // center of rotation
        );

  void Rotate( 
        double sin_angle,         // sin(angle)
        double cos_angle,         // cos(angle)
        const ON_3dVector& axis,  // axis of rotation
        const ON_3dPoint& center  // center of rotation
        );
};

ON_DECL
ON_3dPoint operator*(int, const ON_3dPoint&);

ON_DECL
ON_3dPoint operator*(float, const ON_3dPoint&);

ON_DECL
ON_3dPoint operator*(double, const ON_3dPoint&);

////////////////////////////////////////////////////////////////
//
//   ON_4dPoint (homogeneous coordinates)
//
class ON_CLASS ON_4dPoint
{
public:
  double x, y, z, w;
  
  // use implicit destructor, copy constructor
  ON_4dPoint();                       // x,y,z,w not initialized
  ON_4dPoint(double x,double y,double z,double w);

  ON_4dPoint(const ON_2dPoint& );     // from 2d point
  ON_4dPoint(const ON_3dPoint& );     // from 3d point
  ON_4dPoint(const ON_2dVector& );    // from 2d vector
  ON_4dPoint(const ON_3dVector& );    // from 3d vector
  ON_4dPoint(const double*);          // from double[4] array

  ON_4dPoint(const ON_2fPoint& );     // from 2f point
  ON_4dPoint(const ON_3fPoint& );     // from 3f point
  ON_4dPoint(const ON_4fPoint& );     // from 3f point
  ON_4dPoint(const ON_2fVector& );    // from 2f vector
  ON_4dPoint(const ON_3fVector& );    // from 3f vector
  ON_4dPoint(const float*);           // from float[4] array

  // (double*) conversion operators
  operator double*();
  operator const double*() const;

  // use implicit operator=(const ON_4dPoint&)
  ON_4dPoint& operator=(const ON_2dPoint&);
  ON_4dPoint& operator=(const ON_3dPoint&);
  ON_4dPoint& operator=(const ON_2dVector&);
  ON_4dPoint& operator=(const ON_3dVector&);
  ON_4dPoint& operator=(const double*); // point = double[4] support

  ON_4dPoint& operator=(const class ON_2fPoint&);
  ON_4dPoint& operator=(const class ON_3fPoint&);
  ON_4dPoint& operator=(const class ON_4fPoint&);
  ON_4dPoint& operator=(const class ON_2fVector&);
  ON_4dPoint& operator=(const class ON_3fVector&);
  ON_4dPoint& operator=(const float*);  // point = float[4] support

  ON_4dPoint& operator*=(double);
  ON_4dPoint& operator/=(double);
  ON_4dPoint& operator+=(const ON_4dPoint&); // sum w = sqrt(|w1*w2|)
  ON_4dPoint& operator-=(const ON_4dPoint&); // difference w = sqrt(|w1*w2|)

  ON_4dPoint  operator*(double) const;
  ON_4dPoint  operator/(double) const;
  ON_4dPoint  operator+(const ON_4dPoint&) const; // sum w = sqrt(|w1*w2|)
  ON_4dPoint  operator-(const ON_4dPoint&) const; // difference w = sqrt(|w1*w2|)

  double operator*(const ON_4dPoint&) const;
  ON_4dPoint operator*(const ON_Xform&) const;

  // projective comparison 
  // (i.e., [x,y,z,w] == [c*x,c*y,c*z,c*w] is true for nonzero c)
  bool operator==(ON_4dPoint) const;
  bool operator!=(const ON_4dPoint&) const;

  // index operators mimic double[4] behavior
  double& operator[](int);
  double operator[](int) const;
  double& operator[](unsigned int);
  double operator[](unsigned int) const;

  /*
  Returns:
    False if any coordinate is infinte, a nan, or ON_UNSET_VALUE.
  */
  bool IsValid() const;

  /*
  Returns:
    True if every coordinate is ON_UNSET_VALUE.
  */
  bool IsUnsetPoint() const;

  // set 4d point value
  void Set(double x,double y,double z,double w);

  int MaximumCoordinateIndex() const;
  double MaximumCoordinate() const; // absolute value of maximum coordinate

  int MinimumCoordinateIndex() const;
  double MinimumCoordinate() const; // absolute value of minimum coordinate

  void Zero();      // set all 4 coordinates to zero;
  bool Normalize(); // set so x^2 + y^2 + z^2 + w^2 = 1

  // These transform the point in place. The transformation matrix acts on
  // the left of the point; i.e., result = transformation*point
  void Transform( 
        const ON_Xform&
        );
};

ON_DECL
ON_4dPoint operator*(double, const ON_4dPoint&);

////////////////////////////////////////////////////////////////
//
//   ON_2dVector
//
class ON_CLASS ON_2dVector
{
public:
  double x, y;

  static const ON_2dVector ZeroVector;  // (0.0,0.0)
  static const ON_2dVector XAxis;       // (1.0,0.0)
  static const ON_2dVector YAxis;       // (0.0,1.0)
  static const ON_2dVector UnsetVector; // (ON_UNSET_VALUE,ON_UNSET_VALUE)

  // Description:
  //   A index driven function to get unit axis vectors.
  // Parameters:
  //   index - [in] 0 returns (1,0), 1 returns (0,1)
  // Returns:
  //   Unit 2d vector with vector[i] = (i==index)?1:0;
  static const ON_2dVector& UnitVector(
    int // index
    );

  // use implicit destructor, copy constructor
  ON_2dVector();                     // x,y not initialized
  ON_2dVector(double x,double y);

  ON_2dVector(const ON_3dVector& ); // from 3d vector
  ON_2dVector(const ON_2dPoint& );  // from 2d point
  ON_2dVector(const ON_3dPoint& );  // from 3d point
  ON_2dVector(const double*);       // from double[2] array

  ON_2dVector(const ON_2fVector& ); // from 2f vector
  ON_2dVector(const ON_3fVector& ); // from 3f vector
  ON_2dVector(const ON_2fPoint& );  // from 2f point
  ON_2dVector(const ON_3fPoint& );  // from 3f point
  ON_2dVector(const float*);        // from double[2] array

  // (double*) conversion operators
  operator double*();
  operator const double*() const;

  // use implicit operator=(const ON_2dVector&)
  ON_2dVector& operator=(const ON_3dVector&);
  ON_2dVector& operator=(const ON_2dPoint&);
  ON_2dVector& operator=(const ON_3dPoint&);
  ON_2dVector& operator=(const double*); // vector = double[2] support

  ON_2dVector& operator=(const ON_2fVector&);
  ON_2dVector& operator=(const ON_3fVector&);
  ON_2dVector& operator=(const ON_2fPoint&);
  ON_2dVector& operator=(const ON_3fPoint&);
  ON_2dVector& operator=(const float*);  // vector = float[2] support

  ON_2dVector  operator-() const;

  ON_2dVector& operator*=(double);
  ON_2dVector& operator/=(double);
  ON_2dVector& operator+=(const ON_2dVector&);
  ON_2dVector& operator-=(const ON_2dVector&);
  // DO NOT ADD ANY MORE overrides of += or -=

  double operator*(const ON_2dVector&) const; // inner (dot) product
  double operator*(const ON_2dPoint&) const; // inner (dot) product (point acting as vector)
  double operator*(const ON_2fVector&) const; // inner (dot) product	

  ON_2dVector  operator*(int) const;
  ON_2dVector  operator/(int) const;
  ON_2dVector  operator*(float) const;
  ON_2dVector  operator/(float) const;
  ON_2dVector  operator*(double) const;
  ON_2dVector  operator/(double) const;

  ON_2dVector  operator+(const ON_2dVector&) const;
  ON_2dPoint   operator+(const ON_2dPoint&) const;
  ON_2dVector  operator-(const ON_2dVector&) const;
  ON_2dPoint   operator-(const ON_2dPoint&) const;
  ON_3dVector  operator+(const ON_3dVector&) const;
  ON_3dPoint   operator+(const ON_3dPoint&) const;
  ON_3dVector  operator-(const ON_3dVector&) const;
  ON_3dPoint   operator-(const ON_3dPoint&) const;

  ON_2dVector  operator+(const ON_2fVector&) const;
  ON_2dPoint   operator+(const ON_2fPoint&) const;
  ON_2dVector  operator-(const ON_2fVector&) const;
  ON_2dPoint   operator-(const ON_2fPoint&) const;
  ON_3dVector  operator+(const ON_3fVector&) const;
  ON_3dPoint   operator+(const ON_3fPoint&) const;
  ON_3dVector  operator-(const ON_3fVector&) const;
  ON_3dPoint   operator-(const ON_3fPoint&) const;

  double operator*(const ON_4dPoint&) const;
  ON_2dVector operator*(const ON_Xform&) const;

  bool operator==(const ON_2dVector&) const;
  bool operator!=(const ON_2dVector&) const;

  // dictionary order comparisons
  bool operator<=(const ON_2dVector&) const;
  bool operator>=(const ON_2dVector&) const;
  bool operator<(const ON_2dVector&) const;
  bool operator>(const ON_2dVector&) const;

  // index operators mimic double[2] behavior
  double& operator[](int);
  double operator[](int) const;
  double& operator[](unsigned int);
  double operator[](unsigned int) const;

  /*
  Returns:
    False if any coordinate is infinte, a nan, or ON_UNSET_VALUE.
  */
  bool IsValid() const;

  /*
  Returns:
    True if every coordinate is ON_UNSET_VALUE.
  */
  bool IsUnsetVector() const;

  // set 2d vector value
  void Set(double x,double y);

  int MaximumCoordinateIndex() const;
  double MaximumCoordinate() const; // absolute value of maximum coordinate

  int MinimumCoordinateIndex() const;
  double MinimumCoordinate() const; // absolute value of minimum coordinate

  double LengthSquared() const;
  double Length() const;

	// Signed area of the parallelagram.  The volume element.
	// returns x*B.y - y*B.x
	double WedgeProduct(const ON_2dVector& B) const;

  bool Decompose( // Computes a, b such that this vector = a*X + b*Y
         // Returns false if unable to solve for a,b.  This happens
         // when X,Y is not really a basis.
         //
         // If X,Y is known to be an orthonormal frame,
         // then a = V*X, b = V*Y will compute
         // the same result more quickly.
         const ON_2dVector&, // X
         const ON_2dVector&, // Y
         double*, // a
         double*  // b
         ) const;

  int IsParallelTo( 
        // returns  1: this and other vectors are parallel
        //         -1: this and other vectors are anti-parallel
        //          0: this and other vectors are not parallel
        //             or at least one of the vectors is zero
        const ON_2dVector& other,                           // other vector     
        double angle_tolerance = ON_DEFAULT_ANGLE_TOLERANCE // optional angle tolerance (radians)
        ) const;

  bool IsPerpendicularTo(
        // returns true:  this and other vectors are perpendicular
        //         false: this and other vectors are not perpendicular
        //                or at least one of the vectors is zero
        const ON_2dVector& other,                           // other vector     
        double angle_tolerance = ON_DEFAULT_ANGLE_TOLERANCE // optional angle tolerance (radians)
        ) const;

  void Zero(); // set all coordinates to zero;
  void Reverse(); // negate all coordinates
  bool Unitize();  // returns false if vector has zero length

  // Description:
  //   Test a vector to see if it is very short
  //
  // Parameters:
  //   tiny_tol - [in] (default = ON_ZERO_TOLERANCE) a nonzero
  //              value used as the coordinate zero tolerance.
  //
  // Returns:
  //   ( fabs(x) <= tiny_tol && fabs(y) <= tiny_tol )
  //
  bool IsTiny(
         double tiny_tol = ON_ZERO_TOLERANCE // tiny_tol
         ) const;

  // Returns:
  //   true if vector is the zero vector.
  bool IsZero() const;

  // Returns:
  //   true if vector is valid and has length 1.
  bool IsUnitVector() const;

  // set this vector to be perpendicular to another vector
  bool PerpendicularTo( // Result is not unitized. 
                        // returns false if input vector is zero
        const ON_2dVector& 
        );

  // set this vector to be perpendicular to a line defined by 2 points
  bool PerpendicularTo( 
        const ON_2dPoint&, 
        const ON_2dPoint& 
        );

  // These transform the vector in place. The transformation matrix acts on
  // the left of the vector; i.e., result = transformation*vector
  void Transform( 
        const ON_Xform& // can use ON_Xform here
        );

  void Rotate( 
        double angle            // angle in radians
        );

  void Rotate( 
        double sin_angle,       // sin(angle)
        double cos_angle        // cos(angle)
        );
};

ON_DECL
ON_2dVector operator*(int, const ON_2dVector&);

ON_DECL
ON_2dVector operator*(float, const ON_2dVector&);

ON_DECL
ON_2dVector operator*(double, const ON_2dVector&);

///////////////////////////////////////////////////////////////
//
// ON_2dVector utilities
//

ON_DECL
double 
ON_DotProduct( 
    const ON_2dVector&, 
    const ON_2dVector& 
    );

ON_DECL
ON_3dVector 
ON_CrossProduct(
    const ON_2dVector&, 
    const ON_2dVector& 
    );

ON_DECL
double			 
ON_WedgeProduct(		// signed area of the parallelagram.  Volume element.
    const ON_2dVector& A, // returns A.x * B.y - A.y * B.x 
    const ON_2dVector& B 
    );

ON_DECL
bool 
ON_IsOrthogonalFrame( // true if X, Y are nonzero and mutually perpendicular
    const ON_2dVector&, // X
    const ON_2dVector&  // Y
    );

ON_DECL
bool 
ON_IsOrthonormalFrame( // true if X, Y are orthogonal and unit length
    const ON_2dVector&, // X
    const ON_2dVector&  // Y
    );

ON_DECL
bool 
ON_IsRightHandFrame( // true if X, Y are orthonormal and right handed
    const ON_2dVector&, // X
    const ON_2dVector&  // Y
    );

////////////////////////////////////////////////////////////////
//
//   ON_3dVector
//
class ON_CLASS ON_3dVector
{
public:
  double x, y, z;

  static const ON_3dVector ZeroVector;  // (0.0,0.0,0.0)
  static const ON_3dVector XAxis;       // (1.0,0.0,0.0)
  static const ON_3dVector YAxis;       // (0.0,1.0,0.0)
  static const ON_3dVector ZAxis;       // (0.0,0.0,1.0)
  static const ON_3dVector UnsetVector; // (ON_UNSET_VALUE,ON_UNSET_VALUE,ON_UNSET_VALUE)

  // Description:
  //   A index driven function to get unit axis vectors.
  // Parameters:
  //   index - [in] 0 returns (1,0,0), 1 returns (0,1,0), 
  //                2 returns (0,0,1)
  // Returns:
  //   Unit 3d vector with vector[i] = (i==index)?1:0;
  static const ON_3dVector& UnitVector(
    int // index
    );

  // use implicit destructor, copy constructor
  ON_3dVector();                     // x,y,z not initialized
  ON_3dVector(double x,double y,double z);
  ON_3dVector(const ON_2dVector& );  // from 2d vector
  ON_3dVector(const ON_2dPoint& );   // from 2d point
  ON_3dVector(const ON_3dPoint& );   // from 3d point
  ON_3dVector(const double*);        // from double[3] array

  ON_3dVector(const ON_2fVector& );  // from 2f vector
  ON_3dVector(const ON_3fVector& );  // from 3f vector
  ON_3dVector(const ON_2fPoint& );   // from 2f point
  ON_3dVector(const ON_3fPoint& );   // from 3f point
  ON_3dVector(const float*);         // from float[3] array

  // (double*) conversion operators
  operator double*();
  operator const double*() const;

  // use implicit operator=(const ON_3dVector&)
  ON_3dVector& operator=(const ON_2dVector&);
  ON_3dVector& operator=(const ON_2dPoint&);
  ON_3dVector& operator=(const ON_3dPoint&);
  ON_3dVector& operator=(const double*); // vector = double[3] support
  
  ON_3dVector& operator=(const ON_2fVector&);
  ON_3dVector& operator=(const ON_3fVector&);
  ON_3dVector& operator=(const ON_2fPoint&);
  ON_3dVector& operator=(const ON_3fPoint&);
  ON_3dVector& operator=(const float*);  // vector = float[3] support

  ON_3dVector  operator-() const;

  ON_3dVector& operator*=(double);
  ON_3dVector& operator/=(double);
  ON_3dVector& operator+=(const ON_3dVector&);
  ON_3dVector& operator-=(const ON_3dVector&);
  // DO NOT ADD ANY MORE overrides of += or -=

  double operator*(const ON_3dVector&) const; // inner (dot) product
  double operator*(const ON_3dPoint&) const; // inner (dot) product
  double operator*(const ON_3fVector&) const; // inner (dot) product

  ON_3dVector  operator*(int) const;
  ON_3dVector  operator/(int) const;
  ON_3dVector  operator*(float) const;
  ON_3dVector  operator/(float) const;
  ON_3dVector  operator*(double) const;
  ON_3dVector  operator/(double) const;

  ON_3dVector  operator+(const ON_3dVector&) const;
  ON_3dPoint   operator+(const ON_3dPoint&) const;
  ON_3dVector  operator-(const ON_3dVector&) const;
  ON_3dPoint   operator-(const ON_3dPoint&) const;
  ON_3dVector  operator+(const ON_2dVector&) const;
  ON_3dPoint   operator+(const ON_2dPoint&) const;
  ON_3dVector  operator-(const ON_2dVector&) const;
  ON_3dPoint   operator-(const ON_2dPoint&) const;

  ON_3dVector  operator+(const ON_3fVector&) const;
  ON_3dPoint   operator+(const ON_3fPoint&) const;
  ON_3dVector  operator-(const ON_3fVector&) const;
  ON_3dPoint   operator-(const ON_3fPoint&) const;
  ON_3dVector  operator+(const ON_2fVector&) const;
  ON_3dPoint   operator+(const ON_2fPoint&) const;
  ON_3dVector  operator-(const ON_2fVector&) const;
  ON_3dPoint   operator-(const ON_2fPoint&) const;

  double operator*(const ON_4dPoint&) const;
  ON_3dVector operator*(const ON_Xform&) const;

  bool operator==(const ON_3dVector&) const;
  bool operator!=(const ON_3dVector&) const;

  // dictionary order comparisons
  bool operator<=(const ON_3dVector&) const;
  bool operator>=(const ON_3dVector&) const;
  bool operator<(const ON_3dVector&) const;
  bool operator>(const ON_3dVector&) const;

  // index operators mimic double[3] behavior
  double& operator[](int);
  double operator[](int) const;
  double& operator[](unsigned int);
  double operator[](unsigned int) const;

  /*
  Returns:
    False if any coordinate is infinte, a nan, or ON_UNSET_VALUE.
  */
  bool IsValid() const;

  /*
  Returns:
    True if every coordinate is ON_UNSET_VALUE.
  */
  bool IsUnsetVector() const;

  // set 3d vector value
  void Set(double x,double y,double z);

  int MaximumCoordinateIndex() const;
  double MaximumCoordinate() const; // absolute value of maximum coordinate

  int MinimumCoordinateIndex() const;
  double MinimumCoordinate() const; // absolute value of minimum coordinate

  double LengthSquared() const;
  double Length() const;

  bool Decompose( // Computes a, b, c such that this vector = a*X + b*Y + c*Z
         // Returns false if unable to solve for a,b,c.  This happens
         // when X,Y,Z is not really a basis.
         //
         // If X,Y,Z is known to be an orthonormal frame,
         // then a = V*X, b = V*Y, c = V*Z will compute
         // the same result more quickly.
         const ON_3dVector&, // X
         const ON_3dVector&, // Y
         const ON_3dVector&, // Z
         double*, // a
         double*, // b
         double*  // c
         ) const;

  int IsParallelTo( 
        // returns  1: this and other vectors are parallel
        //         -1: this and other vectors are anti-parallel
        //          0: this and other vectors are not parallel
        //             or at least one of the vectors is zero
        const ON_3dVector& other,                           // other vector     
        double angle_tolerance = ON_DEFAULT_ANGLE_TOLERANCE // optional angle tolerance (radians)
        ) const;

  bool IsPerpendicularTo(
        // returns true:  this and other vectors are perpendicular
        //         false: this and other vectors are not perpendicular
        //                or at least one of the vectors is zero
        const ON_3dVector& other,                           // other vector     
        double angle_tolerance = ON_DEFAULT_ANGLE_TOLERANCE // optional angle tolerance (radians)
        ) const;

  double Fuzz( double tolerance = ON_ZERO_TOLERANCE ) const; // tolerance to use when comparing 3d vectors

  void Zero(); // set all coordinates to zero;
  void Reverse(); // negate all coordinates
  bool Unitize();  // returns false if vector has zero length
  double LengthAndUnitize(); // unitizes and returns initial length

  // Description:
  //   Test a vector to see if it is very short
  //
  // Parameters:
  //   tiny_tol - [in] (default = ON_ZERO_TOLERANCE) a nonzero
  //              value used as the coordinate zero tolerance.
  //
  // Returns:
  //   ( fabs(x) <= tiny_tol && fabs(y) <= tiny_tol && fabs(z) <= tiny_tol )
  //
  bool IsTiny(
         double tiny_tol = ON_ZERO_TOLERANCE // tiny_tol
         ) const;

  // Returns:
  //   true if vector is the zero vector.
  bool IsZero() const;

  // Returns:
  //   true if vector is valid and has length 1.
  bool IsUnitVector() const;

  // set this vector to be perpendicular to another vector
  bool PerpendicularTo( // Result is not unitized. 
                        // returns false if input vector is zero
        const ON_3dVector& 
        );

  // set this vector to be perpendicular to a plane defined by 3 points
  bool PerpendicularTo(
               // about 3 times slower than
               //    ON_3dVector N = ON_CrossProduct(P1-P0,P2-P0); 
               //    N.Unitize();
               // returns false if points are coincident or colinear
         const ON_3dPoint&, const ON_3dPoint&, const ON_3dPoint& 
         );

  // These transform the vector in place. The transformation matrix acts on
  // the left of the vector; i.e., result = transformation*vector
  void Transform( 
        const ON_Xform& // can use ON_Xform here
        );

  void Rotate( 
        double angle,           // angle in radians
        const ON_3dVector& axis // axis of rotation
        );

  void Rotate( 
        double sin_angle,        // sin(angle)
        double cos_angle,        // cos(angle)
        const ON_3dVector& axis  // axis of rotation
        );
};

class ON_CLASS ON_3dRay
{
public:
  ON_3dRay();
  ~ON_3dRay();

  ON_3dPoint  m_P;
  ON_3dVector m_V;
};

/*
Description:
  Typically the vector portion is a unit vector and
  m_d = -(x*P.x + y*P.y + z*P.z) for a point P on the plane.
*/
class ON_CLASS ON_PlaneEquation : public ON_3dVector
{
public:
  // C++ defaults for construction, destruction, copys, and operator=
  // work fine.

  static const ON_PlaneEquation UnsetPlaneEquation; // (ON_UNSET_VALUE,ON_UNSET_VALUE,ON_UNSET_VALUE,ON_UNSET_VALUE)
  static const ON_PlaneEquation ZeroPlaneEquation; // (0.0,0.0,0.0,0.0)

  ON_PlaneEquation();

  ON_PlaneEquation(double xx, double yy, double zz, double dd);

  /*
  Description:
    returns true if x, y, z, d are valid, finite doubles.
  Remarks:
    this function will return true if x, y and z are all zero.
  See Also:
    ON_PlaneEquation::IsSet().
  */
  bool IsValid() const;

  /*
  Description:
    returns true if x, y, z, d are valid, finite doubles and
    at least one of x, y or z is not zero.
  */
  bool IsSet() const;

  /*
  Description:
    Sets (x,y,z) to a unitized N and then sets
    d = -(x*P.x + y*P.y + z*P.z).
  Parameters:
    P - [in] point on the plane
    N - [in] vector perpendicular to the plane
  Returns:
     true if input is valid.
  */
  bool Create( ON_3dPoint P, ON_3dVector N );

  /*
  Description:
    Evaluate the plane at a point.
  Parameters:
    P - [in]
  Returns:
    x*P.x + y*P.y + z*P.z + d;
  */
  double ValueAt(ON_3dPoint P) const;
  double ValueAt(ON_4dPoint P) const;
  double ValueAt(ON_3dVector P) const;
  double ValueAt(double x, double y, double z) const;

  /*
  Description:
    Evaluate the plane at a list of point values.
  Parameters:
    Pcount - [in]
      number of points
    P - [in]
      points
    value - [in]
      If not null, value[] must be an array of length at least Pcount.
      The values will be stored in this array.  If null, the an array
      will be allocated with onmalloc() and returned.
    value_range - [out]
      If not null, the range of values will be returned here.
  Returns:
    An array of Pcount values.  If the input parameter value was null,
    then the array is allocated on the heap using onmalloc() and the 
    caller is responsible for calling onfree() when finished.  If the 
    input is not valid, null is returned.
  */
  double* ValueAt(
        int Pcount,
        const ON_3fPoint* P,
        double* value,
        double value_range[2]
        ) const;

  double* ValueAt(
        int Pcount,
        const ON_3dPoint* P,
        double* value,
        double value_range[2]
        ) const;

  /*
  Description:
    This function calculates and evalutes points that 
    would be exactly on the plane if double precision
    aritmetic were mathematically perfect and returns
    the largest value of the evaluations.
  */
  double ZeroTolerance() const;

  /*
  Description:
    Transform the plane equation so that, if e0 is the initial
    equation, e1 is transformed equation and P is a point,
    then e0.ValueAt(P) = e1.ValueAt(xform*P).
  Parameters:
    xform - [in]
      Invertable transformation.
  Returns:
    True if the plane equation was successfully transformed.
    False if xform is not invertable or the equation is not
    valid.
  Remarks:
    This function has to invert xform.  If you have apply the
    same transformation to a bunch of planes, then it will be
    more efficient to calculate xform's inverse transpose
    and apply the resultingt transformation to the equation's
    coefficients as if they were 4d point coordinates.
  */
  bool Transform( const ON_Xform& xform );

  /*
  Description:
    Get point on plane that is closest to a given point.
  Parameters:
    point - [in]
  Returns:
    A 3d point on the plane that is closest to the input point.
  */
  ON_3dPoint ClosestPointTo( ON_3dPoint point ) const;

  /*
  Description:
    Get the minimum value of the plane equation
    on a bounding box.
  Parameters:
    bbox - [in] 
  Returns:
    Minimum value of the plane equation on the bounding box.
  */
  double MinimumValueAt(const ON_BoundingBox& bbox) const;

  /*
  Description:
    Get the maximum value of the plane equation
    on a bounding box.
  Parameters:
    bbox - [in] 
  Returns:
    Maximum value of the plane equation on the bounding box.
  */
  double MaximumValueAt(const ON_BoundingBox& bbox) const;

  /*
  Description:
    Get the minimum value of the plane equation
    on a bounding box.
  Parameters:
    crvleafbox - [in]
  Returns:
    Minimum value of the plane equation on the curve leaf box.
  */
  double MinimumValueAt(const class ON_CurveLeafBox& crvleafbox) const;

  /*
  Description:
    Get the maximum value of the plane equation
    on a bounding box.
  Parameters:
    crvleafbox - [in]
  Returns:
    Maximum value of the plane equation on the curve leaf box.
  */
  double MaximumValueAt(const class ON_CurveLeafBox& crvleafbox) const;

  /*
  Description:
    Get the minimum value of the plane equation
    on a bounding box.
  Parameters:
    bbox - [in]
  Returns:
    Minimum value of the plane equation on the bounding box.
  */
  double MinimumValueAt(const class ON_SurfaceLeafBox& srfleafbox) const;

  /*
  Description:
    Get the maximum value of the plane equation
    on a bounding box.
  Parameters:
    bbox - [in]
  Returns:
    Maximum value of the plane equation on the bounding box.
  */
  double MaximumValueAt(const class ON_SurfaceLeafBox& srfleafbox) const;

  /*
  Description:
    Get the maximum value of the plane equation on a set of 3d points.
  Parameters:
    bRational - [in]
      False if the points are euclidean (x,y,z)
      True if the points are homogenous rational (x,y,z,w)
      (x/w,y/w,z/w) is used to evaluate the value.
    point_count - [in]
    point_stride - [in]
      i-th point's x coordinate = points[i*point_stride]
    points - [in]
      coordinates of points
    stop_value - [in]
      If stop_value is valid and not ON_UNSET_VALUE, then the 
      evaulation stops if a value > stop_value is found. 
      If stop_value = ON_UNSET_VALUE, then stop_value is ignored.
  Returns:
    Maximum value of the plane equation on the point list.
    If the input is not valid, then ON_UNSET_VALUE is returned.
  */
  double MaximumValueAt(
    bool bRational,
    int point_count,
    int point_stride,
    const double* points,
    double stop_value
    ) const;

  /*
  Description:
    Get the minimum value of the plane equation on a set of 3d points.
  Parameters:
    bRational - [in]
      False if the points are euclidean (x,y,z)
      True if the points are homogenous rational (x,y,z,w)
      (x/w,y/w,z/w) is used to evaluate the value.
    point_count - [in]
    point_stride - [in]
      i-th point's x coordinate = points[i*point_stride]
    points - [in]
      coordinates of points
    stop_value - [in]
      If stop_value is valid and not ON_UNSET_VALUE, then the 
      evaulation stops if a value < stop_value is found. 
      If stop_value = ON_UNSET_VALUE, then stop_value is ignored.
  Returns:
    Maximum value of the plane equation on the point list.
    If the input is not valid, then ON_UNSET_VALUE is returned.
  */
  double MinimumValueAt(
    bool bRational,
    int point_count,
    int point_stride,
    const double* points,
    double stop_value
    ) const;

  /*
  Description:
    Get the maximum absolute value of the plane equation 
    on a set of 3d points.
  Parameters:
    bRational - [in]
      False if the points are euclidean (x,y,z)
      True if the points are homogenous rational (x,y,z,w)
      (x/w,y/w,z/w) is used to evaluate the value.
    point_count - [in]
    point_stride - [in]
      i-th point's x coordinate = points[i*point_stride]
    points - [in]
      coordinates of points
    stop_value - [in]
      If stop_value >= 0.0, then the evaulation stops if an
      absolute value > stop_value is found. If stop_value < 0.0 
      or stop_value is invalid, then stop_value is ignored.
  Returns:
    Maximum value of the plane equation on the point list.
    If the input is not valid, then ON_UNSET_VALUE is returned.
  */
  double MaximumAbsoluteValueAt(
    bool bRational,
    int point_count,
    int point_stride,
    const double* points,
    double stop_value
    ) const;

  /*
  Description:
    Test points on a bezier curve to see if they are near the plane.
  Parameters:
    bezcrv - [in]
    s0 - [in]
    s1 - [in] the interval from s0 to s1 is tested (s0 < s1)
    sample_count - [in] number of interior points to test.  
                Numbers like 1, 3, 7, 15, ... work best.
    endpoint_tolerance - [in] If >= 0, then the end points are 
              tested to see if the distance from the endpoints 
              is <= endpoint_tolerance.
    interior_tolerance - [in] (>=0 and >=endpoint_tolerance) 
              This tolerance is used to test the interior sample points.
    smin - [put]  If not NULL, *smin = bezier parameter of nearest
                  test point.
    smax - [put]  If not NULL, *smax = bezier parameter of farthest
                  test point.  If false is returned, this is the
                  parameter of the test point that failed.
  Returns:
    True if all the tested points passed the tolerance test.
    False if at least one tested point failed the tolerance test.
    (The test terminates when the first failure is encountered.)
  */
  bool IsNearerThan( 
          const class ON_BezierCurve& bezcrv,
          double s0,
          double s1,
          int sample_count,
          double endpoint_tolerance,
          double interior_tolerance,
          double* smin,
          double* smax
          ) const;
  
  bool operator==(const ON_PlaneEquation&) const;
  bool operator!=(const ON_PlaneEquation&) const;

  double d; // 4th coefficient of the plane equation.
};

ON_DECL
ON_3dVector operator*(int, const ON_3dVector&);

ON_DECL
ON_3dVector operator*(float, const ON_3dVector&);

ON_DECL
ON_3dVector operator*(double, const ON_3dVector&);

///////////////////////////////////////////////////////////////
//
// ON_3dVector utilities
//

ON_DECL
double 
ON_DotProduct( 
    const ON_3dVector&, 
    const ON_3dVector& 
    );


ON_DECL
ON_3dVector 
ON_CrossProduct(
    const ON_3dVector&, 
    const ON_3dVector& 
    );

ON_DECL
ON_3dVector 
ON_CrossProduct( // 3d cross product for old fashioned arrays
    const double*, // array of 3d doubles
    const double*  // array of 3d doubles
    );

ON_DECL
double 
ON_TripleProduct( 
    const ON_3dVector&,
    const ON_3dVector&,
    const ON_3dVector&
    );

ON_DECL
double 
ON_TripleProduct(  // 3d triple product for old fashioned arrays
    const double*, // array of 3d doubles
    const double*, // array of 3d doubles
    const double*  // array of 3d doubles
    );

ON_DECL
bool 
ON_IsOrthogonalFrame( // true if X, Y, Z are nonzero and mutually perpendicular
    const ON_3dVector&, // X
    const ON_3dVector&, // Y
    const ON_3dVector&  // Z 
    );

ON_DECL
bool 
ON_IsOrthonormalFrame( // true if X, Y, Z are orthogonal and unit length
    const ON_3dVector&, // X
    const ON_3dVector&, // Y
    const ON_3dVector&  // Z 
    );

ON_DECL
bool 
ON_IsRightHandFrame( // true if X, Y, Z are orthonormal and right handed
    const ON_3dVector&, // X
    const ON_3dVector&, // Y
    const ON_3dVector&  // Z 
    );

///////////////////////////////////////////////////////////////
//
// common points and vectors
//
// ON_unset_point is obsolete - use ON_3dPoint::UnsetPoint
#define ON_unset_point ON_UNSET_POINT

// ON_UNSET_POINT is OBSOLETE - use ON_3dPoint::UnsetPoint
extern ON_EXTERN_DECL const ON_3dPoint  ON_UNSET_POINT; // (ON_UNSET_VALUE,ON_UNSET_VALUE,ON_UNSET_VALUE)

// ON_UNSET_VECTOR is OBSOLETE - use ON_3dPoint::UnsetVector
extern ON_EXTERN_DECL const ON_3dVector ON_UNSET_VECTOR; // (ON_UNSET_VALUE,ON_UNSET_VALUE,ON_UNSET_VALUE)

// ON_origin is OBSOLETE - use ON_3dPoint::Origin
extern ON_EXTERN_DECL const ON_3dPoint  ON_origin; // (0.0, 0.0, 0.0)

// ON_xaxis is OBSOLETE - use ON_3dPoint::XAxis
extern ON_EXTERN_DECL const ON_3dVector ON_xaxis; // (1.0, 0.0, 0.0)

// ON_yaxis is OBSOLETE - use ON_3dPoint::YAxis
extern ON_EXTERN_DECL const ON_3dVector ON_yaxis; // (0.0, 1.0, 0.0)

// ON_zaxis is OBSOLETE - use ON_3dPoint::ZAxis
extern ON_EXTERN_DECL const ON_3dVector ON_zaxis; // (0.0, 0.0, 1.0)

#include "opennurbs_fpoint.h"

////////////////////////////////////////////////////////////////
//
//   ON_SurfaceCurvature
//
class ON_CLASS ON_SurfaceCurvature
{
public:
  double k1, k2; // principal curvatures

  double GaussianCurvature() const;
  double MeanCurvature() const;
  double MinimumRadius() const;
  double MaximumRadius() const;
};

#endif

/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

////////////////////////////////////////////////////////////////
//
//   defines float precision point, vector, and array classes
//
////////////////////////////////////////////////////////////////
#if !defined(ON_FPOINT_INC_)
#define ON_FPOINT_INC_

class ON_Xform;

class ON_2fPoint;
class ON_3fPoint;
class ON_4fPoint;

class ON_2fVector;
class ON_3fVector;

////////////////////////////////////////////////////////////////
//
//   ON_2fPoint
//
class ON_CLASS ON_2fPoint
{
public:
  float x, y;

  static const ON_2fPoint Origin; // (0.0f,0.0f)

  // use implicit destructor, copy constructor
  ON_2fPoint();                       // x,y not initialized
  ON_2fPoint(float x,float y);

  ON_2fPoint(const ON_3fPoint& );     // from 3f point
  ON_2fPoint(const ON_4fPoint& );     // from 4f point
  ON_2fPoint(const ON_2fVector& );    // from 2f vector
  ON_2fPoint(const ON_3fVector& );    // from 3f vector
  ON_2fPoint(const float*);           // from float[2] array

  ON_2fPoint(const ON_2dPoint& );     // from 2d point
  ON_2fPoint(const ON_3dPoint& );     // from 3d point
  ON_2fPoint(const ON_4dPoint& );     // from 4d point
  ON_2fPoint(const ON_2dVector& );    // from 2d vector
  ON_2fPoint(const ON_3dVector& );    // from 3d vector
  ON_2fPoint(const double*);          // from double[2] array

  // (float*) conversion operators
  operator float*();
  operator const float*() const;

  // use implicit operator=(const ON_2fPoint&)
  ON_2fPoint& operator=(const ON_3fPoint&);
  ON_2fPoint& operator=(const ON_4fPoint&);
  ON_2fPoint& operator=(const ON_2fVector&);
  ON_2fPoint& operator=(const ON_3fVector&);
  ON_2fPoint& operator=(const float*);  // point = float[2] support

  ON_2fPoint& operator=(const ON_2dPoint&);
  ON_2fPoint& operator=(const ON_3dPoint&);
  ON_2fPoint& operator=(const ON_4dPoint&);
  ON_2fPoint& operator=(const ON_2dVector&);
  ON_2fPoint& operator=(const ON_3dVector&);
  ON_2fPoint& operator=(const double*); // point = double[2] support

  ON_2fPoint& operator*=(float);
  ON_2fPoint& operator/=(float);
  ON_2fPoint& operator+=(const ON_2fPoint&);
  ON_2fPoint& operator+=(const ON_2fVector&);
  ON_2fPoint& operator+=(const ON_3fVector&);
  ON_2fPoint& operator-=(const ON_2fPoint&);
  ON_2fPoint& operator-=(const ON_2fVector&);
  ON_2fPoint& operator-=(const ON_3fVector&);

  ON_2fPoint  operator*(int) const;
  ON_2fPoint  operator/(int) const;
  ON_2fPoint  operator*(float) const;
  ON_2fPoint  operator/(float) const;
  ON_2dPoint  operator*(double) const;
  ON_2dPoint  operator/(double) const;

  ON_2fPoint  operator+(const ON_2fPoint&) const;
  ON_2fPoint  operator+(const ON_2fVector&) const;
  ON_2fVector operator-(const ON_2fPoint&) const;
  ON_2fPoint  operator-(const ON_2fVector&) const;
  ON_3fPoint  operator+(const ON_3fPoint&) const;
  ON_3fPoint  operator+(const ON_3fVector&) const;
  ON_3fVector operator-(const ON_3fPoint&) const;
  ON_3fPoint  operator-(const ON_3fVector&) const;

  ON_2dPoint  operator+(const ON_2dPoint&) const;
  ON_2dPoint  operator+(const ON_2dVector&) const;
  ON_2dVector operator-(const ON_2dPoint&) const;
  ON_2dPoint  operator-(const ON_2dVector&) const;
  ON_3dPoint  operator+(const ON_3dPoint&) const;
  ON_3dPoint  operator+(const ON_3dVector&) const;
  ON_3dVector operator-(const ON_3dPoint&) const;
  ON_3dPoint  operator-(const ON_3dVector&) const;

  float operator*(const ON_2fPoint&) const; // for points acting as vectors
  float operator*(const ON_2fVector&) const; // for points acting as vectors
  float operator*(const ON_4fPoint&) const;

  bool operator==(const ON_2fPoint&) const;
  bool operator!=(const ON_2fPoint&) const;

  // dictionary order comparisons
  bool operator<=(const ON_2fPoint&) const;
  bool operator>=(const ON_2fPoint&) const;
  bool operator<(const ON_2fPoint&) const;
  bool operator>(const ON_2fPoint&) const;

  // index operators mimic float[2] behavior
  float& operator[](int);
  float operator[](int) const;
  float& operator[](unsigned int);
  float operator[](unsigned int) const;

  // set 2d point value
  void Set(float,float);

  double DistanceTo( const ON_2fPoint& ) const;

  int MaximumCoordinateIndex() const;
  double MaximumCoordinate() const; // absolute value of maximum coordinate

  void Zero(); // set all coordinates to zero;

  // These transform the point in place. The transformation matrix acts on
  // the left of the point; i.e., result = transformation*point
  void Transform( 
        const ON_Xform&
        );

  void Rotate( // rotatation in XY plane
        double,              // angle in radians
        const ON_2fPoint&   // center of rotation
        );

  void Rotate( // rotatation in XY plane
        double,              // sin(angle)
        double,              // cos(angle)
        const ON_2fPoint&   // center of rotation
        );
};

ON_DECL
ON_2fPoint operator*(int, const ON_2fPoint&);

ON_DECL
ON_2fPoint operator*(float, const ON_2fPoint&);

ON_DECL
ON_2dPoint operator*(double, const ON_2fPoint&);

////////////////////////////////////////////////////////////////
//
//   ON_3fPoint
//
class ON_CLASS ON_3fPoint
{
public:
  float x, y, z;

  static const ON_3fPoint Origin; // (0.0f,0.0f,0.0f)

  // use implicit destructor, copy constructor
  ON_3fPoint();                       // x,y,z not initialized
  ON_3fPoint(float x,float y,float z);
  ON_3fPoint(const ON_2fPoint& );     // from 2f point
  ON_3fPoint(const ON_4fPoint& );     // from 4f point
  ON_3fPoint(const ON_2fVector& );    // from 2f vector
  ON_3fPoint(const ON_3fVector& );    // from 3f vector
  ON_3fPoint(const float*);           // from float[3] array

  ON_3fPoint(const ON_2dPoint& );     // from 2d point
  ON_3fPoint(const ON_3dPoint& );     // from 3d point
  ON_3fPoint(const ON_4dPoint& );     // from 4d point
  ON_3fPoint(const ON_2dVector& );    // from 2d vector
  ON_3fPoint(const ON_3dVector& );    // from 3d vector
  ON_3fPoint(const double*);          // from double[3] array

  // (float*) conversion operators
  operator float*();
  operator const float*() const;

  // use implicit operator=(const ON_3fPoint&)
  ON_3fPoint& operator=(const ON_2fPoint&);
  ON_3fPoint& operator=(const ON_4fPoint&);
  ON_3fPoint& operator=(const ON_2fVector&);
  ON_3fPoint& operator=(const ON_3fVector&);
  ON_3fPoint& operator=(const float*);  // point = float[3] support

  ON_3fPoint& operator=(const ON_2dPoint&);
  ON_3fPoint& operator=(const ON_3dPoint&);
  ON_3fPoint& operator=(const ON_4dPoint&);
  ON_3fPoint& operator=(const ON_2dVector&);
  ON_3fPoint& operator=(const ON_3dVector&);
  ON_3fPoint& operator=(const double*); // point = double[3] support

  ON_3fPoint& operator*=(float);
  ON_3fPoint& operator/=(float);
  ON_3fPoint& operator+=(const ON_3fPoint&);
  ON_3fPoint& operator+=(const ON_3fVector&);
  ON_3fPoint& operator-=(const ON_3fPoint&);
  ON_3fPoint& operator-=(const ON_3fVector&);

  ON_3fPoint  operator*(int) const;
  ON_3fPoint  operator/(int) const;
  ON_3fPoint  operator*(float) const;
  ON_3fPoint  operator/(float) const;
  ON_3dPoint  operator*(double) const;
  ON_3dPoint  operator/(double) const;

  ON_3fPoint  operator+(const ON_3fPoint&) const;
  ON_3fPoint  operator+(const ON_3fVector&) const;
  ON_3fVector operator-(const ON_3fPoint&) const;
  ON_3fPoint  operator-(const ON_3fVector&) const;
  ON_3fPoint  operator+(const ON_2fPoint&) const;
  ON_3fPoint  operator+(const ON_2fVector&) const;
  ON_3fVector operator-(const ON_2fPoint&) const;
  ON_3fPoint  operator-(const ON_2fVector&) const;

  ON_3dPoint  operator+(const ON_3dPoint&) const;
  ON_3dPoint  operator+(const ON_3dVector&) const;
  ON_3dVector operator-(const ON_3dPoint&) const;
  ON_3dPoint  operator-(const ON_3dVector&) const;
  ON_3dPoint  operator+(const ON_2dPoint&) const;
  ON_3dPoint  operator+(const ON_2dVector&) const;
  ON_3dVector operator-(const ON_2dPoint&) const;
  ON_3dPoint  operator-(const ON_2dVector&) const;

  float operator*(const ON_3fPoint&) const; // for points acting as vectors
  float operator*(const ON_3fVector&) const; // for points acting as vectors
  float operator*(const ON_4fPoint&) const;

  bool operator==(const ON_3fPoint&) const;
  bool operator!=(const ON_3fPoint&) const;

  // dictionary order comparisons
  bool operator<=(const ON_3fPoint&) const;
  bool operator>=(const ON_3fPoint&) const;
  bool operator<(const ON_3fPoint&) const;
  bool operator>(const ON_3fPoint&) const;

  // index operators mimic float[3] behavior
  float& operator[](int);
  float operator[](int) const;
  float& operator[](unsigned int);
  float operator[](unsigned int) const;

  // set 3d point value
  void Set(float,float,float);

  double DistanceTo( const ON_3fPoint& ) const;

  int MaximumCoordinateIndex() const;
  double MaximumCoordinate() const; // absolute value of maximum coordinate
  double Fuzz( double = ON_ZERO_TOLERANCE ) const; // tolerance to use when comparing 3d points

  void Zero(); // set all coordinates to zero;

  // These transform the point in place. The transformation matrix acts on
  // the left of the point; i.e., result = transformation*point
  void Transform( 
        const ON_Xform&
        );

  void Rotate( 
        double,               // angle in radians
        const ON_3fVector&, // axis of rotation
        const ON_3fPoint&   // center of rotation
        );

  void Rotate( 
        double,               // sin(angle)
        double,               // cos(angle)
        const ON_3fVector&, // axis of rotation
        const ON_3fPoint&   // center of rotation
        );
};

ON_DECL
ON_3fPoint operator*(int, const ON_3fPoint&);

ON_DECL
ON_3fPoint operator*(float, const ON_3fPoint&);

ON_DECL
ON_3dPoint operator*(double, const ON_3fPoint&);

////////////////////////////////////////////////////////////////
//
//   ON_4fPoint (homogeneous coordinates)
//
class ON_CLASS ON_4fPoint
{
public:
  float x, y, z, w;

  // use implicit destructor, copy constructor
  ON_4fPoint();                        // x,y,z,w not initialized
  ON_4fPoint(float x,float y,float z,float w);

  ON_4fPoint(const ON_2fPoint& );     // from 2f point
  ON_4fPoint(const ON_3fPoint& );     // from 3f point
  ON_4fPoint(const ON_2fVector& );    // from 2f vector
  ON_4fPoint(const ON_3fVector& );    // from 3f vector
  ON_4fPoint(const float*);           // from float[4] array

  ON_4fPoint(const ON_2dPoint& );     // from 2d point
  ON_4fPoint(const ON_3dPoint& );     // from 3d point
  ON_4fPoint(const ON_4dPoint& );     // from 4d point
  ON_4fPoint(const ON_2dVector& );    // from 2d vector
  ON_4fPoint(const ON_3dVector& );    // from 3d vector
  ON_4fPoint(const double*);          // from double[4] array

  // (float*) conversion operators
  operator float*();
  operator const float*() const;

  // use implicit operator=(const ON_4fPoint&)
  ON_4fPoint& operator=(const ON_2fPoint&);
  ON_4fPoint& operator=(const ON_3fPoint&);
  ON_4fPoint& operator=(const ON_2fVector&);
  ON_4fPoint& operator=(const ON_3fVector&);
  ON_4fPoint& operator=(const float*);  // point = float[4] support

  ON_4fPoint& operator=(const ON_2dPoint&);
  ON_4fPoint& operator=(const ON_3dPoint&);
  ON_4fPoint& operator=(const ON_4dPoint&);
  ON_4fPoint& operator=(const ON_2dVector&);
  ON_4fPoint& operator=(const ON_3dVector&);
  ON_4fPoint& operator=(const double*); // point = double[4] support

  ON_4fPoint& operator*=(float);
  ON_4fPoint& operator/=(float);
  ON_4fPoint& operator+=(const ON_4fPoint&);
  ON_4fPoint& operator-=(const ON_4fPoint&);

  ON_4fPoint  operator*(float) const;
  ON_4fPoint  operator/(float) const;
  ON_4fPoint  operator+(const ON_4fPoint&) const; // sum w = sqrt(w1*w2)
  ON_4fPoint  operator-(const ON_4fPoint&) const; // difference w = sqrt(w1*w2)

  float operator*(const ON_4fPoint&) const;

  // projective comparison 
  // (i.e., [x,y,z,w] == [c*x,c*y,c*z,c*w] is true for nonzero c)
  bool operator==(ON_4fPoint) const;
  bool operator!=(const ON_4fPoint&) const;

  // index operators mimic float[4] behavior
  float& operator[](int);
  float operator[](int) const;
  float& operator[](unsigned int);
  float operator[](unsigned int) const;

  // set 4d point value
  void Set(float,float,float,float);

  int MaximumCoordinateIndex() const;
  double MaximumCoordinate() const; // absolute value of maximum coordinate

  void Zero();      // set all 4 coordinates to zero;
  bool Normalize(); // set so x^2 + y^2 + z^2 + w^2 = 1

  // These transform the point in place. The transformation matrix acts on
  // the left of the point; i.e., result = transformation*point
  void Transform( 
        const ON_Xform&
        );
};

ON_DECL
ON_4fPoint operator*(float, const ON_4fPoint&);

ON_DECL
ON_4dPoint operator*(double, const ON_4fPoint&);

////////////////////////////////////////////////////////////////
//
//   ON_2fVector
//
class ON_CLASS ON_2fVector
{
public:
  float x, y;

  static const ON_2fVector ZeroVector; // (0.0f,0.0f)
  static const ON_2fVector XAxis;      // (1.0f,0.0f)
  static const ON_2fVector YAxis;      // (0.0f,1.0f)

  // Description:
  //   A index driven function to get unit axis vectors.
  // Parameters:
  //   index - [in] 0 returns (1,0), 1 returns (0,1)
  // Returns:
  //   Unit 3d vector with vector[i] = (i==index)?1:0;
  static const ON_2fVector& UnitVector(
    int // index
    );

  // use implicit destructor, copy constructor
  ON_2fVector();                      // x,y not initialized
  ON_2fVector(float x,float y);
  ON_2fVector(const ON_2fPoint& );     // from 2f point
  ON_2fVector(const ON_3fPoint& );     // from 3f point
  ON_2fVector(const ON_4fPoint& );     // from 4f point
  ON_2fVector(const ON_3fVector& );    // from 3f vector
  ON_2fVector(const float*);           // from float[2] array

  ON_2fVector(const ON_2dPoint& );     // from 2d point
  ON_2fVector(const ON_3dPoint& );     // from 3d point
  ON_2fVector(const ON_4dPoint& );     // from 4d point
  ON_2fVector(const ON_2dVector& );    // from 2d vector
  ON_2fVector(const ON_3dVector& );    // from 3d vector
  ON_2fVector(const double*);          // from double[2] array

  // (float*) conversion operators
  operator float*();
  operator const float*() const;

  // use implicit operator=(const ON_2fVector&)
  ON_2fVector& operator=(const ON_2fPoint&);
  ON_2fVector& operator=(const ON_3fPoint&);
  ON_2fVector& operator=(const ON_3fVector&);
  ON_2fVector& operator=(const float*);  // point = float[2] support

  ON_2fVector& operator=(const ON_2dPoint&);
  ON_2fVector& operator=(const ON_3dPoint&);
  ON_2fVector& operator=(const ON_2dVector&);
  ON_2fVector& operator=(const ON_3dVector&);
  ON_2fVector& operator=(const double*); // point = double[2] support

  ON_2fVector  operator-() const;

  ON_2fVector& operator*=(float);
  ON_2fVector& operator/=(float);
  ON_2fVector& operator+=(const ON_2fVector&);
  ON_2fVector& operator-=(const ON_2fVector&);

  float operator*(const ON_2fVector&) const; // inner (dot) product
  float operator*(const ON_2fPoint&) const; // inner (dot) product point acting as a vector
  double operator*(const ON_2dVector&) const; // inner (dot) product
  
  ON_2fVector  operator*(int) const;
  ON_2fVector  operator/(int) const;
  ON_2fVector  operator*(float) const;
  ON_2fVector  operator/(float) const;
  ON_2dVector  operator*(double) const;
  ON_2dVector  operator/(double) const;

  ON_2fVector  operator+(const ON_2fVector&) const;
  ON_2fPoint   operator+(const ON_2fPoint&) const;
  ON_2fVector  operator-(const ON_2fVector&) const;
  ON_2fPoint   operator-(const ON_2fPoint&) const;
  ON_3fVector  operator+(const ON_3fVector&) const;
  ON_3fPoint   operator+(const ON_3fPoint&) const;
  ON_3fVector  operator-(const ON_3fVector&) const;
  ON_3fPoint   operator-(const ON_3fPoint&) const;

  ON_2dVector  operator+(const ON_2dVector&) const;
  ON_2dPoint   operator+(const ON_2dPoint&) const;
  ON_2dVector  operator-(const ON_2dVector&) const;
  ON_2dPoint   operator-(const ON_2dPoint&) const;
  ON_3dVector  operator+(const ON_3dVector&) const;
  ON_3dPoint   operator+(const ON_3dPoint&) const;
  ON_3dVector  operator-(const ON_3dVector&) const;
  ON_3dPoint   operator-(const ON_3dPoint&) const;

  float operator*(const ON_4fPoint&) const;

  bool operator==(const ON_2fVector&) const;
  bool operator!=(const ON_2fVector&) const;

  // dictionary order comparisons
  bool operator<=(const ON_2fVector&) const;
  bool operator>=(const ON_2fVector&) const;
  bool operator<(const ON_2fVector&) const;
  bool operator>(const ON_2fVector&) const;

  // index operators mimic float[2] behavior
  float& operator[](int);
  float operator[](int) const;
  float& operator[](unsigned int);
  float operator[](unsigned int) const;

  // set 2d vector value
  void Set(float,float);

  int MaximumCoordinateIndex() const;
  double MaximumCoordinate() const; // absolute value of maximum coordinate

  double LengthSquared() const;
  double Length() const;

  bool Decompose( // Computes a, b such that this vector = a*X + b*Y
         // Returns false if unable to solve for a,b.  This happens
         // when X,Y is not really a basis.
         //
         // If X,Y is known to be an orthonormal frame,
         // then a = V*X, b = V*Y will compute
         // the same result more quickly.
         const ON_2fVector&, // X
         const ON_2fVector&, // Y
         double*, // a
         double*  // b
         ) const;

  int IsParallelTo( 
        // returns  1: this and other vectors are parallel
        //         -1: this and other vectors are anti-parallel
        //          0: this and other vectors are not parallel
        //             or at least one of the vectors is zero
        const ON_2fVector&,                 // other vector     
        double = ON_DEFAULT_ANGLE_TOLERANCE // optional angle tolerance (radians)
        ) const;

  bool IsPerpendicularTo(
        // returns true:  this and other vectors are perpendicular
        //         false: this and other vectors are not perpendicular
        //                or at least one of the vectors is zero
        const ON_2fVector&,                 // other vector     
        double = ON_DEFAULT_ANGLE_TOLERANCE // optional angle tolerance (radians)
        ) const;

  void Zero(); // set all coordinates to zero;
  void Reverse(); // negate all coordinates
  bool Unitize();  // returns false if vector has zero length
  bool IsUnitVector() const;

  // Description:
  //   Test a vector to see if it is very short
  //
  // Parameters:
  //   tiny_tol - [in] (default = ON_ZERO_TOLERANCE) a nonzero
  //              value used as the coordinate zero tolerance.
  //
  // Returns:
  //   ( fabs(x) <= tiny_tol && fabs(y) <= tiny_tol )
  //
  bool IsTiny(
         double = ON_ZERO_TOLERANCE // tiny_tol
         ) const;

  // Returns:
  //   true if vector is the zero vector.
  bool IsZero() const;

  // set this vector to be perpendicular to another vector
  bool PerpendicularTo( // Result is not unitized. 
                        // returns false if input vector is zero
        const ON_2fVector& 
        );

  // set this vector to be perpendicular to a line defined by 2 points
  bool PerpendicularTo( 
        const ON_2fPoint&, 
        const ON_2fPoint& 
        );
};

ON_DECL
ON_2fVector operator*(int, const ON_2fVector&);

ON_DECL
ON_2fVector operator*(float, const ON_2fVector&);

ON_DECL
ON_2dVector operator*(double, const ON_2fVector&);

///////////////////////////////////////////////////////////////
//
// ON_2fVector utilities
//

ON_DECL
float 
ON_DotProduct( 
    const ON_2fVector&, 
    const ON_2fVector& 
    );

ON_DECL
ON_3fVector 
ON_CrossProduct(
    const ON_2fVector&, 
    const ON_2fVector& 
    );

ON_DECL
bool 
ON_IsOrthogonalFrame( // true if X, Y are nonzero and mutually perpendicular
    const ON_2fVector&, // X
    const ON_2fVector&  // Y
    );

ON_DECL
bool 
ON_IsOrthonormalFrame( // true if X, Y are orthogonal and unit length
    const ON_2fVector&, // X
    const ON_2fVector&  // Y
    );

ON_DECL
bool 
ON_IsRightHandFrame( // true if X, Y are orthonormal and right handed
    const ON_2fVector&, // X
    const ON_2fVector&  // Y
    );

////////////////////////////////////////////////////////////////
//
//   ON_3fVector
//
class ON_CLASS ON_3fVector
{
public:
  float x, y, z;

  static const ON_3fVector ZeroVector; // (0.0f,0.0f,0.0f)
  static const ON_3fVector XAxis;      // (1.0f,0.0f,0.0f)
  static const ON_3fVector YAxis;      // (0.0f,1.0f,0.0f)
  static const ON_3fVector ZAxis;      // (0.0f,0.0f,1.0f)

  // Description:
  //   A index driven function to get unit axis vectors.
  // Parameters:
  //   index - [in] 0 returns (1,0,0), 1 returns (0,1,0)
  //                2 returns (0,0,1)
  // Returns:
  //   Unit 3d vector with vector[i] = (i==index)?1:0;
  static const ON_3fVector& UnitVector(
    int // index
    );

  // use implicit destructor, copy constructor
  ON_3fVector();                      // x,y,z not initialized
  ON_3fVector(float x,float y,float z);

  ON_3fVector(const ON_2fPoint& );     // from 2f point
  ON_3fVector(const ON_3fPoint& );     // from 3f point
  ON_3fVector(const ON_4fPoint& );     // from 4f point
  ON_3fVector(const ON_2fVector& );    // from 2f vector
  ON_3fVector(const float*);           // from float[3] array

  ON_3fVector(const ON_2dPoint& );     // from 2d point
  ON_3fVector(const ON_3dPoint& );     // from 3d point
  ON_3fVector(const ON_4dPoint& );     // from 4d point
  ON_3fVector(const ON_2dVector& );    // from 2d vector
  ON_3fVector(const ON_3dVector& );    // from 3d vector
  ON_3fVector(const double*);          // from double[3] array

  // (float*) conversion operators
  operator float*();
  operator const float*() const;

  // use implicit operator=(const ON_3fVector&)
  ON_3fVector& operator=(const ON_2fPoint&);
  ON_3fVector& operator=(const ON_3fPoint&);
  ON_3fVector& operator=(const ON_4fPoint&);
  ON_3fVector& operator=(const ON_2fVector&);
  ON_3fVector& operator=(const float*);  // point = float[3] support

  ON_3fVector& operator=(const ON_2dPoint&);
  ON_3fVector& operator=(const ON_3dPoint&);
  ON_3fVector& operator=(const ON_4dPoint&);
  ON_3fVector& operator=(const ON_2dVector&);
  ON_3fVector& operator=(const ON_3dVector&);
  ON_3fVector& operator=(const double*); // point = double[3] support
  
  ON_3fVector  operator-() const;

  ON_3fVector& operator*=(float);
  ON_3fVector& operator/=(float);
  ON_3fVector& operator+=(const ON_3fVector&);
  ON_3fVector& operator-=(const ON_3fVector&);

  float operator*(const ON_3fVector&) const; // inner (dot) product
  float operator*(const ON_3fPoint&) const; // inner (dot) product (point acting as a vector)
  double operator*(const ON_3dVector&) const; // inner (dot) product

  ON_3fVector  operator*(int) const;
  ON_3fVector  operator/(int) const;
  ON_3fVector  operator*(float) const;
  ON_3fVector  operator/(float) const;
  ON_3dVector  operator*(double) const;
  ON_3dVector  operator/(double) const;

  ON_3fVector  operator+(const ON_3fVector&) const;
  ON_3fPoint   operator+(const ON_3fPoint&) const;
  ON_3fVector  operator-(const ON_3fVector&) const;
  ON_3fPoint   operator-(const ON_3fPoint&) const;
  ON_3fVector  operator+(const ON_2fVector&) const;
  ON_3fPoint   operator+(const ON_2fPoint&) const;
  ON_3fVector  operator-(const ON_2fVector&) const;
  ON_3fPoint   operator-(const ON_2fPoint&) const;

  ON_3dVector  operator+(const ON_3dVector&) const;
  ON_3dPoint   operator+(const ON_3dPoint&) const;
  ON_3dVector  operator-(const ON_3dVector&) const;
  ON_3dPoint   operator-(const ON_3dPoint&) const;
  ON_3dVector  operator+(const ON_2dVector&) const;
  ON_3dPoint   operator+(const ON_2dPoint&) const;
  ON_3dVector  operator-(const ON_2dVector&) const;
  ON_3dPoint   operator-(const ON_2dPoint&) const;

  float operator*(const ON_4fPoint&) const;

  bool operator==(const ON_3fVector&) const;
  bool operator!=(const ON_3fVector&) const;

  // dictionary order comparisons
  bool operator<=(const ON_3fVector&) const;
  bool operator>=(const ON_3fVector&) const;
  bool operator<(const ON_3fVector&) const;
  bool operator>(const ON_3fVector&) const;

  // index operators mimic float[3] behavior
  float& operator[](int);
  float operator[](int) const;
  float& operator[](unsigned int);
  float operator[](unsigned int) const;

  // set 3d vector value
  void Set(float,float,float);

  int MaximumCoordinateIndex() const;
  double MaximumCoordinate() const; // absolute value of maximum coordinate

  double LengthSquared() const;
  double Length() const;

  bool IsPerpendicularTo(
        // returns true:  this and other vectors are perpendicular
        //         false: this and other vectors are not perpendicular
        //                or at least one of the vectors is zero
        const ON_3fVector&,                 // other vector     
        double = ON_DEFAULT_ANGLE_TOLERANCE // optional angle tolerance (radians)
        ) const;

  double Fuzz( double = ON_ZERO_TOLERANCE ) const; // tolerance to use when comparing 3d vectors

  void Zero(); // set all coordinates to zero
  void Reverse(); // negate all coordinates
  bool Unitize();  // returns false if vector has zero length
  bool IsUnitVector() const;

  // Description:
  //   Test a vector to see if it is very short
  //
  // Parameters:
  //   tiny_tol - [in] (default = ON_ZERO_TOLERANCE) a nonzero
  //              value used as the coordinate zero tolerance.
  //
  // Returns:
  //   ( fabs(x) <= tiny_tol && fabs(y) <= tiny_tol && fabs(z) <= tiny_tol )
  //
  bool IsTiny(
         double = ON_ZERO_TOLERANCE // tiny_tol
         ) const;

  // Returns:
  //   true if vector is the zero vector.
  bool IsZero() const;

  // set this vector to be perpendicular to another vector
  bool PerpendicularTo( // Result is not unitized. 
                        // returns false if input vector is zero
        const ON_3fVector& 
        );

  // These transform the vector in place. The transformation matrix acts on
  // the left of the vector; i.e., result = transformation*vector
  void Transform( 
        const ON_Xform& // can use ON_Xform here
        );

  void Rotate( 
        double,             // angle in radians
        const ON_3fVector&  // axis of rotation
        );

  void Rotate( 
        double,             // sin(angle)
        double,             // cos(angle)
        const ON_3fVector&  // axis of rotation
        );
};

ON_DECL
ON_3fVector operator*(int, const ON_3fVector&);

ON_DECL
ON_3fVector operator*(float, const ON_3fVector&);

ON_DECL
ON_3dVector operator*(double, const ON_3fVector&);

///////////////////////////////////////////////////////////////
//
// ON_3fVector utilities
//

ON_DECL
float 
ON_DotProduct( 
    const ON_3fVector&, 
    const ON_3fVector& 
    );


ON_DECL
ON_3fVector 
ON_CrossProduct(
    const ON_3fVector&, 
    const ON_3fVector& 
    );

ON_DECL
ON_3fVector 
ON_CrossProduct( // 3d cross product for old fashioned arrays
    const float*, // array of 3d floats
    const float*  // array of 3d floats
    );

ON_DECL
float 
ON_TripleProduct( 
    const ON_3fVector&,
    const ON_3fVector&,
    const ON_3fVector&
    );

ON_DECL
float 
ON_TripleProduct(  // 3d triple product for old fashioned arrays
    const float*, // array of 3d floats
    const float*, // array of 3d floats
    const float*  // array of 3d floats
    );

ON_DECL
bool 
ON_IsOrthogonalFrame( // true if X, Y, Z are nonzero and mutually perpendicular
    const ON_3fVector&, // X
    const ON_3fVector&, // Y
    const ON_3fVector&  // Z 
    );

ON_DECL
bool 
ON_IsOrthonormalFrame( // true if X, Y, Z are orthogonal and unit length
    const ON_3fVector&, // X
    const ON_3fVector&, // Y
    const ON_3fVector&  // Z 
    );

ON_DECL
bool 
ON_IsRightHandFrame( // true if X, Y, Z are orthonormal and right handed
    const ON_3fVector&, // X
    const ON_3fVector&, // Y
    const ON_3fVector&  // Z 
    );

///////////////////////////////////////////////////////////////
//
// common points and vectors
//

// ON_forigin is OBSOLETE - use ON_3fPoint::Origin
extern ON_EXTERN_DECL const ON_3fPoint ON_forigin; // (0.0, 0.0, 0.0)

// ON_fxaxis is OBSOLETE - use ON_3fPoint::XAxis
extern ON_EXTERN_DECL const ON_3fVector ON_fxaxis; // (1.0, 0.0, 0.0)

// ON_fyaxis is OBSOLETE - use ON_3fVector::YAxis
extern ON_EXTERN_DECL const ON_3fVector ON_fyaxis; // (0.0, 1.0, 0.0)

// ON_fzaxis is OBSOLETE - use ON_3fVector::ZAxis
extern ON_EXTERN_DECL const ON_3fVector ON_fzaxis; // (0.0, 0.0, 1.0)


#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(ON_ARRAY_INC_)
#define ON_ARRAY_INC_

class ON_2dPointArray;
class ON_3dPointArray;
class ON_4dPointArray;

class ON_2dVectorArray;
class ON_3dVectorArray;

class ON_2fPointArray;
class ON_3fPointArray;
class ON_4fPointArray;

class ON_2fVectorArray;
class ON_3fVectorArray;

////////////////////////////////////////////////////////////////
//
// The ON_SimpleArray<> template is more efficient than the
// ON_ClassArray<> template, but ON_SimpleArray<> should not
// be used for arrays of classes that require explicit
// construction, destruction, or copy operators.
//
// By default, ON_SimpleArray<> uses onrealloc() to manage
// the dynamic array memory. If you want to use something 
// besides onrealloc() to manage the array memory, then override
// ON_SimpleArray::Realloc().

template <class T> class ON_SimpleArray
{
public:
  // construction ////////////////////////////////////////////////////////

  // These constructors create an array that uses onrealloc() to manage
  // the array memory.
  ON_SimpleArray();
  ON_SimpleArray( int ); // int = initial capacity

  // Copy constructor
  ON_SimpleArray( const ON_SimpleArray<T>& );

  virtual
  ~ON_SimpleArray();

  // Assignment operator
  virtual
  ON_SimpleArray<T>& operator=( const ON_SimpleArray<T>& );
  
  // emergency bailout ///////////////////////////////////////////////////
  void EmergencyDestroy(void); // call only when memory used by this array
                               // may have become invalid for reasons beyond
                               // your control. EmergencyDestroy() zeros
                               // anything that could possibly cause
                               // ~ON_SimpleArray() to crash.

  // query ///////////////////////////////////////////////////////////////
  
	int Count() const;      // number of elements in array
  unsigned int UnsignedCount() const;
	
	int Capacity() const;  // capacity of array

  unsigned int SizeOfArray() const; // amount of memory in the m_a[] array

  unsigned int SizeOfElement() const; // amount of memory in an m_a[] array element

  ON__UINT32 DataCRC(ON__UINT32 current_remainder) const;

  // The operator[] does to not check for valid indices.
  // The caller is responsibile for insuring that 0 <= i < Capacity()
  T& operator[]( int );
  T& operator[]( unsigned int );
  T& operator[]( ON__INT64 );
  T& operator[]( ON__UINT64 );
  const T& operator[]( int ) const;
  const T& operator[]( unsigned int ) const;  
  const T& operator[]( ON__INT64 ) const;
  const T& operator[]( ON__UINT64 ) const;  

  operator T*();                     // The cast operators return a pointer
  operator const T*() const;         // to the array.  If Count() is zero,
                                     // this pointer is NULL.

  T* First();
  const T* First() const;             // returns NULL if count = 0

  // At(index) returns NULL if index < 0 or index >= count
  T* At( int );
  T* At( unsigned int );
  T* At( ON__INT64 );
  T* At( ON__UINT64 );
  const T* At( int ) const;
  const T* At( unsigned int ) const;
  const T* At( ON__INT64 ) const;
  const T* At( ON__UINT64 ) const;

  T* Last();
  const T* Last() const;             // returns NULL if count = 0

  
  // array operations ////////////////////////////////////////////////////

  T& AppendNew();                    // Most efficient way to add a new element 
                                     // to the array.  Increases count by 1.

  void Append( const T& );           // Append copy of element.
                                     // Increments count by 1.

  void Append( int, const T* );      // Append copy of an array T[count]


  void Insert( int, const T& );      // Insert copy of element. Uses
                                     // memmove() to perform any
                                     // necessary moving.
                                     // Increases count by 1.

  void Remove();                     // Removes last element.  Decrements
                                     // count by 1.  Does not change capacity.

  virtual
  void Remove( int );                // Removes element. Uses memmove() to
                                     // perform any necessary shifting.
                                     // Decrements count by 1.  Does not change
                                     // capacity

  void Empty();           // Sets count to 0, leaves capacity untouched.

  void Reverse();         // reverse order

  void Swap(int,int);     // swap elements i and j

  //////////
  // Search( e ) does a SLOW search of the array starting at array[0]
  // and returns the index "i" of the first element that satisfies 
  // e == array[i]. (== is really memcmp()).  If the search is not 
  // successful, then Search() returns -1.  For Search(T) to work 
  // correctly, T must be a simple type.  Use Search(p,compare())
  // for Ts that are structs/classes that contain pointers.  Search()
  // is only suitable for performing infrequent searchs of small 
  // arrays.  Sort the array and use BinarySearch() for performing
  // efficient searches.
  int Search( const T& ) const;

  //////////
  // Search( p, compare ) does a SLOW search of the array starting
  // at array[0] and returns the index "i" of the first element 
  // that satisfies  compare(p,&array[i])==0.  If the search is not
  // successful, then Search() returns -1.  Search() is only suitable
  // for performing infrequent searches of small arrays.  Sort the
  // array and use BinarySearch() for performing efficient searches.
	// See Also: ON_CompareIncreasing<T> and ON_CompareDeccreasing<T>
  int Search( const T*, int (*)(const T*,const T*) ) const;

  //////////
  // BinarySearch( p, compare ) does a fast search of a sorted array
  // and returns the smallest index "i" of the element that satisifies
  // 0==compare(p,&array[i]).  
  //
  // BinarySearch( p, compare, count ) does a fast search of the first
  // count element sorted array and returns the smallest index "i" of 
  // the element that satisifies 0==compare(p,&array[i]).  The version
  // that takes a "count" is useful when elements are being appended
  // during a calculation and the appended elements are not sorted.
  //
  // If the search is successful, 
  // BinarySearch() returns the index of the element (>=0).
  // If the search is not successful, BinarySearch() returns -1.  
  // Use QuickSort( compare ) or, in rare cases and after meaningful
  // performance testing using optimzed release builds, 
  // HeapSort( compare ) to sort the array.
	// See Also: ON_CompareIncreasing<T> and ON_CompareDeccreasing<T>
  int BinarySearch( const T*, int (*)(const T*,const T*) ) const;
  int BinarySearch( const T*, int (*)(const T*,const T*), int ) const;

  //////////
  // Sorts the array using the heap sort algorithm.
  // QuickSort() is generally the better choice.
  bool HeapSort( int (*)(const T*,const T*) );

  //////////
  // Sorts the array using the quick sort algorithm.
	// See Also: ON_CompareIncreasing<T> and ON_CompareDeccreasing<T>
  bool QuickSort( int (*)(const T*,const T*) );

  /*
  Description:
    Sort() fills in the index[] array so that 
    array[index[i]] <= array[index[i+1]].  
    The array is not modified.  

  Parameters:
    sort_algorithm - [in]  
      ON::quick_sort (best in general) or ON::heap_sort
      Use ON::heap_sort only if you have done extensive testing with
      optimized release builds and are confident heap sort is 
      significantly faster.
    index - [out] an array of length Count() that is returned with
        some permutation of (0,1,...,Count()-1). 
    compare - [in] compare function compare(a,b,p) should return
        <0 if a<b, 0, if a==b, and >0 if a>b.
  Returns:
    true if successful
  */
  bool Sort( 
    ON::sort_algorithm sort_algorithm, 
    int* /* index[] */ ,
    int (*)(const T*,const T*) 
    ) const; 

  /*
  Description:
    Sort() fills in the index[] array so that 
    array[index[i]] <= array[index[i+1]].  
    The array is not modified.  

  Parameters:
    sort_algorithm - [in]  
      ON::quick_sort (best in general) or ON::heap_sort
      Use ON::heap_sort only if you have done extensive testing with
      optimized release builds and are confident heap sort is 
      significantly faster.
    index - [out] an array of length Count() that is returned with
        some permutation of (0,1,...,Count()-1). 
    compare - [in] compare function compare(a,b,p) should return
        <0 if a<b, 0, if a==b, and >0 if a>b.
    p - [in] pointer passed as third argument to compare.

  Returns:
    true if successful
  */
  bool Sort( 
    ON::sort_algorithm sort_algorithm,
    int*, // index[] 
    int (*)(const T*,const T*,void*), // int compare(const T*,const T*,void* p)
    void* // p
    ) const; 

  //////////
  // Permutes the array so that output[i] = input[index[i]].
  // The index[] array should be a permutation of (0,...,Count()-1).
  bool Permute( const int* /*index[]*/ );

  //////////
  // Zeros all array memory. 
  // Count and capacity are not changed.
  void Zero();

  //////////
  // Sets all bytes in array memory to value. 
  // Count and capacity are not changed.
  void MemSet(unsigned char); 
  
  // memory managment ////////////////////////////////////////////////////

  void Reserve( int );    // increase capacity to at least the requested value

  void Shrink();          // remove unused capacity

  void Destroy();         // onfree any memory and set count and capacity to zero
    
  // low level memory managment //////////////////////////////////////////

  // By default, ON_SimpleArray<> uses onrealloc() to manage
  // the dynamic array memory. If you want to use something 
  // besides onrealloc() to manage the array memory, then override 
  // Realloc(). The T* Realloc(ptr, capacity) should do the following:
  //
  // 1) If ptr and capacity are zero, return NULL.
  // 2) If ptr is NULL, an capacity > 0, allocate a memory block of 
  //    capacity*sizeof(T) bytes and return a pointer to this block.
  //    If the allocation request fails, return NULL.
  // 3) If ptr is not NULL and capacity is 0, free the memory block
  //    pointed to by ptr and return NULL.
  // 4) If ptr is not NULL and capacity > 0, then reallocate the memory
  //    block and return a pointer to the reallocated block.  If the 
  //    reallocation request fails, return NULL.
  //
  // NOTE WELL: 
  //    Microsoft's VC 6.0 realloc() contains a bug that can cause
  //    crashes and should be avoided. See MSDN Knowledge Base article
  //    ID Q225099 for more information.
  virtual
  T* Realloc(T*,int); // (re)allocated capacity*sizeof(T) bytes

  T* Array();                         // The Array() function return the 
  
  const T* Array() const;             // m_a pointer value.

  void SetCount( int );               // If value is <= Capacity(), then
                                      // sets count to specified value.

  void SetCapacity( int );            // Shrink/grows capacity.  If value
                                      // is < current Count(), then count
                                      // is reduced to value.
                                      //

  int NewCapacity() const;            // When the dynamic array needs to grow,
                                      // this calculates the new value for m_capacity.

  /*
  Description:
    Expert user tool to take charge of the memory used by 
    the dyanmic array.
  Returns:
     A pointer to the array and zeros out this class.
     The returned pointer is on the heap and must be
     deallocated by calling onfree().
  */
  T* KeepArray();

  /*
  Description:
    Do not use this version of SetArray().  Use the one that takes
    a pointer, count and capacity.
  */
  void SetArray(T*);

  /*
  Description:
    Expert user tool to set the memory used by the dyanmic array.
  Parameters:
    T* pointer - [in]
    int count [in]
    int capacity - [in]
       m_a is set to pointer, m_count is set to count, and m_capacity
       is set to capacity.  It is critical that the pointer be one 
       returned by onmalloc(sz), where sz >= capacity*sizeof(T[0]).
  */
  void SetArray(T*, int, int);

protected:
  // implimentation //////////////////////////////////////////////////////
  void Move( int /* dest index*/, int /* src index */, int /* element count*/ );
	T*   m_a;        // pointer to array memory
	int  m_count;    // 0 <= m_count <= m_capacity
	int  m_capacity; // actual length of m_a[]
};


////////////////////////////////////////////////////////////////
//

#if defined(ON_DLL_TEMPLATE)
// This stuff is here because of a limitation in the way Microsoft
// handles templates and DLLs.  See Microsoft's knowledge base 
// article ID Q168958 for details.
#pragma warning( push )
#pragma warning( disable : 4231 )

ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<bool>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<char>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<unsigned char>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<short>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<unsigned short>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<int>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<unsigned int>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<float>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<double>;

ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<bool*>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<char*>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<unsigned char*>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<short*>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<unsigned short*>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<int*>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<unsigned int*>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<float*>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<double*>;

ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_2dPoint>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_3dPoint>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_4dPoint>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_2dVector>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_3dVector>;

ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_2fPoint>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_3fPoint>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_4fPoint>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_2fVector>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_3fVector>;

ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_Color>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_SurfaceCurvature>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_Interval>;

ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_2dex>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_3dex>;

ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_COMPONENT_INDEX>;
#pragma warning( pop )
#endif


/////////////////////////////////////////////////////////////////
//

class ON_CLASS ON_2dPointArray : public ON_SimpleArray<ON_2dPoint>
{
public:
  // see ON_SimpleArray class definition comments for constructor documentation
  ON_2dPointArray();
  ON_2dPointArray(int);
  ON_2dPointArray( const ON_2dPointArray& );
  ON_2dPointArray& operator=( const ON_2dPointArray& );

  bool GetBBox( // returns true if successful
         double boxmin[2],
         double boxmax[2],
         int bGrowBox = false  // true means grow box
         ) const;

  bool Transform( const ON_Xform& );
  bool SwapCoordinates(int,int);
};


/////////////////////////////////////////////////////////////////
//

class ON_CLASS ON_2fPointArray : public ON_SimpleArray<ON_2fPoint>
{
public:
  // see ON_SimpleArray class definition comments for constructor documentation
  ON_2fPointArray();
  ON_2fPointArray(int);
  ON_2fPointArray(const ON_2fPointArray&);
  ON_2fPointArray& operator=( const ON_2fPointArray& );

  bool GetBBox( // returns true if successful
         float boxmin[2],
         float boxmax[2],
         int bGrowBox = false  // true means grow box
         ) const;
  bool Transform( const ON_Xform& );
  bool SwapCoordinates(int,int);
};


/////////////////////////////////////////////////////////////////
//

class ON_CLASS ON_3dPointArray : public ON_SimpleArray<ON_3dPoint>
{
public:
  // see ON_SimpleArray class definition comments for constructor documentation
  ON_3dPointArray();
  ON_3dPointArray(int);
  ON_3dPointArray(const ON_SimpleArray<ON_3dPoint>&);
  ON_3dPointArray& operator=( const ON_3dPointArray& );
  ON_3dPointArray(const ON_SimpleArray<ON_3fPoint>&);
  ON_3dPointArray& operator=( const ON_SimpleArray<ON_3fPoint>& );

  // Description:
  //   Create 3d point list
  // Parameters:
  //   point_dimension - [in] dimension of input points (2 or 3)
  //   bRational - [in] true if points are in homogenous rational form
  //   point_count - [in] number of points
  //   point_stride - [in] number of doubles to skip between points
  //   points - [in] array of point coordinates
  bool Create(
    int point_dimension,
    int bRational,
    int point_count,
    int point_stride,
    const double* points
    );

  // Description:
  //   Create 3d point list
  // Parameters:
  //   point_dimension - [in] dimension of input points (2 or 3)
  //   bRational - [in] true if points are in homogenous rational form
  //   point_count - [in] number of points
  //   point_stride - [in] number of doubles to skip between points
  //   points - [in] array of point coordinates
  bool Create(
    int point_dimension,
    int bRational,
    int point_count,
    int point_stride,
    const float* points
    );

  // Description: 
  //   Get 3d axis aligned bounding box.
  // Returns:
  //   3d bounding box of point list.
  ON_BoundingBox BoundingBox() const;

  // Description:
  //   Get 3d axis aligned bounding box or the union
  //   of the input box with the point list's bounding box.
  // Parameters:
  //   bbox - [in/out] 3d axis aligned bounding box
  //   bGrowBox - [in] (default=false) 
  //     If true, then the union of the input bbox and the 
  //     point list's bounding box is returned in bbox.  
  //     If false, the point list's bounding box is returned in bbox.
  // Returns:
  //   true if successful.
  bool GetBoundingBox( 
    ON_BoundingBox& bbox,
    int bGrowBox = false
    ) const;

  // Description:
  //   Get axis aligned bounding box.
  // Parameters:
  //   boxmin - [in/out] array of 3 doubles
  //   boxmax - [in/out] array of 3 doubles
  //   bGrowBox - [in] (default=false) 
  //     If true, then the union of the input bounding box and the 
  //     object's bounding box is returned.
  //     If false, the object's bounding box is returned.
  // Returns:
  //   true if object has bounding box and calculation was successful
  bool GetBBox(
         double boxmin[3],
         double boxmax[3],
         int bGrowBox = false
         ) const;

  /*
	Description:
    Get tight bounding box of the point list.
	Parameters:
		tight_bbox - [in/out] tight bounding box
		bGrowBox -[in]	(default=false)			
      If true and the input tight_bbox is valid, then returned
      tight_bbox is the union of the input tight_bbox and the 
      tight bounding box of the point list.
		xform -[in] (default=NULL)
      If not NULL, the tight bounding box of the transformed
      point list is calculated.  The point list is not modified.
	Returns:
    True if the returned tight_bbox is set to a valid 
    bounding box.
  */
	bool GetTightBoundingBox( 
			ON_BoundingBox& tight_bbox, 
      int bGrowBox = false,
			const ON_Xform* xform = 0
      ) const;

  // Description:
  //   Transform points by applying xform to each point.
  // Parameters:
  //   xform - [in] transformation matrix
  // Returns:
  //   true if successful.
  bool Transform( 
    const ON_Xform& xform 
    );

  // Description:
  //   Swaps point coordinate values with indices i and j.
  // Parameters:
  //   i - [in] coordinate index
  //   j - [in] coordinate index
  // Returns:
  //   true if successful.
  // Example:
  //   The call SwapCoordinates(0,2) would swap the x and z
  //   coordinates of each point in the array.
  bool SwapCoordinates(
    int i,
    int j
    );

  // Description:
  //   Rotate points about a center and axis.  A positive angle
  //   results in a counter-clockwise rotation about the axis
  //   of rotation.
  // Parameters:
  //   sin_angle - [in] sine of rotation angle
  //   cos_angle - [in] cosine of rotation angle
  //   axis_of_rotation - [in] axis of rotation
  //   center_of_rotation - [in] center (fixed point) of rotation
  // Returns:
  //   true if successful.
  bool Rotate(
        double sin_angle,
        double cos_angle,
        const ON_3dVector& axis_of_rotation,
        const ON_3dPoint& center_of_rotation
        );

  // Description:
  //   Rotate points about a center and axis.  A positive angle
  //   results in a counter-clockwise rotation about the axis
  //   of rotation.
  // Parameters:
  //   angle - [in] angle in radians.  Polsine of rotation angle
  //   cos_angle - [in] cosine of rotation angle
  //   axis_of_rotation - [in] axis of rotation
  //   center_of_rotation - [in] center (fixed point) of rotation
  // Returns:
  //   true if successful.
  bool Rotate(
        double angle_in_radians,
        const ON_3dVector& axis_of_rotation,
        const ON_3dPoint& center_of_rotation
        );

  // Description:
  //   Translate a polyline
  // Parameters:
  //   delta - [in] translation vectorsine of rotation angle
  // Returns:
  //   true if successful.
  bool Translate(
        const ON_3dVector& delta
        );

  /*
  Description:
    Get the index of the point in the array that is closest
    to P.
  Parameters:
    P - [in]
    closest_point_index - [out]
    maximum_distance - [in] optional distance constraint.
        If maximum_distance > 0, then only points Q with
        |P-Q| <= maximum_distance are returned.
  Returns:
    True if a point is found; in which case *closest_point_index
    is the index of the point.  False if no point is found
    or the input is not valid.
  See Also:
    ON_GetClosestPointInPointList
    ON_PointCloud::GetClosestPoint
  */
  bool GetClosestPoint( 
          ON_3dPoint P,
          int* closest_point_index,
          double maximum_distance = 0.0
          ) const;

};


/////////////////////////////////////////////////////////////////
//

class ON_CLASS ON_3fPointArray : public ON_SimpleArray<ON_3fPoint>
{
public:
  // see ON_SimpleArray class definition comments for constructor documentation
  ON_3fPointArray();
  ON_3fPointArray(int);
  ON_3fPointArray(const ON_3fPointArray&);
  ON_3fPointArray& operator=( const ON_3fPointArray& );

  bool GetBBox(
         float boxmin[3],
         float boxmax[3],
         int bGrowBox = false
         ) const;

  bool Transform( const ON_Xform& );

  bool SwapCoordinates(int,int);
};


/////////////////////////////////////////////////////////////////
//

class ON_CLASS ON_4dPointArray : public ON_SimpleArray<ON_4dPoint>
{
public:
  // see ON_SimpleArray class definition comments for constructor documentation
  ON_4dPointArray();
  ON_4dPointArray(int);
  ON_4dPointArray(const ON_4dPointArray&);
  ON_4dPointArray& operator=( const ON_4dPointArray& );

  bool Transform( const ON_Xform& );
  bool SwapCoordinates(int,int);
};


/////////////////////////////////////////////////////////////////
//

class ON_CLASS ON_4fPointArray : public ON_SimpleArray<ON_4fPoint>
{
public:
  // see ON_SimpleArray class definition comments for constructor documentation
  ON_4fPointArray();
  ON_4fPointArray(int);
  ON_4fPointArray(const ON_4fPointArray&);
  ON_4fPointArray& operator=( const ON_4fPointArray& );

  bool Transform( const ON_Xform& );
  bool SwapCoordinates(int,int);
};


/////////////////////////////////////////////////////////////////
//

class ON_CLASS ON_2dVectorArray : public ON_SimpleArray<ON_2dVector>
{
public:
  // see ON_SimpleArray class definition comments for constructor documentation
  ON_2dVectorArray();
  ON_2dVectorArray(int);
  ON_2dVectorArray(const ON_2dVectorArray&);
  ON_2dVectorArray& operator=( const ON_2dVectorArray& );

  bool GetBBox(
         double boxmin[2],
         double boxmax[2],
         int bGrowBox = false
         ) const;

  bool Transform( const ON_Xform& );
  bool SwapCoordinates(int,int);
};


/////////////////////////////////////////////////////////////////
//

class ON_CLASS ON_2fVectorArray : public ON_SimpleArray<ON_2fVector>
{
public:
  // see ON_SimpleArray class definition comments for constructor documentation
  ON_2fVectorArray();
  ON_2fVectorArray(int);
  ON_2fVectorArray(const ON_2fVectorArray&);
  ON_2fVectorArray& operator=( const ON_2fVectorArray& );

  bool GetBBox(
         float boxmin[2],
         float boxmax[2],
         bool = false
         ) const;

  bool Transform( const ON_Xform& );
  bool SwapCoordinates(int,int);
};


/////////////////////////////////////////////////////////////////
//

class ON_CLASS ON_3dVectorArray : public ON_SimpleArray<ON_3dVector>
{
public:
  ON_3dVectorArray();
  ON_3dVectorArray(int);
  ON_3dVectorArray(const ON_3dVectorArray&);
  ON_3dVectorArray& operator=( const ON_3dVectorArray& );

  bool GetBBox(
         double boxmin[3],
         double boxmax[3],
         bool bGrowBow = false
         ) const;

  bool Transform( const ON_Xform& );
  bool SwapCoordinates(int,int);
};

/////////////////////////////////////////////////////////////////
//

class ON_CLASS ON_3fVectorArray : public ON_SimpleArray<ON_3fVector>
{
public:
  ON_3fVectorArray();
  ON_3fVectorArray(int);
  ON_3fVectorArray(const ON_3fVectorArray&);
  ON_3fVectorArray& operator=( const ON_3fVectorArray& );

  bool GetBBox(
         float boxmin[3],
         float boxmax[3],
         int bGrowBox = false
         ) const;

  bool Transform( const ON_Xform& );
  bool SwapCoordinates(int,int);
};

////////////////////////////////////////////////////////////////
//
// The ON_ClassArray<> template is designed to be used with
// classes that require non-trivial construction or destruction.
// Any class used with the ON_ClassArray<> template must have a
// robust operator=().
//
// By default, ON_ClassArray<> uses onrealloc() to manage
// the dynamic array memory. If you want to use something 
// besides onrealloc() to manage the array memory, then override
// ON_ClassArray::Realloc().  In practice this means that if your
// class has members with back-pointers, then you cannot use
// it in the defaule ON_ClassArray.  See ON_ObjectArray
// for an example.
//
template <class T> class ON_ClassArray
{
public:
  // construction ////////////////////////////////////////////////////////
  ON_ClassArray(); 
  ON_ClassArray( int ); // int = initial capacity

  // Copy constructor
  ON_ClassArray( const ON_ClassArray<T>& );

  virtual
  ~ON_ClassArray(); // override for struct member deallocation, etc.

  // Assignment operator
  ON_ClassArray<T>& operator=( const ON_ClassArray<T>& );
  
  // emergency bailout ///////////////////////////////////////////////////
  void EmergencyDestroy(void); // call only when memory used by this array
                               // may have become invalid for reasons beyond
                               // your control. EmergencyDestroy() zeros
                               // anything that could possibly cause
                               // ~ON_ClassArray() to crash.

  // query ///////////////////////////////////////////////////////////////
  
	int Count() const;      // number of elements in array
	unsigned int UnsignedCount() const;

	int Capacity() const;  // capacity of array

  unsigned int SizeOfArray() const; // amount of memory in the m_a[] array

  unsigned int SizeOfElement() const; // amount of memory in an m_a[] array element

  // The operator[] does to not check for valid indices.
  // The caller is responsibile for insuring that 0 <= i < Capacity()
  T& operator[]( int );
  T& operator[]( unsigned int );
  T& operator[]( ON__INT64 );
  T& operator[]( ON__UINT64 );
  const T& operator[]( int ) const;
  const T& operator[]( unsigned int ) const;  
  const T& operator[]( ON__INT64 ) const;
  const T& operator[]( ON__UINT64 ) const;  

  operator T*();                     // The cast operators return a pointer
  operator const T*() const;         // to the array.  If Count() is zero,
                                     // this pointer is NULL.
  T* First();
  const T* First() const;             // returns NULL if count = 0

  // At(index) returns NULL if index < 0 or index >= count
  T* At( int );
  T* At( unsigned int );
  T* At( ON__INT64 );
  T* At( ON__UINT64 );
  const T* At( int ) const;
  const T* At( unsigned int ) const;
  const T* At( ON__INT64 ) const;
  const T* At( ON__UINT64 ) const;

  T* Last();
  const T* Last() const;             // returns NULL if count = 0

  
  // array operations ////////////////////////////////////////////////////

  T& AppendNew();                    // Most efficient way to add a new class 
                                     // to the array.  Increases count by 1.

  void Append( const T& );           // Append copy of element.
                                     // Increments count by 1.

  void Append( int, const T*);       // Append copy of an array T[count]

  void Insert( int, const T& );      // Insert copy of element. Uses
                                     // memmove() to perform any
                                     // necessary moving.
                                     // Increases count by 1.

  void Remove();                     // Removes last element.  Decrements
                                     // count by 1.  Does not change capacity.

  void Remove( int );                // Removes element. Uses memmove() to
                                     // perform any necessary shifting.
                                     // Decrements count by 1.  Does not change
                                     // capacity

  void Empty();           // Sets count to 0, leaves capacity untouched.

  void Reverse();         // reverse order

  void Swap(int,int);     // swap elements i and j

  //////////
  // Search( p, compare ) does a SLOW search of the array starting
  // at array[0] and returns the index "i" of the first element 
  // that satisfies  compare(p,&array[i])==0.  If the search is not
  // successful, then Search() returns -1.  Search() is only suitable
  // for performing infrequent searches of small arrays.  Sort the
  // array and use BinarySearch() for performing efficient searches.
  int Search( const T*, int (*)(const T*,const T*) ) const;

  //////////
  // BinarySearch( p, compare ) does a fast search of a sorted array
  // and returns the smallest index "i" of the element that satisifies
  // 0==compare(p,&array[i]).
  //
  // BinarySearch( p, compare, count ) does a fast search of the first
  // count element sorted array and returns the smallest index "i" of 
  // the element that satisifies 0==compare(p,&array[i]).  The version
  // that takes a "count" is useful when elements are being appended
  // during a calculation and the appended elements are not sorted.
  //
  // If the search is successful, 
  // BinarySearch() returns the index of the element (>=0).
  // If the search is not successful, BinarySearch() returns -1.
  // Use QuickSort( compare ) or, in rare cases and after meaningful
  // performance testing using optimzed release builds, 
  // HeapSort( compare ) to sort the array.
	// See Also: ON_CompareIncreasing<T> and ON_CompareDeccreasing<T>
  int BinarySearch( const T*, int (*)(const T*,const T*) ) const;
  int BinarySearch( const T*, int (*)(const T*,const T*), int ) const;

  //////////
  // Sorts the array using the heap sort algorithm.
	// See Also: ON_CompareIncreasing<T> and ON_CompareDeccreasing<T>
  // QuickSort() is generally the better choice.
  virtual
  bool HeapSort( int (*)(const T*,const T*) );

  //////////
  // Sorts the array using the heap sort algorithm.
  virtual
  bool QuickSort( int (*)(const T*,const T*) );

  /*
  Description:
    Sort() fills in the index[] array so that 
    array[index[i]] <= array[index[i+1]].  
    The array is not modified.  

  Parameters:
    sort_algorithm - [in]  
      ON::quick_sort (best in general) or ON::heap_sort
      Use ON::heap_sort only if you have done extensive testing with
      optimized release builds and are confident heap sort is 
      significantly faster.
    index - [out] an array of length Count() that is returned with
        some permutation of (0,1,...,Count()-1). 
    compare - [in] compare function compare(a,b) should return
        <0 if a<b, 0, if a==b, and >0 if a>b.

  Returns:
    true if successful
  */
  bool Sort( 
    ON::sort_algorithm sort_algorithm, 
    int* /* index[] */ ,
    int (*)(const T*,const T*)
    ) const; 

  /*
  Description:
    Sort() fills in the index[] array so that 
    array[index[i]] <= array[index[i+1]].  
    The array is not modified.  

  Parameters:
    sort_algorithm - [in]  
      ON::quick_sort (best in general) or ON::heap_sort
      Use ON::heap_sort only if you have done extensive testing with
      optimized release builds and are confident heap sort is 
      significantly faster.
    index - [out] an array of length Count() that is returned with
        some permutation of (0,1,...,Count()-1). 
    compare - [in] compare function compare(a,b,p) should return
        <0 if a<b, 0, if a==b, and >0 if a>b.
    p - [in] pointer passed as third argument to compare.

  Returns:
    true if successful
  */
  bool Sort( 
    ON::sort_algorithm sort_algorithm,
    int*, // index[] 
    int (*)(const T*,const T*,void*), // int compare(const T*,const T*,void* p)
    void* // p
    ) const; 

  //////////
  // Permutes the array so that output[i] = input[index[i]].
  // The index[] array should be a permutation of (0,...,Count()-1).
  bool Permute( const int* /*index[]*/ );

  //////////
  // Destroys all elements and fills them with values
  // set by the defualt constructor.
  // Count and capacity are not changed.
  void Zero();

  // memory managment /////////////////////////////////////////////////

  void Reserve( int ); // increase capacity to at least the requested value

  void Shrink();       // remove unused capacity

  void Destroy();      // onfree any memory and set count and capacity to zero
    
  // low level memory managment ///////////////////////////////////////

  // By default, ON_ClassArray<> uses onrealloc() to manage
  // the dynamic array memory. If you want to use something 
  // besides onrealloc() to manage the array memory, then override 
  // Realloc(). The T* Realloc(ptr, capacity) should do the following:
  //
  // 1) If ptr and capacity are zero, return NULL.
  // 2) If ptr is NULL, an capacity > 0, allocate a memory block of 
  //    capacity*sizeof(T) bytes and return a pointer to this block.
  //    If the allocation request fails, return NULL.
  // 3) If ptr is not NULL and capacity is 0, free the memory block
  //    pointed to by ptr and return NULL.
  // 4) If ptr is not NULL and capacity > 0, then reallocate the memory
  //    block and return a pointer to the reallocated block.  If the 
  //    reallocation request fails, return NULL.
  //
  // NOTE WELL: 
  //    Microsoft's VC 6.0 realloc() contains a bug that can cause
  //    crashes and should be avoided. See MSDN Knowledge Base article
  //    ID Q225099 for more information.
  virtual
  T* Realloc(T*,int); // (re)allocated capacity*sizeof(T) bytes

  T* Array();                         // The Array() function return the 
  
  const T* Array() const;             // m_a pointer value.

  void SetCount( int );               // If value is <= Capacity(), then
                                      // sets count to specified value.

  void SetCapacity( int );            // Shrink/grows capacity.  If value
                                      // is < current Count(), then count
                                      // is reduced to value.

  int NewCapacity() const;            // When the dynamic array needs to grow,
                                      // this calculates the new value for m_capacity.

  T* KeepArray();                     // returns pointer to array and zeros
                                      // out this class.  Caller is responsible
                                      // for calling destructor on each element
                                      // and then using onfree() to release array
                                      // memory.  E.g.,
                                      //
                                      //   for (int i=capacity;i>=0;i--) {
                                      //     array[i].~T();
                                      //   }
                                      //   onfree(array);

  /*
  Description:
    Do not use this version of SetArray().  Use the one that takes
    a pointer, count and capacity: SetArray(pointer,count,capacity)
  */
  void SetArray(T*);

  /*
  Description:
    Expert user tool to set the memory used by the dyanmic array.
  Parameters:
    T* pointer - [in]
    int count - [in]  0 <= count <= capacity
    int capacity - [in]
       m_a is set to pointer, m_count is set to count, and m_capacity
       is set to capacity.  It is critical that the pointer be one 
       returned by onmalloc(sz), where sz >= capacity*sizeof(T[0]),
       and that the in-place operator new has been used to initialize
       each element of the array.  
  */
  void SetArray(T*, int, int);

protected:
  // implimentation //////////////////////////////////////////////////////
  void Move( int /* dest index*/, int /* src index */, int /* element count*/ );
  void ConstructDefaultElement(T*);
  void DestroyElement(T&);
	T*   m_a;        // pointer to array memory
	int  m_count;    // 0 <= m_count <= m_capacity
	int  m_capacity; // actual length of m_a[]
};


/*
Description:
  ON_Object array is used to store lists of classes that are
  derived from ON_Object.  It differs from ON_ClassArray in
  that the virtual ON_Object::MemoryRelocate function is called
  when growing the dynamic array requires changing the location
  of the memory buffer used to store the elements in the array.
*/
template <class T> class ON_ObjectArray : public ON_ClassArray<T>
{
public:
  ON_ObjectArray(); 
  ~ON_ObjectArray(); // override for struct member deallocation, etc.
  ON_ObjectArray( int ); // int = initial capacity
  ON_ObjectArray( const ON_ObjectArray<T>& );
  ON_ObjectArray<T>& operator=( const ON_ObjectArray<T>& );

  ON__UINT32 DataCRC(ON__UINT32 current_remainder) const;

  // virtual ON_ClassArray<T> override that 
  // calls MemoryRelocate on each element after
  // the reallocation.
  T* Realloc(T*,int);

  // virtual ON_ClassArray<T> override that 
  // calls MemoryRelocate on each element after
  // the heap sort.
  // QuickSort() is generally the better choice.
  bool HeapSort( int (*)(const T*,const T*) );

  // virtual ON_ClassArray<T> override that 
  // calls MemoryRelocate on each element after
  // the quick sort.
  bool QuickSort( int (*)(const T*,const T*) );
};

class ON_CLASS ON_UuidPair
{
public:
  /*
  Description:
    Compares m_uuid[0] and ignores m_uuid[1]
  */
  static 
  int CompareFirstUuid(const class ON_UuidPair*,const class ON_UuidPair*);

  /*
  Description:
    Compares m_uuid[1] and ignores m_uuid[0]
  */
  static 
  int CompareSecondUuid(const class ON_UuidPair*,const class ON_UuidPair*);

  /*
  Description:
    Compares m_uuid[0] then m_uuid[1].
  */
  static 
  int Compare(const class ON_UuidPair*,const class ON_UuidPair*);

  ON_UuidPair();
  ON_UUID m_uuid[2];
};

#if defined(ON_DLL_TEMPLATE)

// This stuff is here because of a limitation in the way Microsoft
// handles templates and DLLs.  See Microsoft's knowledge base 
// article ID Q168958 for details.
#pragma warning( push )
#pragma warning( disable : 4231 )
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_UUID>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_UuidIndex>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_DisplayMaterialRef>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_LinetypeSegment>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_UuidPair>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_PlaneEquation>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ON_SimpleArray<int> >;
#pragma warning( pop )

#endif


/*
Description:
  The ON_UuidList class provides a tool to efficiently 
  maintain a list of uuids and determine if a uuid is 
  in the list. This class is based on the premise that 
  there are no duplicate uuids in the list.
*/
class ON_CLASS ON_UuidList : private ON_SimpleArray<ON_UUID>
{
public:
  ON_UuidList();
  ON_UuidList(int capacity);
  ~ON_UuidList();
  ON_UuidList(const ON_UuidList& src);
  ON_UuidList& operator=(const ON_UuidList& src);

  /*
  Description:
    Fast uuid compare.  Not necessarily the same
    as ON_UuidCompare().
  */
  static
  int CompareUuid( const ON_UUID* a, const ON_UUID* b );

  /*
  Returns:
    Number of active uuids in the list.
  */
  int Count() const;

  /*
  Returns:
    Array of uuids in the list.  Sorted with
    respect to ON_UuidList::CompareUuid().
  Remarks:
    Calling AddUuid() may grow the dynamic array
    and make the pointer invalid.
  */
  const ON_UUID* Array() const;

  /*
  Description:
    Provides an efficient way to empty a list so that it
    can be used again.
  */
  void Empty();

  /*
  Description:
    Destroy list.  If list will be reused, Empty() is more
    efficient.
  */
  void Destroy();

  void Reserve(int capacity);

  /*
  Description:
    Makes the uuid list as efficent as possible in both search
    speed and memory usage.  Use Compact() when a uuid list
    will be in use but is not likely to be modifed.  A list 
    that has been compacted can still be modified.
  */
  void Compact();

  /*
  Description:
    Adds a uuid to the list.
  Parameters:
    uuid - [in] id to add.
    bCheckForDupicates - [in] if true, then the uuid
       is not added if it is already in the list.
       If you are certain that the uuid is not in the
       list and you are going to have a large list of uuids,
       then setting bCheckForDupicates=false will
       speed up the addition of uuids.
  Returns:
    True if uuid was added.  False if uuid was not added
    because it is already in the collection.
  */
  bool AddUuid(ON_UUID uuid, bool bCheckForDupicates=true);

  /*
  Description:
    Removes a uuid from the list.
  Parameters:
    uuid - [in] id to remove
  Returns:
    True if uuid was in the list and was removed.
    False if uuid was not in the list.
  */
  bool RemoveUuid(ON_UUID uuid);

  /*
  Description:
    Determine if a uuid is in the list.
  Returns:
    True if uuid is in the list.
  */
  bool FindUuid(ON_UUID uuid) const;

  /*
  Description:
    Saves the uuid list in an archive.
  Parameters:
    archive - [in] archive to write to.
  Returns:
    true if write was successful.
  */
  bool Write( 
    class ON_BinaryArchive& archive 
    ) const;

  /*
  Description:
    Read the uuid list from an archive.
  Parameters:
    archive - [in] archive to read from.
  Returns:
    true if the read was successful.
  */
  bool Read( 
    class ON_BinaryArchive& archive 
    );

  /*
  Description:
    Append the uuids in this class to uuid_list.
  Parameters:
    uuid_list - [in/out]
  Returns:
    Number of uuids added to uuid_list.
  */
  int GetUuids(
     ON_SimpleArray<ON_UUID>& uuid_list
     ) const;

  /*
  Description:
    This tool is used in rare situations when the object ids 
    stored in the uuid list need to be remapped.
  Parameters:
    uuid_remap - [in]
      Is it critical that uuid_remap[] be sorted with respect
      to ON_UuidPair::CompareFirstUuid.
  */
  void RemapUuids( 
    const ON_SimpleArray<ON_UuidPair>& uuid_remap 
    );

private:
  void SortHelper();
  ON_UUID* SearchHelper(const ON_UUID*) const;
  int m_sorted_count;
  int m_removed_count;
};

/*
Description:
  The ON_UuidList class provides a tool
  to efficiently maintain a list of uuid-index
  pairs and determine if a uuid is in the list.
  This class is based on the premise that there are
  no duplicate uuids in the list.
*/
class ON_CLASS ON_UuidIndexList : private ON_SimpleArray<ON_UuidIndex>
{
public:
  ON_UuidIndexList();
  ON_UuidIndexList(int capacity);
  ~ON_UuidIndexList();
  ON_UuidIndexList(const ON_UuidIndexList& src);
  ON_UuidIndexList& operator=(const ON_UuidIndexList& src);

  /*
  Returns:
    Number of active uuids in the list.
  */
  int Count() const;

  /*
  Description:
    Provides an efficient way to empty a list so that it
    can be used again.
  */
  void Empty();

  void Reserve( int capacity );

  /*
  Description:
    Adds a uuid-index pair to the list.
  Parameters:
    uuid - [in] id to add.  
      This uuid cannot be ON_max_uuid because ON_max_uuid
      is 
    bCheckForDupicates - [in] if true, then the uuid
       is not added if it is already in the list.
       If you are certain that the uuid is not in the list
       and you have a have a large collection of uuids,
       then setting bCheckForDupicates=false will
       speed up the addition of uuids.
  Returns:
    True if uuid was added.  False if uuid was not added
    because it is already in the collection.
  */
  bool AddUuidIndex(
    ON_UUID uuid, 
    int index, 
    bool bCheckForDupicates=true);

  /*
  Description:
    Removes an element with a matching uuid from the list.
  Parameters:
    uuid - [in] id to remove
  Returns:
    True if an element was removed.  False if the uuid
    was not in the list.
  */
  bool RemoveUuid(
    ON_UUID uuid
    );

  /*
  Description:
    Determine if an element with a uuid is in the list.
  Parameters:
    index - [out] if not NULL and a matching uuid is found,
       then *index is set to the value of the index.
  Returns:
    True if an element was found.  Returns false if
    the uuid is not in the list.
  */
  bool FindUuid(ON_UUID uuid, int* index=NULL) const;

  /*
  Description:
    Determine if a uuid-index pair is in the list.
  Returns:
    True if the uuid-index pair is in the list.
    Returns false if the uuid-index pair is not
    in the list.
  */
  bool FindUuidIndex(ON_UUID uuid, int index) const;

  /*
  Description:
    Append the uuids in this class to uuid_list.
  Parameters:
    uuid_list - [in/out]
  Returns:
    Number of uuids added to uuid_list.
  */
  int GetUuids(
     ON_SimpleArray<ON_UUID>& uuid_list
     ) const;

  /*
  Description:
    If you will perform lots of searches before the next
    change to the list, then calling ImproveSearchSpeed()
    will speed up the searches by culling removed objects
    and completely sorting the list so only a binary search
    is required. You may edit the list at any time after 
    calling ImproveSearchSpeed().  If you are performing 
    a few searches between edits, then excessive calling
    of ImproveSearchSpeed() may actually decrease overall
    program performance.
  */
  void ImproveSearchSpeed();

private:
  ON_UuidIndex* SearchHelper(const ON_UUID*) const;
  unsigned int m_sorted_count;
  unsigned int m_removed_count;
};

/*
Description:
  The ON_UuidPairList class provides a tool
  to efficiently maintain a list of uuid pairs 
  and determine if a uuid is in the list.
  This class is based on the premise that there are
  no duplicate uuids in the list.
*/
class ON_CLASS ON_UuidPairList : private ON_SimpleArray<ON_UuidPair>
{
public:
  ON_UuidPairList();
  ON_UuidPairList(int capacity);
  ~ON_UuidPairList();
  ON_UuidPairList(const ON_UuidPairList& src);
  ON_UuidPairList& operator=(const ON_UuidPairList& src);

  /*
  Returns:
    Number of active uuids in the list.
  */
  int Count() const;

  /*
  Description:
    Provides an efficient way to empty a list so that it
    can be used again.
  */
  void Empty();

  void Reserve( int capacity );

  /*
  Description:
    Adds a uuid-index pair to the list.
  Parameters:
    id1 - [in] id to add.
    id2 - [in] id to add.
    bCheckForDupicates - [in] if true, then the pair
       is not added if id1 is already in the list.
       If you are certain that the id1 is not in the list
       and you have a have a large collection of uuids,
       then setting bCheckForDupicates=false will
       speed up the addition of uuids.
  Returns:
    True if the pair was added.  False if the pair was not added
    because it is already in the collection.
  Remarks:
    You cannot add the pair value ( ON_max_uuid, ON_max_uuid ). This
    pair value is used to mark removed elements in the ON_UuidPairList[].
  */
  bool AddPair(
    ON_UUID id1, 
    ON_UUID id2, 
    bool bCheckForDupicates=true
    );

  /*
  Description:
    Removes an element with a matching id1 from the list.
  Parameters:
    id1 - [in] id to remove
  Returns:
    True if an element was removed.  False if the id1
    was not in the list.
  */
  bool RemovePair(
    ON_UUID id1
    );

  /*
  Description:
    Removes an element with a matching id pair from the list.
  Parameters:
    id1 - [in]
    id2 - [in]
  Returns:
    True if an element was removed.  False if the id pair
    does not appear in the list.
  */
  bool RemovePair(
    ON_UUID id1,
    ON_UUID id2
    );

  /*
  Description:
    Determine if an element with a uuid is in the list.
  Parameters:
    id1 - [in]
    id2 - [out] if not NULL and a matching id1 is found,
       then *id2 is set to the value of the second uuid.
  Returns:
    True if an element was found.  Returns false if
    the id1 is not in the list.
  */
  bool FindId1(ON_UUID id1, ON_UUID* id2=0) const;

  /*
  Description:
    Determine if an id pair is in the list.
  Returns:
    True if the id pair is in the list.
    False if the id pair is not in the list.
  */
  bool FindPair(ON_UUID id1, ON_UUID id2) const;

  /*
  Description:
    Append the value of the first id in each pair to uuid_list[].
  Parameters:
    uuid_list - [in/out]
  Returns:
    Number of ids appended to uuid_list[].
  */
  int GetId1s(
     ON_SimpleArray<ON_UUID>& uuid_list
     ) const;

  /*
  Description:
    If you will perform lots of searches before the next
    change to the list, then calling ImproveSearchSpeed()
    will speed up the searches by culling removed objects
    and completely sorting the list so only a binary search
    is required. You may edit the list at any time after 
    calling ImproveSearchSpeed().  If you are performing 
    a few searches between edits, then excessive calling
    of ImproveSearchSpeed() may actually decrease overall
    program performance.
  */
  void ImproveSearchSpeed();

private:
  ON_UuidPair* SearchHelper(const ON_UUID*) const;
  unsigned int m_sorted_count;
  unsigned int m_removed_count;
};

class ON_CLASS ON_2dexMap : private ON_SimpleArray<ON_2dex>
{
public:
  ON_2dexMap();
  ON_2dexMap(int capacity);
  ~ON_2dexMap();

  int Count() const;

  void Reserve(int capacity);

  const ON_2dex* Array() const;

  ON_2dex operator[](int i) const;

  /*
  Description:
    Creates an index map with the values
    (i0,j),...,(i0+count-1,j)
  Parameters:
    count - [in]
       number of elements
    i0 - [in]
       i value of first element
    j - [in]
       j value for all elements
  */
  void Create(int count, int i0, int j);

  /*
  Description:
    Searches for an element with a matching i
    and returns its j value.  If no matching
    element is found, then not_found_rc is returned. 
  Parameters:
    i - [in]
       value of i to search for
    not_found_rc - [in]
       value to return if there is not a match.
  Returns:
    j value
  */
  int FindIndex( 
          int i, 
          int not_found_rc
          ) const;

  /*
  Description:
    Adds and element (i,j).  If there is already an entry with
    value (i,*), then no element is added.
  Parameters:
    i - [in]
    i - [in]
  Returns:
    True if and element it added.
  */
  bool AddIndex( 
          int i, 
          int j
          );

  /*
  Description:
    Searches for an element (i,*) and sets its j value to j.
    If there is no element with a matching i, then false
    is returned.
  Parameters:
    i - [in]
    j - [in]
  Returns:
    True if and element exists and was set.
  */
  bool SetIndex( 
          int i, 
          int j
          );

  /*
  Description:
    If an element (i,*) exists, its j value is set.  Otherwise
    a new element with value (i,j) is added.
  Parameters:
    i - [in]
    j - [in]
  */
  void SetOrAddIndex( 
          int i, 
          int j
          );

  /*
  Description:
    If an element (i,*) exists, it is removed.  If there is
    not an element with a matching i value, then false
    is returned.
  Parameters:
    i - [in]
  Returns:
    True if the element was removed
  */
  bool RemoveIndex( 
          int i
          );

  const ON_2dex* Find2dex(int i) const;

private:
  bool m_bSorted;
};

/* 
Description:
	Compare function for Sort and Search methods.
Returns:
   -1 if *a < *b is true
    1 if *b < *a is true
    0 if niether *a <*b nor *b<*a is true 
Details:
	Use this template functions to sort ON_SimpleArray and
  ON_ClassArray objects into increasing order.  The elements
  of the arrays must be a type with an operator < defined.
	In particular it works with built in types like double, 
  int and pointers.
Example:

          ON_SimpleArray<int> A;
          A = ...;
          // Sort A in increasing order
          A.QuickSort( ON_CompareIncreasing<double> );		

See Also:
  ON_CompareDecreasing
*/
template< class T>
static
int ON_CompareIncreasing( const T* a, const T* b);

/* 
Description:
	Compare function for Sort and Search methods.
Returns:
   -1 if *b < *a is true
    1 if *a < *b is true
    0 if niether *a < *b nor *b < *a is true 
Details:
	Use this template functions to sort ON_SimpleArray and
  ON_ClassArray objects into decreasing order.  The elements
  of the arrays must be a type with an operator < defined.
	In particular it works with built in types like double, 
  int and pointers.
Example:

          class C
          {
          public:
            ...
            bool operator<(const C&) const;
          };
          ...
          ON_ClassArray<C> A;
          A = ...;
          // Sort A in descrasing order
          A.QuickSort( ON_CompareDecreasing<C> );		

See Also:
  ON_CompareIncreasing
*/
template< class T>
static
int ON_CompareDecreasing( const T* a, const T* b);


// definitions of the template functions are in a different file
// so that Microsoft's developer studio's autocomplete utility
// will work on the template functions.
#include "opennurbs_array_defs.h"


#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(ON_BASE32_INC_)
#define ON_BASE32_INC_


/*
Description:
  Convert a number into base32 digits.
Parameters:
  x - [in]
  x_count - [in]
    x[] is an array of length x_count and represents the value
    x[0]*2^(8*(x_count-1)) + ... + x[x_count-2]*256 + x[x_count-1].
  base32_digits - [out]
    When base32_digits is not a dynamic array, base32_digits[] 
    must a be an array of length at least
    ((8*x_count)/5) + (((8*x_count)%5)?1:0) or 1, 
    whichever is greater.

    The base32_digits[] array will be filled in with base32 digit 
    values (0 to 31) so that the value
    b[0]*32^(b_count-1) + ... + b[b_count-2]*32 + b[b_count-1]
    is the same as that defined by the x[] array.
Returns
  The number of base 32 digits in the base32_digits[] array.
  If 0 is returned, the input is not valid.
*/
ON_DECL
int ON_GetBase32Digits( const ON_SimpleArray<unsigned char>& x, ON_SimpleArray<unsigned char>& base32_digits );
ON_DECL
int ON_GetBase32Digits( const unsigned char* x, int x_count, unsigned char* base32_digits );


/*
Description:
  Convert a list of base32 digits into a string form.
Parameters:
  base32_digits - [in]
  base32_digit_count - [in]
    base32_digits[] is an array of length base32_digit_count. 
    Each element is in the range 0 to 31.
  sBase32 - [out]
    sBase32[] must be an array of length base32_digit_count+1 or 2,
    whichever is greater. The string representation of the base 32
    number will be put in this string. A hash mark symbol (#) is
    used to indicate an error in the input value.  The returned
    string is null terminated.
Returns
  True if the input is valid.  False if the input is not valid,
  in which case hash marks indicate the invalid entries.
*/
ON_DECL
bool ON_Base32ToString( const ON_SimpleArray<unsigned char>& base32_digits, ON_String& sBase32 );
ON_DECL
bool ON_Base32ToString( const ON_SimpleArray<unsigned char>& base32_digits, ON_wString& sBase32 );
ON_DECL
bool ON_Base32ToString( const unsigned char* base32_digits, int base32_digit_count, char* sBase32 );


/*
Description:
  Fixt a common typos in sBase32 string.  Lower case letters are
  converted to upper case. The letters 'I', 'L', 'O' and 'S' are
  converted to '1' (one), '1' (one) '0' zero and '5' (five).
Parameters:
  sBase32 - [in]
  sBase32clean - [out]
    (can be the same string as sBase32)
Returns:
  If the input is valid, the length of the converted string is returned.
  If the input is not valid, 0 is returned.
*/
ON_DECL
int ON_CorrectBase32StringTypos( const wchar_t* sBase32, ON_wString& sBase32clean );
ON_DECL
int ON_CorrectBase32StringTypos( const char* sBase32, ON_String& sBase32clean );
ON_DECL
int ON_CorrectBase32StringTypos( const char* sBase32, char* sBase32clean );


/*
Description:
  Convert a null terminate string containing the 32 symbols 

  0 1 2 3 4 5 6 7 8 9 A B C D E F G H J K M N P Q R T U V W X Y Z

  (I,L,O and S are missing) into a list of base 32 digits.
Parameters:
  sBase32 - [in]
    String with base 32 digits
  base32_digits - [out]
    base32_digits[] is an array of length strlen(sBase32). 
    The returned array, element will be in the range 0 to 31.
    sBase32[] must be an array of length base32_digit_count+1 or 2,
    whichever is greater. The string representation of the base 32
    number will be put in this string. A hash mark symbol (#) is
    used to indicate an error in the input value.  The returned
    string is null terminated.
Returns
  True if the input is valid.  False if the input is not valid,
  in which case hash marks indicate the invalid entries.
*/
ON_DECL
int ON_StringToBase32(const ON_wString& sBase32, ON_SimpleArray<unsigned char>& base32_digits );
ON_DECL
int ON_StringToBase32(const ON_String& sBase32, ON_SimpleArray<unsigned char>& base32_digits );
ON_DECL
int ON_StringToBase32(const char* sBase32, unsigned char* base32_digits );


#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_PLUGINLIST_INC_)
#define OPENNURBS_PLUGINLIST_INC_

/*
Description:
  The ON_PluginRef class is used to store a list of
  application plug-ins that may have saved user data
  in a 3dm file so they can be loaded as needed for
  reading their user data.
*/
class ON_CLASS ON_PlugInRef
{
public:
  ON_PlugInRef();

  // executable informtion
  ON_UUID m_plugin_id;
  int m_plugin_type; // CRhinoPlugIn::plugin_type enum value
  int m_plugin_platform; // 0 = unknown, 1 = C++, 2 = .NET
  int m_plugin_sdk_version;
  int m_plugin_sdk_service_release;
  ON_wString m_plugin_name;
  ON_wString m_plugin_version;
  ON_wString m_plugin_filename; // name of executable file

  // developer contact information
  ON_wString m_developer_organization;
  ON_wString m_developer_address;
  ON_wString m_developer_country;
  ON_wString m_developer_phone;
  ON_wString m_developer_email;
  ON_wString m_developer_website;
  ON_wString m_developer_updateurl;
  ON_wString m_developer_fax;

  void Default();

  bool Write( ON_BinaryArchive& file ) const;
  bool Read( ON_BinaryArchive& file );

  void Dump(ON_TextLog& text_log) const;
};


#if defined(ON_DLL_TEMPLATE)

// This stuff is here because of a limitation in the way Microsoft
// handles templates and DLLs.  See Microsoft's knowledge base 
// article ID Q168958 for details.
#pragma warning( push )
#pragma warning( disable : 4231 )
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ON_PlugInRef>;
#pragma warning( pop )
#endif

#endif

/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(ON_BOUNDING_BOX_INC_)
#define ON_BOUNDING_BOX_INC_

////////////////////////////////////////////////////////////////
//
//   ON_BoundingBox  - axis aligned bounding box
//

class ON_CLASS ON_BoundingBox
{
public:
  static const ON_BoundingBox EmptyBoundingBox; // ((1.0,0,0,0,0),(-1.0,0.0,0.0))

  ON_BoundingBox(); // creates EmptyBox

	ON_BoundingBox(
    const ON_3dPoint&, // min corner of axis aligned bounding box
    const ON_3dPoint&  // max corner of axis aligned bounding box
    );
  ~ON_BoundingBox();


  // temporary - use ON_ClippingRegion - this function will be removed soon.
  int IsVisible( 
    const ON_Xform& bbox2c
    ) const;

  void Destroy(); // invalidates bounding box

  // operator[] returns min if index <= 0 and max if indes >= 1
  ON_3dPoint& operator[](int);
  const ON_3dPoint& operator[](int) const;

  ON_3dPoint Min() const;
  ON_3dPoint Max() const;
  ON_3dVector Diagonal() const; // max corner - min corner
  ON_3dPoint Center() const;
  ON_3dPoint Corner( // 8 corners of box
    int, // x_index   0 = Min().x, 1 = Max().x
    int, // y_index   0 = Min().y, 1 = Max().y
    int  // z_index   0 = Min().z, 1 = Max().z
    ) const;
  bool GetCorners( 
    ON_3dPointArray& box_corners // returns list of 8 corner points
    ) const;
  bool GetCorners( 
    ON_3dPoint box_corners[8] // returns list of 8 corner points
    ) const;

  bool IsValid() const; // empty boxes are not valid
  
  void Dump(class ON_TextLog&) const;
  
  /*
  Description:
    Test a bounding box to see if it is degenerate (flat)
    in one or more directions.
  Parameters:
    tolerance - [in] Distances <= tolerance will be considered
        to be zero.  If tolerance is negative (default), then
        a scale invarient tolerance is used.
  Returns:
    @untitled table
    0     box is not degenerate
    1     box is a rectangle (degenerate in one direction)
    2     box is a line (degenerate in two directions)
    3     box is a point (degenerate in three directions)
    4     box is not valid
  */
  int IsDegenerate( 
    double tolerance = ON_UNSET_VALUE
    ) const;


  //////////
  // ON_BoundingBox::Transform() updates the bounding box
  // to be the smallest axis aligned bounding box that contains
  // the transform of the eight corner points of the input
  // bounding box.
  bool Transform( const ON_Xform& );

  double Tolerance() const; // rough guess at a tolerance to use for comparing
                            // objects in this bounding box


  // All of these Set() functions set or expand a box to enclose the points in the arguments
  // If bGrowBox is true, the existing box is expanded, otherwise it is only set to the current point list
  bool Set(     
    int dim,
    int is_rat,
    int count,
    int stride,
    const double* point_array,
    int bGrowBox = false
    );

  bool Set(
    const ON_3dPoint& point,
    int bGrowBox = false
    );

  bool Set(     
    const ON_SimpleArray<ON_4dPoint>& point_array,
    int bGrowBox = false
    );

  bool Set(     
    const ON_SimpleArray<ON_3dPoint>& point_array,
    int bGrowBox = false
    );

  bool Set(     
    const ON_SimpleArray<ON_2dPoint>& point_array,
    int bGrowBox = false
    );

	bool IsPointIn(
         const ON_3dPoint& test_point, // point to test
         int bStrictlyIn = false 
                   // true to test for strict ( min < point < max )
                   // false to test for (min <= point <= max)
                   //       
         ) const;

  //////////
  // Point on or in the box that is closest to test_point.
  // If test_point is in or on the box, the test_point is returned.
  ON_3dPoint ClosestPoint( 
    const ON_3dPoint& test_point
    ) const;


  /*
  Description:
    Quickly find a lower bound on the distance 
    between the point and this bounding box.
  Parameters:
    P - [in]
  Returns:
    A distance that is less than or equal to the shortest
    distance from the line to this bounding box.
    Put another way, if Q is any point in this bounding box,
    then P.DistanceTo(Q) >= MinimumDistanceTo(bbox).
  */
  double MinimumDistanceTo( const ON_3dPoint& P ) const;

  /*
  Description:
    Quickly find an upper bound on the distance 
    between the point and this bounding box.
  Parameters:
    P - [in]
  Returns:
    A distance that is greater than or equal to the 
    longest distance from the point P to this bounding box.
    Put another way, if Q is any point in this bounding box,
    then P.DistanceTo(Q) <= MaximumDistanceTo(bbox).
  */
  double MaximumDistanceTo( const ON_3dPoint& P ) const;


  /*
  Description:
    Quickly find a lower bound on the distance 
    between this and the other bounding box.
  Parameters:
    other - [in]
  Returns:
    A distance that is less than or equal to the shortest
    distance between the bounding boxes.
    Put another way, if Q is any point in this bounding box
    and P is any point in the other bounding box,
    then P.DistanceTo(Q) >= MinimumDistanceTo(bbox).
  */
  double MinimumDistanceTo( const ON_BoundingBox& other ) const;

  /*
  Description:
    Quickly find an upper bound on the distance 
    between this and the other bounding box.
  Parameters:
    other - [in]
  Returns:
    A distance that is greater than or equal to the longest
    distance between the bounding boxes.
    Put another way, if Q is any point in this bounding box
    and P is any point in the other bounding box,
    then P.DistanceTo(Q) <= MaximumDistanceTo(bbox).
  */
  double MaximumDistanceTo( const ON_BoundingBox& other ) const;

  /*
  Description:
    Quickly find a lower bound on the distance 
    between the line segment and this bounding box.
  Parameters:
    line - [in]
  Returns:
    A distance that is less than or equal to the shortest
    distance from the line to this bounding box.
    Put another way, if Q is any point on line
    and P is any point in this bounding box, then
    P.DistanceTo(Q) >= MinimumDistanceTo(bbox).
  */
  double MinimumDistanceTo( const ON_Line& line ) const;

  /*
  Description:
    Quickly find a tight lower bound on the distance 
    between the plane and this bounding box.
  Parameters:
    plane - [in]
  Returns:
    The minimum distance between a point on the plane
    and a point on the bounding box.
  See Also:
    ON_PlaneEquation::MimimumValueAt
    ON_PlaneEquation::MaximumValueAt
  */
  double MinimumDistanceTo( const ON_Plane& plane ) const;
  double MinimumDistanceTo( const ON_PlaneEquation& plane_equation ) const;

  /*
  Description:
    Quickly find an upper bound on the distance 
    between the line segment and this bounding box.
  Parameters:
    line - [in]
  Returns:
    A distance that is greater than or equal to the 
    longest distance from the line to this bounding box.
    Put another way, if Q is any point on the line
    and P is any point in this bounding box, then
    P.DistanceTo(Q) <= MaximumDistanceTo(bbox).
  */
  double MaximumDistanceTo( const ON_Line& line ) const;

  /*
  Description:
    Quickly find a tight upper bound on the distance 
    between the plane and this bounding box.
  Parameters:
    plane - [in]
  Returns:
    A distance that is equal to the longest distance from
    the plane to this bounding box.  Put another way, 
    if Q is any point on the plane and P is any point 
    in this bounding box, then 
    P.DistanceTo(Q) <= MaximumDistanceTo(bbox) and there
    is at least one point on the bounding box where the
    distance is equal to the returned value.
  See Also:
    ON_PlaneEquation::MaximumValueAt
  */
  double MaximumDistanceTo( const ON_Plane& plane ) const;
  double MaximumDistanceTo( const ON_PlaneEquation& plane_equation ) const;


  /*
  Description:
    Quickly determine if the shortest distance from
    the point P to the bounding box is greater than d.
  Parameters:
    d - [in] distance (> 0.0)
    P - [in] 
  Returns:
    True if if the shortest distance from the point P
    to the bounding box is greater than d. 
  */
  bool IsFartherThan( double d, const ON_3dPoint& P ) const;

  /*
  Description:
    Quickly determine if the shortest distance from the line
    to the bounding box is greater than d.
  Parameters:
    d - [in] distance (> 0.0)
    line - [in] 
  Returns:
    True if the shortest distance from the line
    to the bounding box is greater than d. It is not the
    case that false means that the shortest distance
    is less than or equal to d.
  */
  bool IsFartherThan( double d, const ON_Line& line ) const;

  /*
  Description:
    Quickly determine if the shortest distance from the plane
    to the bounding box is greater than d.
  Parameters:
    d - [in] distance (> 0.0)
    plane - [in] 
  Returns:
    True if the shortest distance from the plane
    to the bounding box is greater than d, and false
    if the shortest distance is less than or equal to d.
  */
  bool IsFartherThan( double d, const ON_Plane& plane ) const;

  /*
  Description:
    Quickly determine if the shortest distance from the plane
    to the bounding box is greater than d.
  Parameters:
    d - [in] distance (> 0.0)
    plane_equation - [in] (the first three coefficients 
                           are assumed to be a unit vector.
                           If not, adjust your d accordingly.)
  Returns:
    True if the shortest distance from the plane
    to the bounding box is greater than d, and false
    if the shortest distance is less than or equal to d.
  */
  bool IsFartherThan( double d, const ON_PlaneEquation& plane_equation ) const;

  /*
  Description:
    Quickly determine if the shortest distance this bounding
    box to another bounding box is greater than d.
  Parameters:
    d - [in] distance (> 0.0)
    other - [in] other bounding box
  Returns:
    True if if the shortest distance from this bounding
    box to the other bounding box is greater than d. 
  */
  bool IsFartherThan( double d, const ON_BoundingBox& other ) const;


  // Description:
  //   Get point in a bounding box that is closest to a line
  //   segment.
  // Parameters:
  //   line - [in] line segment
  //   box_point - [out] point in box that is closest to line
  //       segment point at t0.
  //   t0 - [out] parameter of point on line that is closest to
  //       the box.
  //   t1 - [out] parameter of point on line that is closest to
  //       the box.
  // Returns:
  //   3 success - line segments intersects box in a segment
  //               from line(t0) to line(t1) (t0 < t1)
  //   2 success - line segments intersects box in a single point
  //               at line(t0) (t0==t1)
  //   1 success - line segment does not intersect box.  Closest
  //               point on the line is at line(t0) (t0==t1)
  //   0 failure - box is invalid.
  // Remarks:
  //   The box is treated as a solid box.  If the intersection
  //   of the line segment, then 3 is returned.
  int GetClosestPoint( 
    const ON_Line&, // line
    ON_3dPoint&,    // box_point
    double*,        // t0
    double*         // t1
    ) const;

  //////////
  // Get points on bounding boxes that are closest to each other.
  // If the boxes intersect, then the point at the centroid of the
  // intersection is returned for both points.
  bool GetClosestPoint( 
         const ON_BoundingBox&, // "other" bounding box
         ON_3dPoint&, // point on "this" box that is closest to "other" box
         ON_3dPoint&  // point on "other" box that is closest to "this" box
         )  const;

  //////////
  // Point on the box that is farthest from the test_point.
  ON_3dPoint FarPoint( 
    const ON_3dPoint& // test_point
    ) const;

  //////////
  // Get points on bounding boxes that are farthest from each other.
  bool GetFarPoint( 
         const ON_BoundingBox&, // "other" bounding box
         ON_3dPoint&, // point on "this" box that is farthest from "other" box
         ON_3dPoint&  // point on "other" box that is farthest from "this" box
         )  const;

  /* 
  Description:
    Intersect this with other_bbox and save intersection in this.
  Parameters:
    other_bbox - [in]
  Returns:
    True if this-intesect-other_bbox is a non-empty valid bounding box
    and this is set.  False if the intersection is empty, in which case
    "this" is set to an invalid bounding box.
  Remarks:
    If "this" or other_bbox is invalid, they are treated as
    the empty set, and false is returned.
  */
  bool Intersection(
         const ON_BoundingBox& other_bbox
         );

  /* 
  Description:
    Set "this" to the intersection of bbox_A and bbox_B.
  Parameters:
    bbox_A - [in] 
    bbox_B - [in]
  Returns:
    True if the "this" is a non-empty valid bounding box.
    False if the intersection is empty, in which case
    "this" is set to an invalid bounding box.
  Remarks:
    If bbox_A or bbox_B is invalid, they are treated as
    the empty set, and false is returned.
  */
  bool Intersection( // this = intersection of two args
         const ON_BoundingBox& bbox_A, 
         const ON_BoundingBox& bbox_B
         );

	bool Intersection(				//Returns true when intersect is non-empty. 
				 const ON_Line&,		//Infinite Line segment to intersect with 
				 double* =NULL ,			// t0  parameter of first intersection point
				 double* =NULL       // t1  parameter of last intersection point (t0<=t1)   
				 ) const;			 

  /* 
  Description:
    Test a box to see if it is contained in this box.
  Parameters:
    other - [in] box to test
    bProperSubSet - [in] if true, then the test is for a proper inclusion.
  Returns:
    If bProperSubSet is false, then the result is true when
			this->m_min[i] <= other.m_min[i] and other.m_max[i] <= this->m_max[i].
			for i=0,1 and 2.
    If bProperSubSet is true, then the result is true when
			the above condition is true and at least one of the inequalities is strict.
  */
  bool Includes( 
    const ON_BoundingBox& other,
    bool bProperSubSet = false
    ) const;

	double Volume() const;

  double Area() const;

  // Union() returns true if union is not empty.
  // Invalid boxes are treated as the empty set.
  bool Union( // this = this union arg
         const ON_BoundingBox&
         );

  bool Union( // this = union of two args
         const ON_BoundingBox&, 
         const ON_BoundingBox&
         );
                  
  /* 
  Description:
    Test to see if "this" and other_bbox are disjoint (do not intersect).
  Parameters:
    other_bbox - [in]
  Returns:
    True if "this" and other_bbox are disjoint.
  Remarks:
    If "this" or other_bbox is invalid, then true is returned.
  */
  bool IsDisjoint(
    const ON_BoundingBox& other_bbox
    ) const;

  bool SwapCoordinates( int, int );

  ON_3dPoint m_min;
  ON_3dPoint m_max;
};

#if defined(ON_DLL_TEMPLATE)

// This stuff is here because of a limitation in the way Microsoft
// handles templates and DLLs.  See Microsoft's knowledge base 
// article ID Q168958 for details.
#pragma warning( push )
#pragma warning( disable : 4231 )
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_BoundingBox>;
#pragma warning( pop )

#endif

/*
Description:
  Get a tight bounding box that contains the points.
Parameters:
 dim - [in] (>=1)
 is_rat - [in] true if points are rational
 count - [in] number of points
 stride - [in] stride between points
 point_list - [in]
 bbox - [in/out]
 bGrowBox - [in] (default = false)
   If the input bbox is valid and bGrowBox is true,
   then the output bbox is the union of the input
   bbox and the bounding box of the point list.
 xform - [in] (default = NULL)
   If not null, the bounding box of the transformed
   points is calculated.  The points are not modified.
Returns:
  True if the output bbox is valid.
*/
ON_DECL
bool ON_GetPointListBoundingBox(
    int dim,
    int is_rat,
    int count,
    int stride,
    const double* point_list,
    ON_BoundingBox& bbox,
    int bGrowBox = false,
    const ON_Xform* xform = 0
    );

ON_DECL
bool ON_GetPointListBoundingBox(
    int dim,
    int is_rat,
    int count,
    int stride,
    const float* point_list,
    ON_BoundingBox& bbox,
    int bGrowBox = false,
    const ON_Xform* xform = 0
    );

ON_DECL
bool ON_GetPointListBoundingBox(
    int dim,
    int is_rat,
    int count,
    int stride,
    const double* point_list,
    double* boxmin,       // min[dim]
    double* boxmax,       // max[dim]
    int bGrowBox
    );

ON_DECL
ON_BoundingBox ON_PointListBoundingBox(
    int dim,
    int is_rat,
    int count,
    int stride,
    const double* point_list
    );

ON_DECL
bool ON_GetPointListBoundingBox(
    int dim,
    int is_rat,
    int count,
    int stride,
    const float* point_list,
    float* boxmin,       // min[dim]
    float* boxmax,       // max[dim]
    int bGrowBox
    );

ON_DECL
ON_BoundingBox ON_PointListBoundingBox( // low level workhorse function
    int dim,
    int is_rat,
    int count,
    int stride,
    const float* point_list
    );

ON_DECL
bool ON_GetPointGridBoundingBox(
        int dim,
        int is_rat,
        int point_count0, int point_count1,
        int point_stride0, int point_stride1,
        const double* point_grid,
        double* boxmin,       // min[dim]
        double* boxmax,       // max[dim]
        int bGrowBox
    );

ON_DECL
ON_BoundingBox ON_PointGridBoundingBox(
        int dim,
        int is_rat,
        int point_count0, int point_count1,
        int point_stride0, int point_stride1,
        const double* point_grid
    );

ON_DECL
double ON_BoundingBoxTolerance(
        int dim,
        const double* bboxmin,
        const double* bboxmax
        );

/*
Description:
  Determine if an object is too large or too far 
  from the origin for single precision coordinates
  to be useful.
Parameters:
  bbox - [in]
    Bounding box of an object with single precision
    coordinates.  An ON_Mesh is an example of an
    object with single precision coordinates.
  xform - [out]
    If this function returns false and xform is not
    null, then the identity transform is returned.
    If this function returns true and xform is not
    null, then the transform moves the region
    contained in bbox to a location where single 
    precision coordinates will have enough
    information for the object to be useful.
Returns:
  true:
    The region contained in bbox is too large
    or too far from the origin for single 
    precision coordinates to be useful.
  false:
    A single precision object contained in bbox
    will be satisfactory for common calculations.
*/
ON_DECL
bool ON_BeyondSinglePrecision( const ON_BoundingBox& bbox, ON_Xform* xform );

ON_DECL
bool ON_WorldBBoxIsInTightBBox( 
          const ON_BoundingBox& tight_bbox, 
          const ON_BoundingBox& world_bbox,
          const ON_Xform* xform
          );

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(ON_MATRIX_INC_)
#define ON_MATRIX_INC_

class ON_Xform;

class ON_CLASS ON_Matrix
{
public:
  ON_Matrix();
  ON_Matrix( 
    int row_count,
    int col_count
     );
  ON_Matrix( // see ON_Matrix::Create(int,int,int,int) for details
     int, // first valid row index
     int, // last valid row index
     int, // first valid column index
     int  // last valid column index
     );
  ON_Matrix( const ON_Xform& );
  ON_Matrix( const ON_Matrix& );

  /*
  Description:
    This constructor is for experts who have storage for a matrix
    and need to use it in ON_Matrix form.
  Parameters:
    row_count - [in]
    col_count - [in]
    M - [in]
    bDestructorFreeM - [in]
      If true, ~ON_Matrix will call onfree(M).
      If false, caller is managing M's memory.
  Remarks:
    ON_Matrix functions that increase the value of row_count or col_count
    will fail on a matrix created with this constructor.
  */
  ON_Matrix(
    int row_count,
    int col_count,
    double** M,
    bool bDestructorFreeM
    );

  virtual ~ON_Matrix();
  void EmergencyDestroy(); // call if memory pool used matrix by becomes invalid

  // ON_Matrix[i][j] = value at row i and column j
  //           0 <= i < RowCount()
  //           0 <= j < ColCount()
  double* operator[](int);
  const double* operator[](int) const;

  ON_Matrix& operator=(const ON_Matrix&);
  ON_Matrix& operator=(const ON_Xform&);

  bool IsValid() const;
  int IsSquare() const; // returns 0 for no and m_row_count (= m_col_count) for yes
  int RowCount() const;
  int ColCount() const;
  int MinCount() const; // smallest of row and column count
  int MaxCount() const; // largest of row and column count

  void RowScale(int,double); 
  void ColScale(int,double);
  void RowOp(int,double,int);
  void ColOp(int,double,int);

  bool Create(
     int, // number of rows
     int  // number of columns
     );

  bool Create( // E.g., Create(1,5,1,7) creates a 5x7 sized matrix that with
               // "top" row = m[1][1],...,m[1][7] and "bottom" row
               // = m[5][1],...,m[5][7].  The result of Create(0,m,0,n) is
               // identical to the result of Create(m+1,n+1).
     int, // first valid row index
     int, // last valid row index
     int, // first valid column index
     int  // last valid column index
     );

  /*
  Description:
    This constructor is for experts who have storage for a matrix
    and need to use it in ON_Matrix form.
  Parameters:
    row_count - [in]
    col_count - [in]
    M - [in]
    bDestructorFreeM - [in]
      If true, ~ON_Matrix will call onfree(M).
      If false, caller is managing M's memory.
  Remarks:
    ON_Matrix functions that increase the value of row_count or col_count
    will fail on a matrix created with this constructor.
  */
  bool Create(
    int row_count,
    int col_count,
    double** M,
    bool bDestructorFreeM
    );


  void Destroy();

  void Zero();

  void SetDiagonal(double); // sets diagonal value and zeros off diagonal values
  void SetDiagonal(const double*); // sets diagonal values and zeros off diagonal values
  void SetDiagonal(int, const double*); // sets size to count x count and diagonal values and zeros off diagonal values
  void SetDiagonal(const ON_SimpleArray<double>&); // sets size to length X lengthdiagonal values and zeros off diagonal values

  bool Transpose();

  bool SwapRows( int, int ); // ints are row indices to swap
  bool SwapCols( int, int ); // ints are col indices to swap
  bool Invert( 
          double // zero tolerance
          );

  /*
  Description:
    Set this = A*B.
  Parameters:
    A - [in]
      (Can be this)
    B - [in]
      (Can be this)
  Returns:
    True when A is an mXk matrix and B is a k X n matrix; in which case
    "this" will be an mXn matrix = A*B.
    False when A.ColCount() != B.RowCount().
  */
  bool Multiply( const ON_Matrix& A, const ON_Matrix& B );

  /*
  Description:
    Set this = A+B.
  Parameters:
    A - [in]
      (Can be this)
    B - [in]
      (Can be this)
  Returns:
    True when A and B are mXn matrices; in which case
    "this" will be an mXn matrix = A+B.
    False when A and B have different sizes.
  */
  bool Add( const ON_Matrix& A, const ON_Matrix& B );


  /*
  Description:
    Set this = s*this.
  Parameters:
    s - [in]
  Returns:
    True when A and s are valid.
  */
  bool Scale( double s );


  // Description:
  //   Row reduce a matrix to calculate rank and determinant.
  // Parameters:
  //   zero_tolerance - [in] (>=0.0) zero tolerance for pivot test
  //       If the absolute value of a pivot is <= zero_tolerance,
  //       then the pivot is assumed to be zero.
  //   determinant - [out] value of determinant is returned here.
  //   pivot - [out] value of the smallest pivot is returned here
  // Returns:
  //   Rank of the matrix.
  // Remarks:
  //   The matrix itself is row reduced so that the result is
  //   an upper triangular matrix with 1's on the diagonal.
  int RowReduce( // returns rank
    double,  // zero_tolerance
    double&, // determinant
    double&  // pivot
    ); 

  // Description:
  //   Row reduce a matrix as the first step in solving M*X=B where
  //   B is a column of values.
  // Parameters:
  //   zero_tolerance - [in] (>=0.0) zero tolerance for pivot test
  //       If the absolute value of a pivot is <= zero_tolerance,
  //       then the pivot is assumed to be zero.
  //   B - [in/out] an array of m_row_count values that is row reduced
  //       with the matrix.
  //   determinant - [out] value of determinant is returned here.
  //   pivot - [out] If not NULL, then the value of the smallest 
  //       pivot is returned here
  // Returns:
  //   Rank of the matrix.
  // Remarks:
  //   The matrix itself is row reduced so that the result is
  //   an upper triangular matrix with 1's on the diagonal.
  // Example:
  //   Solve M*X=B;
  //   double B[m] = ...;
  //   double B[n] = ...;
  //   ON_Matrix M(m,n) = ...;
  //   M.RowReduce(ON_ZERO_TOLERANCE,B); // modifies M and B
  //   M.BackSolve(m,B,X); // solution is in X
  // See Also: 
  //   ON_Matrix::BackSolve
  int RowReduce(
    double,        // zero_tolerance
    double*,       // B
    double* = NULL // pivot
    ); 

  // Description:
  //   Row reduce a matrix as the first step in solving M*X=B where
  //   B is a column of 3d points
  // Parameters:
  //   zero_tolerance - [in] (>=0.0) zero tolerance for pivot test
  //       If the absolute value of a pivot is <= zero_tolerance,
  //       then the pivot is assumed to be zero.
  //   B - [in/out] an array of m_row_count 3d points that is 
  //       row reduced with the matrix.
  //   determinant - [out] value of determinant is returned here.
  //   pivot - [out] If not NULL, then the value of the smallest 
  //       pivot is returned here
  // Returns:
  //   Rank of the matrix.
  // Remarks:
  //   The matrix itself is row reduced so that the result is
  //   an upper triangular matrix with 1's on the diagonal.
  // See Also: 
  //   ON_Matrix::BackSolve
  int RowReduce(
    double,        // zero_tolerance
    ON_3dPoint*,   // B
    double* = NULL // pivot
    ); 

  // Description:
  //   Row reduce a matrix as the first step in solving M*X=B where
  //   B is a column arbitrary dimension points.
  // Parameters:
  //   zero_tolerance - [in] (>=0.0) zero tolerance for pivot test
  //       If a the absolute value of a pivot is <= zero_tolerance,
  //       then the pivoit is assumed to be zero.
  //   pt_dim - [in] dimension of points
  //   pt_stride - [in] stride between points (>=pt_dim)
  //   pt - [in/out] array of m_row_count*pt_stride values.
  //        The i-th point is
  //        (pt[i*pt_stride],...,pt[i*pt_stride+pt_dim-1]).
  //        This array of points is row reduced along with the 
  //        matrix.
  //   pivot - [out] If not NULL, then the value of the smallest 
  //       pivot is returned here
  // Returns:
  //   Rank of the matrix.
  // Remarks:
  //   The matrix itself is row reduced so that the result is
  //   an upper triangular matrix with 1's on the diagonal.
  // See Also: 
  //   ON_Matrix::BackSolve
  int RowReduce( // returns rank
    double,      // zero_tolerance
    int,         // pt_dim
    int,         // pt_stride
    double*,     // pt
    double* = NULL // pivot
    ); 

  // Description:
  //   Solve M*X=B where M is upper triangular with a unit diagonal and
  //   B is a column of values.
  // Parameters:
  //   zero_tolerance - [in] (>=0.0) used to test for "zero" values in B
  //       in under determined systems of equations.
  //   Bsize - [in] (>=m_row_count) length of B.  The values in
  //       B[m_row_count],...,B[Bsize-1] are tested to make sure they are
  //       "zero".
  //   B - [in] array of length Bsize.
  //   X - [out] array of length m_col_count.  Solutions returned here.
  // Remarks:
  //   Actual values M[i][j] with i <= j are ignored. 
  //   M[i][i] is assumed to be one and M[i][j] i<j is assumed to be zero.
  //   For square M, B and X can point to the same memory.
  // See Also:
  //   ON_Matrix::RowReduce
  bool BackSolve(
    double,        // zero_tolerance
    int,           // Bsize
    const double*, // B
    double*        // X
      ) const;

  // Description:
  //   Solve M*X=B where M is upper triangular with a unit diagonal and
  //   B is a column of 3d points.
  // Parameters:
  //   zero_tolerance - [in] (>=0.0) used to test for "zero" values in B
  //       in under determined systems of equations.
  //   Bsize - [in] (>=m_row_count) length of B.  The values in
  //       B[m_row_count],...,B[Bsize-1] are tested to make sure they are
  //       "zero".
  //   B - [in] array of length Bsize.
  //   X - [out] array of length m_col_count.  Solutions returned here.
  // Remarks:
  //   Actual values M[i][j] with i <= j are ignored. 
  //   M[i][i] is assumed to be one and M[i][j] i<j is assumed to be zero.
  //   For square M, B and X can point to the same memory.
  // See Also:
  //   ON_Matrix::RowReduce
  bool BackSolve(
    double,            // zero_tolerance
    int,               // Bsize
    const ON_3dPoint*, // B
    ON_3dPoint*        // X
      ) const;

  // Description:
  //   Solve M*X=B where M is upper triangular with a unit diagonal and
  //   B is a column of points
  // Parameters:
  //   zero_tolerance - [in] (>=0.0) used to test for "zero" values in B
  //       in under determined systems of equations.
  //   pt_dim - [in] dimension of points
  //   Bsize - [in] (>=m_row_count) number of points in B[].  The points
  //       correspoinding to indices m_row_count, ..., (Bsize-1)
  //       are tested to make sure they are "zero".
  //   Bpt_stride - [in] stride between B points (>=pt_dim)
  //   Bpt - [in/out] array of m_row_count*Bpt_stride values.
  //        The i-th B point is
  //        (Bpt[i*Bpt_stride],...,Bpt[i*Bpt_stride+pt_dim-1]).
  //   Xpt_stride - [in] stride between X points (>=pt_dim)
  //   Xpt - [out] array of m_col_count*Xpt_stride values.
  //        The i-th X point is
  //        (Xpt[i*Xpt_stride],...,Xpt[i*Xpt_stride+pt_dim-1]).
  // Remarks:
  //   Actual values M[i][j] with i <= j are ignored. 
  //   M[i][i] is assumed to be one and M[i][j] i<j is assumed to be zero.
  //   For square M, B and X can point to the same memory.
  // See Also:
  //   ON_Matrix::RowReduce
  bool BackSolve(
    double,       // zero_tolerance
    int,          // pt_dim
    int,          // Bsize
    int,          // Bpt_stride
    const double*,// Bpt
    int,          // Xpt_stride
    double*       // Xpt
      ) const;

  bool IsRowOrthoganal() const;
  bool IsRowOrthoNormal() const;

  bool IsColOrthoganal() const;
  bool IsColOrthoNormal() const;


  double** m; // m[i][j] = value at row i and column j
              //           0 <= i < RowCount()
              //           0 <= j < ColCount()
private:
  int m_row_count;
  int m_col_count;
  // m_rowmem[i][j] = row i+m_row_offset and column j+m_col_offset.
  ON_SimpleArray<double*> m_rowmem; 
	double** m_Mmem; // used by Create(row_count,col_count,user_memory,true);
	int   m_row_offset; // = ri0 when sub-matrix constructor is used
	int   m_col_offset; // = ci0 when sub-matrix constructor is used
  void* m_cmem;
  // returns 0 based arrays, even in submatrix case.
  double const * const * ThisM() const;
  double * * ThisM();
};

/*
Description:
  Calculate the singular value decomposition of a matrix.

Parameters:
  row_count - [in]
    number of rows in matrix A
  col_count - [in]
    number of columns in matrix A
  A - [in]
    Matrix for which you want the singular value decomposition.
    A[0][0] = coefficeint in the first row and first column.
    A[row_count-1][col_count-1] = coefficeint in the last row
    and last column.
  U - [out]
    The singular value decomposition of A is U*Diag(W)*Transpose(V),
    where U has the same size as A, Diag(W) is a col_count X col_count
    diagonal matrix with (W[0],...,W[col_count-1]) on the diagonal
    and V is a col_count X col_count matrix.
    U and A may be the same pointer.  If the input value of U is
    null, heap storage will be allocated using onmalloc()
    and the calling function must call onfree(U).  If the input
    value of U is not null, U[i] must point to an array of col_count
    doubles.  
  W - [out]
    If the input value W is null, then heap storage will be allocated
    using onmalloc() and the calling function must call onfree(W).
    If the input value of W is not null, then W must point to
    an array of col_count doubles.
  V - [out]
    If the input value V is null, then heap storage will be allocated
    using onmalloc() and the calling function must call onfree(V).
    If the input value of V is not null, then V[i] must point
    to an array of col_count doubles.

Example:

          int m = row_count;
          int n = col_count;
          ON_Matrix A(m,n);
          for (i = 0; i < m; i++ ) for ( j = 0; j < n; j++ )
          {
            A[i][j] = ...;
          }
          ON_Matrix U(m,n);
          double* W = 0; // ON_GetMatrixSVD() will allocate W
          ON_Matrix V(n,n);
          bool rc = ON_GetMatrixSVD(m,n,A.m,U.m,W,V.m);
          ...
          onfree(W); // W allocated in ON_GetMatrixSVD()

Returns:
  True if the singular value decomposition was cacluated.
  False if the algorithm failed to converge.
*/
ON_DECL
bool ON_GetMatrixSVD(
  int row_count,
  int col_count,
  double const * const * A,
  double**& U,
  double*& W,
  double**& V
  );

/*
Description:
  Invert the diagonal matrix in a the singular value decomposition.
Parameters:
  count - [in] number of elements in W
  W - [in]
    diagonal values in the singular value decomposition.
  invW - [out]
    The inverted diagonal is returned here.  invW may be the same
    pointer as W.  If the input value of invW is not null, it must
    point to an array of count doubles.  If the input value of
    invW is null, heap storage will be allocated using onmalloc()
    and the calling function must call onfree(invW).
Remarks:
  If the singular value decomposition were mathematically perfect, then
  this function would be:
    for (i = 0; i < count; i++) 
      invW[i] = (W[i] != 0.0) ? 1.0/W[i] : 0.0;
  Because the double precision arithmetic is not mathematically perfect,
  very small values of W[i] may well be zero and this function makes
  a reasonable guess as to when W[i] should be treated as zero.  
Returns:
  Number of non-zero elements in invW, which, in a mathematically perfect
  situation, is the rank of Diag(W).
*/
ON_DECL
int ON_InvertSVDW(
  int count, 
  const double* W,
  double*& invW
  );

/*
Description:
  Solve a linear system of equations using the singular value decomposition.
Parameters:
  row_count - [in]
    number of rows in matrix U
  col_count - [in]
    number of columns in matrix U
  U - [in]
    row_count X col_count matix.
    See the remarks section for the definition of U.
  invW - [in]
    inverted DVD diagonal.
    See the remarks section for the definition of invW.
  V - [in]
    col_count X col_count matrix.
    See the remarks section for the definition of V.
  B - [in]
    An array of row_count values.
  X - [out]
    The solution array of col_count values is returned here.
    If the input value of X is not null, it must point to an
    array of col_count doubles.  If the input value of X is
    null, heap storage will be allocated using onmalloc() and
    the calling function must call onfree(X).
Remarks:
  If A*X = B is an m X n system of equations (m = row_count, n = col_count)
  and A = U*Diag(W)*Transpose(V) is the singular value decompostion of A,
  then a solution is X = V*Diag(1/W)*Transpose(U).
Example:

          int m = row_count;
          int n = col_count;
          ON_Matrix A(m,n);
          for (i = 0; i < m; i++ ) for ( j = 0; j < n; j++ )
          {
            A[i][j] = ...;
          }
          ON_SimpleArray<double> B(m);
          for (i = 0; i < m; i++ )
          {
            B[i] = ...;
          }

          ON_SimpleArray<double> X; // solution returned here.
          {
            double** U = 0;
            double* W = 0;
            double** V = 0;
            if ( ON_GetMatrixSVD(m,n,A.m,U,W,V) )
            {
              double* invW = 0;
              int rankW = ON_InvertSVDW(n,W,W); // save invW into W
              X.Reserve(n);
              if ( ON_SolveSVD(m,n,U,W,V,B,X.Array()) )
                X.SetCount(n);
            }
            onfree(U); // U allocated in ON_GetMatrixSVD()
            onfree(W); // W allocated in ON_GetMatrixSVD()
            onfree(V); // V allocated in ON_GetMatrixSVD()
          }

          if ( n == X.Count() )
          {
            ... use solution
          }  
Returns:
  True if input is valid and X[] was calculated. 
  False if input is not valid.
*/
ON_DECL
bool ON_SolveSVD(
  int row_count,
  int col_count,
  double const * const * U,
  const double* invW,
  double const * const * V,
  const double* B,
  double*& X
  );
  

/*
Description:
  Perform simple row reduction on a matrix.  If A is square, positive
  definite, and really really nice, then the returned B is the inverse
  of A.  If A is not positive definite and really really nice, then it
  is probably a waste of time to call this function.
Parameters:
  row_count - [in]
  col_count - [in]
  zero_pivot - [in]
    absolute values <= zero_pivot are considered to be zero
  A - [in/out]
    A row_count X col_count matrix.  Input is the matrix to be
    row reduced.  The calculation destroys A, so output A is garbage.
  B - [out]
    A a row_count X row_count matrix. That records the row reduction.
  pivots - [out]
    minimum and maximum absolute values of pivots.
Returns:
  Rank of A.  If the returned value < min(row_count,col_count),
  then a zero pivot was encountered.
  If C = input value of A, then B*C = (I,*)
*/
ON_DECL
int ON_RowReduce( 
          int row_count, 
          int col_count,
          double zero_pivot,
          double** A, 
          double** B, 
          double pivots[2] 
          );

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

////////////////////////////////////////////////////////////////
//
//   defines ON_Xform (4 x 4 transformation matrix)
//
////////////////////////////////////////////////////////////////

#if !defined(ON_XFORM_INC_)
#define ON_XFORM_INC_

class ON_Matrix;

class ON_CLASS ON_Xform
{
public:
  double m_xform[4][4]; // [i][j] = row i, column j.  I.e., 
                        //
                        //           [0][0] [0][1] [0][2] [0][3]
                        //           [1][0] [1][1] [1][2] [1][3]
                        //           [2][0] [2][1] [2][2] [2][3]
                        //           [3][0] [3][1] [3][2] [3][3]

  // use implicit destructor, copy constructor
  ON_Xform();                     // zero matrix

  ON_Xform( int );                // diagonal matrix (d,d,d,1)
  ON_Xform( double );             // diagonal matrix (d,d,d,1)

#if defined(ON_COMPILER_MSC)
  // Microsoft's compiler won't pass double m[4][4] as a const double[4][4] arg.
  // Gnu's compiler handles this.
  ON_Xform( double[4][4] );       // from standard double m[4][4]
  ON_Xform( float[4][4] );        // from standard float m[4][4]
#endif
  
  ON_Xform( const double[4][4] ); // from standard double m[4][4]
  ON_Xform( const float[4][4] );  // from standard float m[4][4]
  
  ON_Xform( const double* );      // from array of 16 doubles (row0,row1,row2,row3)
  ON_Xform( const float* );       // from array of 16 floats (row0,row1,row2,row3)
  
  ON_Xform( const ON_Matrix& ); // from upper left 4x4 of an
                                    // arbitrary matrix.  Any missing
                                    // rows/columns are set to identity. 
	ON_Xform(const ON_3dPoint& P,	// as a frame. 
						const ON_3dVector& X,	
						const ON_3dVector& Y,	
						const ON_3dVector& Z); 

  // use implicit operator=(const ON_3dVector&), operator==
  
  double* operator[](int);
  const double* operator[](int) const;

  // xform = scalar results in a diagonal 3x3 with bottom row = 0,0,0,1
  ON_Xform& operator=( int );
  ON_Xform& operator=( float );
  ON_Xform& operator=( double );
  ON_Xform& operator=( const ON_Matrix& ); // from upper left 4x4 of an
                                               // arbitrary matrix.  Any missing
                                               // rows/columns are set to identity.

  // All non-commutative operations have "this" as left hand side and
  // argument as right hand side.
  ON_2dPoint operator*( const ON_2dPoint& ) const;
  ON_3dPoint operator*( const ON_3dPoint& ) const;
  ON_4dPoint operator*( const ON_4dPoint& ) const;
  
  ON_2dVector operator*( const ON_2dVector& ) const;
  ON_3dVector operator*( const ON_3dVector& ) const;
  
  ON_Xform operator*( const ON_Xform& /*rhs*/ ) const;
  ON_Xform operator+( const ON_Xform& ) const;
  ON_Xform operator-( const ON_Xform& /*rhs*/ ) const;

  /*
  Description:
    Test the entries of the transformation matrix
    to see if they are valid number.
  Returns:
    True if ON_IsValid() is true for every number
    in the transformation matrix.
  */
  bool IsValid() const;

  /*
  Returns:
    true if matrix is the identity transformation

          1 0 0 0
          0 1 0 0
          0 0 1 0
          0 0 0 1
  Remarks:
    An element of the matrix is "zero" if fabs(x) <= zero_tolerance.
    An element of the matrix is "one" if fabs(1.0-x) <= zero_tolerance.
    If the matrix contains a nan, false is returned.
  */
  bool IsIdentity( double zero_tolerance = 0.0) const;
  
  /*
  Returns:
    true if the matrix is valid and is not the identity transformation
  Remarks:
    An element of the matrix is "zero" if fabs(x) <= zero_tolerance.
    An element of the matrix is "one" if fabs(1.0-x) <= zero_tolerance.
    If the matrix contains a nan, false is returned.
  */
  bool IsNotIdentity( double zero_tolerance = 0.0) const;
  
  /*
  Returns:
    true if matrix is a pure translation

          1 0 0 dx
          0 1 0 dy
          0 0 1 dz
          0 0 0 1
  Remarks:
    The test for zero is fabs(x) <= zero_tolerance.
    The test for one is fabs(x-1) <= zero_tolerance.
  */
  bool IsTranslation( double zero_tolerance = 0.0) const;
  
  /*
  Returns:
    true if matrix is the zero transformation

          0 0 0 0
          0 0 0 0
          0 0 0 0
          0 0 0 *
  */
  bool IsZero() const;

  /*
  Description:
    A similarity transformation can be broken into a sequence
    of dialations, translations, rotations, and reflections.
  Returns:
    +1: This transformation is an orientation preserving similarity.
    -1: This transformation is an orientation reversing similarity.
     0: This transformation is not a similarity.
  */
  int IsSimilarity() const;


  int Compare( const ON_Xform& other ) const;

  
  // matrix operations
  void Transpose(); // transposes 4x4 matrix

  int 
  Rank( // returns 0 to 4
    double* = NULL // If not NULL, returns minimum pivot
  ) const;

  double
  Determinant( // returns determinant of 4x4 matrix
    double* = NULL // If not NULL, returns minimum pivot
  ) const;

  bool
  Invert( // If matrix is non-singular, returns true,
          // otherwise returns false and sets matrix to 
          // pseudo inverse.
    double* = NULL // If not NULL, returns minimum pivot
  );

  ON_Xform
  Inverse(  // If matrix is non-singular, returns inverse,
            // otherwise returns pseudo inverse.
    double* = NULL // If not NULL, returns minimum pivot
  ) const;

  /*
  Description:
    When transforming 3d point and surface or mesh normals
    two different transforms must be used.
    If P_xform transforms the point, then the inverse
    transpose of P_xform must be used to tranform normal
    vectors.
  Parameters:
    N_xform - [out]
  Returns:
    The determinant of the transformation.
    If non-zero, "this" is invertable and N_xform can be calculated.
    False if "this" is not invertable, in which case
    the returned N_xform = this with the right hand column
    and bottom row zeroed out.
  */
  double GetSurfaceNormalXform( ON_Xform& N_xform ) const;

  /*
  Description:
    If a texture mapping is applied to an object, the object
    is subsequently transformed by T, and the texture mapping
    needs to be recalculated, then two transforms are required
    to recalcalculate the texture mapping.
  Parameters:
    P_xform - [out] 
      Transform to apply to points before applying the
      texture mapping transformation.
    N_xform - [out] 
      Transform to apply to surface normals before applying
      the texture mapping transformation.
  Returns:
    The determinant of the "this" transformation.
    If non-zero, "this" is invertable and P_xform and N_xform
    were calculated.
    False if "this" is not invertable, in which case
    the returned P_xform and N_xform are the identity.
  */
  double GetMappingXforms( ON_Xform& P_xform, ON_Xform& N_xform ) const;

  // Description:
  //   Computes matrix * transpose([x,y,z,w]).
  //
  // Parameters:
  //   x - [in]
  //   y - [in]
  //   z - [in]
  //   z - [in]
  //   ans - [out] = matrix * transpose([x,y,z,w])
  void ActOnLeft(
         double, // x
         double, // y
         double, // z
         double, // w
         double[4] // ans
         ) const;

  // Description:
  //   Computes [x,y,z,w] * matrix.
  //
  // Parameters:
  //   x - [in]
  //   y - [in]
  //   z - [in]
  //   z - [in]
  //   ans - [out] = [x,y,z,w] * matrix
  void ActOnRight(
         double, // x
         double, // y
         double, // z
         double, // w
         double[4] // ans
         ) const;

  ////////////////////////////////////////////////////////////////
  // standard transformations

  // All zeros including the bottom row.
  void Zero();

  // diagonal is (1,1,1,1)
  void Identity();

  // diagonal 3x3 with bottom row = 0,0,0,1
  void Diagonal(double); 

  /*
  Description:
    Create non-uniform scale transformation with the origin as
    a fixed point.
  Parameters:
    fixed_point - [in]
    x_scale_factor - [in]
    y_scale_factor - [in]
    z_scale_factor - [in]
  Remarks:
    The diagonal is (x_scale_factor, y_scale_factor, z_scale_factor, 1)
  */
  void Scale( 
    double x_scale_factor,
    double y_scale_factor,
    double z_scale_factor
    );

  /*
  Description:
    Create non-uniform scale transformation with the origin as
    a fixed point.
  Parameters:
    fixed_point - [in]
    scale_vector - [in]
  Remarks:
    The diagonal is (scale_vector.x, scale_vector.y, scale_vector.z, 1)
  */
  void Scale( 
    const ON_3dVector& scale_vector
    );

  /*
  Description:
    Create uniform scale transformation with a specified
    fixed point.
  Parameters:
    fixed_point - [in]
    scale_factor - [in]
  */
  void Scale
    (
    ON_3dPoint fixed_point,
    double scale_factor
    );

  /*
  Description:
    Create non-uniform scale transformation with a specified
    fixed point.
  Parameters:
    plane - [in] plane.origin is the fixed point
    x_scale_factor - [in] plane.xaxis scale factor
    y_scale_factor - [in] plane.yaxis scale factor
    z_scale_factor - [in] plane.zaxis scale factor
  */
  void Scale
    (
    const ON_Plane& plane,
    double x_scale_factor,
    double y_scale_factor,
    double z_scale_factor
    );

  /*
  Description:
    Create shear transformation.
  Parameters:
    plane - [in] plane.origin is the fixed point
    x1 - [in] plane.xaxis scale factor
    y1 - [in] plane.yaxis scale factor
    z1 - [in] plane.zaxis scale factor
  */
  void Shear
    (
    const ON_Plane& plane,
    const ON_3dVector& x1,
    const ON_3dVector& y1,
    const ON_3dVector& z1
    );

  // Right column is (d.x, d.y,d.z, 1).
  void Translation( 
    const ON_3dVector& // d
    );

  // Right column is (dx, dy, dz, 1).
  void Translation( 
    double, // dx
    double, // dy
    double  // dz
    );

  // Description:
  //   Get transformation that projects to a plane
  // Parameters:
  //   plane - [in] plane to project to
  // Remarks:
  //   This transformaton maps a 3d point P to the
  //   point plane.ClosestPointTo(Q).
  void PlanarProjection(
    const ON_Plane& plane
    );

  // Description: 
  //   The Rotation() function is overloaded and provides several
  //   ways to compute a rotation transformation.  A positive
  //   rotation angle indicates a counter-clockwise (right hand rule)
  //   rotation about the axis of rotation.
  //
  // Parameters:
  //   sin_angle - sin(rotation angle)
  //   cos_angle - cos(rotation angle)
  //   rotation_axis - 3d unit axis of rotation
  //   rotation_center - 3d center of rotation
  //
  // Remarks: 
  //   In the overloads that take frames, the frames should 
  //   be right hand orthonormal frames 
  //   (unit vectors with Z = X x Y).  
  //   The resulting rotation fixes
  //   the origin (0,0,0), maps initial X to 
  //   final X, initial Y to final Y, and initial Z to final Z.
  //  
  //   In the overload that takes frames with center points, 
  //   if the initial and final center are equal, then that 
  //   center point is the fixed point of the rotation.  If 
  //   the initial and final point differ, then the resulting
  //   transform is the composition of a rotation fixing P0
  //   and translation from P0 to P1.  The resulting 
  //   transformation maps P0 to P1, P0+X0 to P1+X1, ...
  //
  //   The rotation transformations that map frames to frames
  //   are not the same as the change of basis transformations
  //   for those frames.  See ON_Xform::ChangeBasis().
  //   
  void Rotation(
    double sin_angle,
    double cos_angle,
    ON_3dVector rotation_axis,
    ON_3dPoint rotation_center
    );

  // Parameters:
  //   angle - rotation angle in radians
  //   rotation_axis - 3d unit axis of rotation
  //   rotation_center - 3d center of rotation
  void Rotation(
    double angle_radians,
    ON_3dVector rotation_axis,
    ON_3dPoint rotation_center
    );

  /*
  Description:
    Calculate the minimal transformation that rotates
    start_dir to end_dir while fixing rotation_center.    
  */
  void Rotation(
    ON_3dVector start_dir,
    ON_3dVector end_dir,
    ON_3dPoint rotation_center
    );

  // Parameters:
  //   X0 - initial frame X
  //   Y0 - initial frame Y
  //   Z0 - initial frame Z
  //   X1 - final frame X
  //   Y1 - final frame Y
  //   Z1 - final frame Z
  //
  void Rotation( 
    const ON_3dVector& X0,
    const ON_3dVector& Y0,
    const ON_3dVector& Z0,
    const ON_3dVector& X1,
    const ON_3dVector& Y1,
    const ON_3dVector& Z1
    );

  // Parameters:
  //   P0 - initial frame center
  //   X0 - initial frame X
  //   Y0 - initial frame Y
  //   Z0 - initial frame Z
  //   P1 - initial frame center
  //   X1 - final frame X
  //   Y1 - final frame Y
  //   Z1 - final frame Z
  void Rotation( 
    const ON_3dPoint& P0,
    const ON_3dVector& X0,
    const ON_3dVector& Y0,
    const ON_3dVector& Z0,
    const ON_3dPoint& P1,
    const ON_3dVector& X1,
    const ON_3dVector& Y1,
    const ON_3dVector& Z1
    );

  /*
  Description:
    Create rotation transformation that maps plane0 to plane1.
  Parameters:
    plane0 - [in]
    plane1 - [in]
  */
  void Rotation( 
    const ON_Plane& plane0,
    const ON_Plane& plane1
    );

  /*
  Description:
    Create mirror transformation matrix.
  Parameters:
    point_on_mirror_plane - [in] point on mirror plane
    normal_to_mirror_plane - [in] normal to mirror plane
  Remarks:
    The mirror transform maps a point Q to
    Q - (2*(Q-P)oN)*N, where
    P = point_on_mirror_plane and N = normal_to_mirror_plane.
  */
  void Mirror(
    ON_3dPoint point_on_mirror_plane,
    ON_3dVector normal_to_mirror_plane
    );

  // Description: The ChangeBasis() function is overloaded 
  //   and provides several
  //   ways to compute a change of basis transformation.
  //
  // Parameters:
  //   plane0 - inital plane
  //   plane1 - final plane
  //
  // Returns:
  //   @untitled table
  //   true    success
  //   false   vectors for initial frame are not a basis
  //
  // Remarks: 
  //   If you have points defined with respect to planes, the
  //   version of ChangeBasis() that takes two planes computes
  //   the transformation to change coordinates from one plane to 
  //   another.  The predefined world plane ON_world_plane can
  //   be used as an argument.
  //
  //   If P = plane0.Evaluate( a0,b0,c0 ) and 
  //
  //   (a1,b1,c1) = ChangeBasis(plane0,plane1)*ON_3dPoint(a0,b0,c0),
  //
  //   then P = plane1.Evaluate( a1, b1, c1 )
  //          
  //   The version of ChangeBasis() that takes six vectors
  //   maps (a0,b0,c0) to (a1,b1,c1) where
  //   a0*X0 + b0*Y0 + c0*Z0 = a1*X1 + b1*Y1 + c1*Z1
  //
  //   The version of ChangeBasis() that takes six vectors
  //   with center points
  //   maps (a0,b0,c0) to (a1,b1,c1) where
  //   P0 + a0*X0 + b0*Y0 + c0*Z0 = P1 + a1*X1 + b1*Y1 + c1*Z1
  //
  //   The change of basis transformation is not the same as
  //   the rotation transformation that rotates one orthonormal
  //   frame to another.  See ON_Xform::Rotation().
  bool ChangeBasis( 
    const ON_Plane& plane0,
    const ON_Plane& plane1
    );

  // Description:
  //   Get a change of basis transformation.
  // Parameters:
  //   X0 - initial basis X (X0,Y0,Z0 can be any 3d basis)
  //   Y0 - initial basis Y
  //   Z0 - initial basis Z
  //   X1 - final basis X (X1,Y1,Z1 can be any 3d basis)
  //   Y1 - final basis Y
  //   Z1 - final basis Z
  // Remarks:
  //   Change of basis transformations and rotation transformations
  //   are often confused.  This is a change of basis transformation.
  //   If Q = a0*X0 + b0*Y0 + c0*Z0 = a1*X1 + b1*Y1 + c1*Z1
  //   then this transform will map the point (a0,b0,c0) to (a1,b1,c1)
  bool ChangeBasis( 
    const ON_3dVector& X0,
    const ON_3dVector& Y0,
    const ON_3dVector& Z0,
    const ON_3dVector& X1,
    const ON_3dVector& Y1,
    const ON_3dVector& Z1
    );

  // Parameters:
  //   P0 - initial center
  //   X0 - initial basis X (X0,Y0,Z0 can be any 3d basis)
  //   Y0 - initial basis Y
  //   Z0 - initial basis Z
  //   P1 - final center
  //   X1 - final basis X (X1,Y1,Z1 can be any 3d basis)
  //   Y1 - final basis Y
  //   Z1 - final basis Z
  // Remarks:
  //   Change of basis transformations and rotation transformations
  //   are often confused.  This is a change of basis transformation.
  //   If Q = P0 + a0*X0 + b0*Y0 + c0*Z0 = P1 + a1*X1 + b1*Y1 + c1*Z1
  //   then this transform will map the point (a0,b0,c0) to (a1,b1,c1)
  bool ChangeBasis( 
    const ON_3dPoint& P0,
    const ON_3dVector& X0,
    const ON_3dVector& Y0,
    const ON_3dVector& Z0,
    const ON_3dPoint& P1,
    const ON_3dVector& X1,
    const ON_3dVector& Y1,
    const ON_3dVector& Z1
    );

  // standard viewing transformations
  void WorldToCamera( 
         const ON_3dPoint&,  // CameraLocation
         const ON_3dVector&, // unit CameraX vector (right)
         const ON_3dVector&, // unit CameraY vector (up)
         const ON_3dVector&  // unit CameraZ vector (from screen to camera)
         );
  void CameraToWorld( 
         const ON_3dPoint&,  // CameraLocation
         const ON_3dVector&, // unit CameraX vector (right)
         const ON_3dVector&, // unit CameraY vector (up)
         const ON_3dVector&  // unit CameraZ vector (from screen to camera)
         );
  bool CameraToClip( // maps viewport frustum to -1 <= x,y,z <= 1 box
      ON_BOOL32, // true for perspective, false for orthographic
      double, double, // left != right (usually left < right )
      double, double, // bottom != top (usually bottom < top )
      double, double  // near != far (usually 0 < near < far )
      );

  // maps -1 <= x,y,z <= 1 box to viewport frustum
  bool ClipToCamera( 
      int, // true for perspective, false for orthographic
      double, double, // left != right (usually left < right )
      double, double, // bottom != top (usually bottom < top )
      double, double  // near != far an bot are non-zero (usually 0 < near < far )
      );

  // Computes transform that maps the clipping box 
  //
  //           -1<x<1,-1<y<1,-1<z<1 
  //
  // to the screen box
  //
  //          (left,right) X (bottom,top) X (near,far)
  bool ClipToScreen(                           
      double, // left
      double, // right
      double, // bottom
      double, // top
      double, // near_z
      double  // far_z
      );

  // Computes transform that maps the screen box
  //
  //          (left,right) X (bottom,top) X (near,far)
  //  
  // to the clipping box 
  //
  //           -1<x<1,-1<y<1,-1<z<1 
  bool ScreenToClip(
      double, // left
      double, // right
      double, // bottom
      double, // top
      double, // near_z
      double  // far_z
      );

  // Description: Computes homogeneous point clipping flags and
  //   returns an int with bits set to indicate if the point
  //   is outside of the clipping box.
  //
  // Parameters:
  //   point - [in] 4d homogeneous clipping coordinate point
  //
  // Returns:  
  //  @table  
  //   bit      point location
  //   1        x/w < -1
  //   2        x/w > +1
  //   4        y/w < -1
  //   8        y/w > +1
  //   16       z/w < -1
  //   32       z/w > +1
  //
  int ClipFlag4d(
    const double* // point
    ) const;

  // Parameters:
  //   count - [in] number of 4d points
  //   stride - [in] (>=4)
  //   points - [in] 4d clipping coordinate points 
  //            (array of stride*count doubles)
  //   bTestZ - [in] (default=true) if false, do not test "z" coordinate
  //
  int ClipFlag4d(
    int, // count
    int, // stride
    const double*, // points
    ON_BOOL32 = true // bTeztZ
    ) const;

  // Description: 
  //   Computes 3d point clipping flags and
  //   returns an int with bits set to indicate if the point
  //   is outside of the clipping box.
  //
  // Parameters:
  //   point - [in] 3d clipping coordinate point
  //
  // Returns:  
  //  @table  
  //   bit      point location
  //   1        x < -1
  //   2        x > +1
  //   4        y < -1
  //   8        y > +1
  //   16       z < -1
  //   32       z > +1
  int ClipFlag3d(
    const double* // point
    ) const;

  // Parameters:
  //   count - [in] number of 3d points
  //   stride - [in] (>=3)
  //   points - [in] 3d clipping coordinate points (array of stride*count doubles)
  //   bTestZ - [in] (default=true) if false, do not test "z" coordinate
  //
  int ClipFlag3d(
    int, // count
    int, // stride 
    const double*, // points
    ON_BOOL32 = true // bTestZ
    ) const;

  // Description: Computes 3d clipping flags for a 3d bounding
  //   box and returns an int with bits set to indicate if
  //   the bounding box is outside of the clipping box.
  //
  // Parameters:
  //   boxmin - [in] 3d boxmin corner
  //   boxmax - [in] 3d boxmax corner
  //
  // Returns:  
  //  @table  
  //   bit      box location
  //   1        boxmax x < -1
  //   2        boxmin x > +1
  //   4        boxmax y < -1
  //   8        boxmin y > +1
  //   16       boxmax z < -1
  //   32       boxmin z > +1
  int ClipFlag3dBox(
    const double*, // boxmin
    const double*  // boxmax
    ) const;


  /*
  Description:
    Calculates the transformation that linearly maps
    old_interval to new_interval.
  Parameters:
    dir - [in] 0 = x, 1 = y, 2= z;
    old_interval - [in]
    new_interval - [in]
  */
  bool IntervalChange(
    int dir,
    ON_Interval old_interval,
    ON_Interval new_interval
    );
};

class ON_CLASS ON_ClippingRegion
{
public:
  ON_ClippingRegion();

  // The transformation m_xform transforms the view frustum,
  // in object coordinates to the (-1,+1)^3 clipping 
  // coordinate box.
  ON_Xform m_xform;

  /*
  Parameters:
    clip_plane_tolerance - [in]  
      3d world coordinates tolerance to use when testing 
      objects to see if the planes in m_clip_plane[] hide
      the objects.      
  Remarks:
    The constructor sets this value to zero.  Rhino uses
    values around 1e-5.
  */
  void SetClipPlaneTolerance( double clip_plane_tolerance );

  /*
  Returns:
    3d world coordinates tolerance to use when testing 
    objects to see if the planes in m_clip_plane[] hide
    the objects.      
  Remarks:
    The constructor sets this value to zero.  Rhino uses
    values around 1e-5.
  */
  double ClipPlaneTolerance() const;

  enum
  {
    max_clip_plane_count = 16, // must be <= 25
    frustum_bitmask      = 0x0000003F,
    near_plane_bitmask   = 0x00000020,
    far_plane_bitmask    = 0x00000010,
    clip_plane_bitmask   = 0x7FFFFFC0,
    negw_bitmask         = 0x80000000
  };

  // Up to 25 additional clipping planes in object coordinates.
  // The convex region that is the intersection of the positive 
  // side of these planes is the active region.
  int m_clip_plane_count; // (0 <= m_clip_plane_count <= max_clip_plane_count)

private:
  // The "float" should be a double, but that can't happen
  // until V6 because it will brake the SDK.  Use the
  // SetClipPlaneTolerance() and ClipPlaneTolerance() 
  // functions to set and get this value.
  float m_clip_plane_tolerance;

public:
  ON_PlaneEquation m_clip_plane[max_clip_plane_count];

  /*
  Description:
    The "view frustum" is the frustum the m_xform transformation
    maps to clipping coordinate box (-1,+1)^3.  These functions
    determine if some portion of the convex hull of the test points
    is inside the view frustum.
  Parameters:
    P - [in] point
    box - [in] bounding box
    count - [in] number of points
    p - [in] array of points
    bEnableClippingPlanes - [in]
      If true, then the additional clipping planes are tested.
      If false, then the additional clipping planes are ignored.
  Returns:
    0 = No part of the of the convex hull of the tested points
        is in the view frustum.
    1 = A portion of the convex hull of the otested points may
        be in the view frustum.
    2 = The entire convex hull of the tested points is in the
        view frustum.
  */
  int InViewFrustum( 
    ON_3dPoint P
    ) const;
  int InViewFrustum( 
    const ON_BoundingBox& bbox
    ) const;
  int InViewFrustum( 
    int count, 
    const ON_3fPoint* p
    ) const;
  int InViewFrustum( 
    int count, 
    const ON_3dPoint* p
    ) const;
  int InViewFrustum( 
    int count, 
    const ON_4dPoint* p
    ) const;

  /*
  Description:
    The "clip plane region" is the convex hull of the planes in
    the m_clip_plane[] array.  These functions determine if
    some portion of the convex hull of the test points is inside
    the clip plane region.
  Parameters:
    P - [in] point
    box - [in] bounding box
    count - [in] number of points
    p - [in] array of points
    bEnableClippingPlanes - [in]
      If true, then the additional clipping planes are tested.
      If false, then the additional clipping planes are ignored.
  Returns:
    0 = No part of the of the convex hull of the tested points
        is in the clip plane region.
    1 = A portion of the convex hull of the tested points may
        be in the clip plane region.
    2 = The entire convex hull of the tested points is in the
        clip plane region.
  */
  int InClipPlaneRegion( 
    ON_3dPoint P
    ) const;
  int InClipPlaneRegion( 
    const ON_BoundingBox& bbox
    ) const;
  int InClipPlaneRegion( 
    int count, 
    const ON_3fPoint* p
    ) const;
  int InClipPlaneRegion( 
    int count, 
    const ON_3dPoint* p
    ) const;
  int InClipPlaneRegion( 
    int count, 
    const ON_4dPoint* p
    ) const;


  /*
  Description:
    The "visible area" is the intersection of the view frustum,
    defined by m_xform, and the clipping region, defined by the
    m_clip_plane[] array.  These functions determing if some
    portion of the convex hull of the test points is visible.
  Parameters:
    P - [in] point
    box - [in] bounding box
    count - [in] number of points
    p - [in] array of points
  Returns:
    0 = no part of the object is in the region.
    1 = a portion of the object is in the region
    2 = entire object is in clipping region
  */
  int IsVisible( 
    ON_3dPoint P
    ) const;
  int IsVisible( 
    const ON_BoundingBox& bbox
    ) const;
  int IsVisible( 
    int count, 
    const ON_3fPoint* p
    ) const;
  int IsVisible( 
    int count, 
    const ON_3dPoint* p
    ) const;
  int IsVisible( 
    int count, 
    const ON_4dPoint* p
    ) const;

  /*
  Description:
    Transform a list of 4d homogenous points while testing
    for visibility.
  Parameters:
    count - [in] number of points
    p - [in/out] array of points to test and transform
          If 0 is returned, some of the points may not
          be transformed.  In all other cases, the output
          points are transformed by m_xform.
    pflags - [out]
          0 when the point is in the visible region.  
          Otherwise the bits are set to indicate which planes clip the
          intput point.
          0x01 left of the view frusturm
          0x02 right of the view frustum
          0x04 below the view frustum
          0x08 above the view frustum
          0x10 behind the view frustum (too far)
          0x20 in front of the view frustum (too near)

          0x10 below m_clip_plane[0]
          0x20 below m_clip_plane[1]
          ...
          0x40000000 below m_clip_plane[24]

          0x80000000 transformation created a non-positive weight
  Returns:
    0 = convex hull of the points is not in the region.
        The m_cull_bits field reports which plane or planes
        culled the point set.
    1 = a portion of the convex hull is in the region.
        The m_cull_bits field reports which plane or planes
        culled the point set.
    2 = all points are in the region.
        The m_cull_bits field will be zero.
  */
  int TransformPoints( int count, ON_4dPoint* p ) const;
  int TransformPoints( int count, ON_4dPoint* p, unsigned int* pflags ) const;


  /*
  Description:
    Transform a pont and return the clipping information.
  Parameters:
    P - [in] point ot transform
    Q - [out] transformed point
  Returns:
    0 when the point is in the visible region.  
    Otherwise the bits are set to indicate which planes clip the
    intput point.
    0x01 left of the view frusturm
    0x02 right of the view frustum
    0x04 below the view frustum
    0x08 above the view frustum
    0x10 behind the view frustum (too far)
    0x20 in front of the view frustum (too near)

    0x10 below m_clip_plane[0]
    0x20 below m_clip_plane[1]
    ...
    0x40000000 below m_clip_plane[24]

    0x80000000 transformation created a non-positive weight
  */
  unsigned int TransformPoint(
                     const ON_4dPoint& P, 
                     ON_4dPoint& Q
                     ) const;
  unsigned int TransformPoint(
                     const ON_3dPoint& P, 
                     ON_3dPoint& Q
                     ) const;
  unsigned int TransformPoint(
                     const ON_3fPoint& P, 
                     ON_3dPoint& Q
                     ) const;

  /*
  Description:
    Calculate the interval for the segment of a line that
    is in the clip plane region.
  Parameters:
    P0 - [in] start point
    P1 - [in] end point
    t0 - [out] start parameter
    t1 - [out] end parameter
  Returns:
    True if some portion of the line is visible and
    0.0 <= *t0 <= *t1 <= 1.0.
  */
  bool GetLineClipPlaneParamters( 
         ON_4dPoint P0, 
         ON_4dPoint P1, 
         double* t0, 
         double* t1 
         ) const;

};


class ON_CLASS ON_Localizer
{
public:
  ON_Localizer();
  ~ON_Localizer();

  ON_Localizer(const ON_Localizer&);
  ON_Localizer& operator=(const ON_Localizer&);

  void Destroy();
  bool Read(ON_BinaryArchive&);
  bool Write(ON_BinaryArchive&) const;

  /*
  Descrption:
    Creates a cylindrical localizer.
    If d = distance from the point to the line, 
    then the localizer has the following behavior:

    point distance                localizer value
    d <= r0 < r1 or d >= r0 > r1      0
    d >= r1 > r0 or d <= r1 < r0      1

    For values of d between r0 and r1, the localizer
    smoothly transitions between 0 to 1.

  Parameters:
    P - [in] cylinder axis point
    D - [in] cylinder axis direction
    r0 - [in]
    r1 - [in]
      r0 and r1 are radii that control where the localizer is nonzero.  
      Both r0 and r1 must be postive and the cannot be equal.  
      If 0 < r0 < r1, then the localizer is zero for points 
      inside the cylinder of radius r0 and one for points outside
      the cylinder of radius r1.
      If 0 < r1 < r0, then the localizer is one for points 
      inside the cylinder of radius r1 and zero for points outside
      the cylinder of radius r0.      

  Returns:
    True if the input is value and the localizer is initialized.
  */
  bool CreateCylinderLocalizer( ON_3dPoint P, ON_3dVector D, double r0, double r1 );

  /*
  Descrption:
    Creates a planar localizer.
    If d = signed distance from the point to the plane,
    then the localizer has the following behavior:

    point distance                localizer value
    d <= h0 < h1 or d >= h0 > h1      0
    d >= h1 > h0 or d <= h1 < h0      1

    For values of d between h0 and h1, the localizer
    smoothly transitions between 0 to 1.

  Parameters:
    P - [in] point on plane
    N - [in] normal to plane
    h0 - [in]
    h1 - [in]
      h0 and h1 are signed distances that control where the 
      localizer is nonzero.

  Returns:
    True if the input is value and the localizer is initialized.
  */
  bool CreatePlaneLocalizer( ON_3dPoint P, ON_3dVector N, double h0, double h1 );

  /*
  Descrption:
    Creates a spherical localizer.
    If d = distance from the point to the center of the sphere, 
    then the localizer has the following behavior:

    point distance                localizer value
    d <= r0 < r1 or d >= r0 > r1      0
    d >= r1 > r0 or d <= r1 < r0      1

    For values of d between r0 and r1, the localizer
    smoothly transitions between 0 to 1.

  Parameters:
    P - [in] center of sphere
    r0 - [in]
    r1 - [in]
      r0 and r1 are radii that control where the localizer is nonzero.  
      Both r0 and r1 must be postive and the cannot be equal.  
      If 0 < r0 < r1, then the localizer is zero for points 
      inside the cylinder of radius r0 and one for points outside
      the cylinder of radius r1.
      If 0 < r1 < r0, then the localizer is one for points 
      inside the cylinder of radius r1 and zero for points outside
      the cylinder of radius r0.      

  Returns:
    True if the input is value and the localizer is initialized.
  */
  bool CreateSphereLocalizer( ON_3dPoint P, double r0, double r1 );

  /*
  Description:
    Evaluators.
  Parameters:
    P - [in]
      Evaluation point
    distance - [in]
      Evaluation distance
  Returns:
    Value of the localizer.
  */
  double Value(ON_3dPoint P) const;
  double Value(double distance) const;

  /*
  Parameters:
    bbox - [in]
  Returns:
    True if localizer is identically zero inside bbox.
  */
  bool IsZero( const ON_BoundingBox& bbox ) const;

  enum TYPE
  {
    no_type       = 0,
    sphere_type   = 1,
    plane_type    = 2,
    cylinder_type = 3,
    curve_type    = 4,
    surface_type  = 5,
    distance_type = 6,
    force_32bit_localizer_type = 0xFFFFFFFF
  };

  TYPE m_type;

  ON_Interval      m_d;
  ON_3dPoint       m_P;
  ON_3dVector      m_V;
  class ON_NurbsCurve*   m_nurbs_curve;
  class ON_NurbsSurface* m_nurbs_surface;
};


class ON_CLASS ON_SpaceMorph
{
public:
  ON_SpaceMorph();
  virtual ~ON_SpaceMorph();

  /*
  Description:
    Provides a quick way to determine if a morph function
    is the identity (doesn't move the points) on a region
    of space.
  Parameters:
    bbox - [in] region of space to test.
  Returns:
    The default always returns false.  If you override
    this function, then return true when every point
    in the bounding box is fixed by the morph.  
  */
  virtual
  bool IsIdentity( const ON_BoundingBox& bbox ) const;

  /*
  Description:
    Returns the desired accuracy of the morph.
    This value is primarily used for deforming
    surfaces and breps.
  Returns:
    3d fitting tolerance.
  Remarks:
    The default is 0.0 and any value <= 0.0 is 
    ignored by morphing functions.
    The value returned by Tolerance() does not
    affect the way meshes and points are morphed.
  */
  double Tolerance() const;

  /*
  Description:
    Set the 3d fitting tolerance used when morphing
    surfaces and breps.
  Parameters:
    tolerance - [in] values < 0.0 are treated as 0.0.                     
  */
  void SetTolerance(
          double tolerance
          );

  /*
  Returns:
    True if the morph should be done as quickly as
    possible because the result is being used for
    some type of dynamic preview.  If QuickPreview
    is true, the tolerance may be ignored.
  Remarks:
    The value returned by QuickPreview() does not
    affect the way meshes and points are morphed.
    The default is false.
  */
  bool QuickPreview() const;

  /*
  Description:
    Set the quick preview value.
  Parameters:
    bQuickPreview - [in]
  */
  void SetQuickPreview( 
          bool bQuickPreview 
          );

  /*
  Returns:
    True if the morph should be done in a way that
    preserves the structure of the geometry.  
    In particular, for NURBS objects, true
    means that only the control points are moved.
  Remarks:
    The value returned by PreserveStructure() does not
    affect the way meshes and points are morphed.
    The default is false.
  */
  bool PreserveStructure() const;

  /*
  Description:
    Set the preserve structure value.
  Parameters:
    bPreserveStructure - [in]
  */
  void SetPreserveStructure( 
          bool bPreserveStructure
          );

private:
  double m_tolerance;
  bool m_bQuickPreview;
  bool m_bPreserveStructure;
};

#if defined(ON_DLL_TEMPLATE)

// This stuff is here because of a limitation in the way Microsoft
// handles templates and DLLs.  See Microsoft's knowledge base 
// article ID Q168958 for details.
#pragma warning( push )
#pragma warning( disable : 4231 )
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_Xform>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ON_Localizer>;
#pragma warning( pop )
#endif

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_WORKSPACE_INC_)
#define OPENNURBS_WORKSPACE_INC_

/*
Description:
  Use ON_Workspace classes on the stack to efficiently get 
  and automatically clean up workspace memory and scratch 
  files.
*/
class ON_CLASS ON_Workspace
{
public:
  /*
  Description:
    ON_Workspace classes should be on the stack
    or as members on classes that are never copied.
    The destructor frees memory that was allocated by
    ON_Workspace::GetMemory and closes files that were 
    opened with ON_Workspace::OpenFile.
  */
  ON_Workspace();

  /*
  Description:
    The destructor frees memory that was allocated by
    ON_Workspace::GetMemory and closes files that were 
    opened with ON_Workspace::OpenFile.
  */
  ~ON_Workspace();


  /*
  Description:
    The destructor frees memory that was allocated by
    ON_Workspace::GetMemory and closes files that were 
    opened with ON_Workspace::OpenFile.  The workspace
    can be used again after calling destroy.
  */
  void Destroy();

  /*
  Description:
    Gets a block of heap memory that will be freed by 
    ~ON_Workspace. The intent of ON_Workspace::GetMemory
    is to provide an easy way to get blocks of scratch 
    memory without having to worry about cleaning up 
    before returning.
  Parameters:
    sz - [in] (>0) size of memory block in bytes. 
              If sz <= 0, then NULL is returned.
  Returns:
    A pointer to the memory block.
  Remarks.
    onmalloc() is used to get the block of memory.
    Do NOT free the pointer returned by GetMemory().
    ~ON_Workspace() will free the memory.  If you decide
    you want to keep the memory block, pass the pointer
    to KeepMemory before ~ON_Workspace is called.
  See Also:
    ON_Workspace::::~ON_Workspace
    ON_Workspace::KeepMemory
    ON_Workspace::GrowMemory
    ON_Workspace::GetIntMemory
    ON_Workspace::GetDoubleMemory
    ON_Workspace::GetPointMemory
    ON_Workspace::GetVectorMemory
  */
  void* GetMemory( size_t sz );

  /*
  Description:
    Gets an array of integers that will be freed by ~ON_Workspace.
    The intent of ON_Workspace::GetIntMemory is to provide
    an easy way to get scratch integer arrays without
    having to worry about cleaning up before returning.
  Parameters:
    count - [in] (>0) number of integers in memory block.
              If count <= 0, then NULL is returned.
  Returns:
    A pointer to the array of integers.
  Remarks.
    This is a simple helper function so you don't have to
    mess around with (int*) casts and sizeof(int)s in a call
    to GetMemory().  It is exactly like calling
    (int*)GetMemory(count*sizeof(int));
  See Also:
    ON_Workspace::GetMemory
    ON_Workspace::KeepMemory
    ON_Workspace::GrowIntMemory
  */
  int* GetIntMemory( size_t count );

  /*
  Description:
    Gets an matrix of integers
  Parameters:
    row_count - [in] (>0) number of  rows
    col_count - [in] (>0) number of columns
  Returns:
    A pointer p so that p[i][j] is an integer when
    0 <= i < row_count and 0 <= j < col_count.
  Remarks.
    This is a simple helper function so you don't have to
    mess around building the 2d array.
  See Also:
    ON_Workspace::KeepMemory
  */
  int** GetIntMemory( size_t row_count, size_t col_count );

  /*
  Description:
    Gets an array of doubles that will be freed by ~ON_Workspace.
    The intent of ON_Workspace::GetDoubleMemory is to provide
    an easy way to get scratch double arrays without
    having to worry about cleaning up before returning.
  Parameters:
    count - [in] (>0) number of doubles in memory block.
              If count <= 0, then NULL is returned.
  Returns:
    A pointer to the array of doubles.
  Remarks.
    This is a simple helper function so you don't have to
    mess around with (double*) casts and sizeof(double)s 
    in a call to GetMemory().  It is exactly like calling
    (double*)GetMemory(count*sizeof(double));
  See Also:
    ON_Workspace::GetMemory
    ON_Workspace::KeepMemory
    ON_Workspace::GrowIntMemory
  */
  double* GetDoubleMemory( size_t count );

  /*
  Description:
    Gets an matrix of doubles
  Parameters:
    row_count - [in] (>0) number of  rows
    col_count - [in] (>0) number of columns
  Returns:
    A pointer p so that p[i][j] is an double when
    0 <= i < row_count and 0 <= j < col_count.
  Remarks.
    This is a simple helper function so you don't have to
    mess around building the 2d array.
  See Also:
    ON_Workspace::KeepMemory
  */
  double** GetDoubleMemory( size_t row_count, size_t col_count );

  /*
  Description:
    Gets an array of ON_3dPoints that will be freed by ~ON_Workspace.
    The intent of ON_Workspace::GetPointMemory is to 
    provide an easy way to get scratch point arrays without
    having to worry about cleaning up before returning.
  Parameters:
    count - [in] (>0) number of points in memory block.
              If count <= 0, then NULL is returned.
  Returns:
    A pointer to the memory block.
  Remarks.
    This is a simple helper function so you don't have to
    mess around with (ON_3dPoint*) casts and sizeof(ON_3dPoint)s
    in a call to GetMemory().  It is exactly like calling
    (ON_3dPoint*)GetMemory(count*sizeof(ON_3dPoint));
  See Also:
    ON_Workspace::GetMemory
    ON_Workspace::KeepMemory
    ON_Workspace::GrowIntMemory
  */
  ON_3dPoint* GetPointMemory( size_t count );

  /*
  Description:
    Gets an array of ON_3dVectors that will be freed by ~ON_Workspace.
    The intent of ON_Workspace::GetVectorMemory is to 
    provide an easy way to get scratch Vector arrays without
    having to worry about cleaning up before returning.
  Parameters:
    count - [in] (>0) number of Vectors in memory block.
              If count <= 0, then NULL is returned.
  Returns:
    A pointer to the memory block.
  Remarks.
    This is a simple helper function so you don't have to
    mess around with (ON_3dVector*) casts and sizeof(ON_3dVector)s
    in a call to GetMemory().  It is exactly like calling
    (ON_3dVector*)GetMemory(count*sizeof(ON_3dVector));
  See Also:
    ON_Workspace::GetMemory
    ON_Workspace::KeepMemory
    ON_Workspace::GrowIntMemory
  */
  ON_3dVector* GetVectorMemory( size_t count );

  /*
  Description:
    Grows a block of heap memory that was allocated by
    ON_Workspace::GetMemory.
  Parameters:
    ptr - [in] pointer returned by an earlier call to
               GetMemory or GrowMemory.
    sz - [in] (>0) size of memory block in bytes. 
              If sz <= 0, then NULL is returned.
              If ptr is not NULL and was not allocated by an 
              earlier call to GetMemory or GrowMemory, then
              NULL is returned.
  Returns:
    A pointer to the memory block.
  Remarks.
    onrealloc() is used to grow the block of memory.
    Do NOT free the pointer returned by GrowMemory().
    ~ON_Workspace() will free the memory.  If you decide
    you want to keep the memory block, pass the pointer
    to KeepMemory before ~ON_Workspace is called.
  See Also:
    ON_Workspace::GetMemory
    ON_Workspace::KeepMemory
    ON_Workspace::GrowIntMemory
    ON_Workspace::GrowDoubleMemory
    ON_Workspace::GrowPointMemory
    ON_Workspace::GrowVectorMemory
  */
  void* GrowMemory( void* ptr, size_t sz );

  /*
  Description:
    Grows the array of integers that was allocated by
    GetIntMemory or GrowIntMemory.
  Parameters:
    ptr - [in] pointer returned by an earlier call to
               GetIntMemory or GrowIntMemory.
    count - [in] (>0) number of integers in memory block.
              If count <= 0, then NULL is returned.
              If ptr was not allocated by this ON_Workspace
              class, then NULL is returned.
  Returns:
    A pointer to the integer array.
  Remarks.
    onrealloc() is used to grow the block of memory.
    Do NOT free the pointer returned by GrowIntMemory().
    ~ON_Workspace() will free the memory.  If you decide
    you want to keep the memory block, pass the pointer
    to KeepMemory before ~ON_Workspace is called.
  See Also:
    ON_Workspace::GetIntMemory
    ON_Workspace::KeepMemory
  */
  int* GrowIntMemory( int* ptr, size_t count );

  /*
  Description:
    Grows the array of doubles that was allocated by
    GetDoubleMemory or GrowDoubleMemory.
  Parameters:
    ptr - [in] pointer returned by an earlier call to
               GetDoubleMemory or GrowDoubleMemory.
    count - [in] (>0) number of doubles in memory block.
              If count <= 0, then NULL is returned.
              If ptr was not allocated by this ON_Workspace
              class, then NULL is returned.
  Returns:
    A pointer to the double array.
  Remarks.
    onrealloc() is used to grow the block of memory.
    Do NOT free the pointer returned by GrowDoubleMemory().
    ~ON_Workspace() will free the memory.  If you decide
    you want to keep the memory block, pass the pointer
    to KeepMemory before ~ON_Workspace is called.
  See Also:
    ON_Workspace::GetDoubleMemory
    ON_Workspace::KeepMemory
  */
  double* GrowDoubleMemory( double* ptr, size_t count );

  /*
  Description:
    Grows the array of points that was allocated by
    GetPointMemory or GrowPointMemory.
  Parameters:
    ptr - [in] pointer returned by an earlier call to
               GetPointMemory or GrowPointMemory.
    count - [in] (>0) number of points in memory block.
              If count <= 0, then NULL is returned.
              If ptr was not allocated by this ON_Workspace
              class, then NULL is returned.
  Returns:
    A pointer to the point array.
  Remarks.
    onrealloc() is used to grow the block of memory.
    Do NOT free the pointer returned by GrowMemory().
    ~ON_Workspace() will free the memory.  If you decide
    you want to keep the memory block, pass the pointer
    to KeepMemory before ~ON_Workspace is called.
  See Also:
    ON_Workspace::GetPointMemory
    ON_Workspace::KeepMemory
  */
  ON_3dPoint* GrowPointMemory( ON_3dPoint* ptr, size_t count );

  /*
  Description:
    Grows the array of vectors that was allocated by
    GetVectorMemory or GrowVectorMemory.
  Parameters:
    ptr - [in] pointer returned by an earlier call to
               GetVectorMemory or GrowVectorMemory.
    count - [in] (>0) number of vectors in memory block.
              If count <= 0, then NULL is returned.
              If ptr was not allocated by this ON_Workspace
              class, then NULL is returned.
  Returns:
    A pointer to the vector array.
  Remarks.
    onrealloc() is used to grow the block of memory.
    Do NOT free the pointer returned by GrowMemory().
    ~ON_Workspace() will free the memory.  If you decide
    you want to keep the memory block, pass the pointer
    to KeepMemory before ~ON_Workspace is called.
  See Also:
    ON_Workspace::GetVectorMemory
    ON_Workspace::KeepMemory
  */
  ON_3dVector* GrowVectorMemory( ON_3dVector* ptr, size_t count );

  /*
  Description:
    Calling the KeepMemory() function with a pointer 
    returned from one of the Get...() or Grow...() calls 
    keeps the workspace destructor from freeing the memory.
    After calling KeepMemory(), you can no longer use
    Grow...() on the pointer.  The caller is responsible 
    for using onfree() to release the memory when it is no
    longer needed.
  Parameters:
    ptr - [in] pointer returned by a Get...() or Grow()
               call to this ON_Workspace.
  Returns:
    True if the pointer was successfully found and removed
    from this ON_Workspace.
  See Also:
    ON_Workspace::~ON_Workspace
    ON_Workspace::GetMemory
    ON_Workspace::KeepAllMemory
  */
  ON_BOOL32 KeepMemory( void* ptr );

  /*
  Description:
    Calling KeepAllMemory() has the same effect as calling
    KeepMemory(p) for every active allocation in the workspace.
    After calling KeepAllMemory(), you can no longer use
    Grow...() on the pointers and you are responsible 
    for using onfree() to release the memory when it is no
    longer needed.
  See Also:
    ON_Workspace::~ON_Workspace
    ON_Workspace::GetMemory
    ON_Workspace::KeepMemory
  */
  void KeepAllMemory();

  /*
  Description:
    Uses ON::OpenFile to open a file.  ~ON_Workspace will
    close the file.
  Parameters:
    filename - [in] name of file
    filemode - [in] open mode (just like second argument to fopen).
  Returns:
    Pointer to opened file.
  Remarks:
    ~ON_Workspace will close the file.
  See Also:
    ON_Workspace::~ON_Workspace
    ON_Workspace::KeepFile
    ON::OpenFile
  */
  FILE* OpenFile(
          const char* filename, 
          const char* filemode
          );

  /*
  Description:
    Uses ON::OpenFile to open a file.  ~ON_Workspace will
    close the file.
  Parameters:
    filename - [in] name of file
    filemode - [in] open mode (just like second argument to _wfopen).
  Returns:
    Pointer to opened file.
  Remarks:
    ~ON_Workspace will close the file.
  See Also:
    ON_Workspace::~ON_Workspace
    ON_Workspace::KeepFile
    ON::OpenFile
  */
  FILE* OpenFile(
          const wchar_t* filename, 
          const wchar_t* filemode
          );

  /*
  Description:
    If you want to prevent ~ON_Workspace from closing a file
    that was opened with ON_Workspace::OpenFile, then pass
    the returned FILE pointer to KeepFile.  After calling
    KeepFile, the caller is responsible for calling
    ON::CloseFile to close the file.
  Parameters:
    fileptr - [in] pointer returned by OpenFile.
  Returns:
    True if file was successfully closed.
  See Also:
    ON_Workspace::~ON_Workspace
    ON_Workspace::OpenFile
    ON::OpenFile
    ON::CloseFile
  */
  int KeepFile(FILE* fileptr);

private:
  struct ON_Workspace_FBLK * m_pFileBlk;
  struct ON_Workspace_MBLK * m_pMemBlk;

private:
  // There is no implementation of the following to prevent use.
  // ON_Workspaces should never be copied, or you will get
  // multiple attempts to free the same pointer.
  ON_Workspace( const ON_Workspace& );
  ON_Workspace& operator=( const ON_Workspace& );
};


#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(ON_PLANE_INC_)
#define ON_PLANE_INC_

class ON_CLASS ON_Plane
{
public:

  /*
  Description:
    The default constructor creates a plane
    with orgin=(0,0,0), xaxis=(1,0,0), yaxis=(0,1,0)
    zaxis=(0,0,1), and equation=(0,0,1,0).
  */
  ON_Plane();

  /*
  Description:
    Construct a plane from a point and normal vector.
  Parameters:
    origin - [in] point on the plane
    normal - [in] non-zero normal to the plane
  Remarks:
    origin = point, zaxis = unitized normal, xaxis
    xaxis set with xaxis.PerpindicularTo(zaxis).
  See Also:
    ON_Plane::CreateFromNormal
  */
  ON_Plane(
    const ON_3dPoint& origin,
    const ON_3dVector& normal
    );

  /*
  Description:
    Construct a plane from a point, and two vectors in
    the plane.
  Parameters:
    origin - [in] point on the plane
    x_dir - [in] non-zero vector in the plane that
        determines the xaxis direction.
    y_dir - [in] non-zero vector not parallel to x_dir
        that is used to determine the yaxis direction.
        y_dir does not have to be perpendicular to x_dir.
  */
  ON_Plane(
    const ON_3dPoint& origin,
    const ON_3dVector& x_dir,
    const ON_3dVector& y_dir
    );

  /*
  Description:
    Construct a plane from three non-colinear points.
  Parameters:
    origin - [in] point on the plane
    x_point - [in] second point in the plane.
        The xaxis will be parallel to x_point-origin.
    y_point - [in] third point on the plane that is
        not colinear with the first two points.
        yaxis*(y_point-origin) will be > 0.
  */
  ON_Plane(
    const ON_3dPoint& origin,
    const ON_3dPoint& x_point,
    const ON_3dPoint& y_point
    );

  /*
  Description:
    Construct a plane from an equation.
  Parameters:
    equation - [in] an array of 4 doubles with
       one of equation[0], equation[1], or equation[2]
       being non-zero.
  */
  ON_Plane(
    const double equation[4]
    );

  ~ON_Plane();

  bool operator==(const ON_Plane&) const;
  bool operator!=(const ON_Plane&) const;

  /*
  Description:
    Create a plane from a point and normal vector.
  Parameters:
    origin - [in] point on the plane
    normal - [in] non-zero normal to the plane
  Remarks:
    origin = point, zaxis = unitized normal, xaxis
    xaxis set with xaxis.PerpindicularTo(zaxis).
  Returns:
    true if valid plane is created.
  */
  bool CreateFromNormal(
    const ON_3dPoint& origin,
    const ON_3dVector& normal
    );

  /*
  Description:
    Construct a plane from a point, and two vectors in
    the plane.
  Parameters:
    origin - [in] point on the plane
    x_dir - [in] non-zero vector in the plane that
        determines the xaxis direction.
    y_dir - [in] non-zero vector not parallel to x_dir
        that is used to determine the yaxis direction.
        y_dir does not have to be perpendicular to x_dir.
  Returns:
    true if valid plane is created.
  */
  bool CreateFromFrame(
    const ON_3dPoint& origin,
    const ON_3dVector& x_dir,
    const ON_3dVector& y_dir
    );

  /*
  Description:
    Construct a plane from three non-colinear points.
  Parameters:
    origin - [in] point on the plane
    point_on_x - [in] second point in the plane.
        The xaxis will be parallel to x_point-origin.
    point_on - [in] third point on the plane that is
        not colinear with the first two points.
        yaxis*(y_point-origin) will be > 0.
  Returns:
    true if valid plane is created.
  */
  bool CreateFromPoints(
    const ON_3dPoint& origin,
    const ON_3dPoint& point_on_x,
    const ON_3dPoint& point_on
    );

  /*
  Description:
    Construct a plane from an equation.
  Parameters:
    equation - [in] an array of 4 doubles with
       one of equation[0], equation[1], or equation[2]
       being non-zero.
  Remarks:
    points on the plane will satisfy 
    x*equation[0] +y*equation[1] + z*equation[2] + equation[3] = 0
  Returns:
    true if valid plane is created.
  */
  bool CreateFromEquation( 
    const double equation[4]
    );

  /*
  Description:
    Test plane to see if it is valid.
  Returns:
    true if all fields contain reasonable
    information and equation jibes with point and zaxis.
  */
  bool IsValid() const;

  /*
  Returns:
    Plane origin.
  */
  const ON_3dPoint& Origin() const;

  /*
  Returns:
    Plane unit x-axis.
  */
  const ON_3dVector& Xaxis() const;

  /*
  Returns:
    Plane unit y-axis.
  */
  const ON_3dVector& Yaxis() const;

  /*
  Returns:
    Plane unit normal.
  */
  const ON_3dVector& Normal() const;


  /*
  Description:
    Set the origin and update the plane equation
  Parameters:
    origin - [in] the new origin
  */
  void SetOrigin( const ON_3dPoint& origin );
  
  /*
  Description:
    Evaluate a point on the plane
  Parameters:
    u - [in]
    v - [in] evaulation parameters
  Returns:
    plane.origin + u*plane.xaxis + v*plane.yaxis
  */
  ON_3dPoint PointAt(
    double u,
    double v
    ) const;

  /*
  Description:
    Evaluate a point on the plane
  Parameters:
    u - [in]
    v - [in] evaluation parameters
    w - [in] elevation parameter
  Returns:
    plane.origin + u*plane.xaxis + v*plane.yaxis + z*plane.zaxis
  */
  ON_3dPoint PointAt(
    double u,
    double v,
    double w
    ) const;

  /*
  Description:
    Get an isoparameteric line on the plane.
  Parameters:
    dir - [in] direction of iso-parametric line
        0: first parameter varies and second parameter is constant
           e.g., line(t) = plane(t,c)
        1: first parameter is constant and second parameter varies
           e.g., line(t) = plane(c,t)
    c - [in] value of constant parameter 
  Returns:
    iso-parametric line
  */
  ON_Line IsoLine(
         int dir,
         double c
         ) const;

  /*
  Description:
    Get signed distance from the plane to a point.
  Parameters:
    point - [in]
  Returns:
    Signed distance from a point to a plane.
  Remarks:
    If the point is on the plane, the distance is 0.
    If the point is above the plane, the distance is > 0.
    If the point is below the plane the distance is < 0.
    The zaxis determines the plane's orientation.
  */
  double DistanceTo( 
        const ON_3dPoint& point
        ) const;


  bool GetDistanceToBoundingBox(
           //returns false if plane has zero length normal
				   const ON_BoundingBox&, // Box

           //output
				   double* min,    // min signed dist from plane to box 
           double* max     //max signed dist from plane to box
           ) const;

  /*
  Description:
    Update the plane equation based on the current values
    of the origin and zaxis.
  Returns:
    true if successful.  false if zaxis is zero.
  Remarks:
    If you modify a plane's origin or zaxis, call UpdateEquation()
    to set equation[]. 
  */
  bool UpdateEquation();

  /*
  Description:
    Get point on plane that is closest to a given point.
  Parameters:
    world_point - [in] 3d point
    u - [out] 
    v - [out] The point ON_Plane::PointAt(*u,*v) is the point
              on the plane that is closest to world_point.
  Returns:
    true if successful.
  */
  bool ClosestPointTo( 
         ON_3dPoint world_point,
         double* u,
         double* v
         ) const;

  /*
  Description:
    Get point on plane that is closest to a given point.
  Parameters:
    point - [in]
  Returns:
    A 3d point on the plane that is closest to world_point.
  */
  ON_3dPoint ClosestPointTo( 
         ON_3dPoint point
         ) const;

  // For intersections see ON_Intersect();

  /*
  Description:
    Transform plane.
  Parameters:
    xform - [in] transformation to apply to plane
  Returns:
    true if successful
  */
  bool Transform( 
        const ON_Xform& xform
        );

  /*
  Description:
    Transform a plane by swapping coordinates.
  Parameters:
    i - [in]
    j - [in] indices of coordinates to swap.
        0 = x coordinate, 1 = y coordinate, 2 = z coordinate.
  Returns:
    true if successful.
  */
  bool SwapCoordinates(
        int i,
        int j
        );

  /*
  Description:
    Rotate a plane about its origin.
  Parameters:
    sin_angle - [in] sine of rotation angle
    cos_angle - [in] cosine of rotation angle
    axis - [in] axis of rotation
  Returns:
    true if successful
  */
  bool Rotate(
        double sin_angle,
        double cos_angle,
        const ON_3dVector& axis
        );

  /*
  Description:
    Rotate a plane about its origin.
  Parameters:
    angle - [in] rotation angle in radians
    axis - [in] axis of rotation
  Returns:
    true if successful
  */
  bool Rotate(
        double angle,
        const ON_3dVector& axis
        );

  /*
  Description:
    Rotate a plane about a point.
  Parameters:
    sin_angle - [in] sine of rotation angle
    cos_angle - [in] cosine of rotation angle
    axis - [in] axis of rotation
    center - [in] center of rotation
  Returns:
    true if successful
  */
  bool Rotate(
        double sin_angle,
        double cos_angle,
        const ON_3dVector& axis,
        const ON_3dPoint&  center
        );

  /*
  Description:
    Rotate a plane about a point.
  Parameters:
    angle - [in] rotation angle in radians
    axis - [in] axis of rotation
    center - [in] center of rotation
  Returns:
    true if successful
  */
  bool Rotate(
        double angle,
        const ON_3dVector& axis,
        const ON_3dPoint& center
        );

  /*
  Description:
    Translate a plane.
  Parameters:
    delta - [in] translation vector
  Returns:
    true if successful
  */
  bool Translate(
        const ON_3dVector&  delta
        );

  /*
  Description:
    Flip plane orientation by swapping x and y axes,
    reversing the zaxis, and updating the equation.
  Returns:
    true if successful
  */
  bool Flip();

// world plane coordinate system ON_Plane(ON_origin, ON_xaxis, ON_yaxis); 
	const static
	ON_Plane World_xy;	

public:
  // origin of plane
  ON_3dPoint  origin;

  // unit X axis of plane
  ON_3dVector xaxis;

  // unit Y axis of plane
  ON_3dVector yaxis;

  // unit Z axis of plane
  ON_3dVector zaxis;

  // equation of plane
  ON_PlaneEquation plane_equation;
  //double equation[4];
};

class ON_CLASS ON_ClippingPlaneInfo
{
public:
  // C++ defaults for construction, destruction, copy construction
  // and operator= work fine.

  // A point is visible if m_plane_equation.ValueAt(point) <= 0.
  // (This is the opposite convention from what OpenGL uses.)
  ON_PlaneEquation m_plane_equation;
  ON_UUID m_plane_id;
  bool m_bEnabled;

  void Default();
  bool Write( ON_BinaryArchive& ) const;
  bool Read( ON_BinaryArchive& );
};

class ON_CLASS ON_ClippingPlane
{
public:
  ON_ClippingPlane();
  ~ON_ClippingPlane();

  void Default();

  ON_Plane m_plane;
  ON_UuidList m_viewport_ids; //ids of viewports that this clipping plane "clips"
  ON_UUID m_plane_id;
  bool m_bEnabled; // true if this clipping plane is active

  ON_ClippingPlaneInfo ClippingPlaneInfo() const;

  bool Read( class ON_BinaryArchive& );
  bool Write( class ON_BinaryArchive& ) const;
};


#if defined(ON_DLL_TEMPLATE)

// This stuff is here because of a limitation in the way Microsoft
// handles templates and DLLs.  See Microsoft's knowledge base 
// article ID Q168958 for details.
#pragma warning( push )
#pragma warning( disable : 4231 )
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_Plane>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ON_ClippingPlane>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_ClippingPlaneInfo>;
#pragma warning( pop )

#endif

extern ON_EXTERN_DECL const ON_Plane ON_xy_plane;
extern ON_EXTERN_DECL const ON_Plane ON_yz_plane;
extern ON_EXTERN_DECL const ON_Plane ON_zx_plane;

/*
Description:
  Get a convex hull of a set of 3d points.
Parameters:
  points - [in]
    List of points.  This function can handle tens of points
    but is too slow for hundreds of points.
  hull -[out]
    Equations of the sides of the convex hull are appended to
    this list.  
    A point P is inside the hull if hull[i].ValueAt(P) <= 0 for
    every plane equation.
Returns:
  Number of equations appended to hull[] array.
  If 0, then the points are coincident or colinear.
  If 2, then the points are coplanar and the returned
  planes are parallel.
  If >= 4, then the points are in a 3d convex hull.
*/
ON_DECL
int ON_Get3dConvexHull( 
          const ON_SimpleArray<ON_3dPoint> & points, 
          ON_SimpleArray<ON_PlaneEquation> & hull 
          );

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(ON_CIRCLE_INC_)
#define ON_CIRCLE_INC_

class ON_NurbsCurve;

/*
Description:
	ON_Circle is a circle in 3d.  The cirle is represented by a radius and an 
	orthonormal frame	of the plane containing the circle, with origin at the center.

	An Is_Valid() circle has positive radius and an Is_ Valid() plane defining the frame.
	
	The circle is parameterized by radians from 0 to 2 Pi given by 
     t -> center + cos(t)*radius*xaxis + sin(t)*radius*yaxis	
	where center, xaxis and yaxis define the orthonormal frame of the circle's plane.  
*/
class ON_CLASS ON_Circle
{
public:
  // Creates a radius one circle with center (0,0,0)
  // in the world XY plane
  ON_Circle();

  // Creates a circle in the plane with center at
  // plane.origin.
  ON_Circle(
    const ON_Plane& plane,
    double radius
    );

  // Creates a circle parallel to the world XY plane
  // with given center and radius
  ON_Circle(
    const ON_3dPoint& center,
    double radius
    );

  // Creates a circle parallel to the plane
  // with given center and radius.
  ON_Circle(
    const ON_Plane& plane,
    const ON_3dPoint& center,
    double radius
    );

  // Create a circle through three 2d points.
  // The start/end of the circle is at point P.
  ON_Circle( // circle through 3 2d points
    const ON_2dPoint& P,
    const ON_2dPoint& Q,
    const ON_2dPoint& R
    );

  // Create a circle through three 3d points.
  // The start/end of the circle is at point P.
  ON_Circle(
    const ON_3dPoint& P,
    const ON_3dPoint& Q,
    const ON_3dPoint& R
    );

  ~ON_Circle();

  // Creates a circle in the plane with center at
  // plane.origin.
  bool Create(
    const ON_Plane& plane,
    double radius
    );

  // Creates a circle parallel to the world XY plane
  // with given center and radius
  bool Create(
    const ON_3dPoint& center,
    double radius
    );

  // Creates a circle parallel to the plane
  // with given centr and radius.
  bool Create(
    const ON_Plane& plane,
    const ON_3dPoint& center,
    double radius
    );

  // Create a circle through three 2d points.
  // The start/end of the circle is at point P.
  bool Create( // circle through 3 2d points
    const ON_2dPoint& P,
    const ON_2dPoint& Q,
    const ON_2dPoint& R
    );

  // Create a circle through three 3d points.
  // The start/end of the circle is at point P.
  bool Create(
    const ON_3dPoint& P,
    const ON_3dPoint& Q,
    const ON_3dPoint& R
    );

  // Create a circle from two 2d points and a 
  // tangent at the first point.
  // The start/end of the circle is at point P.
  bool Create(
    const ON_2dPoint& P,
    const ON_2dVector& tangent_at_P,
    const ON_2dPoint& Q
    );

  // Create a circle from two 3d points and a 
  // tangent at the first point.
  // The start/end of the circle is at point P.
  bool Create(
    const ON_3dPoint& P,
    const ON_3dVector& tangent_at_P,
    const ON_3dPoint& Q
    );

	//	A Valid circle has m_radius>0 and m_plane.IsValid().
  bool IsValid() const;

  //bool UpdatePoints();  // sets m_point[] to have valid points

  bool IsInPlane( const ON_Plane&, double = ON_ZERO_TOLERANCE ) const;

  double Radius() const;
  double Diameter() const;
  double Circumference() const;
  const ON_3dPoint& Center() const;
  const ON_3dVector& Normal() const;
  const ON_Plane& Plane() const; // plane containing circle

  ON_BoundingBox BoundingBox() const;

  /*
	Description:
    Get tight bounding box.
	Parameters:
		tight_bbox - [in/out] tight bounding box
		bGrowBox -[in]	(default=false)			
      If true and the input tight_bbox is valid, then returned
      tight_bbox is the union of the input tight_bbox and the 
      arc's tight bounding box.
		xform -[in] (default=NULL)
      If not NULL, the tight bounding box of the transformed
      arc is calculated.  The arc is not modified.
	Returns:
    True if a valid tight_bbox is returned.
  */
	bool GetTightBoundingBox( 
			ON_BoundingBox& tight_bbox, 
      int bGrowBox = false,
			const ON_Xform* xform = 0
      ) const;

  bool Transform( const ON_Xform& );

  // Circles use trigonometric parameterization
  // t -> center + cos(t)*radius*xaxis + sin(t)*radius*yaxis
  ON_3dPoint PointAt( 
    double // evaluation parameter
    ) const;
  ON_3dVector DerivativeAt( 
    int,   // derivative (>=0)
    double // evaluation parameter
    ) const;

  ON_3dVector TangentAt(double) const;

  // returns parameters of point on circle that is closest to given point
  bool ClosestPointTo( 
         const ON_3dPoint& point, 
         double* t
         ) const;

  // returns point on circle that is closest to given point
  ON_3dPoint ClosestPointTo( 
         const ON_3dPoint& point
         ) const;

  // evaluate circle's implicit equation in plane
  double EquationAt( const ON_2dPoint& plane_point ) const;

  ON_2dVector GradientAt( const ON_2dPoint& plane_point ) const;

  // rotate circle about its center
  bool Rotate(
        double sin_angle,
        double cos_angle,
        const ON_3dVector& axis_of_rotation
        );

  bool Rotate(
        double angle_in_radians,
        const ON_3dVector&  axis_of_rotation
        );

  // rotate circle about a point and axis
  bool Rotate(
        double sin_angle,
        double cos_angle,
        const ON_3dVector& axis_of_rotation,
        const ON_3dPoint& center_of_rotation
        );

  bool Rotate(
        double angle_in_radians,
        const ON_3dVector&  axis_of_rotation,
        const ON_3dPoint& center_of_rotation
        );

  bool Translate(
        const ON_3dVector& delta
        );

  bool Reverse();

  // Description:
  //   Get a four span rational degree 2 NURBS circle representation
  //   of the circle.
  // Returns:
  //   2 for success, 0 for failure
  // Remarks:
  //   Note that the parameterization of NURBS curve
  //   does not match  circle's transcendental paramaterization.  
  //   Use ON_Circle::GetRadianFromNurbFormParameter() and
  //   ON_Circle::GetParameterFromRadian() to convert between 
  //   the NURBS curve parameter and the transcendental parameter.
  int GetNurbForm(
        ON_NurbsCurve& nurbs_curve
        ) const; 

  /*
  Description:
    Convert a NURBS curve circle parameter to a circle radians parameter.
  Parameters:
    nurbs_parameter - [in]
    circle_radians_parameter - [out]
  Example:

          ON_Circle circle = ...;
          double nurbs_t = 1.2345; // some number in interval (0,2.0*ON_PI).
          double circle_t;
          circle.GetRadianFromNurbFormParameter( nurbs_t, &circle_t );

          ON_NurbsCurve nurbs_curve;
          circle.GetNurbsForm( nurbs_curve );
          circle_pt = circle.PointAt(circle_t);
          nurbs_pt = nurbs_curve.PointAt(nurbs_t);
          // circle_pt and nurbs_pt will be the same

  Remarks:
    The NURBS curve parameter is with respect to the NURBS curve
    created by ON_Circle::GetNurbForm.  At nurbs parameter values of 
    0.0, 0.5*ON_PI, ON_PI, 1.5*ON_PI, and 2.0*ON_PI, the nurbs
    parameter and radian parameter are the same.  At all other
    values the nurbs and radian parameter values are different.
  See Also:
    ON_Circle::GetNurbFormParameterFromRadian
  */
  bool GetRadianFromNurbFormParameter(
        double nurbs_parameter,
        double* circle_radians_parameter
        ) const;

  /*
  Description:
    Convert a circle radians parameter to a NURBS curve circle parameter.
  Parameters:
    circle_radians_parameter - [in] 0.0 to 2.0*ON_PI
    nurbs_parameter - [out]
  Example:

          ON_Circle circle = ...;
          double circle_t = 1.2345; // some number in interval (0,2.0*ON_PI).
          double nurbs_t;
          circle.GetNurbFormParameterFromRadian( circle_t, &nurbs_t );

          ON_NurbsCurve nurbs_curve;
          circle.GetNurbsForm( nurbs_curve );
          circle_pt = circle.PointAt(circle_t);
          nurbs_pt = nurbs_curve.PointAt(nurbs_t);
          // circle_pt and nurbs_pt will be the same

  Remarks:
    The NURBS curve parameter is with respect to the NURBS curve
    created by ON_Circle::GetNurbForm.  At radian values of 
    0.0, 0.5*ON_PI, ON_PI, 1.5*ON_PI, and 2.0*ON_PI, the nurbs
    parameter and radian parameter are the same.  At all other
    values the nurbs and radian parameter values are different.
  See Also:
    ON_Circle::GetNurbFormParameterFromRadian
  */
  bool GetNurbFormParameterFromRadian(
        double circle_radians_parameter,
        double* nurbs_parameter
        ) const;

public:
  // circle is in the plane with center at plane.m_origin.
  ON_Plane   plane;  
  double     radius;   // radius
  //ON_3dPoint m_point[3]; // 3 points on the circle
};


#endif

/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_ELLIPSE_INC_)
#define OPENNURBS_ELLIPSE_INC_

class ON_Ellipse;
class ON_Plane;

class ON_CLASS ON_Ellipse
{
public:
  ON_Ellipse(); // zeros all fields - plane is invalid

  ON_Ellipse(
    const ON_Plane&,
    double, double     // radii for x and y vectors
    );

  ON_Ellipse(
    const ON_Circle&
    );

  ~ON_Ellipse();

  ON_Ellipse& operator=(const ON_Circle&);

  ON_BOOL32 Create(
    const ON_Plane&,  // point on the plane
    double, double     // radii for x and y vectors
    );

  ON_BOOL32 Create(
    const ON_Circle&
    );

  ON_BOOL32 IsValid() const; // returns true if all fields contain reasonable
                        // information and equation jibes with point and Z.

  ON_BOOL32 IsCircle() const; // returns true is ellipse is a circle

  double Radius( 
    int // 0 = x axis radius, 1 = y axis radius
    ) const; 
  const ON_3dPoint& Center() const;
  const ON_3dVector& Normal() const;
  const ON_Plane& Plane() const; // plane containing ellipse

  /*
  Returns:
    Distance from the center to a focus, commonly called "c".
  */
  double FocalDistance() const;

  bool GetFoci( ON_3dPoint& F1, ON_3dPoint& F2 ) const;

  // Evaluation uses the trigonometrix parameterization
  // t -> plane.origin + cos(t)*radius[0]*plane.xaxis + sin(t)*radius[1]*plane.yaxis
  // evaluate parameters and return point
  ON_3dPoint  PointAt( double ) const;
  ON_3dVector DerivativeAt( 
                 int, // desired derivative ( >= 0 )
                 double // parameter
                 ) const;

  ON_3dVector TangentAt( double ) const;  // returns unit tangent
  ON_3dVector CurvatureAt( double ) const;  // returns curvature vector

  // returns parameters of point on ellipse that is closest to given point
  ON_BOOL32 ClosestPointTo( 
         const ON_3dPoint&, 
         double*
         ) const;
  // returns point on ellipse that is closest to given point
  ON_3dPoint ClosestPointTo( 
         const ON_3dPoint& 
         ) const;

  // evaluate ellipse's implicit equation in plane
  double EquationAt( const ON_2dPoint& ) const;
  ON_2dVector GradientAt( const ON_2dPoint& ) const;

  // rotate ellipse about its center
  ON_BOOL32 Rotate(
        double,              // sin(angle)
        double,              // cos(angle)
        const ON_3dVector&  // axis of rotation
        );
  ON_BOOL32 Rotate(
        double,              // angle in radians
        const ON_3dVector&  // axis of rotation
        );

  // rotate ellipse about a point and axis
  ON_BOOL32 Rotate(
        double,              // sin(angle)
        double,              // cos(angle)
        const ON_3dVector&, // axis of rotation
        const ON_3dPoint&   // center of rotation
        );
  ON_BOOL32 Rotate(
        double,              // angle in radians
        const ON_3dVector&, // axis of rotation
        const ON_3dPoint&   // center of rotation
        );

  ON_BOOL32 Translate(
        const ON_3dVector&
        );

  // parameterization of NURBS curve does not match ellipse's transcendental paramaterization
  int GetNurbForm( ON_NurbsCurve& ) const; // returns 0=failure, 2=success

public: // members left public
  // The center of the ellipse is at the plane's origin.  The axes of the
  // ellipse are the plane's x and y axes. The equation of the ellipse 
  // with respect to the plane is (x/m_r[0])^2 + (y/m_r[1])^2 = 1;
  ON_Plane plane;
  double radius[2]; // radii for x and y axes (both must be > 0)
};

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2007 Robert McNeel & Associates. All rights reserved.
// Rhinoceros is a registered trademark of Robert McNeel & Assoicates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_X_INC_)
#define OPENNURBS_X_INC_

// The ON_X_EVENT class is used to report curve-curve and curve-surface
// intersection events.
class ON_CLASS ON_X_EVENT
{
  // NO VIRTUAL FUNCTIONS IN THIS CLASS
public:
  
  // Default construction sets everything to zero.
  ON_X_EVENT();

  // This class must use default copy constructor, operator=, and destructor.

  /*
  Description:
    Compares intersection events and sorts them in the 
    canonical order.
  Returns:
    @untitled table
    -1    this  < other
     0    this == other
    +1    this  > other
  Remarks:
    ON_CX_EVENT::Compare is used to sort intersection events into canonical
    order.
  */
  static
  int Compare( const ON_X_EVENT* a, const ON_X_EVENT* b );

  void Dump(ON_TextLog& text_log) const;

  /*
  Description:
    Check intersection event values to make sure they are valid.
  Parameters:
    text_log - [in] If not null and an error is found, then a description
                    of the error is printed to text_log.
    intersection_tolerance - [in] 
         0.0 or value used in intersection calculation.
    overlap_tolerance - [in] 
         0.0 or value used in intersection calculation.
    curveA - [in] 
         NULL or curveA passed to intersection calculation.
    curveA_domain - [in] 
         NULL or curveA domain used in intersection calculation.
    curveB - [in]
         NULL or curveB passed to intersection calculation.
    curveB_domain - [in]
         NULL or curveB domain used in intersection calculation.
    surfaceB - [in]
         NULL or surfaceB passed to intersection calculation.
    surfaceB_domain0 - [in]
         NULL or surfaceB "u" domain used in intersection calculation.
    surfaceB_domain1 - [in]
         NULL or surfaceB "v" domain used in intersection calculation.
  Returns:
    True if event is valid.
  */
  bool IsValid(
          ON_TextLog* text_log,
          double intersection_tolerance,
          double overlap_tolerance,
          const class ON_Curve* curveA,
          const class ON_Interval* curveA_domain,
          const class ON_Curve* curveB,
          const class ON_Interval* curveB_domain,
          const class ON_Surface* surfaceB,
          const class ON_Interval* surfaceB_domain0,
          const class ON_Interval* surfaceB_domain1
          ) const;


  /*
  Description:
    Expert user tool to copy portions of the itersection
    event information from one event to another.  
    If src.m_type is ON_X_EVENT::csx_*, then the
    m_b[] and m_nodeB_t[] values are treated as
    surface parameters, otherwise the values are
    treated as curve parameters.  The m_type field
    is not copied.
  Parameters:
    src - [in]
    src_end - [in] 0 or 1 (m_A[] source index)
    dst - [out]
    dst_end - [in] 0 or 1 (m_A[] destination index)
  */
  static 
  void CopyEventPart(
        const ON_X_EVENT& src, 
        int src_end,
        ON_X_EVENT& dst, 
        int dst_end 
        );

  /*
  Description:
    Expert user tool to cleanup a list of intersection 
    events.
  Parameters:
    event_tolerance - [in] If the distance between
      events is <= event_tolerance, they will
      be considered to be the same event.  Typically,
      event_tolerance is "small" and
      event_tolerance <= intersection_tolerance.

    overlap_tolerance - [in] minimum length for an
      intersection overlap segment. Typically,
      overlap_tolerance is "large" and
      overlap_tolerance > intersection_tolerance

    xevent_count - [in]
    xevent - [in/out]
  Returns:
    Length of cleaned list.
  */
  static
  int CleanList(
          double event_tolerance,
          double overlap_tolerance,
          int xevent_count,
          ON_X_EVENT* xevent
          );

  /*
  Description:
    Expert user tool to check a list of intersection events.
  Parameters:
    xevent_count - [in]
    xevent - [in]
    text_log - [in] NULL or place to describe errors.
    intersection_tolerance - [in]
    overlap_tolerance - [in]
    curveA - [in]
    curveA_domain - [in] (can be NULL)
    curveB - [in] (NULL for curve-surface intersection events)
    curveB_domain - [in] (can be NULL)
    surfaceB - [in] (NULL for curve-curve intersection events)
    surfaceB_domain0 - [in] (can be NULL)
    surfaceB_domain1 - [in] (can be NULL)
  Returns:
    True if list is valid.
  */
  static
  bool IsValidList(
          int xevent_count,
          const ON_X_EVENT* xevent,
          ON_TextLog* text_log,
          double intersection_tolerance,
          double overlap_tolerance,
          const class ON_Curve* curveA,
          const class ON_Interval* curveA_domain,
          const class ON_Curve* curveB,
          const class ON_Interval* curveB_domain,
          const class ON_Surface* surfaceB,
          const class ON_Interval* surfaceB_domain0,
          const class ON_Interval* surfaceB_domain1
          );

  /*
  Description:
    Do a quick and simple test to see if this curve
    lies on some portion of curveB.
  Parameters:
    curveA_domain - [in] non empty interval
    sample_count - [in] minimum number of test points
    overlap_tolerance - [in]
    cnodeA - [in]
    cnodeB - [in]
    curveB_domain - [in] optional domain restriction
  Returns:
    True if sections overlap.
  */
  static
  bool IsValidCurveCurveOverlap( 
        ON_Interval curveA_domain,
        int sample_count,
        double overlap_tolerance,
        const class ON_CurveTreeNode* cnodeA, 
        const class ON_CurveTreeNode* cnodeB,
        const ON_Interval* curveB_domain = 0
        );

  /*
  Description:
    Do a quick and simple test to see if this curve
    lies on the plane.
  Parameters:
    curveA_domain - [in]  non empty interval
    sample_count - [in] minimum number of test points
    endpont_tolerance - [in] tolerance to use when checking ends
    overlap_tolerance - [in] tolerance to use when checking interior
    cnodeA - [in]
    plane_equation - [in]
  Returns:
    True if curve lies on the plane
  */
  static 
  bool IsValidCurvePlaneOverlap( 
        ON_Interval curveA_domain,
        int sample_count,
        double endpoint_tolerance,
        double overlap_tolerance,
        const class ON_CurveTreeNode* cnodeA,
        const ON_PlaneEquation* plane_equation
        );

  /*
  Description:
    Do a quick and simple test to see if this curve
    lies on the surface.
  Parameters:
    curveA_domain - [in]  non empty interval
    sample_count - [in] minimum number of test points
    overlap_tolerance - [in]
    cnodeA - [in]
    snodeB - [in]
    surfaceB_udomain - [in] optional domain restriction
    surfaceB_vdomain - [in] optional domain restriction
  Returns:
    True if sections overlap.
  */
  static 
  bool IsValidCurveSurfaceOverlap( 
        ON_Interval curveA_domain,
        int sample_count,
        double overlap_tolerance,
        const class ON_CurveTreeNode* cnodeA, 
        const class ON_SurfaceTreeNode* snodeB,
        const ON_Interval* surfaceB_udomain = 0,
        const ON_Interval* surfaceB_vdomain = 0
        );

  /*
  Description:
    Convert input intersection tolerance to value used
    in calculations.
  Parameters:
    intersection_tolerance - [in]
  Returns:
    Value use in intersection calculations.
  */
  static
  double IntersectionTolerance( double intersection_tolerance );

  /*
  Description:
    Convert input intersection tolerance to value used
    in calculations.
  Parameters:
    intersection_tolerance - [in]
  Returns:
    Value use in intersection calculations.
  */
  static
  double OverlapTolerance( double intersection_tolerance, double overlap_tolerance );

  /*
  Returns:
    True if m_type is ccx_point or csx_point.
  */
  bool IsPointEvent() const;

  /*
  Returns:
    True if m_type is ccx_overlap or csx_overlap.
  */
  bool IsOverlapEvent() const;

  /*
  Returns:
    True if m_type is ccx_point or ccx_overlap
  */
  bool IsCCXEvent() const;

  /*
  Returns:
    True if m_type is csx_point or csx_overlap
  */
  bool IsCSXEvent() const;


  enum TYPE
  { 
    no_x_event  =  0,

    // Two valid event types for curve-curve intersections
    ccx_point   =  1, // curve-curve transverse intersection point
    ccx_overlap =  2, // curve-curve intersection overlap

    // Two valid event types for curve-surface intersections
    csx_point   =  3, // curve-surface transverse intersection point
    csx_overlap =  4  // curve-surface intersection overlap
  };

  // Event directions for use in the m_dirA[] and m_dirB[]
  // fields. The "x_from_*" values are used to report the 
  // behavior of the curve as it enters the intersection 
  // event. The "x_to_*" values are used to report the 
  // behavior of the curve as it leaves the intersection
  // event.
  enum DIRECTION
  { 
    no_x_dir       = 0, 

    at_end_dir     = 1, // event is at the start/end/side of object's
                        // parameter space

    from_above_dir = 2, // curve enters x-event from above surface/other curve
    from_below_dir = 3, // curve enters x-event from below surface/other curve
    from_on_dir    = 4, // curve enters x-event tangent surface/other curve

    to_above_dir   = 5, // curve leaves x-event above surface/other curve
    to_below_dir   = 6, // curve leaves x-event below surface/other curve
    to_on_dir      = 7  // curve leaves x-event tangent to surface/other curve
  };

  // This field is a scratch field for users.
  // The constructor sets it to zero and the 
  // intersectors never use it.
  ON_U m_user;

  // The m_type field determines how the values in the other
  // fields are interpreted.  See the detailed comment below
  // for complete informtion
  TYPE m_type;

  ON_3dPoint m_A[2]; // intersection points on first curve
  ON_3dPoint m_B[2]; // intersection points on second curve or surface
  double m_a[2];     // intersection parameters on first curve
  double m_b[4];     // intersection parameters on second curve or surface
  
  // There are cases when it is valuable to have direction
  // flags on intersection events.  The m_dirA[] and m_dirB[]
  // fields provide a place to store these flags.  Because this
  // information is rarely used, it is not computed by the
  // intersection routines.  You can use
  //   ON_SetCurveCurveIntersectionDir 
  // or
  //   ON_SetCurveSurfaceIntersectionDir
  // to fill in these fields.
  DIRECTION m_dirA[2];
  DIRECTION m_dirB[2];

  // tree nodes where the intersection events occured.
  const class ON_CurveTreeNode* m_cnodeA[2];
  double m_nodeA_t[2]; // nodeA bezier paramters corresponding to a[] values 
  const class ON_CurveTreeNode* m_cnodeB[2];
  const class ON_SurfaceTreeNode* m_snodeB[2];
  double m_nodeB_t[4]; // nodeB bezier paramters corresponding to b[] values.

  // Each intersection event is assigned a runtime serial number.
  unsigned int m_x_eventsn;

  /*
  The m_type field determines how the values in the other
  fields are interpreted.

    ccx_point events:
      a[0] = a[1] = first curve parameter
      A[0] = A[1] = intersection point on first curve
      b[0] = b[1] = second curve parmeter
      B[0] = B[1] = intersection point on second curve
      b[2] = b[3] = not used
      cnodeA[0] = cnodeA[1] = pointer to first curve's tree node
      cnodeB[0] = cnodeB[1] = pointer to second curve's tree node
      snodeB[0] = snodeB[1] = 0

    ccx_overlap events:
      (a[0],a[1]) = first curve parameter range (a[0] < a[1])
      A[0] = intersection start point on first curve
      A[1] = intersection end point on first curve
      (b[0],b[1]) = second curve parameter range (b[0] != b[1])
      B[0] = intersection start point on second curve
      B[1] = intersection end point on second curve
      b[2] = b[3] = not used
      cnodeA[0] = pointer to first curve's tree node for start point
      cnodeA[1] = pointer to first curve's tree node for end point
      cnodeB[0] = pointer to second curve's tree node for start point
      cnodeB[1] = pointer to second curve's tree node for end point
      snodeB[0] = snodeB[1] = 0
   
   csx_point events:
      a[0] = a[1] = curve parameter
      A[0] = A[1] = intersection point on curve
      (b[0],b[1]) = (b[2],b[3]) = surface parameter
      B[0] = B[1] intersection point on surface
      cnodeA[0] = cnodeA[1] = pointer to curve's tree node
      cnodeB[0] = cnodeB[1] = 0;
      snodeB[0] = snodeB[1] = pointer to surface's tree node

    csx_overlap events:
      (a[0],a[1]) = curve parmamter range (a[0] < a[1])
      A[0] = intersection start point on first curve
      A[1] = intersection end point on first curve
      (b[0],b[1]) = surface parameter for curve(a[0]).
      B[0] = intersection start point on surface
      (b[2],b[3]) = surface parameter for curve(a[1]).
      B[1] = intersection end point on surface
      cnodeA[0] = pointer to curve's tree node for start point
      cnodeA[1] = pointer to curve's tree node for end point
      snodeB[0] = pointer to surface's tree node for start point
      snodeB[1] = pointer to surface's tree node for end point
  */
};



/*
Description:
  Sets ON_X_EVENT m_dirA[] and m_dirB[] flags for in intersection
  of coplanar curves.  For each  m_dirA[]/m_dirB[] flag that is 
  set to ON_X_EVENT, the curve geometry at the itersection is
  examined to set the flags.
Parameters:
  N [in] normal to the plane
  xcount - [in] number of intersection events
  xevent - [in] array of xcount intersection events
  a0 - [in]
  a1 - [in] (a0,a1) = curveA intersection domain
  b0 - [in]
  b1 - [in] (b0,b1) = curveB intersection domain
See Also:
  ON_Curve::IntersectCurve
  ON_SetCurveSurfaceIntersectionDir
*/
ON_DECL
bool ON_SetCurveCurveIntersectionDir(
            ON_3dVector N,
            int xcount,
            ON_X_EVENT* xevent,
            double a0,
            double a1,
            double b0,
            double b1
            );


/*
Description:
  Sets ON_X_EVENT m_dirA[] and m_dirB[] flags for a curve surface
  intersection.  For each  m_dirA[]/m_dirB[] flag that is 
  set to ON_X_EVENT, the curve and surface geometry at the 
  itersection is examined to set the flags.
Parameters:
  xcount - [in] number of intersection events
  xevent - [in] array of xcount intersection events
  t0 - [in]
  t1 - [in] (t0,t1) = curveA intersection domain
  u0 - [in]
  u1 - [in] (u0,u1) = surfaceB u interesection domain
  v0 - [in]
  v1 - [in] (v0,v1) = surfaceB v interesection domain
Returns:
  << TODO: Add return codes here >>
See Also:
  ON_Curve::IntersectSurface
  ON_SetCurveCurveIntersectionDir
*/
ON_DECL
bool ON_SetCurveSurfaceIntersectionDir(
            int xcount,
            ON_X_EVENT* xevent,
            double t0,
            double t1,
            double u0,
            double u1,
            double v0,
            double v1
            );

// The ON_SSX_EVENT class is used to report surface-surface
// intersection events.
class ON_CLASS ON_SSX_EVENT
{
  // NO VIRTUAL FUNCTIONS IN THIS CLASS
public:
  ON_SSX_EVENT();
  ~ON_SSX_EVENT(); // deletes m_curveA, m_curveB, m_curve3d

  void Dump(ON_TextLog& text_log) const;

  /*
  Description:
    Check intersection event values to make sure they are valid.
  Parameters:
    text_log - [in] If not null and an error is found, then a description
                    of the error is printed to text_log.
    intersection_tolerance - [in] 
         0.0 or value used in intersection calculation.
    overlap_tolerance - [in] 
         0.0 or value used in intersection calculation.
    fitting_tolerance - [in] 
         0.0 or value used in intersection calculation.
    surfaceA - [in] 
         NULL or surfaceA passed to intersection calculation.
    surfaceA_domain0 - [in]
         NULL or surfaceA "u" domain used in intersection calculation.
    surfaceA_domain1 - [in]
         NULL or surfaceA "v" domain used in intersection calculation.
    surfaceB - [in]
         NULL or surfaceB passed to intersection calculation.
    surfaceB_domain0 - [in]
         NULL or surfaceB "u" domain used in intersection calculation.
    surfaceB_domain1 - [in]
         NULL or surfaceB "v" domain used in intersection calculation.
  Returns:
    True if event is valid.
  */
  bool IsValid(
          ON_TextLog* text_log,
          double intersection_tolerance,
          double overlap_tolerance,
          double fitting_tolerance,
          const class ON_Surface* surfaceA,
          const class ON_Interval* surfaceA_domain0,
          const class ON_Interval* surfaceA_domain1,
          const class ON_Surface* surfaceB,
          const class ON_Interval* surfaceB_domain0,
          const class ON_Interval* surfaceB_domain1
          ) const;

  /*
  Returns:
    True if m_type is ssx_transverse_point or ssx_tangent_point.
  See Also:
    ON_SSX_EVENT::IsCurveEvent
    ON_SSX_EVENT::IsTinyEvent
  */
  bool IsPointEvent() const;

  /*
  Returns:
    True if m_type is ssx_transverse or ssx_tangent.
  See Also:
    ON_SSX_EVENT::IsPointEvent
    ON_SSX_EVENT::IsTinyEvent
  */
  bool IsCurveEvent() const;

  /*
  Description:
    This function can be used to detect intersection events
    that are "nearly" points.
  Parameters:
    tiny_tolerance - [in]
  Returns:
    True if 
    m_type is ssx_transverse_point or ssx_tangent_point,
    or,
    m_type is ssx_transverse, ssx_tangent or ssx_overlap
    and length of the longest side of m_curve3d's
    bounding box is <= tiny_tolerance.
  See Also:
    ON_SSX_EVENT::IsPointEvent
    ON_SSX_EVENT::IsCurveEvent
  */
  bool IsTinyEvent(double tiny_tolerance) const;

  /*
  Returns:
    True if m_type is ssx_tangent,  or ssx_tangent_point.
  */
  bool IsTangentEvent() const;

  /*
  Returns:
    True if m_type is ssx_overlap.
  */
  bool IsOverlapEvent() const;

  // This field is a scratch field for users.
  // The constructor sets it to zero and the 
  // intersectors never use it.
  ON_U m_user;

  enum TYPE
  {
    no_ssx_event         = 0,
    ssx_transverse       = 1, // transverse surface-surface intersection curve
    ssx_tangent          = 2, // tangent surface-surface intersection curve
    ssx_overlap          = 3, // overlap surface-surface intersection curve
    ssx_transverse_point = 4, // transverse surface-surface intersection point
    ssx_tangent_point    = 5, // tangent surface-surface intersection point
    ssx_32bit_enum       = 0xFFFFFFFF
  };

  TYPE m_type;

  // If m_type = ssx_transverse, ssx_tangent, or ssx_overlap,
  // then the intersection curves are returned here.  
  // In all cases the 3 curves are compatibly oriented.
  // For ssx_transverse events, the 3d curve direction
  // agrees with SurfaceNormalB x SurfaceNormalA
  // For ssx_tangent events, the orientation is random.
  // For ssx_overlap events, the overlap is to the left of
  // m_curveA.  These curves are deleted by ~ON_SSX_EVENT().
  // If you want to harvest a curve for long term use, set 
  // the pointer to NULL.
  ON_Curve* m_curveA;  // 2d surface A parameter space curve
  ON_Curve* m_curveB;  // 2d surface B parameter space curve
  ON_Curve* m_curve3d; // 3d surface B parameter space curve

  // If m_type = ssx_transverse_point or ssx_tangent_point,
  // the the points are returned here
  ON_3dPoint m_pointA;  // 2d surfaceA parameter space point with z = 0
  ON_3dPoint m_pointB;  // 2d surfaceB parameter space point with z = 0
  ON_3dPoint m_point3d; // 3d intersection point
};

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(ON_LINE_INC_)
#define ON_LINE_INC_

class ON_CLASS ON_Line
{
public:

  ON_Line();
  ON_Line( const ON_3dPoint& start, const ON_3dPoint& end );
  ~ON_Line();

  /*
  Returns:
    True if from != to.
  */
  bool IsValid() const;

  // line[0] = start point line[1] = end point
  ON_3dPoint& operator[](int);
  const ON_3dPoint& operator[](int) const;


  // Description:
  //   Create a line from two points.
  // Parameters:
  //   start - [in] point at start of line segment
  //   end - [in] point at end of line segment
  // Returns:
  //   true if start and end are distinct points.
  bool Create( 
    const ON_3dPoint& start, 
    const ON_3dPoint& end
    );

  /*
  Description: 
    Get line's 3d axis aligned bounding box.
  Returns:
    3d bounding box.
  */
  ON_BoundingBox BoundingBox() const;

  /*
  Description:
    Get line's 3d axis aligned bounding box or the
    union of the input box with the object's bounding box.
  Parameters:
    bbox - [in/out] 3d axis aligned bounding box
    bGrowBox - [in] (default=false) 
      If true, then the union of the input bbox and the 
      object's bounding box is returned in bbox.  
      If false, the object's bounding box is returned in bbox.
  Returns:
    true if object has bounding box and calculation was successful.
  */
  bool GetBoundingBox(
         ON_BoundingBox& bbox,
         int bGrowBox = false
         ) const;

  /*
	Description:
    Get tight bounding box.
	Parameters:
		tight_bbox - [in/out] tight bounding box
		bGrowBox -[in]	(default=false)			
      If true and the input tight_bbox is valid, then returned
      tight_bbox is the union of the input tight_bbox and the 
      line's tight bounding box.
		xform -[in] (default=NULL)
      If not NULL, the tight bounding box of the transformed
      line is calculated.  The line is not modified.
	Returns:
    True if a valid tight_bbox is returned.
  */
	bool GetTightBoundingBox( 
			ON_BoundingBox& tight_bbox, 
      int bGrowBox = false,
			const ON_Xform* xform = 0
      ) const;

  /*
  Description:
    Get a plane that contains the line.
  Parameters:
    plane - [out] a plane that contains the line.  The orgin
       of the plane is at the start of the line.  The distance
       from the end of the line to the plane is <= tolerance.
       If possible a plane parallel to the world xy, yz or zx
       plane is returned.
    tolerance - [in]
  Returns:
    true if a coordinate of the line's direction vector is
    larger than tolerance.
  */
  bool InPlane( ON_Plane& plane, double tolerance = 0.0 ) const;

  // Returns:
  //   Length of line
  double Length() const;

  // Returns:
  //   direction vector = line.to - line.from
  // See Also:
  //   ON_Line::Tangent
  ON_3dVector Direction() const;

  // Returns:
  //   Unit tangent vector.
  // See Also:
  //   ON_Line::Direction
  ON_3dVector Tangent() const;

  /*
  Description:
    Evaluate point on (infinite) line.
  Parameters:
    t - [in] evaluation parameter. t=0 returns line.from
             and t=1 returns line.to.
  Returns:
    (1-t)*line.from + t*line.to.
  See Also:
    ON_Line::Direction
    ON_Line::Tangent
  */
  ON_3dPoint PointAt( 
    double t 
    ) const;

  /*
  Description:
    Find the point on the (infinite) line that is
    closest to the test_point.
  Parameters:
    test_point - [in]
    t - [out] line.PointAt(*t) is the point on the line 
              that is closest to test_point.
  Returns:
    true if successful.
  */
  bool ClosestPointTo( 
    const ON_3dPoint& test_point, 
    double* t
    ) const;

  /*
  Description:
    Find the point on the (infinite) line that is
    closest to the test_point.
  Parameters:
    test_point - [in]
  Returns:
    The point on the line that is closest to test_point.
  */
  ON_3dPoint ClosestPointTo( 
    const ON_3dPoint& test_point
    ) const;

  /*
  Description:
    Find the point on the (infinite) line that is
    closest to the test_point.
  Parameters:
    test_point - [in]
  Returns:
    distance from the point on the line that is closest
    to test_point.
  See Also:
    ON_3dPoint::DistanceTo
    ON_Line::ClosestPointTo
  */
  double DistanceTo( ON_3dPoint test_point ) const;


  /*
  Description:
    Finds the shortest distance between the line as a finite
    chord and the other object.
  Parameters:
    P - [in]
    L - [in] (another finite chord)
  Returns:
    A value d such that if Q is any point on 
    this line and P is any point on the other object, 
    then d <= Q.DistanceTo(P).
  */
  double MinimumDistanceTo( const ON_3dPoint& P ) const;
  double MinimumDistanceTo( const ON_Line& L ) const;

  /*
  Description:
    Finds the longest distance between the line as a finite
    chord and the other object.
  Parameters:
    P - [in]
    L - [in] (another finite chord)
  Returns:
    A value d such that if Q is any point on this line and P is any
    point on the other object, then d >= Q.DistanceTo(P).
  */
  double MaximumDistanceTo( const ON_3dPoint& P ) const;
  double MaximumDistanceTo( const ON_Line& other ) const;


  /*
  Description:
    Quickly determine if the shortest distance from
    this line to the other object is greater than d.
  Parameters:
    d - [in] distance (> 0.0)
    P - [in] 
    L - [in] 
  Returns:
    True if if the shortest distance from this line
    to the other object is greater than d.
  */
  bool IsFartherThan( double d, const ON_3dPoint& P ) const;
  bool IsFartherThan( double d, const ON_Line& L ) const;


  // For intersections see ON_Intersect();

  // Description:
  //   Reverse line by swapping from and to.
  void Reverse();

  bool Transform( 
    const ON_Xform& xform
    );

  // rotate line about a point and axis
  bool Rotate(
        double sin_angle,
        double cos_angle,
        const ON_3dVector& axis_of_rotation,
        const ON_3dPoint& center_of_rotation
        );

  bool Rotate(
        double angle_in_radians,
        const ON_3dVector& axis_of_rotation,
        const ON_3dPoint& center_of_rotation
        );

  bool Translate(
        const ON_3dVector& delta
        );


  /*
  Description:
    Intersect infinite line with surfaceB.
  Parameters:
    surfaceB - [in]
    x - [out] Intersection events are appended to this array.
    intersection_tolerance - [in]  If the distance from a point
      on this line to the surface is <= intersection tolerance,
      then the point will be part of an intersection event.
      If the input intersection_tolerance <= 0.0, then 0.001 is used.
    overlap_tolerance - [in] If t1 and t2 are curve parameters of
      intersection events and the distance from line(t) to the
      surface is <= overlap_tolerance for every t1 <= t <= t2,
      then the event will be returened as an overlap event.
      If the input overlap_tolerance <= 0.0, then
      intersection_tolerance*2.0 is used.
    line_domain - [in] optional restriction on line's domain
      If you want a finite intersection, then specify a
      line_domain. If you want a ray intersection, then specify
      a line domain like (0.0, ON_DBL_MAX).
    surfaceB_udomain - [in] optional restriction on surfaceB u domain
    surfaceB_vdomain - [in] optional restriction on surfaceB v domain
  Returns:
    Number of intersection events appended to x.
  */
  int IntersectSurface(
          const class ON_Surface* surfaceB,
          ON_SimpleArray<ON_X_EVENT>& x,
          double intersection_tolerance = 0.0,
          double overlap_tolerance = 0.0,
          const ON_Interval* line_domain = 0,
          const ON_Interval* surfaceB_udomain = 0,
          const ON_Interval* surfaceB_vdomain = 0
          ) const;


public:
  ON_3dPoint from; // start point
  ON_3dPoint to;   // end point
};

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(ON_POLYLINE_INC_)
#define ON_POLYLINE_INC_

class ON_CLASS ON_Polyline : public ON_3dPointArray
{
public:
  ON_Polyline();
  ON_Polyline(const ON_3dPointArray&);
  ON_Polyline& operator=(const ON_3dPointArray&);
  ~ON_Polyline();

  // Description:
  //   Create a regular polygon inscribed in a circle.
  //   The vertices of the polygon will be on the circle.
  // Parameters:
  //   circle - [in]
  //   side_count - [in] (>=3) number of sides
  // Returns:
  //   true if successful.  false if circle is invalid or
  //   side_count < 3.
  bool CreateInscribedPolygon(
    const ON_Circle& circle,
    int side_count
    );

  // Description:
  //   Create a regular polygon circumscribe about a circle.
  //   The midpoints of the polygon's edges will be tanget to the
  //   circle.
  // Parameters:
  //   circle - [in]
  //   side_count - [in] (>=3) number of sides
  // Returns:
  //   true if successful.  false if circle is invalid or
  //   side_count < 3.
  bool CreateCircumscribedPolygon(
    const ON_Circle& circle,
    int side_count
    );

  // Description:
  //   Create a regular star polygon.
  //   The star begins at circle.PointAt(0) and the vertices alternate
  //   between being on circle and begin on a concentric circle of
  //   other_radius.
  // Parameters:
  //   circle - [in] circle star polygon starts on
  //   other_radius - [in] radius of other circle 
  //   corner_count - [in] (>=3) number of corners on circle
  //      There will be 2*corner_count sides and 2*corner_count
  //      vertices.
  // Returns:
  //   true if successful.  false if circle is invalid, other_radius < 0.0,
  //   or side_count < 3.
  bool CreateStarPolygon(
    const ON_Circle& circle,
    double other_radius,
    int side_count
    );

  // Description:
  //   Checks that polyline has at least two points
  //   and that sequential points are distinct.  If the
  //   polyline has 2 or 3 points, then the start and end
  //   point must be distinct.
  // Parameters:
  //   tolerance - [in] tolerance used to check for duplicate points.
  // Returns:
  //   true if polyline is valid.
  // See Also:
  //   ON_Polyline::Clean.
  bool IsValid(
    double tolerance = 0.0 
    ) const;

  // Description:
  //   Removes duplicate points that result in zero length segments.
  // Parameters:
  //   tolerance - [in] tolerance used to check for duplicate points.
  // Returns:
  //   Number of points removed.
  // Remarks:
  //   If the distance between points polyline[i] and polyline[i+1]
  //   is <= tolerance, then the point with index (i+1) is removed.
  int Clean( 
    double tolerance = 0.0 
    );

  // Returns:
  //   Number of points in the polyline.
  int PointCount() const;

  // Returns:
  //   Number of segments in the polyline.
  int SegmentCount() const;

  // Description:
  //   Test a polyline to see if it is closed.
  // Returns:
  //   true if polyline has 4 or more points, the distance between the
  //   start and end points is <= tolerance, and there is a
  //   point in the polyline whose distance from the start and end
  //   points is > tolerance.
  bool IsClosed(
    double tolerance = 0.0 
    ) const;


  // Returns:
  //   Length of the polyline.
  double Length() const;

  // Parameters:
  //   segment_index - [in] zero based segment index
  // Returns:
  //   vector = point[segment_index+1] - point[segment_index].
  ON_3dVector SegmentDirection (
    int segment_index
    ) const;

  // Parameters:
  //   segment_index - [in] zero based segment index
  // Returns:
  //   Unit vector in the direction of the segment
  ON_3dVector SegmentTangent (
    int segment_index
    ) const;

  // Description:
  //   Evaluate the polyline location at a parameter.
  // Parameters:
  //   t - [in] the i-th segment goes from i <= t < i+1
  ON_3dPoint PointAt( double t ) const;

  // Description:
  //   Evaluate the polyline first derivative at a parameter.
  // Parameters:
  //   t - [in] the i-th segment goes from i <= t < i+1
  ON_3dVector DerivativeAt( double t ) const;

  // Description:
  //   Evaluate the polyline unit tangent at a parameter.
  // Parameters:
  //   t - [in] the i-th segment goes from i <= t < i+1
  ON_3dVector TangentAt( double t ) const;

  // Description:
  //   Find a point on the polyline that is closest 
  //   to test_point.
  // Parameters:
  //   test_point - [in]
  //   t - [out] parameter for a point on the polyline that
  //             is closest to test_point.  If mulitple solutions
  //             exist, then the smallest solution is returned.
  // Returns:
  //   true if successful.
  bool ClosestPointTo( 
        const ON_3dPoint& test_point, 
        double* t
        ) const;

  // Description:
  //   Find a point on the polyline that is closest 
  //   to test_point.
  // Parameters:
  //   test_point - [in]
  //   t - [out] parameter for a point on the polyline that
  //             is closest to test_point.  If mulitple solutions
  //             exist, then the smallest solution is returned.
  //   segment_index0 - [in] index of segment where search begins
  //   segment_index1 - [in] index of segment where search ends
  //                         This segment is NOT searched.
  // Example:
  //   Search segments 3,4, and 5 for the point closest to (0,0,0).
  //   double t;
  //   ClosestPointTo( ON_3dPoint(0,0,0), &t, 3, 6 );
  // Returns:
  //   true if successful.
  bool ClosestPointTo( 
        const ON_3dPoint& test_point, 
        double* t, 
        int segment_index0, // index of segment where search begins
        int segment_index1 // index + 1 of segment where search stops
        ) const;

  // Description:
  //   Find a point on the polyline that is closest 
  //   to test_point.
  // Parameters:
  //   test_point - [in]
  // Returns:
  //   point on polyline.
  ON_3dPoint ClosestPointTo( 
       const ON_3dPoint& test_point
    ) const;

};

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_CYLINDER_INC_)
#define OPENNURBS_CYLINDER_INC_

class ON_NurbsSurface;
class ON_RevSurface;
class ON_Brep;

/*
Description:
  ON_Cylinder is a right circular cylinder.
*/
class ON_CLASS ON_Cylinder
{
public:
  ON_Cylinder(); // zeros all fields - cylinder is invalid

  ON_Cylinder( // infinte cylinder
    const ON_Circle&  // point on the bottom plane
    );

  ON_Cylinder( // infinte cylinder
    const ON_Circle&,  // point on the bottom plane
    double             // height
    );

  ~ON_Cylinder();

  bool Create(
    const ON_Circle&  // point on the bottom plane
    );

  bool Create(
    const ON_Circle&,  // point on the bottom plane
    double               // height
    );

  bool IsValid() const; // returns true if all fields contain reasonable
                        // information and equation jibes with point and Z.

  bool IsFinite() const; // returns true if the cylinder is finite
                         // (height[0] != height[1]) and false if the
                         // cylinder is infinite.

  const ON_3dVector& Axis() const;
  const ON_3dPoint& Center() const;
  double Height() const; // returns 0 for infinite cylinder
  ON_Circle CircleAt( 
        double // linear parameter
        ) const;
  ON_Line LineAt( 
        double // angular parameter
        ) const;

  // evaluate parameters and return point
  ON_3dPoint PointAt(
    double, // angular parameter [0,2pi]
    double  // linear parameter (height from base circle's plane)
    ) const;
  ON_3dPoint NormalAt(
    double, // angular parameter [0,2pi]
    double  // linear parameter (height from base circle's plane)
    ) const;

  // returns parameters of point on cylinder that is closest to given point
  bool ClosestPointTo( 
         ON_3dPoint, 
         double*, // angular parameter [0,2pi]
         double*  // linear parameter (height from base circle's plane)
         ) const;
  // returns point on cylinder that is closest to given point
  ON_3dPoint ClosestPointTo( 
         ON_3dPoint 
         ) const;

  // For intersections see ON_Intersect();

  // rotate cylinder about its origin
  bool Rotate(
        double,               // sin(angle)
        double,               // cos(angle)
        const ON_3dVector&  // axis of rotation
        );
  bool Rotate(
        double,               // angle in radians
        const ON_3dVector&  // axis of rotation
        );

  // rotate cylinder about a point and axis
  bool Rotate(
        double,               // sin(angle)
        double,               // cos(angle)
        const ON_3dVector&, // axis of rotation
        const ON_3dPoint&   // center of rotation
        );
  bool Rotate(
        double,              // angle in radians
        const ON_3dVector&, // axis of rotation
        const ON_3dPoint&   // center of rotation
        );

  bool Translate(
        const ON_3dVector&
        );

  // parameterization of NURBS surface does not match cylinder's transcendental paramaterization
  int GetNurbForm( ON_NurbsSurface& ) const; // returns 0=failure, 2=success

  /*
  Description:
    Creates a surface of revolution definition of the cylinder.
  Parameters:
    srf - [in] if not NULL, then this srf is used.
  Result:
    A surface of revolution or NULL if the cylinder is not 
    valid or is infinite.
  */
  ON_RevSurface* RevSurfaceForm( ON_RevSurface* srf = NULL ) const;

public: // members left public
  // base circle
  ON_Circle  circle;

  
  // If height[0] = height[1], the cylinder is infinite,
  // Otherwise, height[0] < height[1] and the center of
  // the "bottom" cap is 
  //
  //          circle.plane.origin + height[0]*circle.plane.zaxis,
  //
  // and the center of the top cap is 
  //
  //          circle.plane.origin + height[1]*circle.plane.zaxis.
  double height[2];
};

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(ON_CONE_INC_)
#define ON_CONE_INC_

class ON_NurbsSurface;
class ON_Brep;

// Description:
//   Lightweight right circular cone.  Use ON_ConeSurface if
//   you need ON_Cone geometry as a virtual ON_Surface.
class ON_CLASS ON_Cone
{
public:

  // Creates a cone with world XY plane as the base plane,
  // center = (0,0,0), radius = 0.0, height = 0.0.
  ON_Cone();

  // See ON_Cone::Create.
  ON_Cone(
    const ON_Plane& plane,
    double height,
    double radius
    );

  ~ON_Cone();

  // Description:
  //   Creates a right circular cone from a plane, height,
  //   and radius.
  //  plane - [in] The apex of cone is at plane.origin and
  //      the axis of the cone is plane.zaxis.
  //  height - [in] The center of the base is height*plane.zaxis.
  //  radius - [in] tan(cone angle) = radius/height
  ON_BOOL32 Create(
    const ON_Plane& plane,
    double height,
    double radius
    );

  // Returns true if plane is valid, height is not zero, and
  // radius is not zero.
  ON_BOOL32 IsValid() const;

  // Returns:
  //   Center of base circle.
  // Remarks:
  //   The base point is plane.origin + height*plane.zaxis.
  ON_3dPoint BasePoint() const;

  // Returns:
  //   Point at the tip of the cone.
  // Remarks:
  //   The apex point is plane.origin.
  const ON_3dPoint& ApexPoint() const;

  // Returns:
  //   Unit vector axis of cone.
  const ON_3dVector& Axis() const;

  // Returns:
  //   The angle (in radians) between the axis and the 
  //   side of the cone.
  //   The angle and the height have the same sign.
  double AngleInRadians() const;

  // Returns:
  //   The angle Iin degrees) between the axis and the side.
  //   The angle and the height have the same sign.
  double AngleInDegrees() const;           

  // evaluate parameters and return point
  // Parameters:
  //   radial_parameter - [in] 0.0 to 2.0*ON_PI
  //   height_parameter - [in] 0 = apex, height = base
  ON_3dPoint PointAt(
    double radial_parameter,
    double height_parameter
    ) const;

  // Parameters:
  //   radial_parameter - [in] (in radians) 0.0 to 2.0*ON_PI
  //   height_parameter - [in] 0 = apex, height = base
  // Remarks:
  //   If radius>0 and height>0, then the normal points "out"
  //   when height_parameter >= 0.
  ON_3dVector NormalAt(
    double radial_parameter,
    double height_parameter
    ) const;

  // Description:
  //   Get iso curve circle at a specified height.
  // Parameters:
  //   height_parameter - [in] 0 = apex, height = base
  ON_Circle CircleAt( 
    double height_parameter
    ) const;

  // Description:
  //   Get iso curve line segment at a specified angle.
  // Parameters:
  //   radial_parameter - [in] (in radians) 0.0 to 2.0*ON_PI
  ON_Line LineAt( 
    double radial_parameter 
    ) const;

  // returns parameters of point on cone that is closest to given point
  bool ClosestPointTo( 
          ON_3dPoint point, 
          double* radial_parameter,
          double* height_parameter
         ) const;

  // returns point on cone that is closest to given point
  ON_3dPoint ClosestPointTo( 
         ON_3dPoint 
         ) const;

  ON_BOOL32 Transform( const ON_Xform& );

  // rotate cone about its origin
  ON_BOOL32 Rotate(
        double sin_angle,
        double cos_angle,
        const ON_3dVector& axis_of_rotation
        );

  ON_BOOL32 Rotate(
        double angle_in_radians,
        const ON_3dVector& axis_of_rotation
        );

  // rotate cone about a point and axis
  ON_BOOL32 Rotate(
        double sin_angle,
        double cos_angle,
        const ON_3dVector& axis_of_rotation,
        const ON_3dPoint& center_of_rotation
        );
  ON_BOOL32 Rotate(
        double angle_in_radians,
        const ON_3dVector& axis_of_rotation,
        const ON_3dPoint& center_of_rotation
        );

  ON_BOOL32 Translate(
        const ON_3dVector& delta
        );

  ON_BOOL32 GetNurbForm( ON_NurbsSurface& ) const;

  /*
  Description:
    Creates a surface of revolution definition of the cylinder.
  Parameters:
    srf - [in] if not NULL, then this srf is used.
  Result:
    A surface of revolution or NULL if the cylinder is not 
    valid or is infinite.
  */
  ON_RevSurface* RevSurfaceForm( ON_RevSurface* srf = NULL ) const;

public:
  ON_Plane plane; // apex = plane.origin, axis = plane.zaxis
  double   height; // not zero
  double   radius; // not zero
};

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(ON_SPHERE_INC_)
#define ON_SPHERE_INC_

class ON_RevSurface;

class ON_CLASS ON_Sphere
{
public:
  
  ON_Plane plane; // equitorial plane
  double radius;  // > 0

  ON_Sphere();
  ON_Sphere( const ON_3dPoint& center, double radius ); // center, radius
  ~ON_Sphere();

  bool IsValid() const;

  bool Create( const ON_3dPoint& center, double radius); // center radius

  ON_Circle LatitudeRadians(double latitude_radians ) const;
  ON_Circle LatitudeDegrees(double latitude_degrees) const;
  ON_Circle LongitudeRadians(double longitude_radians) const;
  ON_Circle LongitudeDegrees(double longitude_degrees) const;

  ON_3dPoint Center() const;
  ON_3dPoint NorthPole() const;
  ON_3dPoint SouthPole() const;
  double Diameter() const;
  double Radius() const;

  ON_3dPoint PointAt(
    double longitude_radians, 
    double latitude_radians
    ) const;   // longitude [0,2pi], latitude [-pi/2,pi/2] in radians

  ON_3dVector NormalAt(
    double longitude_radians, 
    double latitude_radians
    ) const;   // longitude [0,2pi], latitude [-pi/2,pi/2] in radians

  ON_BoundingBox BoundingBox() const;

  // returns parameters of point on sphere that is closest to given point
  bool ClosestPointTo( 
         ON_3dPoint test_point, 
         double* longitude_radians, // longitude  [0,2pi)
         double* latitude_radians // latitude   [-pi/2,pi/2]
         ) const;

  // returns point on sphere that is closest to given point
  ON_3dPoint ClosestPointTo( 
         ON_3dPoint test_point
         ) const;

  // For intersections see ON_Intersect();

  // rotate sphere about its origin
  bool Rotate(
        double sin_angle,               // sin(angle)
        double cos_angle,               // cos(angle)
        const ON_3dVector& axis_of_rotation // axis of rotation
        );

  bool Rotate(
        double angle_radians,               // angle in radians
        const ON_3dVector& axis_of_rotation // axis of rotation
        );

  // rotate sphere about a point and axis
  bool Rotate(
        double sin_angle,               // sin(angle)
        double cos_angle,               // cos(angle)
        const ON_3dVector& axis_of_rotation, // axis of rotation
        const ON_3dPoint& center_of_rotation  // center of rotation
        );

  bool Rotate(
        double angle_radians,               // angle in radians
        const ON_3dVector& axis_of_rotation, // axis of rotation
        const ON_3dPoint& center_of_rotation  // center of rotation
        );

  bool Translate(
        const ON_3dVector&
        );

  bool Transform( const ON_Xform& );

  // parameterization of NURBS surface does not match sphere's transcendental paramaterization
  int GetNurbForm( ON_NurbsSurface& ) const; // returns 0=failure, 2=success

  /*
  Description:
    Creates a surface of revolution definition of the sphere.
  Parameters:
    bArcLengthParameterization - [in]
      true: 
        The domain will be set to (0,radius*2*pi)x(-radius*pi/2,radius*pi/2)
      false: 
        The domain will be set to (0,2*pi)x(-pi/2,pi/2)
    srf - [in]
      if not NULL, then this srf is used.
  Result:
    A surface of revolution or NULL if the sphere is not valid.
  */
  ON_RevSurface* RevSurfaceForm( bool bArcLengthParameterization, ON_RevSurface* srf = NULL ) const;
  ON_DEPRECATED ON_RevSurface* RevSurfaceForm( ON_RevSurface* srf = NULL ) const;
};

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(ON_BOX_INC_)
#define ON_BOX_INC_

class ON_CLASS ON_Box
{
public:
  ON_Plane plane; 
  // intervals are finite and increasing when the box is valid
  ON_Interval dx;
  ON_Interval dy;
  ON_Interval dz;

  ON_Box();
  ON_Box( const ON_BoundingBox& bbox );
  ~ON_Box();

  bool IsValid() const;

  bool Create( const ON_BoundingBox& bbox );

  void Destroy();

  ON_3dPoint Center() const;
  bool GetCorners( ON_3dPoint* corners ) const;
  bool GetCorners( ON_SimpleArray<ON_3dPoint>& corners ) const;

  ON_BoundingBox BoundingBox() const;

  ON_3dPoint PointAt( 
          double r, 
          double s, 
          double t 
          ) const;

  bool ClosestPointTo( 
          ON_3dPoint point, 
          double* r, 
          double* s, 
          double* t 
          ) const;

  // returns point on box that is closest to given point
  ON_3dPoint ClosestPointTo( 
         ON_3dPoint test_point
         ) const;

  // rotate sphere about its origin
  bool Rotate(
        double sin_angle,               // sin(angle)
        double cos_angle,               // cos(angle)
        const ON_3dVector& axis_of_rotation // axis of rotation
        );

  bool Rotate(
        double angle_radians,               // angle in radians
        const ON_3dVector& axis_of_rotation // axis of rotation
        );

  // rotate sphere about a point and axis
  bool Rotate(
        double sin_angle,               // sin(angle)
        double cos_angle,               // cos(angle)
        const ON_3dVector& axis_of_rotation, // axis of rotation
        const ON_3dPoint& center_of_rotation  // center of rotation
        );

  bool Rotate(
        double angle_radians,               // angle in radians
        const ON_3dVector& axis_of_rotation, // axis of rotation
        const ON_3dPoint& center_of_rotation  // center of rotation
        );

  bool Translate(
        const ON_3dVector&
        );

  bool Transform( const ON_Xform& );

  /*
  Description:
    Test the box to see if it is degenerate (flat)
    in one or more directions.
  Parameters:
    tolerance - [in] Distances <= tolerance will be considered
        to be zero.  If tolerance is negative (default), then
        a scale invarient tolerance is used.
  Returns:
    @untitled table
    0     box is not degenerate
    1     box is a rectangle (degenerate in one direction)
    2     box is a line (degenerate in two directions)
    3     box is a point (degenerate in three directions)
    4     box is not valid
  */
  int IsDegenerate( 
    double tolerance = ON_UNSET_VALUE
    ) const;

  double Volume() const;

  double Area() const;
};

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(ON_TORUS_INC_)
#define ON_TORUS_INC_

class ON_RevSurface;
class ON_TextLog;

/*
Description:
  The torus is defined by a major circle and minor radius.  The
  torus is parameterized by (major_angle,minor_angle).  The angles
  are specified in radians.  The domain of both parameters is (0,2pi).
*/
class ON_CLASS ON_Torus
{

public:
  // for expert users

  ON_Plane plane; // major circle plane
  double major_radius;  // > minor_radius
  double minor_radius;  // > 0

public:

  ON_Torus();
  ON_Torus( const ON_Plane& major__plane, double major__radius, double minor__radius );
  ON_Torus( const ON_Circle& major__circle, double minor__radius );
  ~ON_Torus();

  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  ON_BOOL32 Create( const ON_Plane& major__plane, double major__radius, double minor__radius );
  ON_BOOL32 Create( const ON_Circle& major__circle, double minor__radius);

  /*
  Description:
    Get the circle that is the isocurve on the torus
    at a specified minor angle.
  Parameteters:
    minor_angle_radians - [in]
  Returns:
    A circle with normal major_circle.plane.zaxis that starts
    at PointAt( 0.0, minor_angle_radians ).
  See Also:
    ON_Torus::MajorCircleRadians
    ON_Torus::MajorCircleDegrees
    ON_Torus::MinorCircleRadians
    ON_Torus::MinorCircleDegrees
  */
  ON_Circle MajorCircleRadians(double minor_angle_radians ) const;

  /*
  Description:
    Get the circle that is the isocurve on the torus
    at a specified minor angle.
  Parameteters:
    minor_angle_degrees - [in]
  Returns:
    A circle with normal major_circle.plane.zaxis that starts
    at PointAt( 0.0, minor_angle_degrees*ON_PI/180.0 ).
  See Also:
    ON_Torus::MajorCircleRadians
    ON_Torus::MajorCircleDegrees
    ON_Torus::MinorCircleRadians
    ON_Torus::MinorCircleDegrees
  */
  ON_Circle MajorCircleDegrees(double minor_angle_degrees) const;

  /*
  Description:
    Get the minor circle that is the isocurve on the torus
    at a specified major angle.
  Parameteters:
    major_angle_radians - [in]
  Returns:
    A circle with radius = minor_radis, 
    center = major_circle.PointAt(major_angle_radians), and
    starting point PointAt( major_angle_radians, 0.0 ).
  See Also:
    ON_Torus::MajorCircleRadians
    ON_Torus::MajorCircleDegrees
    ON_Torus::MinorCircleRadians
    ON_Torus::MinorCircleDegrees
  */
  ON_Circle MinorCircleRadians(double major_angle_radians) const;

  /*
  Description:
    Get the minor circle that is the isocurve on the torus
    at a specified major angle.
  Parameteters:
    major_angle_degrees - [in]
  Returns:
    A circle with radius = minor_radis, 
    center = major_circle.PointAt(major_angle_degrees*ON_PI/180.0), and
    starting point PointAt( major_angle_degrees*ON_PI/180.0, 0.0 ).
  See Also:
    ON_Torus::MajorCircleRadians
    ON_Torus::MajorCircleDegrees
    ON_Torus::MinorCircleRadians
    ON_Torus::MinorCircleDegrees
  */
  ON_Circle MinorCircleDegrees(double major_angle_degrees) const;

  ON_3dPoint Center() const;
  ON_3dVector Axis() const;
  double MajorRadius() const;
  double MinorRadius() const;

  ON_3dPoint PointAt(
    double major_angle_radians, 
    double minor_angle_radians
    ) const;

  ON_3dVector NormalAt(
    double major_angle_radians, 
    double minor_angle_radians
    ) const;

  // returns parameters of point on torus that is closest to test_point.
  ON_BOOL32 ClosestPointTo( 
         ON_3dPoint test_point, 
         double* major_angle_radians, 
         double* minor_angle_radians
         ) const;

  // returns point on torus that is closest to test_point
  ON_3dPoint ClosestPointTo( 
         ON_3dPoint test_point
         ) const;

  // rotate torus about its origin
  ON_BOOL32 Rotate(
        double sin_angle,               // sin(angle)
        double cos_angle,               // cos(angle)
        const ON_3dVector& axis_of_rotation // axis of rotation
        );

  ON_BOOL32 Rotate(
        double angle_radians,               // angle in radians
        const ON_3dVector& axis_of_rotation // axis of rotation
        );

  // rotate torus about a point and axis
  ON_BOOL32 Rotate(
        double sin_angle,               // sin(angle)
        double cos_angle,               // cos(angle)
        const ON_3dVector& axis_of_rotation, // axis of rotation
        const ON_3dPoint& center_of_rotation  // center of rotation
        );

  ON_BOOL32 Rotate(
        double angle_radians,               // angle in radians
        const ON_3dVector& axis_of_rotation, // axis of rotation
        const ON_3dPoint& center_of_rotation  // center of rotation
        );

  ON_BOOL32 Translate(
        const ON_3dVector&
        );

  ON_BOOL32 Transform( const ON_Xform& );

  // parameterization of NURBS surface does not match torus's transcendental paramaterization
  int GetNurbForm( ON_NurbsSurface& ) const; // returns 0=failure, 2=success

  /*
  Description:
    Creates a surface of revolution definition of the torus.
  Parameters:
    srf - [in] if not NULL, then this srf is used.
  Result:
    A surface of revolution or NULL if the torus is not valid.
  */
  ON_RevSurface* RevSurfaceForm( ON_RevSurface* srf = NULL ) const;
};

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_BEZIER_INC_)
#define OPENNURBS_BEZIER_INC_

class ON_PolynomialCurve;
class ON_PolynomialSurface;
class ON_BezierCurve;
class ON_BezierSurface;
class ON_TextLog;
class ON_NurbsCurve;
class ON_NurbsSurface;
class ON_X_EVENT;

class ON_CLASS ON_PolynomialCurve
{
public:
  ON_PolynomialCurve();

  // Description:
  //   See ON_PolynomialCurve::Create.
  // Parameters:
  //   dim - [in] dimension of the curve
  //   bIsRational - [in] true if rational
  //   order - [in] (>=2) order = degree+1
  ON_PolynomialCurve(
    int dim,
    ON_BOOL32 bIsRational,
    int order
    );

  ~ON_PolynomialCurve();

  ON_PolynomialCurve(const ON_PolynomialCurve&);

  ON_PolynomialCurve(const ON_BezierCurve&);

  ON_PolynomialCurve& operator=(const ON_PolynomialCurve&);

  ON_PolynomialCurve& operator=(const ON_BezierCurve&);

  // Description:
  //   Initializes fields and allocates the m_cv array. 
  // Parameters:
  //   dim - [in] dimension of the curve
  //   bIsRational - [in] true if rational
  //   order - [in] (>=2) order = degree+1
  ON_BOOL32 Create(
    int dim,
    ON_BOOL32 bIsRational,
    int order
    );

  // Description:
  //   Deallocates the m_cv array and sets fields to zero.
  void Destroy();

  // Description:
  //   Evaluate a polynomial curve.
  // Parameters:
  //   t - [in] evaluation parameter ( usually in Domain() ).
  //   der_count - [in] (>=0) number of derivatives to evaluate
  //   v_stride - [in] (>=Dimension()) stride to use for the v[] array
  //   v - [out] array of length (der_count+1)*v_stride
  //       curve(t) is returned in (v[0],...,v[m_dim-1]),
  //       curve'(t) is retuned in (v[v_stride],...,v[v_stride+m_dim-1]),
  //       curve"(t) is retuned in (v[2*v_stride],...,v[2*v_stride+m_dim-1]),
  //       etc.
  // Returns:
  //   false if unable to evaluate.
  ON_BOOL32 Evaluate(
         double t,
         int der_count,
         int v_stride,
         double* v
         ) const;

  // dimension of polynomial curve (1,2, or 3)
  int m_dim;

  // 1 if polynomial curve is rational, 0 if polynomial curve is not rational
  int m_is_rat;

  // order (=degree+1) of polynomial
  int m_order;

  // coefficients ( m_cv.Count() = order of monomial )
  ON_4dPointArray m_cv;

  // domain of polynomial
  ON_Interval m_domain;
};

class ON_CLASS ON_PolynomialSurface
{
public:
  ON_PolynomialSurface();
  ON_PolynomialSurface(
    int,  // dim,
    ON_BOOL32, // true if rational
    int,  // "u" order
    int   // "v" order
    );
  ~ON_PolynomialSurface();
  ON_PolynomialSurface(const ON_PolynomialSurface&);
  ON_PolynomialSurface(const ON_BezierSurface&);
  ON_PolynomialSurface& operator=(const ON_PolynomialSurface&);
  ON_PolynomialSurface& operator=(const ON_BezierSurface&);

  ON_BOOL32 Create(
    int,  // dim,
    ON_BOOL32, // true if rational
    int,  // "u" order
    int   // "v" order
    );
  void Destroy();

  ON_BOOL32 Evaluate(          // returns false if unable to evaluate
         double s, 
         double t,        // evaluation parameter
         int der_count,   // number of derivatives (>=0)
         int v_stride,    // array stride (>=Dimension())
         double* v        // array of length stride*(ndir+1)*(ndir+2)/2
         ) const;

  int m_dim;    // 1,2, or 3
  int m_is_rat; // 1 if rational, 0 if not rational
  int m_order[2];
  ON_4dPointArray m_cv; // coefficients ( m_C.Length() = m_order[0]*m_order[1]
                        // coefficient of s^m*t^n = m_cv[m_order[1]*m+n]
  ON_Interval m_domain[2];
};

class ON_CLASS ON_BezierCurve
{
public:

  ON_BezierCurve();

  // Description:
  //   Creates a bezier with cv memory allocated.
  // Parameters:
  //   dim - [in] (>0) dimension of bezier curve
  //   bIsRational - [in] true for a rational bezier
  //   order - [in] (>=2) order (=degree+1) of bezier curve
  ON_BezierCurve(
    int dim,
    ON_BOOL32 bIsRational,
    int order
    );

  ~ON_BezierCurve();
  ON_BezierCurve(const ON_BezierCurve&);
  ON_BezierCurve(const ON_PolynomialCurve&);
  ON_BezierCurve(const ON_2dPointArray&); // sets control points
  ON_BezierCurve(const ON_3dPointArray&); // sets control points
  ON_BezierCurve(const ON_4dPointArray&); // sets control points
  ON_BezierCurve& operator=(const ON_BezierCurve&);
  ON_BezierCurve& operator=(const ON_PolynomialCurve&);


  ON_BezierCurve& operator=(const ON_2dPointArray&); // sets control points
  ON_BezierCurve& operator=(const ON_3dPointArray&); // sets control points
  ON_BezierCurve& operator=(const ON_4dPointArray&); // sets control points

  bool IsValid() const;

  void Dump( ON_TextLog& ) const; // for debugging

  // Returns:
  //   Dimension of bezier.
  int Dimension() const;

  // Description:
  //   Creates a bezier with cv memory allocated.
  // Parameters:
  //   dim - [in] (>0) dimension of bezier curve
  //   bIsRational - [in] true for a rational bezier
  //   order - [in] (>=2) order (=degree+1) of bezier curve
  // Returns:
  //   true if successful.
  bool Create(
    int dim,
    ON_BOOL32 bIsRational,
    int order
    );

  // Description:
  //   Deallocates m_cv memory.
  void Destroy();

  void EmergencyDestroy(); // call if memory used by ON_NurbsCurve becomes invalid

  // Description:
  //   Loft a bezier curve through a list of points.
  // Parameters:
  //   points - [in] an array of 2 or more points to interpolate
  // Returns:
  //   true if successful
  // Remarks:
  //   The result has order = points.Count() and the loft uses the 
  //   uniform parameterizaton curve( i/(points.Count()-1) ) = points[i].
  bool Loft( 
    const ON_3dPointArray& points
    );

  // Description:
  //   Loft a bezier curve through a list of points.
  // Parameters:
  //   pt_dim - [in] dimension of points to interpolate
  //   pt_count - [in] number of points (>=2)
  //   pt_stride - [in] (>=pt_dim) pt[] array stride
  //   pt - [in] array of points
  //   t_stride - [in] (>=1) t[] array stride
  //   t - [in] strictly increasing array of interpolation parameters
  // Returns:
  //   true if successful
  // Remarks:
  //   The result has order = points.Count() and the loft uses the 
  //   parameterizaton curve( t[i] ) = points[i].
  bool Loft(
    int pt_dim,
    int pt_count,
    int pt_stride,
    const double* pt,
    int t_stride,
    const double* t
    );

  // Description:
  //   Gets bounding box.
  // Parameters:
  //   box_min - [out] minimum corner of axis aligned bounding box
  //       The box_min[] array must have size m_dim.
  //   box_max - [out] maximum corner of axis aligned bounding box
  //       The box_max[] array must have size m_dim.
  //   bGrowBox - [in] if true, input box_min/box_max must be set
  //      to valid bounding box corners and this box is enlarged to
  //      be the union of the input box and the bezier's bounding
  //      box.
  // Returns:
  //   true if successful.
  bool GetBBox( // returns true if successful
         double* box_min,
         double* box_max,
         int bGrowBox = false
         ) const;

  // Description:
  //   Gets bounding box.
  // Parameters:
  //   bbox - [out] axis aligned bounding box returned here.
  //   bGrowBox - [in] if true, input bbox must be a valid
  //      bounding box and this box is enlarged to
  //      be the union of the input box and the 
  //      bezier's bounding box.
  // Returns:
  //   true if successful.
  bool GetBoundingBox(
         ON_BoundingBox& bbox,
         int bGrowBox = false
         ) const;

  // Description:
  //   Gets bounding box.
  // Returns:
  //   Axis aligned bounding box.
  ON_BoundingBox BoundingBox() const;

  /*
	Description:
    Get tight bounding box of the bezier.
	Parameters:
		tight_bbox - [in/out] tight bounding box
		bGrowBox -[in]	(default=false)			
      If true and the input tight_bbox is valid, then returned
      tight_bbox is the union of the input tight_bbox and the 
      tight bounding box of the bezier curve.
		xform -[in] (default=NULL)
      If not NULL, the tight bounding box of the transformed
      bezier is calculated.  The bezier curve is not modified.
	Returns:
    True if the returned tight_bbox is set to a valid 
    bounding box.
  */
	bool GetTightBoundingBox( 
			ON_BoundingBox& tight_bbox, 
      int bGrowBox = false,
			const ON_Xform* xform = 0
      ) const;

  // Description:
  //   Transform the bezier.
  // Parameters:
  //   xform - [in] transformation to apply to bezier
  // Returns:
  //   true if successful.  false if bezier is invalid
  //   and cannot be transformed.
  bool Transform( 
         const ON_Xform& xform
         );

  // Description:
  //   Rotates the bezier curve about the specified axis.  A positive
  //   rotation angle results in a counter-clockwise rotation
  //   about the axis (right hand rule).
  // Parameters:
  //   sin_angle - [in] sine of rotation angle
  //   cos_angle - [in] sine of rotation angle
  //   rotation_axis - [in] direction of the axis of rotation
  //   rotation_center - [in] point on the axis of rotation
  // Returns:
  //   true if bezier curve successfully rotated
  // Remarks:
  //   Uses ON_BezierCurve::Transform() function to calculate the result.
  bool Rotate(
        double sin_angle,
        double cos_angle,
        const ON_3dVector& rotation_axis,
        const ON_3dPoint& rotation_center
        );

  // Description:
  //   Rotates the bezier curve about the specified axis.  A positive
  //   rotation angle results in a counter-clockwise rotation
  //   about the axis (right hand rule).
  // Parameters:
  //   rotation_angle - [in] angle of rotation in radians
  //   rotation_axis - [in] direction of the axis of rotation
  //   rotation_center - [in] point on the axis of rotation
  // Returns:
  //   true if bezier curve successfully rotated
  // Remarks:
  //   Uses ON_BezierCurve::Transform() function to calculate the result.
  bool Rotate(
        double rotation_angle,
        const ON_3dVector& rotation_axis,
        const ON_3dPoint& rotation_center
        );

  // Description:
  //   Translates the bezier curve along the specified vector.
  // Parameters:
  //   translation_vector - [in] translation vector
  // Returns:
  //   true if bezier curve successfully translated
  // Remarks:
  //   Uses ON_BezierCurve::Transform() function to calculate the result.
  bool Translate( 
    const ON_3dVector& translation_vector
    );

  // Description:
  //   Scales the bezier curve by the specified facotor.  The scale is
  //   centered at the origin.
  // Parameters:
  //   scale_factor - [in] scale factor
  // Returns:
  //   true if bezier curve successfully scaled
  // Remarks:
  //   Uses ON_BezierCurve::Transform() function to calculate the result.
  bool Scale( 
    double scale_factor
    );

  // Returns:
  //   Domain of bezier (always [0,1]).
  ON_Interval Domain() const;

  // Description:
  //   Reverses bezier by reversing the order
  //   of the control points.
  bool Reverse();

  // Description:
  //   Evaluate point at a parameter.
  // Parameters:
  //   t - [in] evaluation parameter
  // Returns:
  //   Point (location of curve at the parameter t).
  ON_3dPoint  PointAt( 
                double t 
                ) const;

  // Description:
  //   Evaluate first derivative at a parameter.
  // Parameters:
  //   t - [in] evaluation parameter
  // Returns:
  //   First derivative of the curve at the parameter t.
  // Remarks:
  //   No error handling.
  // See Also:
  //   ON_Curve::Ev1Der
  ON_3dVector DerivativeAt(
                double t 
                ) const;

  // Description:
  //   Evaluate unit tangent vector at a parameter.
  // Parameters:
  //   t - [in] evaluation parameter
  // Returns:
  //   Unit tangent vector of the curve at the parameter t.
  // Remarks:
  //   No error handling.
  // See Also:
  //   ON_Curve::EvTangent
  ON_3dVector TangentAt(
                double t 
                ) const;

  // Description:
  //   Evaluate the curvature vector at a parameter.
  // Parameters:
  //   t - [in] evaluation parameter
  // Returns:
  //   curvature vector of the curve at the parameter t.
  // Remarks:
  //   No error handling.
  // See Also:
  //   ON_Curve::EvCurvature
  ON_3dVector CurvatureAt(
                double t
                ) const;

  // Description:
  //   Evaluate point at a parameter with error checking.
  // Parameters:
  //   t - [in] evaluation parameter
  //   point - [out] value of curve at t
  // Returns:
  //   false if unable to evaluate.
  bool EvPoint(
         double t,
         ON_3dPoint& point
         ) const;

  // Description:
  //   Evaluate first derivative at a parameter with error checking.
  // Parameters:
  //   t - [in] evaluation parameter
  //   point - [out] value of curve at t
  //   first_derivative - [out] value of first derivative at t
  // Returns:
  //   false if unable to evaluate.
  bool Ev1Der(
         double t,
         ON_3dPoint& point,
         ON_3dVector& first_derivative
         ) const;

  // Description:
  //   Evaluate second derivative at a parameter with error checking.
  // Parameters:
  //   t - [in] evaluation parameter
  //   point - [out] value of curve at t
  //   first_derivative - [out] value of first derivative at t
  //   second_derivative - [out] value of second derivative at t
  // Returns:
  //   false if unable to evaluate.
  bool Ev2Der(
         double t,
         ON_3dPoint& point,
         ON_3dVector& first_derivative,
         ON_3dVector& second_derivative
         ) const;

  /*
  Description:
    Evaluate unit tangent at a parameter with error checking.
  Parameters:
    t - [in] evaluation parameter
    point - [out] value of curve at t
    tangent - [out] value of unit tangent
  Returns:
    false if unable to evaluate.
  See Also:
    ON_Curve::TangentAt
    ON_Curve::Ev1Der
  */
  bool EvTangent(
         double t,
         ON_3dPoint& point,
         ON_3dVector& tangent
         ) const;

  /*
  Description:
    Evaluate unit tangent and curvature at a parameter with error checking.
  Parameters:
    t - [in] evaluation parameter
    point - [out] value of curve at t
    tangent - [out] value of unit tangent
    kappa - [out] value of curvature vector
  Returns:
    false if unable to evaluate.
  */
  bool EvCurvature(
         double t,
         ON_3dPoint& point,
         ON_3dVector& tangent,
         ON_3dVector& kappa
         ) const;

  // Description:
  //   Evaluate a bezier.
  // Parameters:
  //   t - [in] evaluation parameter (usually 0 <= t <= 1)
  //   der_count - [in] (>=0) number of derivatives to evaluate
  //   v_stride - [in] (>=m_dim) stride to use for the v[] array
  //   v - [out] array of length (der_count+1)*v_stride
  //       bez(t) is returned in (v[0],...,v[m_dim-1]),
  //       bez'(t) is retuned in (v[v_stride],...,v[v_stride+m_dim-1]),
  //       bez"(t) is retuned in (v[2*v_stride],...,v[2*v_stride+m_dim-1]),
  //       etc.
  // Returns:
  //   true if successful
  bool Evaluate(
         double t,
         int der_count,
         int v_stride,
         double* v
         ) const;

  // Description:
  //   Get ON_NurbsCurve form of a bezier.
  // Parameters:
  //   nurbs_curve - [out] NURBS curve form of a bezier.
  //       The domain is [0,1].
  // Returns:
  //   true if successful
  bool GetNurbForm( 
    ON_NurbsCurve& nurbs_curve
    ) const;

  // Returns:
  //   true if bezier is rational.
  bool IsRational() const;
  
  // Returns:
  //   Number of doubles per control vertex.
  //   (= IsRational() ? Dim()+1 : Dim())
  int CVSize() const;

  // Returns:
  //   Number of control vertices in the bezier.
  //   This is always the same as the order of the bezier.
  int CVCount() const;
  
  // Returns:
  //   Order of the bezier. (order=degree+1)
  int Order() const;        // order = degree + 1
	
  // Returns:
  //   Degree of the bezier. (degree=order-1)
  int Degree() const;

  /*
  Description:
    Expert user function to get a pointer to control vertex
    memory.  If you are not an expert user, please use
    ON_BezierCurve::GetCV( ON_3dPoint& ) or 
    ON_BezierCurve::GetCV( ON_4dPoint& ).
  Parameters:
    cv_index - [in] (0 <= cv_index < m_order)
  Returns:
    Pointer to control vertex.
  Remarks:
    If the Bezier curve is rational, the format of the 
    returned array is a homogeneos rational point with
    length m_dim+1.  If the Bezier curve is not rational, 
    the format of the returned array is a nonrational 
    euclidean point with length m_dim.
  See Also
    ON_BezierCurve::CVStyle
    ON_BezierCurve::GetCV
    ON_BezierCurve::Weight
  */
  double* CV(
        int cv_index
        ) const;

  /*
  Description:
    Returns the style of control vertices in the m_cv array.
  Returns:
    @untitled table
    ON::not_rational                m_is_rat is false
    ON::homogeneous_rational        m_is_rat is true
  */
  ON::point_style CVStyle() const;

  // Parameters:
  //   cv_index - [in] control vertex index (0<=i<m_order)
  // Returns:
  //   Weight of the i-th control vertex.
  double Weight(
        int cv_index
        ) const;

  // Description:
  //   Set weight of a control vertex.
  // Parameters:
  //   cv_index - [in] control vertex index (0 <= cv_index < m_order)
  //   weight - [in] weight
  // Returns:
  //   true if the weight can be set.  If weight is not 1 and
  //   the bezier is not rational, then false is returned.
  //   Use ON_BezierCurve::MakeRational to make a bezier curve
  //   rational.
  // See Also:
  //   ON_BezierCurve::SetCV, ON_BezierCurve::MakeRational,
  //   ON_BezierCurve::IsRational, ON_BezierCurve::Weight
  bool SetWeight(
        int cv_index,
        double weight
        );

  // Description:
  //   Set control vertex
  // Parameters:
  //   cv_index - [in] control vertex index (0 <= cv_index < m_order)
  //   pointstyle - [in] specifes what kind of values are passed
  //      in the cv array.
  //        ON::not_rational 
  //          cv[] is an array of length m_dim that defines
  //          a euclidean (world coordinate) point
  //        ON::homogeneous_rational
  //          cv[] is an array of length (m_dim+1) that defines
  //          a rational homogeneous point.
  //        ON::euclidean_rational
  //          cv[] is an array of length (m_dim+1).  The first
  //          m_dim values define the euclidean (world coordinate) 
  //          location of the point.  cv[m_dim] is the weight
  //        ON::intrinsic_point_style
  //          If m_is_rat is true, cv[] has ON::homogeneous_rational
  //          point style.  If m_is_rat is false, cv[] has 
  //          ON::not_rational point style.
  //   cv - [in] array with control vertex value.
  // Returns:
  //   true if the point can be set.
  bool SetCV(
        int cv_index,
        ON::point_style pointstyle,
        const double* cv
        );

  // Description:
  //   Set location of a control vertex.
  // Parameters:
  //   cv_index - [in] control vertex index (0 <= cv_index < m_order)
  //   point - [in] control vertex location.  If the bezier
  //      is rational, the weight will be set to 1.
  // Returns:
  //   true if successful.
  // See Also:
  //   ON_BezierCurve::CV, ON_BezierCurve::SetCV,
  //   ON_BezierCurve::SetWeight, ON_BezierCurve::Weight
  bool SetCV(
        int cv_index,
        const ON_3dPoint& point
        );

  // Description:
  //   Set value of a control vertex.
  // Parameters:
  //   cv_index - [in] control vertex index (0 <= cv_index < m_order)
  //   point - [in] control vertex value.  If the bezier
  //      is not rational, the euclidean location of
  //      homogenoeous point will be used.
  // Returns:
  //   true if successful.
  // See Also:
  //   ON_BezierCurve::CV, ON_BezierCurve::SetCV,
  //   ON_BezierCurve::SetWeight, ON_BezierCurve::Weight
  bool SetCV(
        int cv_index,
        const ON_4dPoint& point
        );

  // Description:
  //   Get location of a control vertex.
  // Parameters:
  //   cv_index - [in] control vertex index (0 <= cv_index < m_order)
  //   pointstyle - [in] specifes what kind of values to get
  //        ON::not_rational 
  //          cv[] is an array of length m_dim that defines
  //          a euclidean (world coordinate) point
  //        ON::homogeneous_rational
  //          cv[] is an array of length (m_dim+1) that defines
  //          a rational homogeneous point.
  //        ON::euclidean_rational
  //          cv[] is an array of length (m_dim+1).  The first
  //          m_dim values define the euclidean (world coordinate) 
  //          location of the point.  cv[m_dim] is the weight
  //        ON::intrinsic_point_style
  //          If m_is_rat is true, cv[] has ON::homogeneous_rational
  //          point style.  If m_is_rat is false, cv[] has 
  //          ON::not_rational point style.
  //   cv - [out] array with control vertex value.
  // Returns:
  //   true if successful.  false if cv_index is invalid.
  bool GetCV(
        int cv_index,
        ON::point_style pointstyle,
        double* cv
        ) const;

  // Description:
  //   Get location of a control vertex.
  // Parameters:
  //   cv_index - [in] control vertex index (0 <= cv_index < m_order)
  //   point - [out] Location of control vertex.  If the bezier
  //      is rational, the euclidean location is returned.
  // Returns:
  //   true if successful.
  bool GetCV(
        int cv_index,
        ON_3dPoint& point
        ) const;

  // Description:
  //   Get value of a control vertex.
  // Parameters:
  //   cv_index - [in] control vertex index (0 <= cv_index < m_order)
  //   point - [out] Homogenous value of control vertex.
  //      If the bezier is not rational, the weight is 1.
  // Returns:
  //   true if successful.
  bool GetCV(
        int cv_index,
        ON_4dPoint& point
        ) const;

  // Description:
  //   Zeros control vertices and, if rational, sets weights to 1.
  bool ZeroCVs(); 

  // Description:
  //   Make beizer rational.
  // Returns:
  //   true if successful.
  // See Also:
  //   ON_Bezier::MakeNonRational
  bool MakeRational();

  // Description:
  //   Make beizer not rational by setting all control
  //   vertices to their euclidean locations and setting
  //   m_is_rat to false.
  // See Also:
  //   ON_Bezier::MakeRational
  bool MakeNonRational();

  // Description:
  //   Increase degree of bezier.
  // Parameters:
  //   desired_degree - [in]
  // Returns:
  //   true if successful.  false if desired_degree < current degree.
  bool IncreaseDegree(
          int desired_degree
          );

  // Description:
  //   Change dimension of bezier.
  // Parameters:
  //   desired_dimension - [in]
  // Returns:
  //   true if successful.  false if desired_dimension < 1
  bool ChangeDimension(
          int desired_dimension
          );

  /////////////////////////////////////////////////////////////////
  // Tools for managing CV and knot memory

  // Description:
  //   Make sure m_cv array has a certain length.
  // Parameters:
  //   desired_cv_capacity - [in] minimum length of m_cv array.
  // Returns:
  //   true if successful.
  bool ReserveCVCapacity(
    int desired_cv_capacity
    );

  // Description:
  //   Trims (or extends) the bezier so the bezier so that the 
  //   result starts bezier(interval[0]) and ends at 
  //   bezier(interval[1]) (Evaluation performed on input bezier.)
  // Parameters:
  //   interval -[in]
  // Example:
  //   An interval of [0,1] leaves the bezier unchanged.  An
  //   interval of [0.5,1] would trim away the left half.  An
  //   interval of [0.0,2.0] would extend the right end.
  bool Trim( 
    const ON_Interval& interval 
    );

  // Description:
  //   Split() divides the Bezier curve at the specified parameter.
  //   The parameter must satisfy 0 < t < 1.  You may pass *this as
  //   one of the curves to be returned.
  // Parameters:
  //   t - [in] (0 < t < 1 ) parameter to split at
  //   left_side - [out]
  //   right_side - [out]  
  // Example:
  //       ON_BezierCurve crv = ...;
  //       ON_BezierCurve right_side;
  //       crv.Split( 0.5, crv, right_side );
  //   would split crv at the 1/2, put the left side in crv,
  //   and return the right side in right_side.
  bool Split( 
         double t,
         ON_BezierCurve& left_side,
         ON_BezierCurve& right_side
         ) const;

  // Description:
  //   returns the length of the control polygon
  double ControlPolygonLength() const;

  /*
  Description:
    Use a linear fractional tranformation for [0,1] to reparameterize
    the bezier.  The locus of the curve is not changed, but the
    parameterization is changed.
  Parameters:
    c - [in]
      reparameterization constant (generally speaking, c should be > 0).
      If c != 1, then the returned bezier will be rational.
  Returns:
    true if successful.
  Remarks:
    The reparameterization is performed by composing the input Bezier with
    the function lambda: [0,1] -> [0,1] given by

          t ->  c*t / ( (c-1)*t + 1 )

    Note that lambda(0) = 0, lambda(1) = 1, lambda'(t) > 0, 
    lambda'(0) = c and lambda'(1) = 1/c.

    If the input Bezier has control vertices {B_0, ..., B_d}, then the 
    output Bezier has control vertices 

          (B_0, ... c^i * B_i, ..., c^d * B_d).

    To derive this formula, simply compute the i-th Bernstein polynomial
    composed with lambda().

    The inverse parameterization is given by 1/c.  That is, the 
    cumulative effect of the two calls

          Reparameterize(c)
          Reparameterize(1.0/c)

    is to leave the bezier unchanged.
  See Also:
    ON_Bezier::ScaleConrolPoints
  */
  bool Reparameterize(
          double c
          );

  // misspelled function name is obsolete
  ON_DEPRECATED bool Reparametrize(double);

  /*
  Description:
    Scale a rational Bezier's control vertices to set a weight to a 
    specified value.
  Parameters:
    i - [in] (0 <= i < order)
    w - [in] w != 0.0
  Returns:
    True if successful.  The i-th control vertex will have weight w.
  Remarks:
    Each control point is multiplied by w/w0, where w0 is the
    input value of Weight(i).
  See Also:
    ON_Bezier::Reparameterize
    ON_Bezier::ChangeWeights
  */
  bool ScaleConrolPoints( 
          int i, 
          double w
          );

  /*
  Description:
    Use a combination of scaling and reparameterization to set two 
    rational Bezier weights to specified values.
  Parameters:
    i0 - [in] control point index (0 <= i0 < order, i0 != i1)
    w0 - [in] Desired weight for i0-th control point
    i1 - [in] control point index (0 <= i1 < order, i0 != i1)
    w1 - [in] Desired weight for i1-th control point
  Returns:
    True if successful.  The returned bezier has the same locus but
    probably has a different parameterization.
  Remarks:
    The i0-th cv will have weight w0 and the i1-rst cv will have 
    weight w1.  If v0 and v1 are the cv's input weights, 
    then  v0, v1, w0 and w1 must all be nonzero, and w0*v0 
    and w1*v1 must have the same sign.

    The equations

          s * r^i0 = w0/v0
          s * r^i1 = w1/v1

    determine the scaling and reparameterization necessary to 
    change v0,v1 to w0,w1. 

    If the input Bezier has control vertices 
    
          (B_0, ..., B_d),

    then the output Bezier has control vertices 
    
          (s*B_0, ... s*r^i * B_i, ..., s*r^d * B_d).
  See Also:
    ON_Bezier::Reparameterize
    ON_Bezier::ScaleConrolPoints
  */
  bool ChangeWeights(
          int i0, 
          double w0, 
          int i1, 
          double w1
          );


  /*
  Description:
    Get the parameter of the point on the bezier curve
    that is closest to the point P.
  Parameters:
    P - [in]
    t - [out]
      Closest point parameter.
    maximum_distance - [in]
      If maximum_distance > 0.0, then an answer is returned
      only if the distance from the bezier curve to P
      is <= maximum_distance.  If maximum_distance <= 0.0,
      then maximum_distance is ignored.
    sub_domain - [in]
      If not NULL, the search is confined to the intersection
      of the sub_domain interval and (0,1).
  Returns:
    True if a point is found.
  See Also:
    ON_CurveTreeNode::GetClosestPoint
  Remarks:
    This function is not efficient if you will be finding
    multiple closest points to the same bezier.  To efficiently
    find multiple closest points, make a curve tree and use it.
    See the ON_BezierCurve::GetClosestPoint code for an example.
  */
  bool GetClosestPoint( 
          ON_3dPoint P,
          double* t,
          double maximum_distance = 0.0,
          const ON_Interval* sub_domain = 0
          ) const;


  /*
  Description:
    Get the parameter of the point on the bezier curve
    that is locally closest to the point P when the search
    begins at seed_parameter.
  Parameters:
    P - [in]
    seed_parameter - [in]
      Parameter where the search begins.
    t - [out]
      Closest point parameter.
    sub_domain - [in]
      If not NULL, the search is confined to the intersection
      of the sub_domain interval and (0,1).
  Returns:
    True if a point is found.
  */
  bool GetLocalClosestPoint( 
          ON_3dPoint P,
          double seed_parameter,
          double* t,
          const ON_Interval* sub_domain = 0
          ) const;


  /*
  Description:
    Get a local curve-curve intersection point.
  Parameters:
    other_bezcrv - [in] other curve
    this_seed_t - [in] this curve seed paramter
    other_seed_t - [in] other curve seed paramter
    this_t - [out] this curve paramter
    other_t - [out] other curve paramter
    this_domain - [in] optional this curve domain restriction
    other_domain - [in] optional other curve domain restriction
  Returns:
    True if something is returned in (t,u,v).  Check
    answer.
  */
  bool GetLocalCurveIntersection( 
          const ON_BezierCurve* other_bezcrv,
          double this_seed_t,
          double other_seed_t,
          double* this_t,
          double* other_t,
          const ON_Interval* this_domain = 0,
          const ON_Interval* other_domain = 0
          ) const;

  /*
  Description:
    Find bezier self intersection points.
  Parameters:
    x - [out] 
       Intersection events are appended to this array.
    intersection_tolerance - [in]
  Returns:
    Number of intersection events appended to x.
  */
  int IntersectSelf( 
          ON_SimpleArray<ON_X_EVENT>& x,
          double intersection_tolerance = 0.0
          ) const;

  /*
  Description:
    Intersect this bezier with bezierB.
  Parameters:
    curveB - [in]
    x - [out] Intersection events are appended to this array.
    intersection_tolerance - [in]  If the distance from a point
      on this curve to curveB is <= intersection tolerance,
      then the point will be part of an intersection event.
      If the input intersection_tolerance <= 0.0, then 0.001 is used.
    overlap_tolerance - [in] If t1 and t2 are parameters of this 
      curve's intersection events and the distance from curve(t) to 
      curveB is <= overlap_tolerance for every t1 <= t <= t2,
      then the event will be returened as an overlap event.
      If the input overlap_tolerance <= 0.0, then 
      intersection_tolerance*2.0 is used.
    curveA_domain - [in] optional restriction on this bezier's domain
    curveB_domain - [in] optional restriction on bezierB domain
  Returns:
    Number of intersection events appended to x.
  Remarks:
    If you are performing more than one intersection,
    you should create curve trees and intersect them.
    See the IntersectBezierCurve code for an example.
  */
  int IntersectCurve( 
          const ON_BezierCurve* bezierB,
          ON_SimpleArray<ON_X_EVENT>& x,
          double intersection_tolerance = 0.0,
          double overlap_tolerance = 0.0,
          const ON_Interval* bezierA_domain = 0,
          const ON_Interval* bezierB_domain = 0
          ) const;

  /*
  Description:
    Get a local curve-surface intersection point.
  Parameters:
    bezsrf - [in]
    seed_t - [in] curve paramter
    seed_u - [in] surface parameter
    seed_v - [in] surface parameter
    t - [out] curve paramter
    u - [out] surface parameter
    v - [out] surface parameter
    tdomain - [in] optional curve domain restriction
    udomain - [in] optional surface domain restriction
    vdomain - [in] optional surface domain restriction
  Returns:
    True if something is returned in (t,u,v).  Check
    answer.
  */
  bool GetLocalSurfaceIntersection( 
          const ON_BezierSurface* bezsrf,
          double seed_t,
          double seed_u,
          double seed_v,
          double* t,
          double* u,
          double* v,
          const ON_Interval* tdomain = 0,
          const ON_Interval* udomain = 0,
          const ON_Interval* vdomain = 0
          ) const;


  /*
  Description:
    Intersect this bezier curve with bezsrfB.
  Parameters:
    bezsrfB - [in]
    x - [out] Intersection events are appended to this array.
    intersection_tolerance - [in]  If the distance from a point
      on this curve to the surface is <= intersection tolerance,
      then the point will be part of an intersection event.
      If the input intersection_tolerance <= 0.0, then 0.001 is used.
    overlap_tolerance - [in] If t1 and t2 are curve parameters of
      intersection events and the distance from curve(t) to the
      surface is <= overlap_tolerance for every t1 <= t <= t2,
      then the event will be returened as an overlap event.
      If the input overlap_tolerance <= 0.0, then 
      intersection_tolerance*2.0 is used.
    curveA_domain - [in] optional restriction on this curve's domain
    surfaceB_udomain - [in] optional restriction on surfaceB u domain
    surfaceB_vdomain - [in] optional restriction on surfaceB v domain
  Returns:
    Number of intersection events appended to x.
  Remarks:
    If you are performing more than one intersection,
    you should create curve and surface trees and 
    intersect them. See the IntersectBezierSurface code
    for an example.
  */
  int IntersectSurface( 
          const ON_BezierSurface* bezsrfB,
          ON_SimpleArray<ON_X_EVENT>& x,
          double intersection_tolerance = 0.0,
          double overlap_tolerance = 0.0,
          const ON_Interval* bezierA_domain = 0,
          const ON_Interval* bezsrfB_udomain = 0,
          const ON_Interval* bezsrfB_vdomain = 0
          ) const;


  /////////////////////////////////////////////////////////////////
  // Implementation
public:
  // NOTE: These members are left "public" so that expert users may efficiently
  //       create bezier curves using the default constructor and borrow the
  //       knot and CV arrays from their native NURBS representation.
  //       No technical support will be provided for users who access these
  //       members directly.  If you can't get your stuff to work, then use
  //       the constructor with the arguments and the SetKnot() and SetCV()
  //       functions to fill in the arrays.


  // dimension of bezier (>=1)
  int m_dim;

  // 1 if bezier is rational, 0 if bezier is not rational
  int m_is_rat;

  // order = degree+1
  int m_order;

  // Number of doubles per cv ( >= ((m_is_rat)?m_dim+1:m_dim) )
  int m_cv_stride;

  // The i-th cv begins at cv[i*m_cv_stride].
  double* m_cv;

  // Number of doubles in m_cv array.  If m_cv_capacity is zero
  // and m_cv is not NULL, an expert user is managing the m_cv
  // memory.  ~ON_BezierCurve will not deallocate m_cv unless
  // m_cv_capacity is greater than zero.
  int m_cv_capacity;

#if 8 == ON_SIZEOF_POINTER
  // pad to a multiple of 8 bytes so custom allocators
  // will keep m_cv aligned and tail-padding reuse will
  // not be an issue.
  int m_reserved_ON_BezierCurve;
#endif
};


class ON_CLASS ON_BezierSurface
{
public:
  ON_BezierSurface();
  ON_BezierSurface(
    int dim,
    int is_rat,
    int order0,
    int order1
    );

  ~ON_BezierSurface();
  ON_BezierSurface(const ON_BezierSurface&);
  ON_BezierSurface(const ON_PolynomialSurface&);
  ON_BezierSurface& operator=(const ON_BezierSurface&);
  ON_BezierSurface& operator=(const ON_PolynomialSurface&);

  bool IsValid() const;
  void Dump( ON_TextLog& ) const; // for debugging
  int Dimension() const;

  bool Create(
    int dim,
    int is_rat,
    int order0,
    int order1
    );

  void Destroy();
  void EmergencyDestroy(); // call if memory used by ON_NurbsCurve becomes invalid

  /*
  Description:
    Loft a bezier surface through a list of bezier curves.
  Parameters:
    curve_list - [in]  list of curves that have the same degree.
  Returns:
    True if successful.
  */
  bool Loft( const ON_ClassArray<ON_BezierCurve>& curve_list );

  /*
  Description:
    Loft a bezier surface through a list of bezier curves.
  Parameters:
    curve_count - [in] number of curves in curve_list
    curve_list - [in]  array of pointers to curves that have the same degree.
  Returns:
    True if successful.
  */
  bool Loft( 
    int count, 
    const ON_BezierCurve* const* curve_list 
    );

  bool GetBBox(        // returns true if successful
         double*,      // minimum
         double*,      // maximum
         int bGrowBox = false  // true means grow box
         ) const;

  bool GetBoundingBox(
        ON_BoundingBox& bbox,
        int bGrowBox
        ) const;

  ON_BoundingBox BoundingBox() const;

  bool Transform( 
         const ON_Xform&
         );

  // Description:
  //   Rotates the bezier surface about the specified axis.  A positive
  //   rotation angle results in a counter-clockwise rotation
  //   about the axis (right hand rule).
  // Parameters:
  //   sin_angle - [in] sine of rotation angle
  //   cos_angle - [in] sine of rotation angle
  //   rotation_axis - [in] direction of the axis of rotation
  //   rotation_center - [in] point on the axis of rotation
  // Returns:
  //   true if bezier surface successfully rotated
  // Remarks:
  //   Uses ON_BezierSurface::Transform() function to calculate the result.
  bool Rotate(
        double sin_angle,
        double cos_angle,
        const ON_3dVector& rotation_axis,
        const ON_3dPoint& rotation_center
        );

  // Description:
  //   Rotates the bezier surface about the specified axis.  A positive
  //   rotation angle results in a counter-clockwise rotation
  //   about the axis (right hand rule).
  // Parameters:
  //   rotation_angle - [in] angle of rotation in radians
  //   rotation_axis - [in] direction of the axis of rotation
  //   rotation_center - [in] point on the axis of rotation
  // Returns:
  //   true if bezier surface successfully rotated
  // Remarks:
  //   Uses ON_BezierSurface::Transform() function to calculate the result.
  bool Rotate(
        double rotation_angle,
        const ON_3dVector& rotation_axis,
        const ON_3dPoint& rotation_center
        );

  // Description:
  //   Translates the bezier surface along the specified vector.
  // Parameters:
  //   translation_vector - [in] translation vector
  // Returns:
  //   true if bezier surface successfully translated
  // Remarks:
  //   Uses ON_BezierSurface::Transform() function to calculate the result.
  bool Translate( 
    const ON_3dVector& translation_vector
    );

  // Description:
  //   Scales the bezier surface by the specified facotor.  The scale is
  //   centered at the origin.
  // Parameters:
  //   scale_factor - [in] scale factor
  // Returns:
  //   true if bezier surface successfully scaled
  // Remarks:
  //   Uses ON_BezierSurface::Transform() function to calculate the result.
  bool Scale( 
    double scale_factor
    );

  ON_Interval Domain(
    int // 0 = "u" domain, 1 = "v" domain
    ) const;

  bool Reverse( int );  // reverse parameterizatrion
                        // Domain changes from [a,b] to [-b,-a]
  
  bool Transpose(); // transpose surface parameterization (swap "s" and "t")

  bool Evaluate( // returns false if unable to evaluate
         double, double, // evaluation parameter
         int,            // number of derivatives (>=0)
         int,            // array stride (>=Dimension())
         double*         // array of length stride*(ndir+1)*(ndir+2)/2
         ) const;

  ON_3dPoint PointAt(double s, double t) const;

  bool GetNurbForm( ON_NurbsSurface& ) const;

  bool IsRational() const;  // true if NURBS curve is rational
  
  int CVSize() const;       // number of doubles per control vertex 
                // = IsRational() ? Dim()+1 : Dim()
  
  int Order(        // order = degree + 1
        int // dir
        ) const;
	
  int Degree(       // degree = order - 1
        int // dir
        ) const;

  /*
  Description:
    Expert user function to get a pointer to control vertex
    memory.  If you are not an expert user, please use
    ON_BezierSurface::GetCV( ON_3dPoint& ) or 
    ON_BezierSurface::GetCV( ON_4dPoint& ).
  Parameters:
    cv_index0 - [in] (0 <= cv_index0 < m_order[0])
    cv_index1 - [in] (0 <= cv_index1 < m_order[1])
  Returns:
    Pointer to control vertex.
  Remarks:
    If the Bezier surface is rational, the format of the 
    returned array is a homogeneos rational point with
    length m_dim+1.  If the Bezier surface is not rational, 
    the format of the returned array is a nonrational 
    euclidean point with length m_dim.
  See Also
    ON_BezierSurface::CVStyle
    ON_BezierSurface::GetCV
    ON_BezierSurface::Weight
  */
  double* CV(
        int cv_index0,
        int cv_index1
        ) const;

  /*
  Description:
    Returns the style of control vertices in the m_cv array.
  Returns:
    @untitled table
    ON::not_rational                m_is_rat is false
    ON::homogeneous_rational        m_is_rat is true
  */
  ON::point_style CVStyle() const;

  double Weight(        // get value of control vertex weight
        int,int          // CV index ( >= 0 and < CVCount() )
        ) const;

  bool SetWeight(      // set value of control vertex weight
        int,int,         // CV index ( >= 0 and < CVCount() )
        double
        );

  bool SetCV(              // set a single control vertex
        int,int,         // CV index ( >= 0 and < CVCount() )
        ON::point_style, // style of input point
        const double*     // value of control vertex
        );

  bool SetCV(               // set a single control vertex
        int,int,         // CV index ( >= 0 and < CVCount() )
        const ON_3dPoint& // value of control vertex
                           // If NURBS is rational, weight
                           // will be set to 1.
        );

  bool SetCV(              // set a single control vertex
        int,int,         // CV index ( >= 0 and < CVCount() )
        const ON_4dPoint& // value of control vertex
                          // If NURBS is not rational, euclidean
                          // location of homogeneous point will
                          // be used.
        );

  bool GetCV(              // get a single control vertex
        int,int,          // CV index ( >= 0 and < CVCount() )
        ON::point_style, // style to use for output point
        double*           // array of length >= CVSize()
        ) const;

  bool GetCV(              // get a single control vertex
        int,int,         // CV index ( >= 0 and < CVCount() )
        ON_3dPoint&      // gets euclidean cv when NURBS is rational
        ) const;

  bool GetCV(              // get a single control vertex
        int,int,         // CV index ( >= 0 and < CVCount() )
        ON_4dPoint&      // gets homogeneous cv
        ) const;

  bool ZeroCVs(); // zeros control vertices and, if rational, sets weights to 1

  bool MakeRational();

  bool MakeNonRational();

  bool Split( 
         int, // 0 split at "u"=t, 1= split at "v"=t
         double, // t = splitting parameter must 0 < t < 1
         ON_BezierSurface&, // west/south side returned here (can pass *this)
         ON_BezierSurface&  // east/north side returned here (can pass *this)
         ) const;

  bool Trim(
       int dir,
       const ON_Interval& domain
       );

	// returns the isocurve.  
	ON_BezierCurve* IsoCurve(
		   int dir,    // 0 first parameter varies and second parameter is constant
                   //   e.g., point on IsoCurve(0,c) at t is srf(t,c)
                   // 1 first parameter is constant and second parameter varies
                   //   e.g., point on IsoCurve(1,c) at t is srf(c,t)
       double c,    // value of constant parameter
			 ON_BezierCurve* iso=NULL	// When NULL result is constructed on the heap.
			 ) const;

	bool IsSingular( // true if surface side is collapsed to a point
         int        // side of parameter space to test
                   // 0 = south, 1 = east, 2 = north, 3 = west
         ) const;
 

  /////////////////////////////////////////////////////////////////
  // Tools for managing CV and knot memory
  bool ReserveCVCapacity(
    int // number of doubles to reserve
    );


  /*
  Description:
    Get the parameters of the point on the bezier surface
    that is closest to the point P.
  Parameters:
    P - [in]
    s - [out]
    t - [out]
      Closest point parameters.
    maximum_distance - [in]
      If maximum_distance > 0.0, then an answer is returned
      only if the distance from the bezier surface to P
      is <= maximum_distance.  If maximum_distance <= 0.0,
      then maximum_distance is ignored.
    sub_domain0 - [in]
      If not NULL, the search is confined to "s" parameters
      in the intersection of the sub_domain0 interval and (0,1).
    sub_domain1 - [in]
      If not NULL, the search is confined to "t" parameters
      in the intersection of the sub_domain1 interval and (0,1).
  Returns:
    True if a point is found.
  See Also:
    ON_SurfaceTreeNode::GetClosestPoint
  Remarks:
    This function is not efficient if you will be finding
    multiple closest points to the same bezier.  To efficiently
    find multiple closest points, make a surface tree and use it.
    See the ON_BezierSurface::GetClosestPoint code for an example.
  */
  bool GetClosestPoint(
          ON_3dPoint P,
          double* s,
          double* t,
          double maximum_distance = 0.0,
          const ON_Interval* sub_domain0 = 0,
          const ON_Interval* sub_domain1 = 0
          ) const;


  /*
  Description:
    Get the parameter of the point on the bezier surface
    that is locally closest to the point P when the search
    begins at (s_seed,t_seed).
  Parameters:
    P - [in]
    s_seed - [in]
    t_seed - [in]
      Parameters where the search begins.
    s - [out]
    t - [out]
      Closest point parameter.
    sub_domain0 - [in]
      If not NULL, the search is confined to "s" parameters
      in the intersection of the sub_domain0 interval and (0,1).
    sub_domain1 - [in]
      If not NULL, the search is confined to "t" parameters
      in the intersection of the sub_domain1 interval and (0,1).
  Returns:
    True if a point is found.
  */
  bool GetLocalClosestPoint(
          ON_3dPoint P,
          double s_seed,
          double t_seed,
          double* s,
          double* t,
          const ON_Interval* sub_domain0 = 0,
          const ON_Interval* sub_domain1 = 0
          ) const;


  /////////////////////////////////////////////////////////////////
  // Implementation
public:
  // NOTE: These members are left "public" so that expert users may efficiently
  //       create bezier curves using the default constructor and borrow the
  //       knot and CV arrays from their native NURBS representation.
  //       No technical support will be provided for users who access these
  //       members directly.  If you can't get your stuff to work, then use
  //       the constructor with the arguments and the SetKnot() and SetCV()
  //       functions to fill in the arrays.


  int     m_dim;           // >= 1
  int     m_is_rat;        // 0 = no, 1 = yes
  int     m_order[2];      // order = degree+1 >= 2
  int     m_cv_stride[2];  
  double* m_cv;
  int     m_cv_capacity;   // if 0, then destructor does not free m_cv
#if 8 == ON_SIZEOF_POINTER
  // pad to a multiple of 8 bytes so custom allocators
  // will keep m_cv aligned and tail-padding reuse will
  // not be an issue.
  int m_reserved_ON_BezierSurface;
#endif
};




class ON_CLASS ON_BezierCage
{
public:
  ON_BezierCage();

  ON_BezierCage(
    int dim,
    bool is_rat,
    int order0,
    int order1,
    int order2
    );


  /*
  Description:
    Construct a bezier volume that maps the unit cube
    to a bounding box.
  Parameters:
    bbox - [in] target bounding box
    order0 - [in]
    order1 - [in]
    order2 - [in]
  */
  ON_BezierCage( 
    const ON_BoundingBox& bbox,
    int order0,
    int order1,
    int order2
    );


  /*
  Description:
    Construct a bezier volume that maps the unit cube
    to an eight sided box.
  Parameters:
    box_corners - [in] 8 points that define corners of the
                       target volume.

            7______________6
            |\             |\
            | \            | \
            |  \ _____________\
            |   4          |   5
            |   |          |   |
            |   |          |   |
            3---|----------2   |
            \   |          \   |
             \  |t          \  |
            s \ |            \ |
               \0_____________\1
                       r

    order0 - [in]
    order1 - [in]
    order2 - [in]
  */
  ON_BezierCage( 
    const ON_3dPoint* box_corners,
    int order0,
    int order1,
    int order2
    );

  ~ON_BezierCage();

  ON_BezierCage(const ON_BezierCage& src);

  ON_BezierCage& operator=(const ON_BezierCage& src);


  /*
  Description:
    Tests class to make sure members are correctly initialized.
  Returns:
    True if the orders are all >= 2, dimension is positive,
    and the rest of the members have settings that are
    valid for the orders and dimension.
  */
  bool IsValid() const;

  void Dump( ON_TextLog& text_log) const;


  /*
  Description:
    The dimension of the image of the bazier volume map.
    This is generally three, but can be any positive
    integer.
  Returns:
    Dimesion of the image space.
  */
  int Dimension() const;


  /*
  Description:
    Creates a bezier volume with specified orders.
  Parameters:
    dim - [in]
    is_rat - [in]
    order0 - [in]
    order1 - [in]
    order2 - [in]
  Returns:
    True if input was valid and creation succeded.
  */
  bool Create(
    int dim,
    bool is_rat,
    int order0,
    int order1,
    int order2
    );

  /*
  Description:
    Create a Bezier volume with corners defined by a bounding box.
  Parameters:
    bbox - [in] target bounding box - the bezier will
               map the unit cube onto this bounding box.
    order0 - [in]
    order1 - [in]
    order2 - [in]
  */
  bool Create(
    const ON_BoundingBox& bbox,
    int order0,
    int order1,
    int order2
    );

  /*
  Description:
    Create a bezier volume from a 3d box
  Parameters:
    box_corners - [in] 8 points that define corners of the volume

            7______________6
            |\             |\
            | \            | \
            |  \ _____________\
            |   4          |   5
            |   |          |   |
            |   |          |   |
            3---|----------2   |
            \   |          \   |
             \  |t          \  |
            s \ |            \ |
               \0_____________\1
                       r

  */
  bool Create(
    const ON_3dPoint* box_corners,
    int order0,
    int order1,
    int order2
    );


  /*
  Description:
    Frees the CV array and sets all members to zero.
  */
  void Destroy();

  /*
  Description:
    Sets all members to zero.  Does not free the CV array
    even when m_cv is not NULL.  Generally used when the
    CVs were allocated from a memory pool that no longer
    exists and the free done in ~ON_BezierCage would
    cause a crash.
  */
  void EmergencyDestroy();


  /*
  Description:
    Reads the definition of this class from an
    archive previously saved by ON_BezierVolue::Write.
  Parameters:
    archive - [in] target archive
  Returns:
    True if successful.
  */
  bool Read(ON_BinaryArchive& archive);

  /*
  Description:
    Saves the definition of this class in serial binary
    form that can be read by ON_BezierVolue::Read.
  Parameters:
    archive - [in] target archive
  Returns:
    True if successful.
  */
  bool Write(ON_BinaryArchive& archive) const;


  /*
  Description:
    Gets the axis aligned bounding box that contains
    the bezier's control points.  The bezier volume
    maps the unit cube into this box.
  Parameters:
    boxmin - [in] array of Dimension() doubles
    boxmax - [in] array of Dimension() doubles
    bGrowBox =  [in] if true and the input is a valid box
                          then the input box is grown to
                          include this object's bounding box.
  Returns:
    true if successful.
  */
  bool GetBBox(
         double* boxmin,
         double* boxmax,
         int bGrowBox = false 
         ) const;

  bool Transform( 
         const ON_Xform& xform
         );

  // Description:
  //   Rotates the bezier surface about the specified axis.  A positive
  //   rotation angle results in a counter-clockwise rotation
  //   about the axis (right hand rule).
  // Parameters:
  //   sin_angle - [in] sine of rotation angle
  //   cos_angle - [in] sine of rotation angle
  //   rotation_axis - [in] direction of the axis of rotation
  //   rotation_center - [in] point on the axis of rotation
  // Returns:
  //   true if bezier surface successfully rotated
  // Remarks:
  //   Uses ON_BezierCage::Transform() function to calculate the result.
  bool Rotate(
        double sin_angle,
        double cos_angle,
        const ON_3dVector& rotation_axis,
        const ON_3dPoint& rotation_center
        );

  // Description:
  //   Rotates the bezier surface about the specified axis.  A positive
  //   rotation angle results in a counter-clockwise rotation
  //   about the axis (right hand rule).
  // Parameters:
  //   rotation_angle - [in] angle of rotation in radians
  //   rotation_axis - [in] direction of the axis of rotation
  //   rotation_center - [in] point on the axis of rotation
  // Returns:
  //   true if bezier surface successfully rotated
  // Remarks:
  //   Uses ON_BezierCage::Transform() function to calculate the result.
  bool Rotate(
        double rotation_angle,
        const ON_3dVector& rotation_axis,
        const ON_3dPoint& rotation_center
        );

  // Description:
  //   Translates the bezier surface along the specified vector.
  // Parameters:
  //   translation_vector - [in] translation vector
  // Returns:
  //   true if bezier surface successfully translated
  // Remarks:
  //   Uses ON_BezierCage::Transform() function to calculate the result.
  bool Translate( 
    const ON_3dVector& translation_vector
    );

  // Description:
  //   Scales the bezier surface by the specified facotor.  The scale is
  //   centered at the origin.
  // Parameters:
  //   scale_factor - [in] scale factor
  // Returns:
  //   true if bezier surface successfully scaled
  // Remarks:
  //   Uses ON_BezierCage::Transform() function to calculate the result.
  bool Scale( 
    double scale_factor
    );

  ON_Interval Domain(
    int // 0 = "u" domain, 1 = "v" domain, 2 = "w" domain
    ) const;

  // returns false if unable to evaluate
  bool Evaluate( 
         double r, 
         double s, 
         double t,
         int der_count,
         int v_stride,
         double* v        // array of length stride*(ndir+1)*(ndir+2)/2
         ) const;

  /*
  Description:
    Evaluates bezer volume map.
  Parameters:
    rst - [in]
  Returns:
    Value of the bezier volume map at (r,s,t).
  */
  ON_3dPoint PointAt(
         double r, 
         double s, 
         double t
         ) const;

  /*
  Description:
    Evaluates bezer volume map.
  Parameters:
    rst - [in]
  Returns:
    Value of the bezier volume map at (rst.x,rst.y,rst.z).
  */
  ON_3dPoint PointAt(
         ON_3dPoint rst
         ) const;

  bool IsRational() const;  // true if NURBS curve is rational
  
  bool IsSingular( // true if surface side is collapsed to a point
        int        // side of parameter space to test
                   // 0 = south, 1 = east, 2 = north, 3 = west
        ) const;

  int CVSize() const;       // number of doubles per control vertex 
                // = IsRational() ? Dim()+1 : Dim()
  
  int Order(        // order = degree + 1
        int // dir
        ) const;
	
  int Degree(       // degree = order - 1
        int // dir
        ) const;

  /*
  Description:
    Expert user function to get a pointer to control vertex
    memory.  If you are not an expert user, please use
    ON_BezierCage::GetCV( ON_3dPoint& ) or 
    ON_BezierCage::GetCV( ON_4dPoint& ).
  Parameters:
    cv_index0 - [in] (0 <= cv_index0 < m_order[0])
    cv_index1 - [in] (0 <= cv_index1 < m_order[1])
  Returns:
    Pointer to control vertex.
  Remarks:
    If the Bezier surface is rational, the format of the 
    returned array is a homogeneos rational point with
    length m_dim+1.  If the Bezier surface is not rational, 
    the format of the returned array is a nonrational 
    euclidean point with length m_dim.
  See Also
    ON_BezierCage::CVStyle
    ON_BezierCage::GetCV
    ON_BezierCage::Weight
  */
  double* CV(
        int i,
        int j,
        int k
        ) const;

  /*
  Description:
    Returns the style of control vertices in the m_cv array.
  Returns:
    @untitled table
    ON::not_rational                m_is_rat is false
    ON::homogeneous_rational        m_is_rat is true
  */
  ON::point_style CVStyle() const;

  double Weight(        // get value of control vertex weight
        int i,
        int j,
        int k
        ) const;

  bool SetWeight(      // set value of control vertex weight
        int i,
        int j,
        int k,
        double w
        );

  bool SetCV(              // set a single control vertex
        int i,
        int j,
        int k,
        ON::point_style, // style of input point
        const double*     // value of control vertex
        );

  // set a single control vertex
  // If NURBS is rational, weight
  // will be set to 1.
  bool SetCV(
        int i,
        int j,
        int k,
        const ON_3dPoint& point
        );

  // set a single control vertex
  // value of control vertex
  // If NURBS is not rational, euclidean
  // location of homogeneous point will
  // be used.
  bool SetCV(
        int i,
        int j,
        int k,
        const ON_4dPoint& hpoint
        );

  bool GetCV(              // get a single control vertex
        int i,
        int j,
        int k,
        ON::point_style, // style to use for output point
        double*           // array of length >= CVSize()
        ) const;

  bool GetCV(              // get a single control vertex
        int i,
        int j,
        int k,
        ON_3dPoint&      // gets euclidean cv when NURBS is rational
        ) const;

  bool GetCV(              // get a single control vertex
        int i,
        int j,
        int k,
        ON_4dPoint&      // gets homogeneous cv
        ) const;

  bool ZeroCVs(); // zeros control vertices and, if rational, sets weights to 1

  bool MakeRational();

  bool MakeNonRational();


  /////////////////////////////////////////////////////////////////
  // Tools for managing CV and knot memory

  /*
  Description:
    cv_capacity - [in] number of doubles to reserve
  */
  bool ReserveCVCapacity(
    int cv_capacity
    );

  /////////////////////////////////////////////////////////////////
  // Implementation
public:
  // NOTE: These members are left "public" so that expert users may efficiently
  //       create bezier curves using the default constructor and borrow the
  //       knot and CV arrays from their native NURBS representation.
  //       No technical support will be provided for users who access these
  //       members directly.  If you can't get your stuff to work, then use
  //       the constructor with the arguments and the SetKnot() and SetCV()
  //       functions to fill in the arrays.


  int     m_dim;
  bool    m_is_rat;
  int     m_order[3];
  int     m_cv_stride[3];
  int     m_cv_capacity;
  double* m_cv;
};


class ON_CLASS ON_BezierCageMorph : public ON_SpaceMorph
{
public:
  ON_BezierCageMorph();
  ~ON_BezierCageMorph();

  /*
  Description:
    Create a Bezier volume.
  Parameters:
    P0 - [in] 
    P1 - [in] 
    P2 - [in] 
    P3 - [in] 
         P0,P1,P2,P3 defines a parallepiped in world space. The morph
         maps this parallepiped to the (0,1)x(0,1)x(0,1) unit cube
         and then applies the BezierCage map.
              

             ______________
            |\             |\
            | \            | \
            |  \P3____________\
            |   |          |   |
            |   |          |   |
            |   |          |   |
           P2---|----------    |
            \   |          \   |
             \  |z          \  |
            y \ |            \ |
               \P0____________P1
                       x


    point_countX - [in]
    point_countY - [in]
    point_countZ - [in]
      Number of control points in the bezier volume map.  The 
      bezier volume in the returned morph is the identity map
      which can be modified as needed.
  Returns:
    True if resulting morph is valid.
  See Also:
    ON_BezierCage::SetBezierCage
    ON_BezierCage::SetXform
  */
  bool Create( 
    ON_3dPoint P0,
    ON_3dPoint P1,
    ON_3dPoint P2,
    ON_3dPoint P3,
    int point_countX,
    int point_countY,
    int point_countZ
    );

  /*
  Description:
    Set the world to unit cube map.
  Parameters:
    world2unitcube - [in]
      Tranformation matrix that maps world coordinates
      to the unit cube (0,1)x(0,1)x(0,1).
  Returns
    True if current bezier volum and input transformation
    matrix are valid.  In all cases, the morph's m_xyz2rst
    member is set.
  See Also:
    ON_BezierCage::Create
    ON_BezierCage::SetBezierCage
  */
  bool SetXform( ON_Xform world2unitcube );

  /*
  Description:
    Set the unit cube to world map.
  Parameters:
    world2unitcube - [in]
      Bezier volume map from the unit cube (0,1)x(0,1)x(0,1)
      to world space.
  Returns
    True if current transformation matrix and input
    bezier volume are valid.  In all cases, the 
    morph's m_rst2xyz member is set.
  See Also:
    ON_BezierCage::Create
    ON_BezierCage::SetXform
  */
  bool SetBezierCage( ON_BezierCage& unitcube2world );

  const ON_Xform& WorldToUnitCube() const;
  const ON_BezierCage& BezierCage() const;

  bool Read(ON_BinaryArchive& archive);
  bool Write(ON_BinaryArchive& archive) const;

  /*
  Description:
    Transforms the morph by transforming the bezier volume map.
  Parameters:
    xform - [in]
  Returns
    True if input is valid.
  */
  bool Transform(const ON_Xform& xform);

private:
  bool m_bValid;

  // transforms world (x,y,z) coordinate into
  // unit cube.
  ON_Xform m_xyz2rst;

  // function that maps unit cube into world
  ON_BezierCage m_rst2xyz;
};

#if defined(ON_DLL_TEMPLATE)

// This stuff is here because of a limitation in the way Microsoft
// handles templates and DLLs.  See Microsoft's knowledge base 
// article ID Q168958 for details.
#pragma warning( push )
#pragma warning( disable : 4231 )
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ON_BezierCurve>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_BezierCurve*>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ON_BezierSurface>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_BezierSurface*>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ON_BezierCage>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_BezierCage*>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ON_BezierCageMorph>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_BezierCageMorph*>;
#pragma warning( pop )

#endif

#endif

/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(ON_MATH_INC_)
#define ON_MATH_INC_

class ON_3dVector;
class ON_Interval;
class ON_Line;
class ON_Arc;
class ON_Plane;

/*
Description:
  Class for carefully adding long list of numbers.
*/
class ON_CLASS ON_Sum
{
public:

  /*
  Description:
    Calls ON_Sum::Begin(x)
  */
  void operator=(double x);

  /*
  Description:
    Calls ON_Sum::Plus(x);
  */
  void operator+=(double x);

  /*
  Description:
    Calls ON_Sum::Plus(-x);
  */
  void operator-=(double x);

  /*
  Description:
    Creates a sum that is ready to be used.
  */
  ON_Sum();

  /*
  Description:
    If a sum is being used more than once, call Begin()
    before starting each sum.
  Parameters:
    starting_value - [in] Initial value of sum.
  */
  void Begin( double starting_value = 0.0 );

  /*
  Description:
    Add x to the current sum.
  Parameters:
    x - [in] value to add to the current sum.
  */
  void Plus( double x );

  /*
  Description:
    Calculates the total sum.   
  Parameters:
    error_estimate - [out] if not NULL, the returned value of
       *error_estimate is an estimate of the error in the sum.
  Returns:
    Total of the sum.
  Remarks:
    You can get subtotals by mixing calls to Plus() and Total().
    In delicate sums, some precision may be lost in the final
    total if you call Total() to calculate subtotals.
  */
  double Total( double* error_estimate = NULL );

  /*
  Returns:
    Number of summands.
  */
  int SummandCount() const;

private:
  enum {
    sum1_max_count=256,
    sum2_max_count=512,
    sum3_max_count=1024
  };
  double m_sum_err;
  double m_pos_sum;     
  double m_neg_sum;  
  
  int m_zero_count; // number of zeros added
  int m_pos_count; // number of positive numbers added
  int m_neg_count; // number of negative numbers added
  
  int m_pos_sum1_count;
  int m_pos_sum2_count;
  int m_pos_sum3_count;
  double m_pos_sum1[sum1_max_count];
  double m_pos_sum2[sum2_max_count];
  double m_pos_sum3[sum3_max_count];
  
  int m_neg_sum1_count;
  int m_neg_sum2_count;
  int m_neg_sum3_count;
  double m_neg_sum1[sum1_max_count];
  double m_neg_sum2[sum2_max_count];
  double m_neg_sum3[sum3_max_count];

  double SortAndSum( int, double* );
};

/*
Description:
  Abstract function with an arbitrary number of parameters
  and values.  ON_Evaluator is used to pass functions to
  local solvers.
*/
class ON_CLASS ON_Evaluator
{
public:

  /*
  Description:
    Construction of the class for a function that takes
    parameter_count input functions and returns
    value_count values.  If the domain is infinite, pass
    a NULL for the domain[] and periodic[] arrays.  If
    the domain is finite, pass a domain[] array with
    parameter_count increasing intervals.  If one or more of
    the parameters is periodic, pass the fundamental domain
    in the domain[] array and a true in the periodic[] array.
  Parameters:
    parameter_count - [in] >= 1.  Number of input parameters
    value_count - [in] >= 1.  Number of output values.
    domain - [in] If not NULL, then this is an array
                  of parameter_count increasing intervals
                  that defines the domain of the function.
    periodic - [in] if not NULL, then this is an array of 
                parameter_count bools where b[i] is true if
                the i-th parameter is periodic.  Valid 
                increasing finite domains must be specificed
                when this parameter is not NULL.
  */
  ON_Evaluator( 
    int parameter_count,
    int value_count,
    const ON_Interval* domain,
    const bool* periodic
    );

  virtual ~ON_Evaluator();
  
  /*
  Description:
    Evaluate the function that takes m_parameter_count parameters
    and returns a m_value_count dimensional point.
  Parameters:
    parameters - [in] array of m_parameter_count evaluation parameters
    values - [out] array of m_value_count function values
    jacobian - [out] If NULL, simply evaluate the value of the function.
                     If not NULL, this is the jacobian of the function.
                     jacobian[i][j] = j-th partial of the i-th value
                     0 <= i < m_value_count,
                     0 <= j < m_parameter_count
                     If not NULL, then all the memory for the
                     jacobian is allocated, you just need to fill
                     in the answers.
  Example:
    If f(u,v) = square of the distance from a fixed point P to a 
    surface evaluated at (u,v), then

          values[0] = (S-P)o(S-P)
          jacobian[0] = ( 2*(Du o (S-P)), 2*(Dv o (S-P)) )

    where S, Du, Dv = surface point and first partials evaluated
    at u=parameters[0], v = parameters[1].

    If the function takes 3 parameters, say (x,y,z), and returns
    two values, say f(x,y,z) and g(z,y,z), then

          values[0] = f(x,y,z)
          values[1] = g(x,y,z)

          jacobian[0] = (DfDx, DfDy, DfDz)
          jacobian[1] = (DgDx, DgDy, DgDz)

    where dfx denotes the first partial of f with respect to x.

  Returns:
    0 = unable to evaluate
    1 = successful evaluation
    2 = found answer, terminate search
  */
  virtual int Evaluate(
       const double* parameters,
       double* values,
       double** jacobian
       ) = 0;

  /*
  Description:
    OPTIONAL ability to evaluate the hessian in the case when 
    m_value_count is one.  If your function has more that
    one value or it is not feasable to evaluate the hessian,
    then do not override this function.  The default implementation
    returns -1.
  Parameters:
    parameters - [in] array of m_parameter_count evaluation parameters
    value - [out] value of the function (one double)
    gradient - [out] The gradient of the function.  This is a vector
                     of length m_parameter_count; gradient[i] is
                     the first partial of the function with respect to
                     the i-th parameter.
    hessian - [out] The hessian of the function. This is an
                    m_parameter_count x m_parameter_count 
                    symmetric matrix: hessian[i][j] is the
                    second partial of the function with respect
                    to the i-th and j-th parameters.  The evaluator
                    is responsible for filling in both the upper
                    and lower triangles.  Since the matrix is
                    symmetrix, you should do something like evaluate
                    the upper triangle and copy the values to the
                    lower tiangle.
  Returns:
   -1 = Hessian evaluation not available.
    0 = unable to evaluate
    1 = successful evaluation
    2 = found answer, terminate search
  */
  virtual int EvaluateHessian(
       const double* parameters,
       double* value,
       double* gradient,
       double** hessian
       );
  
  // Number of the function's input parameters. This number
  // is >= 1 and is specified in the constructor.
  const int m_parameter_count;

  // Number of the function's output values. This number
  // is >= 1 and is specified in the constructor.
  const int m_value_count;

  /*
  Description:
    Functions can have finite or infinite domains. Finite domains
    are specified by passing the domain[] array to the constructor
    or filling in the m_domain[] member variable.  If
    m_domain.Count() == m_parameter_count > 0, then the function
    has finite domains.
  Returns:
    True if the domain of the function is finite.
  */
  bool FiniteDomain() const;

  /*
  Description:
    If a function has a periodic parameter, then the m_domain
    interval for that parameter is the fundamental domain and
    the m_bPeriodicParameter bool for that parameter is true.
    A parameter is periodic if, and only if, 
    m_domain.Count() == m_parameter_count, and 
    m_bPeriodicParameter.Count() == m_parameter_count, and
    m_bPeriodicParameter[parameter_index] is true.
  Returns:
    True if the function parameter is periodic.
  */
  bool Periodic(
    int parameter_index
    ) const;

  /*
  Description:
    If a function has a periodic parameter, then the m_domain
    interval for that parameter is the fundamental domain and
    the m_bPeriodicParameter bool for that parameter is true.
    A parameter is periodic if, and only if, 
    m_domain.Count() == m_parameter_count, and 
    m_bPeriodicParameter.Count() == m_parameter_count, and
    m_bPeriodicParameter[parameter_index] is true.
  Returns:
    The domain of the parameter.  If the domain is infinite,
    the (-1.0e300, +1.0e300) is returned.
  */
  ON_Interval Domain(
    int parameter_index
    ) const;


  // If the function has a finite domain or periodic
  // parameters, then m_domain[] is an array of 
  // m_parameter_count finite increasing intervals.
  ON_SimpleArray<ON_Interval> m_domain;

  // If the function has periodic parameters, then 
  // m_bPeriodicParameter[] is an array of m_parameter_count
  // bools.  If m_bPeriodicParameter[i] is true, then
  // the i-th parameter is periodic and m_domain[i] is 
  // the fundamental domain for that parameter.
  ON_SimpleArray<bool> m_bPeriodicParameter;

private:
  ON_Evaluator(); // prohibit default constructor
  ON_Evaluator& operator=(const ON_Evaluator&); // prohibit operator= (can't copy const members)
};

/*
Description:
  Test a double to make sure it is a valid number.
Returns:
  True if x != ON_UNSET_VALUE and _finite(x) is true.
*/
ON_DECL
bool ON_IsValid( double x );

ON_DECL
bool ON_IsValidFloat( float x );

/*
class ON_CLASS ON_TimeLimit
{
  ON_TimeLimit();
  ON_TimeLimit(ON__UINT64 time_limit_seconds);
  void SetTimeLimit(ON__UINT64 time_limit_seconds);
  bool Continue() const;
  bool IsSet() const;
private:
  ON__UINT64 m_time_limit[2];
};
*/

// The ON_IS_FINITE and ON_IS_VALID defines are much faster
// than calling ON_IsValid(), but need to be used when
// the macro expansion works.

#if   defined(ON_LITTLE_ENDIAN)

// works on little endian CPUs with IEEE doubles
#define ON_IS_FINITE(x) (0x7FF0 != (*((unsigned short*)(&x) + 3) & 0x7FF0))
#define ON_IS_VALID(x)  (x != ON_UNSET_VALUE && 0x7FF0 != (*((unsigned short*)(&x) + 3) & 0x7FF0))
#define ON_IS_VALID_FLOAT(x)  (x != ON_UNSET_FLOAT)
//TODO - ADD FAST ugly bit check#define ON_IS_VALID_FLOAT(x)  (x != ON_UNSET_FLOAT && 0x7FF0 != (*((unsigned short*)(&x) + 3) & 0x7FF0))

#elif defined(ON_BIG_ENDIAN)

// works on big endian CPUs with IEEE doubles
#define ON_IS_FINITE(x) (0x7FF0 != (*((unsigned short*)(&x)) & 0x7FF0))
#define ON_IS_VALID(x)  (x != ON_UNSET_VALUE && 0x7FF0 != (*((unsigned short*)(&x)) & 0x7FF0))
#define ON_IS_VALID_FLOAT(x)  (x != ON_UNSET_FLOAT)
//TODO - ADD FAST ugly bit check#define ON_IS_VALID_FLOAT(x)  (x != ON_UNSET_FLOAT && 0x7FF0 != (*((unsigned short*)(&x) + 3) & 0x7FF0))

#else

// Returns true if x is a finite double.  Specifically,
// _finite returns a nonzero value (true) if its argument x
// is not infinite, that is, if -INF < x < +INF. 
// It returns 0 (false) if the argument is infinite or a NaN.
//
// If you are trying to compile opennurbs on a platform
// that does not support finite(), then see if you can
// use _fpclass(), fpclass(), _isnan(), or isnan().  If
// you can't find anything, then just set this
// function to return true.

#if defined(_GNU_SOURCE)
// if you are using an older version of gcc, use finite()
//#define ON_IS_FINITE(x) (finite(x)?true:false)
#define ON_IS_FINITE(x) (isfinite(x)?true:false)
#else
#define ON_IS_FINITE(x) (_finite(x)?true:false)
#endif

#define ON_IS_VALID(x)  (x != ON_UNSET_VALUE && ON_IS_FINITE(x))
#define ON_IS_VALID_FLOAT(x)  (x != ON_UNSET_FLOAT && ON_IS_FINITE(x))

#endif


ON_DECL
float ON_ArrayDotProduct( // returns AoB
          int,           // size of arrays (can be zero)
          const float*, // A[]
          const float*  // B[]
          );

ON_DECL
void   ON_ArrayScale( 
          int,           // size of arrays (can be zero)
          float,        // a
          const float*, // A[]
          float*        // returns a*A[]
          );

ON_DECL
void   ON_Array_aA_plus_B( 
          int,           // size of arrays (can be zero)
          float,        // a
          const float*, // A[]
          const float*, // B[]
          float*        // returns a*A[] + B[]
          );

ON_DECL
double ON_ArrayDotProduct( // returns AoB
          int,           // size of arrays (can be zero)
          const double*, // A[]
          const double*  // B[]
          );

ON_DECL
double ON_ArrayDotDifference( // returns A o ( B - C )
          int,           // size of arrays (can be zero)
          const double*, // A[]
          const double*, // B[]
          const double*  // C[]
          );

ON_DECL
double ON_ArrayMagnitude( // returns sqrt(AoA)
          int,           // size of arrays (can be zero)
          const double*  // A[]
          );

ON_DECL
double ON_ArrayMagnitudeSquared( // returns AoA
          int,           // size of arrays (can be zero)
          const double*  // A[]
          );

ON_DECL
double ON_ArrayDistance( // returns sqrt((A-B)o(A-B))
          int,           // size of arrays (can be zero)
          const double*, // A[]
          const double*  // B[]
          );

ON_DECL
double ON_ArrayDistanceSquared( // returns (A-B)o(A-B)
          int,           // size of arrays (can be zero)
          const double*, // A[]
          const double*  // B[]
          );

ON_DECL
void   ON_ArrayScale( 
          int,           // size of arrays (can be zero)
          double,        // a
          const double*, // A[]
          double*        // returns a*A[]
          );

ON_DECL
void   ON_Array_aA_plus_B( 
          int,           // size of arrays (can be zero)
          double,        // a
          const double*, // A[]
          const double*, // B[]
          double*        // returns a*A[] + B[]
          );

ON_DECL
int    ON_SearchMonotoneArray( // find a value in an increasing array
          // returns  -1: t < array[0]
          //           i: array[i] <= t < array[i+1] ( 0 <= i < length-1 )
          //    length-1: t == array[length-1]
          //      length: t >= array[length-1]
          const double*, // array[]
          int,           // length of array
          double         // t = value to search for
          );


/* 
Description:
  Compute a binomial coefficient.
Parameters:
  i - [in]
  j - [in]
Returns:
  (i+j)!/(i!j!), if 0 <= i and 0 <= j, and 0 otherwise.
See Also:
  ON_TrinomialCoefficient()
Remarks:
  If (i+j) <= 52, this function is fast and returns the exact
  value of the binomial coefficient.  

  For (i+j) > 52, the coefficient is computed recursively using
  the formula  bc(i,j) = bc(i-1,j) + bc(i,j-1).
  For (i+j) much larger than 60, this is inefficient.
  If you need binomial coefficients for large i and j, then you
  should probably be using something like Stirling's Formula.  
  (Look up "Stirling" or "Gamma function" in a calculus book.)
*/
ON_DECL
double ON_BinomialCoefficient( 
          int i,
          int j
          );


/* 
Description:
  Compute a trinomial coefficient.
Parameters:
  i - [in]
  j - [in]
  k - [in]
Returns:
  (i+j+k)!/(i!j!k!), if 0 <= i, 0 <= j and 0<= k, and 0 otherwise.
See Also:
  ON_BinomialCoefficient()
Remarks:
  The trinomial coefficient is computed using the formula

          (i+j+k)!      (i+j+k)!       (j+k)!
          --------   =  --------   *  -------
          i! j! k!      i! (j+k)!      j! k!

                      = ON_BinomialCoefficient(i,j+k)*ON_BinomialCoefficient(j,k)
  
*/
ON_DECL
double ON_TrinomialCoefficient( 
          int i,
          int j,
          int k
          );


ON_DECL
ON_BOOL32 ON_GetParameterTolerance(
        double, double, // domain
        double,          // parameter in domain
        double*, double* // parameter tolerance (tminus, tplus) returned here
        );


ON_DECL
ON_BOOL32 ON_IsValidPointList(
        int,  // dim
        ON_BOOL32, // true for homogeneous rational points
        int,  // count
        int,  // stride
        const float*
        );

ON_DECL
ON_BOOL32 ON_IsValidPointList(
        int,  // dim
        ON_BOOL32, // true for homogeneous rational points
        int,  // count
        int,  // stride
        const double*
        );

/*
Description:
  Determine if a list of points is planar.
Parameters:
  bRational - [in]
    false if the points are euclidean (x,y,z)
    true if the points are homogeneous rational (x,y,z,w)
  point_count - [in]
    number of points
  point_stride - [in]
    number of doubles between point x coordinates
    first point's x coordinate = points[0],
    second point's x coordinate = points[point_stride],...
  points - [in]
    point coordinates (3d or 4d homogeneous rational)
  boxMin - [in]
  boxMax - [in]
    optional 3d bounding box - pass nulls if not readily available
  tolerance - [in] >= 0.0
  plane_equation0 - [in]
    If you want to test for planarity in a specific plane,
    pass the plane equation in here.  If you want to find
    a plane containing the points, pass null here.
  plane_equation - [out]
    If this point is not null, then the equation of the plane
    containing the points is retuened here.
Returns:
  0 - points are not coplanar to the specified tolerance
  1 - points are coplanar to the specified tolerance
  2 - points are colinear to the specified tolerance
      (in this case, plane_equation is not a unique answer)
  3 - points are coincident to the specified tolerance
      (in this case, plane_equation is not a unique answer)
*/
ON_DECL
int ON_IsPointListPlanar(
    bool bRational,
    int count,
    int stride,
    const double* points,
    const double* boxMin,
    const double* boxMax,
    double tolerance,
    ON_PlaneEquation* plane_equation
    );

ON_DECL
ON_BOOL32 ON_IsValidPointGrid(
        int,  // dim
        ON_BOOL32, // true for homogeneous rational points
        int, int, // point_count0, point_count1,
        int, int, // point_stride0, point_stride1,
        const double*
        );

ON_DECL
bool ON_ReversePointList(
        int,  // dim
        ON_BOOL32, // true for homogeneous rational points
        int,  // count
        int,  // stride
        double*
        );

ON_DECL
ON_BOOL32 ON_ReversePointGrid(
        int,  // dim
        ON_BOOL32, // true for homogeneous rational points
        int, int, // point_count0, point_count1,
        int, int, // point_stride0, point_stride1,
        double*,
        int       // dir = 0 or 1
        );

ON_DECL
bool ON_SwapPointListCoordinates( 
        int, // count
        int, // stride
        float*,
        int, int // coordinates to swap
        );

ON_DECL
bool ON_SwapPointListCoordinates( 
        int, // count
        int, // stride
        double*,
        int, int // coordinates to swap
        );

ON_DECL
ON_BOOL32 ON_SwapPointGridCoordinates(
        int, int, // point_count0, point_count1,
        int, int, // point_stride0, point_stride1,
        double*,
        int, int // coordinates to swap
        );

ON_DECL
bool ON_TransformPointList(
        int,  // dim
        ON_BOOL32, // true for homogeneous rational points
        int,  // count
        int,  // stride
        float*,
        const ON_Xform&
        );

ON_DECL
bool ON_TransformPointList(
        int,  // dim
        ON_BOOL32, // true for homogeneous rational points
        int,  // count
        int,  // stride
        double*,
        const ON_Xform&
        );

ON_DECL
ON_BOOL32 ON_TransformPointGrid(
        int,      // dim
        ON_BOOL32,     // true for homogeneous rational points
        int, int, // point_count0, point_count1,
        int, int, // point_stride0, point_stride1,
        double*,
        const ON_Xform&
        );

ON_DECL
ON_BOOL32 ON_TransformVectorList(
       int,  // dim
       int,  // count
       int,  // stride
       float*,
       const ON_Xform&
       );

ON_DECL
ON_BOOL32 ON_TransformVectorList(
       int,  // dim
       int,  // count
       int,  // stride
       double*,
       const ON_Xform&
       );

/*
Parameters:
  dim - [in]
    >= 1
  is_rat - [in]
    true if the points are rational and points[dim] is the "weight"
  pointA - [in]
  pointB - [in]
    point coordinates
Returns:
  True if the input is valid and for each coordinate pair,
  |a-b| <= ON_ZERO_TOLERANCE 
  or |a-b| <= (fabs(a)+fabs(b))*ON_RELATIVE_TOLERANCE.
  False otherwise.
*/
ON_DECL
bool ON_PointsAreCoincident(
    int dim,
    int is_rat,
    const double* pointA,
    const double* pointB
    );

/*
Description
  See ON_PointsAreCoincident() for a description of when opennurbs
  considers two points to be conincident.
Parameters:
  dim - [in]
    >= 1
  is_rat - [in]
    true if the points are rational and points[dim] is the "weight"
  point_count - [in]
    number of points >= 2
  point_stride - [in]
    >= (0 != is_rat) ? (dim+1) : dim
  points - [in]
    point coordinates
Returns:
  True if the first and last points are coincident and all other
  points in the list are coincident with the previous point.
  False if there are points that are not coincident or
  point_count < 2 or other input parameters are invalid.
*/
ON_DECL
bool ON_PointsAreCoincident(
    int dim,
    int is_rat,
    int point_count,
    int point_stride,
    const double* points
    );

ON_DECL
int ON_ComparePoint( // returns 
                              // -1: first < second
                              //  0: first == second
                              // +1: first > second
          int dim,            // dim (>=0)
          ON_BOOL32 israt,    // true for rational CVs
          const double* cv0,  // first CV
          const double* cv1   // secont CV
          );

ON_DECL
int ON_ComparePointList( // returns 
                              // -1: first < second
                              //  0: first == second
                              // +1: first > second
          int,           // dim (>=0)
          ON_BOOL32,          // true for rational CVs
          int,           // count
          // first point list
          int,           // stride
          const double*, // point
          // second point list
          int,           // stride
          const double*  // point
          );

ON_DECL
ON_BOOL32 ON_IsPointListClosed(
       int,  // dim
       int,  // true for homogeneos rational points
       int,  // count
       int,  // stride
       const double*
       );

ON_DECL
ON_BOOL32 ON_IsPointGridClosed(
        int,  // dim
        ON_BOOL32, // true for homogeneous rational points
        int, int, // point_count0, point_count1,
        int, int, // point_stride0, point_stride1,
        const double*,
        int       // dir = 0 or 1
       );

ON_DECL
int ON_SolveQuadraticEquation( // solve a*X^2 + b*X + c = 0
        // returns 0: two distinct real roots (r0 < r1)
        //         1: one real root (r0 = r1)
        //         2: two complex conjugate roots (r0 +/- (r1)*sqrt(-1))
        //        -1: failure - a = 0, b != 0        (r0 = r1 = -c/b)
        //        -2: failure - a = 0, b  = 0 c != 0 (r0 = r1 = 0.0)
        //        -3: failure - a = 0, b  = 0 c  = 0 (r0 = r1 = 0.0)
       double, double, double, // a, b, c
       double*, double*        // roots r0 and r1 returned here
       );

ON_DECL
ON_BOOL32 ON_SolveTriDiagonal( // solve TriDiagMatrix( a,b,c )*X = d
        int,               // dimension of d and X (>=1)
        int,               // number of equations (>=2)
        double*,           // a[n-1] = sub-diagonal (a is modified)
        const double*,     // b[n] = diagonal
        double*,           // c[n-1] = supra-diagonal
        const double*,     // d[n*dim]
        double*            // X[n*dim] = unknowns
        );

// returns rank - if rank != 2, system is under determined
// If rank = 2, then solution to 
//
//          a00*x0 + a01*x1 = b0, 
//          a10*x0 + a11*x1 = b1 
//
// is returned
ON_DECL
int ON_Solve2x2( 
        double, double,   // a00 a01 = first row of 2x2 matrix
        double, double,   // a10 a11 = second row of 2x2 matrix
        double, double,   // b0 b1
        double*, double*, // x0, x1 if not NULL, then solution is returned here
        double*           // if not NULL, then pivot_ratio returned here
        );

// Description:
//   Solves a system of 3 linear equations and 2 unknowns.
//
//          x*col0[0] + y*col1[0] = d0
//          x*col0[1] + y*col1[1] = d0
//          x*col0[2] + y*col1[2] = d0
//
// Parameters:
//   col0 - [in] coefficents for "x" unknown
//   col1 - [in] coefficents for "y" unknown
//   d0 - [in] constants
//   d1 - [in]
//   d2 - [in]
//   x - [out]
//   y - [out]
//   error - [out]
//   pivot_ratio - [out]
//
// Returns:
//   rank of the system.  
//   If rank != 2, system is under determined
//   If rank = 2, then the solution is
//
//         (*x)*[col0] + (*y)*[col1]
//         + (*error)*((col0 X col1)/|col0 X col1|)
//         = (d0,d1,d2).
ON_DECL
int ON_Solve3x2( 
        const double[3], // col0
        const double[3], // col1
        double,  // d0
        double,  // d1
        double,  // d2
        double*, // x
        double*, // y
        double*, // error
        double*  // pivot_ratio
        );

/* 
Description:
  Use Gauss-Jordan elimination with full pivoting to solve 
  a system of 3 linear equations and 3 unknowns(x,y,z)

        x*row0[0] + y*row0[1] + z*row0[2] = d0
        x*row1[0] + y*row1[1] + z*row1[2] = d1
        x*row2[0] + y*row2[1] + z*row2[2] = d2

Parameters:
    row0 - [in] first row of 3x3 matrix
    row1 - [in] second row of 3x3 matrix
    row2 - [in] third row of 3x3 matrix
    d0 - [in] 
    d1 - [in] 
    d2 - [in] (d0,d1,d2) right hand column of system
    x_addr - [in] first unknown
    y_addr - [in] second unknown
    z_addr - [in] third unknown
    pivot_ratio - [out] if not NULL, the pivot ration is 
         returned here.  If the pivot ratio is "small",
         then the matrix may be singular or ill 
         conditioned. You should test the results 
         before you use them.  "Small" depends on the
         precision of the input coefficients and the
         use of the solution.  If you can't figure out
         what "small" means in your case, then you
         must check the solution before you use it.

Returns:
    The rank of the 3x3 matrix (0,1,2, or 3)
    If ON_Solve3x3() is successful (returns 3), then
    the solution is returned in 
    (*x_addr, *y_addr, *z_addr)
    and *pivot_ratio = min(|pivots|)/max(|pivots|).
    If the return code is < 3, then (0,0,0) is returned
    as the "solution".

See Also:
  ON_Solve2x2
  ON_Solve3x2
  ON_Solve4x4
*/
ON_DECL
int ON_Solve3x3( 
        const double row0[3], 
        const double row1[3], 
        const double row2[3],
        double d0, 
        double d1, 
        double d2,
        double* x_addr, 
        double* y_addr, 
        double* z_addr,
        double* pivot_ratio
        );

/* 
Description:
  Use Gauss-Jordan elimination with full pivoting to solve 
  a system of 4 linear equations and 4 unknowns(x,y,z,w)

        x*row0[0] + y*row0[1] + z*row0[2] + w*row0[3] = d0
        x*row1[0] + y*row1[1] + z*row1[2] + w*row1[3] = d1
        x*row2[0] + y*row2[1] + z*row2[2] + w*row2[3] = d2
        x*row3[0] + y*row3[1] + z*row3[2] + w*row3[2] = d3

Parameters:
    row0 - [in] first row of 4x4 matrix
    row1 - [in] second row of 4x4 matrix
    row2 - [in] third row of 4x4 matrix
    row3 - [in] forth row of 4x4 matrix
    d0 - [in] 
    d1 - [in] 
    d2 - [in] 
    d3 - [in] (d0,d1,d2,d3) right hand column of system
    x_addr - [in] first unknown
    y_addr - [in] second unknown
    z_addr - [in] third unknown
    w_addr - [in] forth unknown
    pivot_ratio - [out] if not NULL, the pivot ration is 
         returned here.  If the pivot ratio is "small",
         then the matrix may be singular or ill 
         conditioned. You should test the results 
         before you use them.  "Small" depends on the
         precision of the input coefficients and the
         use of the solution.  If you can't figure out
         what "small" means in your case, then you
         must check the solution before you use it.

Returns:
    The rank of the 4x4 matrix (0,1,2,3, or 4)
    If ON_Solve4x4() is successful (returns 4), then
    the solution is returned in 
    (*x_addr, *y_addr, *z_addr, *w_addr)
    and *pivot_ratio = min(|pivots|)/max(|pivots|).
    If the return code is < 4, then, it a solution exists,
    on is returned.  However YOU MUST CHECK THE SOLUTION
    IF THE RETURN CODE IS < 4.

See Also:
  ON_Solve2x2
  ON_Solve3x2
  ON_Solve3x3
*/
ON_DECL
int
ON_Solve4x4(
          const double row0[4], 
          const double row1[4], 
          const double row2[4],  
          const double row3[4],
          double d0, 
          double d1, 
          double d2, 
          double d3,
          double* x_addr, 
          double* y_addr, 
          double* z_addr, 
          double* w_addr,
          double* pivot_ratio
          );

/*
Description:
  Use Gauss-Jordan elimination to find a numerical 
  solution to M*X = B where M is a n x n matrix,
  B is a known n-dimensional vector and X is
  an unknown.
Paramters:
  bFullPivot - [in] if true, full pivoting is used,
    otherwise partial pivoting is used.  In rare
    cases full pivoting can produce a more accurate
    answer and never produces a less accurate answer.
    However full pivoting is slower.  If speed is an
    issue, then experiement with bFullPivot=false
    and see if it makes a difference.  Otherwise,
    set it to true.
  bNormalize - [in]
    If bNormalize is true, then the rows of the
    matrix are scaled so the sum of their squares
    is one.  This doesn't make the solution more
    accurate but in some cases it makes the pivot
    ratio more meaningful.  Set bNormalize to
    false unless you have a reason for setting it
    to true.
  n - [in] size of the matrix and vectors.
  M - [in] n x n matrix.  The values in M are
    changed as the solution is calculated.
    If you need to preserve M for future use,
    pass in a copy.
  B - [in] n-dimensional vector.  The values in
    B are changed as the solution is calculated.
    If you need to preserve B for future use,
    pass in a copy.
  X - [out] solution to M*X = B.
Returns:
  If the returned value is <= 0.0, the input matrix
  has rank < n and no solution is returned in X.
  If the returned value is > 0.0, then a solution is
  returned in X and the returned value is the ratio
  (minimum pivot)/(maximum pivot).  This value is
  called the pivot ratio and will be denoted "pr"
  the discussion below. If pr <= 1e-15, then
  M was nearly degenerate and the solution should be
  used with caution.  If an accurate solution is
  critcial, then check the solution anytime pr <= 1e-10
  In general, the difference between M*X and B will be
  reasonably small.  However, when the pr is small
  there tend to be vector E, substantually different
  from zero, such that M*(X+E) - B is also reasonably
  small.
See Also:
  ON_Solve2x2
  ON_Solve3x3
  ON_Solve4x4
  ON_Solve3x2
*/
ON_DECL
double ON_SolveNxN(bool bFullPivot, bool bNormalize, int n, double* M[], double B[], double X[]);


// return false if determinant is (nearly) singular
ON_DECL
ON_BOOL32 ON_EvJacobian( 
        double, // ds o ds
        double, // ds o dt
        double, // dt o dt
        double* // jacobian = determinant ( ds_o_ds dt_o_dt / ds_o_dt ds_o_dt )
        );

/*
Description:
  Finds scalars x and y so that the component of V in the plane
  of A and B is x*A + y*B.
Parameters:
  V - [in]
  A - [in] nonzero and not parallel to B
  B - [in] nonzero and not parallel to A
  x - [out]
  y - [out]
Returns:
  1 - The rank of the problem is 2.  The decomposition is unique.
	0 - The rank less than 2.  Either there is no solution or there
			are infinitely many solutions.

See Also:
  ON_Solve2x2
*/
ON_DECL
int ON_DecomposeVector(
        const ON_3dVector& V,
        const ON_3dVector& A,
        const ON_3dVector& B,
        double* x, double* y
        );


/*
Description:
   Evaluate partial derivatives of surface unit normal
Parameters:
  ds - [in]
  dt - [in] surface first partial derivatives
  dss - [in]
  dst - [in]
  dtt - [in] surface second partial derivatives
  ns - [out]
  nt - [out] First partial derivatives of surface unit normal
             (If the Jacobian is degenerate, ns and nt are set to zero.)
Returns:
  true if Jacobian is nondegenerate
  false if Jacobian is degenerate
*/
ON_DECL
ON_BOOL32 ON_EvNormalPartials(
        const ON_3dVector& ds,
        const ON_3dVector& dt,
        const ON_3dVector& dss,
        const ON_3dVector& dst,
        const ON_3dVector& dtt,
        ON_3dVector& ns,
        ON_3dVector& nt
        );

ON_DECL
ON_BOOL32 
ON_Pullback3dVector( // use to pull 3d vector back to surface parameter space
      const ON_3dVector&,   // 3d vector
      double,              // signed distance from vector location to closet point on surface
                                    // < 0 if point is below with respect to Du x Dv
      const ON_3dVector&,     // ds      surface first partials
      const ON_3dVector&,     // dt
      const ON_3dVector&,     // dss     surface 2nd partials
      const ON_3dVector&,     // dst     (used only when dist != 0)
      const ON_3dVector&,     // dtt
      ON_2dVector&            // pullback
      );

ON_DECL
ON_BOOL32 
ON_GetParameterTolerance(
        double,   // t0      domain
        double,   // t1 
        double,   // t       parameter in domain
        double*,  // tminus  parameter tolerance (tminus, tplus) returned here
        double*   // tplus
        );


ON_DECL
ON_BOOL32 ON_EvNormal(
        int, // limit_dir 0=default,1=from quadrant I, 2 = from quadrant II, ...
        const ON_3dVector&, const ON_3dVector&, // first partials (Du,Dv)
        const ON_3dVector&, const ON_3dVector&, const ON_3dVector&, // optional second partials (Duu, Duv, Dvv)
        ON_3dVector& // unit normal returned here
        );

// returns false if first returned tangent is zero
ON_DECL
bool ON_EvTangent(
        const ON_3dVector&, // first derivative
        const ON_3dVector&, // second derivative
        ON_3dVector&        // Unit tangent returned here
        );

// returns false if first derivtive is zero
ON_DECL
ON_BOOL32 ON_EvCurvature(
        const ON_3dVector&, // first derivative
        const ON_3dVector&, // second derivative
        ON_3dVector&,       // Unit tangent returned here
        ON_3dVector&        // Curvature returned here
        );

ON_DECL
ON_BOOL32 ON_EvPrincipalCurvatures( 
        const ON_3dVector&, // Ds,
        const ON_3dVector&, // Dt,
        const ON_3dVector&, // Dss,
        const ON_3dVector&, // Dst,
        const ON_3dVector&, // Dtt,
        const ON_3dVector&, // N,   // unit normal to surface (use ON_EvNormal())
        double*, // gauss,  // = Gaussian curvature = kappa1*kappa2
        double*, // mean,   // = mean curvature = (kappa1+kappa2)/2
        double*, // kappa1, // = largest principal curvature value (may be negative)
        double*, // kappa2, // = smallest principal curvature value (may be negative)
        ON_3dVector&, // K1,     // kappa1 unit principal curvature direction
        ON_3dVector&  // K2      // kappa2 unit principal curvature direction
                        // output K1,K2,N is right handed frame
        );

ON_DECL
ON_BOOL32 ON_EvPrincipalCurvatures( 
        const ON_3dVector&, // Ds,
        const ON_3dVector&, // Dt,
        double l, // Dss*N Second fundamental form coefficients
        double m, // Dst*N,
        double n, // Dtt*N,
        const ON_3dVector&, // N,   // unit normal to surface (use ON_EvNormal())
        double*, // gauss,  // = Gaussian curvature = kappa1*kappa2
        double*, // mean,   // = mean curvature = (kappa1+kappa2)/2
        double*, // kappa1, // = largest principal curvature value (may be negative)
        double*, // kappa2, // = smallest principal curvature value (may be negative)
        ON_3dVector&, // K1,     // kappa1 unit principal curvature direction
        ON_3dVector&  // K2      // kappa2 unit principal curvature direction
                        // output K1,K2,N is right handed frame
        );

/*
Description:
  Evaluate sectional curvature from surface derivatives and 
  section plane normal.
Parameters:
  S10, S01 - [in]
    surface 1st partial derivatives
  S20, S11, S02 - [in]
    surface 2nd partial derivatives
  planeNormal - [in]
    unit normal to section plane
  K - [out] Sectional curvature
    Curvature of the intersection curve of the surface
    and plane through the surface point where the partial
    derivatives were evaluationed.
Returns:
  True if successful.
  False if first partials are not linearly independent, in
  which case the K is set to zero.
*/
ON_DECL
bool ON_EvSectionalCurvature( 
    const ON_3dVector& S10, 
    const ON_3dVector& S01,
    const ON_3dVector& S20, 
    const ON_3dVector& S11, 
    const ON_3dVector& S02,
    const ON_3dVector& planeNormal,
    ON_3dVector& K 
    );


ON_DECL
ON_3dVector ON_NormalCurvature( 
        const ON_3dVector&, // surface 1rst partial (Ds)
        const ON_3dVector&, // surface 1rst partial (Dt)
        const ON_3dVector&, // surface 1rst partial (Dss)
        const ON_3dVector&, // surface 1rst partial (Dst)
        const ON_3dVector&, // surface 1rst partial (Dtt)
        const ON_3dVector&, // surface unit normal
        const ON_3dVector&  // unit tangent direction
        );

/*
Description:
  Determing if two curvatrues are different enough
  to qualify as a curvature discontinuity.
Parameters:
  Km - [in]
  Kp - [in]
    Km and Kp should be curvatures evaluated at the same
    parameters using limits from below (minus) and above (plus).
    The assumption is that you have already compared the
    points and tangents and consider to curve to be G1 at the
    point in question.
  cos_angle_tolerance - [in]
    If the inut value of cos_angle_tolerance >= -1.0
    and cos_angle_tolerance <= 1.0 and
    Km o Kp < cos_angle_tolerance*|Km|*|Kp|, then
    true is returned.  Otherwise it is assumed Km and Kp
    are parallel. If the curve being tested is nonplanar,
    then use something like cos(2*tangent angle tolerance)
    for this parameter. If the curve being tested is planar,
    then 0.0 will work fine.
  curvature_tolerance - [in]
    If |Kp-Km| <= curvature_tolerance,
    then false is returned, otherwise other tests are used
    to determing continuity.
  zero_curvature - [in] (ignored if < 2^-110 = 7.7037197787136e-34)
    If |K| <= zero_curvature, then K is treated as zero.
    When in doubt, use ON_ZERO_CURVATURE_TOLERANCE.
  radius_tolerance - [in]
    If radius_tolerance >= 0.0 and the difference between the
    radii of curvature is >= radius_tolerance, then true 
    is returned.
  relative_tolerance - [in]
    If relative_tolerance > 0 and
    |(|Km| - |Kp|)|/max(|Km|,|Kp|) > relative_tolerance,
    then true is returned.  Note that if the curvatures are
    nonzero and rm and rp are the radii of curvature, then
    |(|Km| - |Kp|)|/max(|Km|,|Kp|) = |rm-rp|/max(rm,rp).
    This means the relative_tolerance insures both the scalar
    curvature and the radii of curvature agree to the specified
    number of decimal places.
    When in double use ON_RELATIVE_CURVATURE_TOLERANCE, which
    is currently 0.05.
Returns:
  False if the curvatures should be considered G2.
  True if the curvatures are different enough that the curve should be
  considered not G2.  
  In addition to the tests described under the curvature_tolerance and 
  radius_tolerance checks, other hurestic tests are used.
*/
ON_DECL
bool ON_IsCurvatureDiscontinuity( 
  const ON_3dVector Km, 
  const ON_3dVector Kp,
  double cos_angle_tolerance,
  double curvature_tolerance,
  double zero_curvature,
  double radius_tolerance,
  double relative_tolerance
  );

ON_DECL
bool ON_IsCurvatureDiscontinuity( 
  const ON_3dVector Km, 
  const ON_3dVector Kp,
  double cos_angle_tolerance,
  double curvature_tolerance,
  double zero_curvature,
  double radius_tolerance
  );


/*
Description:
  This function is used to test curvature continuity
  in IsContinuous and GetNextDiscontinuity functions
  when the continuity parameter is ON::G2_continuous.
Parameters:
  Km - [in]
    Curve's vector curvature evaluated from below
  Kp - [in]
    Curve's vector curvature evaluated from below
Returns:
  True if the change from Km to Kp should be considered
  G2 continuous.
*/
ON_DECL
bool ON_IsG2CurvatureContinuous(
  const ON_3dVector Km, 
  const ON_3dVector Kp,
  double cos_angle_tolerance,
  double curvature_tolerance
  );

/*
Description:
  This function is used to test curvature continuity
  in IsContinuous and GetNextDiscontinuity functions
  when the continuity parameter is ON::Gsmooth_continuous.
Parameters:
  Km - [in]
    Curve's vector curvature evaluated from below
  Kp - [in]
    Curve's vector curvature evaluated from below
Returns:
  True if the change from Km to Kp should be considered
  Gsmooth continuous.
*/
ON_DECL
bool ON_IsGsmoothCurvatureContinuous(
  const ON_3dVector Km, 
  const ON_3dVector Kp,
  double cos_angle_tolerance,
  double curvature_tolerance
  );

/*
Description:
  Test curve continuity from derivative values.
Parameters:
  c - [in] type of continuity to test for. Read ON::continuity
           comments for details.
  Pa - [in] point on curve A.
  D1a - [in] first derviative of curve A.
  D2a - [in] second derviative of curve A.
  Pb - [in] point on curve B.
  D1b - [in] first derviative of curve B.
  D3b - [in] second derviative of curve B.
  point_tolerance - [in] if the distance between two points is
      greater than point_tolerance, then the curve is not C0.
  d1_tolerance - [in] if the difference between two first derivatives is
      greater than d1_tolerance, then the curve is not C1.
  d2_tolerance - [in] if the difference between two second derivatives is
      greater than d2_tolerance, then the curve is not C2.
  cos_angle_tolerance - [in] default = cos(1 degree) Used only when
      c is ON::G1_continuous or ON::G2_continuous.  If the cosine
      of the angle between two tangent vectors 
      is <= cos_angle_tolerance, then a G1 discontinuity is reported.
  curvature_tolerance - [in] (default = ON_SQRT_EPSILON) Used only when
      c is ON::G2_continuous.  If K0 and K1 are curvatures evaluated
      from above and below and |K0 - K1| > curvature_tolerance,
      then a curvature discontinuity is reported.
Returns:
  true if the curve has at least the c type continuity at 
  the parameter t.
*/
ON_DECL
ON_BOOL32 ON_IsContinuous(
  ON::continuity c,
  ON_3dPoint Pa,
  ON_3dVector D1a,
  ON_3dVector D2a,
  ON_3dPoint Pb,
  ON_3dVector D1b,
  ON_3dVector D2b,
  double point_tolerance=ON_ZERO_TOLERANCE,
  double d1_tolerance=ON_ZERO_TOLERANCE,
  double d2_tolerance=ON_ZERO_TOLERANCE,
  double cos_angle_tolerance=ON_DEFAULT_ANGLE_TOLERANCE_COSINE,
  double curvature_tolerance=ON_SQRT_EPSILON
  );


ON_DECL
bool ON_TuneupEvaluationParameter( 
   int side,
   double s0, double s1, // segment domain
   double *s             // segment parameter
   );


ON_DECL
int ON_Compare2dex( const ON_2dex* a, const ON_2dex* b);

ON_DECL
int ON_Compare3dex( const ON_3dex* a, const ON_3dex* b);

ON_DECL
int ON_Compare4dex( const ON_4dex* a, const ON_4dex* b);

ON_DECL
const ON_2dex* ON_BinarySearch2dexArray( 
          int key_i, 
          const ON_2dex* base, 
          size_t nel
          );

// These simple intersectors are fast and detect transverse intersections.
// If the intersection is not a simple transverse case, then they
// return false and you will have to use one of the slower but fancier
// models.

// returns closest points between the two infinite lines
ON_DECL
bool ON_Intersect( 
          const ON_Line&, 
          const ON_Line&, 
          double*, // parameter on first line
          double*  // parameter on second line
          );

// Returns false unless intersection is a single point
// If returned parameter is < 0 or > 1, then the line
// segment between line.m_point[0] and line.m_point[1]
// does not intersect the plane
ON_DECL
bool ON_Intersect( 
          const ON_Line&, 
          const ON_Plane&, 
          double* // parameter on line
          );

ON_DECL
bool ON_Intersect( 
        const ON_Plane&, 
        const ON_Plane&, 
        ON_Line& // intersection line is returned here
        );

ON_DECL
bool ON_Intersect( 
        const ON_Plane&, 
        const ON_Plane&, 
        const ON_Plane&,
        ON_3dPoint& // intersection point is returned here
        );

// returns 0 = no intersections, 
// 1 = intersection = single point, 
// 2 = intersection = circle
// If 0 is returned, returned circle has radius=0
// and center = point on sphere closest to plane.
// If 1 is returned, intersection is a single
// point and returned circle has radius=0
// and center = intersection point on sphere.
ON_DECL
int ON_Intersect( 
                 const ON_Plane&, const ON_Sphere&, ON_Circle&
                  );

// Intersects an infinte line and sphere and returns 
// 0 = no intersections, 
// 1 = one intersection, 
// 2 = 2 intersections
// If 0 is returned, first point is point 
// on line closest to sphere and 2nd point is the point
// on the sphere closest to the line.
// If 1 is returned, first point is obtained by evaluating
// the line and the second point is obtained by evaluating
// the sphere.
ON_DECL
int ON_Intersect(                  
        const ON_Line&, 
        const ON_Sphere&,
        ON_3dPoint&, 
        ON_3dPoint& // intersection point(s) returned here
        );


// Intersects an infinte line and cylinder and returns 
// 0 = no intersections, 
// 1 = one intersection, 
// 2 = 2 intersections
// 3 = line lies on cylinder
//
// If 0 is returned, first point is point 
// on line closest to cylinder and 2nd point is the point
// on the cylinder closest to the line.
// If 1 is returned, first point is obtained by evaluating
// the line and the second point is obtained by evaluating
// the cylinder.
//
// The value of cylinder.IsFinite() determines if the
// intersection is performed on the finite or infinite cylinder.
ON_DECL
int ON_Intersect( 
      const ON_Line&, // [in]
      const ON_Cylinder&, // [in]
      ON_3dPoint&, // [out] first intersection point
      ON_3dPoint& // [out] second intersection point
      );

// Description:
//   Intersect an infinte line and circle.
// Parameters:
//   line - [in]
//   circle - [in]
//   line_t0 - [out] line parameter of first intersection point
//   circle_point0 - [out] first intersection point on circle
//   line_t1 - [out] line parameter of second intersection point
//   circle_point1 - [out] second intersection point on circle
// Returns:
//   0     No intersection
//   1     One intersection at line.PointAt(*line_t0)
//   2     Two intersections at line.PointAt(*line_t0)
//         and line.PointAt(*line_t1).
ON_DECL
int ON_Intersect( 
                  const ON_Line& line, 
                  const ON_Circle& circle,
                  double* line_t0,
                  ON_3dPoint& circle_point0,
                  double* line_t1,
                  ON_3dPoint& circle_point1
                  );



// Description:
//   Intersect a infinte line and arc.
// Parameters:
//   line - [in]
//   arc - [in]
//   line_t0 - [out] line parameter of first intersection point
//   arc_point0 - [out] first intersection point on arc
//   line_t1 - [out] line parameter of second intersection point
//   arc_point1 - [out] second intersection point on arc
// Returns:
//   0     No intersection
//   1     One intersection at line.PointAt(*line_t0)
//   2     Two intersections at line.PointAt(*line_t0)
//         and line.PointAt(*line_t1).
ON_DECL
int ON_Intersect( 
                  const ON_Line& line, 
                  const ON_Arc& arc,
                  double* line_t0,
                  ON_3dPoint& arc_point0,
                  double* line_t1,
                  ON_3dPoint& arc_point1
                  );

// Description:
//   Intersect a plane and a circle.
// Parameters:
//   plane - [in]
//   circle - [in]
//   point0 - [out] first intersection point 
//   point1 - [out] second intersection point
// Returns:
//   0     No intersection
//   1     One intersection at point0
//   2     Two intersections at point0
//         and point1.
//	 3		 Circle lies on plane
ON_DECL
int ON_Intersect( 
                  const ON_Plane& plane, 
                  const ON_Circle& circle,
                  ON_3dPoint& point0,
                  ON_3dPoint& point1
                  );

// Description:
//   Intersect a plane and an arc.
// Parameters:
//   plane - [in]
//   arc - [in]
//   point0 - [out] first intersection point 
//   point1 - [out] second intersection point
// Returns:
//   0     No intersection
//   1     One intersection at point0
//   2     Two intersections at point0
//         and point1.
//	 3		 Arc lies on plane
ON_DECL
int ON_Intersect( 
                  const ON_Plane& plane, 
                  const ON_Arc& arc,
                  ON_3dPoint& point0,
                  ON_3dPoint& point1
                  );


// returns 0 = no, 1 = yes, 2 = points are coincident and on line
ON_DECL
int ON_ArePointsOnLine(
        int, // dimension of points
        int, // is_rat = true if homogeneous rational
        int, // count = number of points
        int, // stride ( >= is_rat?(dim+1) :dim)
        const double*, // point array
        const ON_BoundingBox&, // if needed, use ON_GetBoundingBox(dim,is_rat,count,stride,point)
        const ON_Line&,
        double         // tolerance (if 0.0, a tolerance based on bounding box size is used)
        );

// returns 0 = no, 1 = yes, 2 = points are coincident and on line
ON_DECL
int ON_ArePointsOnPlane(
        int, // dimension of points
        int, // is_rat = true if homogeneous rational
        int, // count = number of points
        int, // stride ( >= is_rat?(dim+1) :dim)
        const double*, // point array
        const ON_BoundingBox&, // if needed, use ON_GetBoundingBox(dim,is_rat,count,stride,point)
        const ON_Plane&,
        double         // tolerance (if 0.0, a tolerance based on bounding box size is used)
        );

/*
Description:
  Use the quotient rule to compute derivatives of a one parameter
  rational function F(t) = X(t)/W(t), where W is a scalar
  and F and X are vectors of dimension dim.
Parameters:
  dim - [in]
  der_count - [in] number of derivative (>=0)
  v_stride - [in] (>= dim+1)
  v - [in/out]
    v[] is an array of length (der_count+1)*v_stride.
    The input v[] array contains  derivatives of the numerator and
    denominator	functions in the order (X, W), (Xt, Wt), (Xtt, Wtt), ...
    In general, the (dim+1) coordinates of the d-th derivative 
    are in (v[n],...,v[n+dim]) where n = d*v_stride.
    In the output v[] array the derivatives of X are replaced with
    the derivatives of F and the derivatives of W are divided by
    w = v[dim].
Returns:
  True if input is valid; i.e., v[dim] != 0.
See Also:
  ON_EvaluateQuotientRule2
  ON_EvaluateQuotientRule3
*/
ON_DECL
bool ON_EvaluateQuotientRule( 
          int dim, 
          int der_count,
          int v_stride, 
          double *v 
          );

/*
Description:
  Use the quotient rule to compute partial derivatives of a two parameter
  rational function F(s,t) = X(s,t)/W(s,t), where W is a scalar
  and F and X are vectors of dimension dim.
Parameters:
  dim - [in]
  der_count - [in] number of derivative (>=0)
  v_stride - [in] (>= dim+1)
  v - [in/out]
    v[] is an array of length (der_count+2)*(der_count+1)*v_stride.
    The input array contains derivatives of the numerator and denominator
		functions in the order X, W, Xs, Ws, Xt, Wt, Xss, Wss, Xst, Wst, Xtt, Wtt, ...
    In general, the (i,j)-th derivatives are in the (dim+1) entries of v[]
		v[k], ..., answer[k+dim], where	k = ((i+j)*(i+j+1)/2 + j)*v_stride.
    In the output v[] array the derivatives of X are replaced with
    the derivatives of F and the derivatives of W are divided by
    w = v[dim].
Returns:
  True if input is valid; i.e., v[dim] != 0.
See Also:
  ON_EvaluateQuotientRule
  ON_EvaluateQuotientRule3
*/
ON_DECL
bool ON_EvaluateQuotientRule2( 
          int dim, 
          int der_count, 
          int v_stride, 
          double *v 
          );

/*
Description:
  Use the quotient rule to compute partial derivatives of a 3 parameter
  rational function F(r,s,t) = X(r,s,t)/W(r,s,t), where W is a scalar
  and F and X are vectors of dimension dim.
Parameters:
  dim - [in]
  der_count - [in] number of derivative (>=0)
  v_stride - [in] (>= dim+1)
  v - [in/out]
    v[] is an array of length 
    v_stride*(der_count+1)*(der_count+2)*(der_count+3)/6.
    The input v[] array contains  derivatives of the numerator and
    denominator	functions in the order (X, W), (Xr, Wr), (Xs, Ws),
    (Xt, Wt), (Xrr, Wrr), (Xrs, Wrs), (Xrt, Wrt), (Xss, Wss), 
    (Xst, Wst), (Xtt, Wtt), ...
    In general, the (dim+1) coordinates of the derivative 
    (Dr^i Ds^j Dt^k, i+j+k=d) are at v[n], ..., v[n+dim] where 
    n = v_stride*( d*(d+1)*(d+2)/6  +  (d-i)*(d-i+1)/2  +  k ).
    In the output v[] array the derivatives of X are replaced with
    the derivatives of F and the derivatives of W are divided by
    w = v[dim].
Returns:
  True if input is valid; i.e., v[dim] != 0.
See Also:
  ON_EvaluateQuotientRule
  ON_EvaluateQuotientRule2
*/
ON_DECL
bool ON_EvaluateQuotientRule3( 
          int dim, 
          int der_count, 
          int v_stride,
          double *v 
          );

ON_DECL
bool ON_GetPolylineLength(
        int,           // dimension of points
        ON_BOOL32,          // bIsRational true if points are homogeneous rational
        int,           // number of points
        int,           // stride between points
        const double*, // points
        double*        // length returned here
        );


/*
Description:
  Find the index of the point in the point_list that is closest to P.
Parameters:
  point_count - [in]
  point_list - [in]
  P - [in]
  closest_point_index - [out]
Returns:
  True if successful and *closest_point_index is set.
  False if input is not valid, in which case *closest_point_index
  is undefined.
*/
ON_DECL
bool ON_GetClosestPointInPointList( 
          int point_count,
          const ON_3dPoint* point_list,
          ON_3dPoint P,
          int* closest_point_index
          );

/*
Description:
  Test math library functions.
Parameters:
  function_index - [in]  Determines which math library function is called.

           1:    z = x+y
           2:    z = x-y
           3:    z = x*y
           4:    z = x/y
           5:    z = fabs(x)
           6:    z = exp(x)
           7:    z = log(x)
           8:    z = logb(x)
           9:    z = log10(x)
          10:    z = pow(x,y)
          11:    z = sqrt(x)
          12:    z = sin(x)
          13:    z = cos(x)
          14:    z = tan(x)
          15:    z = sinh(x)
          16:    z = cosh(x)
          17:    z = tanh(x)
          18:    z = asin(x)
          19:    z = acos(x)
          20:    z = atan(x)
          21:    z = atan2(y,x)
          22:    z = fmod(x,y)
          23:    z = modf(x,&y)
          24:    z = frexp(x,&y)

  double x - [in]
  double y - [in]
Returns:
  Returns the "z" value listed in the function_index parameter
  description.
Remarks:
  This function is used to test the results of class floating
  point functions.  It is primarily used to see what happens
  when opennurbs is used as a DLL and illegal operations are
  performed.
*/
ON_DECL
double ON_TestMathFunction( 
        int function_index, 
        double x, 
        double y 
        );

// If performance is important, then
// you are better off using ((b<a)?a:b)
ON_DECL double ON_Max(double a, double b);

// If performance is important, then
// you are better off using ((b<a)?a:b)
ON_DECL float ON_Max(float a, float b);

// If performance is important, then
// you are better off using ((b<a)?a:b)
ON_DECL int ON_Max(int a, int b);

// If performance is important, then
// you are better off using ((a<b)?a:b)
ON_DECL double ON_Min(double a, double b);

// If performance is important, then
// you are better off using ((a<b)?a:b)
ON_DECL float ON_Min(float a, float b);

// If performance is important, then
// you are better off using ((a<b)?a:b)
ON_DECL int ON_Min(int a, int b);

// Do not call ON_Round() in any opennurbs code, tl code
// or any other code that does critical calculations or
// when there is any possibility that x is invalid or
// fabs(x)>2147483647. Use floor(x+0.5) instead.
ON_DECL int ON_Round(double x);


/*
Description:
  Find the equation of the parabola, ellipse or hyperbola 
  (non-degenerate conic) that passes through six distinct points.
Parameters:
  stride - [in] (>=2) 
    points array stride
  points2d - [in] (>=2) 
    i-th point is (points[i*stride],points[i*stride+1])
  conic - [out]
    Coefficients of the conic equation.
    The points on the conic satisfy the equation
      0 = conic[0]*x^2 + conic[1]*xy + conic[2]*y^2 
        + conic[3]*x + conic[4]*y + conic[5]
  max_pivot - [out] (can be null)
  min_pivot - [out] (can be null)
  zero_pivot - [out] (can be null)
    If there are some near duplicates in the input point set,
    the calculation is not stable.  If you want to get an
    estimate of the validity of the solution, then inspect
    the returned values.  max_pivot should around 1, 
    min_pivot should be > 1e-4 or so, and zero_pivot should
    be < 1e-10 or so.  If the returned pivots don't satisify
    these condtions, then exercise caution when using the
    returned solution.
Returns:
  True if a there is an ellipse, parabola or hyperbola through the  
  six points.
  False if the input is invalid or the conic degenerate (the
  points lie on one or two lines).
  If false is returned, then conic[0]=...=conic[5] = 0 and
  *min_pivot = *max_pivot = *zero_pivot = 0.
*/
ON_DECL bool ON_GetConicEquationThrough6Points( 
        int stride, 
        const double* points2d, 
        double conic[6],
        double* max_pivot,
        double* min_pivot,
        double* zero_pivot
        );

/*
Description:
  Test a conic equation to see if it defines and ellipse. If so,
  return the center and axes of the ellipse.
Parameters:
  conic - [in]
    Coefficients of the conic equation.
    The points on the conic satisfy the equation
      0 = conic[0]*x^2 + conic[1]*xy + conic[2]*y^2 
        + conic[3]*x + conic[4]*y + conic[5]
  center - [out]
  major_axis - [out]
  minor_axis - [out]
  major_radius - [out]
  minor_radius - [out]
Returns:
  True if the conic is an ellipse and the center and axes were found.
  False if the conic is not an ellipse, in which case the input values
  of center, major_axis, minor_axis, major_radius, and minor_radius
  are not changed.
*/
ON_DECL bool ON_IsConicEquationAnEllipse( 
        const double conic[6], 
        ON_2dPoint& center, 
        ON_2dVector& major_axis, 
        ON_2dVector& minor_axis, 
        double* major_radius, 
        double* minor_radius
        );

/*
Description:
  Get the conic equation of an ellipse.
Parameters:
  a - [in] (a>0)
  b - [in] (b>0)
    a and b are the lengths of the axes. Either one
    may be largest and they can be equal.
  x0 - [in]
  y0 - [in]
    (x0,y0) is the enter of the ellipse.
  alpha - [in] (angle in radians)
    When alpha is 0, a corresponds to the x-axis and
    b corresponds to the y axis.  If alpha is non-zero
    it specifies the rotation of these axes.
  conic - [out]
    Coefficients of the conic equation.
    The points on the conic satisfy the equation
      0 = conic[0]*x^2 + conic[1]*xy + conic[2]*y^2 
        + conic[3]*x + conic[4]*y + conic[5]
  center - [out]
  major_axis - [out]
  minor_axis - [out]
  major_radius - [out]
  minor_radius - [out]
Remarks:
  Here is the way to evaluate a point on the ellipse:

          
          double t = ellipse paramter in radians;
          double x = a*cos(t);
          double y = b*sin(t);
          ON_2dPoint ellipse_point;
          ellipse_point.x = x0 + x*cos(alpha) + y*sin(alpha);
          ellipse_point.y = y0 - x*sin(alpha) + y*cos(alpha);

Returns:
  True if the input is valid and conic[] was filled in.
  Falis if the input is not valid.  In this case the values in conic[]
  are not changed.
*/
ON_DECL bool ON_GetEllipseConicEquation( 
      double a, double b, 
      double x0, double y0, 
      double alpha,
      double conic[6]
      );

#endif
/*
Descripton:
  Return the length of a 2d vector (x,y)
Returns:
 sqrt(x^2 + y^2) calculated in as precisely and safely as possible.
*/
ON_DECL double ON_Length2d( double x, double y );

/*
Descripton:
  Return the length of a 3d vector (x,y,z)
Returns:
 sqrt(x^2 + y^2 + z^2) calculated in as precisely and safely as possible.
*/
ON_DECL double ON_Length3d( double x, double y, double z );


/*
Description:
  Convert a double x to the largest float f such that
  the mathematical value of f is at most the value of x.
Parameters:
  x - [in]
Returns
  The largest float f such that the mathematical value
  of f is at most the value of x.
*/
ON_DECL float ON_FloatFloor(double x);

/*
Description:
  Convert a double x to the smallest float f such that
  the mathematical value of f is at least the value of x.
Parameters:
  x - [in]
Returns
  The smallest float f such that the mathematical value
  of f is at least the value of x.
*/
ON_DECL float ON_FloatCeil(double x);

/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(ON_INTERSECT_INC_)
#define ON_INTERSECT_INC_

// These simple intersectors are fast and detect transverse intersections.
// If the intersection is not a simple transverse case, then they
// return false and you will have to use one of the slower but fancier
// models.


/*
Description:
  Intersect two lines.
Parameters:
  lineA - [in]
  lineB - [in]
  double* a - [out]
  double* b - [out] The shortest distance between the lines is the
                   chord from lineA.PointAt(*a) to lineB.PointAt(*b).
  tolerance - [in] If > 0.0, then an intersection is reported only
                   if the distance between the points is <= tolerance.
                   If <= 0.0, then the closest point between the lines
                   is reported.
  bIntersectSegments - [in] if true, the input lines are treated
                           as finite segments.  If false, the
                           input lines are treated as infinite lines.
Returns:
  True if a closest point can be calculated and the result passes
  the tolerance parameter test.
See Also:
  ON_Intersect( const ON_Line& lineA, const ON_Line& line B)
Remarks:
  If the lines are exactly parallel, meaning the system of equations
  used to find a and b has no numerical solution, then false is returned.
  If the lines are nearly parallel, which is often numerically true
  even if you think the lines look exactly parallel, then the
  closest points are found and true is returned.  So, if you
  care about weeding out "parallel" lines, then you need to
  do something like the following.

          bool rc = ON_IntersectLineLine(lineA,lineB,
                                         &a,&b,
                                         tolerance,
                                         bIntersectSegments);
          if (rc)
          {
            double angle_tolerance_radians = 0.5*ON_PI/180.0; // or whatever
            double parallel_tol = cos(angle_tolerance_radians);
            if ( fabs(lineA.Tangent()*lineB.Tangent()) >= parallel_tol )
            {
              ... do whatever you think is appropriate
            }
          }
*/
ON_DECL
bool ON_IntersectLineLine(
          const ON_Line& lineA, 
          const ON_Line& lineB, 
          double* a,
          double* b,
          double tolerance,
          bool bIntersectSegments
          );

/*
Description:
  Find the closest point between two infinte lines.
Parameters:
  lineA - [in]
  lineB - [in]
  double* a - [out]
  double* b - [out] The shortest distance between the lines is the
                   chord from lineA.PointAt(*a) to lineB.PointAt(*b).
Returns:
  True if points are found and false if the lines are numerically parallel.
  Numerically parallel means the 2x2 matrix

            AoA  -AoB
           -AoB   BoB

 is numerically singluar, where A = lineA.to-lineA.from 
 and B = lineB.to-lineB.from.
See Also:
  ON_IntersectLineLine
*/
ON_DECL
bool ON_Intersect(
          const ON_Line& lineA, 
          const ON_Line& lineB, 
          double* a,
          double* b
          );

ON_DECL
bool ON_Intersect( // Returns false unless intersection is a single point
                   // If returned parameter is < 0 or > 1, then the line
                   // segment between line.m_point[0] and line.m_point[1]
                   // does not intersect the plane
          const ON_Line&, 
          const ON_Plane&, 
          double* // parameter on line
          );

ON_DECL
bool ON_Intersect( const ON_Plane&, 
                  const ON_Plane&, 
                   ON_Line& // intersection line is returned here
                   );

ON_DECL
bool ON_Intersect( const ON_Plane&, 
                  const ON_Plane&, 
                  const ON_Plane&,
                  ON_3dPoint& // intersection point is returned here
                  );

/*
Description:
  Intersect a plane and a sphere.
Parameters:
  plane - [in]
  sphere - [in]
  circle - [out]
Returns:
  0: no intersection
    circle radius = 0 and circle origin = point on the plane
    closest to the sphere.
  1: intersection is a single point
    circle radius = 0;
  2: intersection is a circle
    circle radius > 0.
*/
ON_DECL
int ON_Intersect(
          const ON_Plane& plane, 
          const ON_Sphere& sphere,
          ON_Circle& circle
          );

ON_DECL
int ON_Intersect( // returns 0 = no intersections, 
                  // 1 = one intersection, 
                  // 2 = 2 intersections
                  // If 0 is returned, first point is point 
                  // on line closest to sphere and 2nd point is the point
                  // on the sphere closest to the line.
                  // If 1 is returned, first point is obtained by evaluating
                  // the line and the second point is obtained by evaluating
                  // the sphere.
                 const ON_Line&, const ON_Sphere&,
                  ON_3dPoint&, ON_3dPoint& // intersection point(s) returned here
                  );

ON_DECL
int ON_Intersect( // returns 0 = no intersections, 
                  // 1 = one intersection, 
                  // 2 = 2 intersections
                  // 3 = line lies on cylinder
                  // If 0 is returned, first point is point 
                  // on line closest to cylinder and 2nd point is the point
                  // on the sphere closest to the line.
                  // If 1 is returned, first point is obtained by evaluating
                  // the line and the second point is obtained by evaluating
                  // the sphere.
                  const ON_Line&, const ON_Cylinder&,
                  ON_3dPoint&, ON_3dPoint& // intersection point(s) returned here
                  );

/*
Description:
  Intersect an infinite line and an axis aligned bounding box.
Parameters:
  bbox - [in]
  line - [in]
  tolerance - [in]  If tolerance > 0.0, then the intersection is
                   performed against a box that has each side
                   moved out by tolerance.
  line_parameters - [out] 
    Pass null if you do not need the parameters.
    If true is returned and line.from != line.to,
    then the chord from line.PointAt(line_parameters[0])
    to line.PointAt(line_parameters[1]) is the intersection.
    If true is returned and line.from = line.to, then line.from
    is in the box and the interval (0.0,0.0) is returned.
    If false is returned, the input value of line_parameters
    is not changed.
Returns:
  True if the line intersects the box and false otherwise.
*/
ON_DECL
bool ON_Intersect( const ON_BoundingBox& bbox, 
                   const ON_Line& line, 
                   double tolerance,
                   ON_Interval* line_parameters
                   );

/*
Description:
  Intersect two spheres using exact calculations.
Parameters:
  sphere0 - [in]
  sphere1 - [in]
  circle - [out] If intersection is a point, then that point will be the center, radius 0.
Returns:
  0 if no intersection,
  1 if a single point,
  2 if a circle,
  3 if the spheres are the same.
*/
ON_DECL
int ON_Intersect( const ON_Sphere& sphere0, 
                  const ON_Sphere& sphere1, 
                  ON_Circle& circle
                 );
#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_OPTIMIZE_INC_)
#define OPENNURBS_OPTIMIZE_INC_

// find a local minimum of a 1 parameter function
ON_BOOL32 ON_FindLocalMinimum( // returns 0 - failed to converge, 1 - success, 2 - failed to converge to requested tolerances
        int (*)(void*,double,double*,double*), // f(void*, double t, double* value, double* derivative );
        void*, // passed as the void* argument to the above function
        double, double, double, // ax,bx,cx, 3 abcissa  ax<bx<cx or ax>bx>cx, and
                                // f(bx) < f(ax), and f(bx) < f(cx)
        double, // tol > 0 (minimum relative step size (use ON_EPSILON when in doubt)
        double, // zeps > 0 (minimum absolute step size (use 1/2*(desired absolute precision))
        int,     // maximum number of iterations ( use 100 when in doubt)
        double*  // abcissa of local minimum returned here
        );

// find a local zero of a 1 parameter function
class ON_LocalZero1
{
public:
  ON_LocalZero1();
  virtual ~ON_LocalZero1();

  virtual
  ON_BOOL32 Evaluate( // returns true if successful
     double,  // evaluation parameter
     double*, // f(t) returned here - NULL never passed
     double*, // If not NULL, then f'(t) returned here
     int      // <  0: evaluate from below
              // >= 0: evaluate from above
  ) = 0;


  ON_BOOL32 FindZero( double* );  // Searches domain between m_t0 and m_t1
                             // domain for a root.  Returns true if
                             // a root is found.

  // m_t0 and m_t1 specify the domain to search and must satisfy 
  //
  //          1) m_t0 != m_t1
  //          2) f(m_t0) and f(m_t1) must have different signs
  //             or one must have absolute value <= m_f_tolerance
  double m_t0, m_t1; 

  double m_f_tolerance; // (>= 0.0)  If this value is > 0.0, then
                        // the search is terminated when a parameter
                        // "t" is found where |f(t)| <= m_f_tolerance.

  double m_t_tolerance; // (>= 0.0)  If this value is > 0.0, then
                        // the search is terminated when a parameter
                        // the root is bracketed in a domain with width
                        // <= m_t_tolerance.

  // m_k[] is either NULL or monotone increasing array of length m_k_count.
  //
  // This zero finder works on continuous piecewise c2 functions.
  // If the function is c2 on the interior of the domain 
  //
  //          [min(t0,t1), max(m_t0,m_t1)]
  //
  // then there is no need to initialize m_k[].  If the function
  // is not c2 on the domain in question, then the m_k[m_count] array
  // is a list of parameters that define the c2 domains.  When m_k[] 
  // is not NULL, m_count must be >= 2 and m_k[] must be monotone 
  // increasing and satisfy 
  //
  //          m_k[0] <= min(m_t0,m_t1) 
  //          and
  //          m_k[m_count-1] >= max(m_t0,m_t1).
  //
  // Duplicate values in m_k[] are permitted so that NURBS knot
  // vector arrays may be used directly.
  const double* m_k;
  
  // length of m_k[] array ( 0 or >= 2 ).
  int m_k_count;     

private:
  double m_s0, m_f0, m_s1, m_f1;
  ON_BOOL32 BracketZero(double,double,double,double,int=0);
  ON_BOOL32 BracketSpan(double,double,double,double);
  ON_BOOL32 NewtonRaphson( double, double, double, double, int, double* );
};

#endif

/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_KNOT_INC_)
#define OPENNURBS_KNOT_INC_

ON_DECL
double ON_DomainTolerance(
          double, // start of domain
          double  // end of domain
          );

ON_DECL
double ON_KnotTolerance(
          int,           // order (>=2)
          int,           // cv count
          const double*, // knot[] array
          int            // knot index
          );

ON_DECL
double ON_SpanTolerance(
          int,           // order (>=2)
          int,           // cv count
          const double*, // knot[] array
          int            // span index
          );

ON_DECL
int ON_KnotCount( // returns (order + cv_count - 2)
          int, // order (>=2)
          int  // cv_count (>=order)
          );

ON_DECL
int ON_KnotMultiplicity(
          int,   // order (>=2)
          int,   // cv_count (>=order)
          const double*, // knot[]
          int            // knot_index
          );

ON_DECL
int ON_KnotVectorSpanCount(
          int,           // order (>=2)
          int,           // cv count
          const double*  // knot[] array
          );

ON_DECL
bool ON_GetKnotVectorSpanVector(
          int,           // order (>=2)
          int,           // cv count
          const double*, // knot[] array
          double*        // s[] array
          );

/*
Description:
  Given an evaluation parameter t in the domain of a NURBS curve,
  ON_NurbsSpanIndex(order,cv_count,knot,t,0,0) returns the integer
  i such that (knot[i],...,knot[i+2*degree-1]),  and 
  (cv[i],...,cv[i+degree]) are the knots and control points that
  define the span of the NURBS that are used for evaluation at t.
Parameters:
  order - [in] order >= 2
  cv_count - [in] cv_count >= order
  knot - [in] valid knot vector
  t - [in] evaluation parameter
  side - [in] determines which span is used when t is at a knot
              value;  side = 0 for the default (from above),
              side = -1 means from below, and 
              side = +1 means from above.
  hint - [in] Search hint, or 0 if not hint is available.
Returns:
  Returns the index described above.
*/
ON_DECL
int ON_NurbsSpanIndex(
          int order,
          int cv_count,
          const double* knot,
          double t,
          int side,
          int hint
          );

ON_DECL
int ON_NextNurbsSpanIndex(
          // returns  0: input span_index < 0
          //           cv_count-order: input span_index = cv_count-order
          //         -1: input span_index > cv_count-order;
          //     otherwise next span index
          int order,
          int cv_count,
          const double* knot,
          int            // current span_index 
          );

ON_DECL
int ON_GetSpanIndices( // returns span count, which is one less than length of span_indices[]
          int order,
          int cv_count,
          const double* knot,
          int*           // span_indices[cv_count-order+2]. 
                         //Indices of knots at end of group of mult knots 
                         //at start of span, and knot at start of group of mult knots
                         //at end of spline.
          );

ON_DECL
double ON_SuperfluousKnot( 
          int order,
          int cv_count,
          const double* knot,
          int            // 0 = first superfluous knot 
                         // 1 = last superfluous knot
          );

ON_DECL
bool ON_IsKnotVectorPeriodic(
          int order,
          int cv_count,
          const double* knot
          );

ON_DECL
bool ON_IsKnotVectorClamped(
          int order,
          int cv_count,
          const double* knot,
          int = 2        // 0 = check left end, 1 = check right end, 2 = check both
          );

ON_DECL
bool ON_IsKnotVectorUniform(
          int order,
          int cv_count,
          const double* knot 
          );

//////////
// returns true if all knots have multiplicity = degree
ON_DECL
bool ON_KnotVectorHasBezierSpans(
          int order,
          int cv_count,
          const double* knot
          );


ON_DECL
ON::knot_style ON_KnotVectorStyle( 
          int order,
          int cv_count,
          const double* knot
          );

/*
Description:
  Set the domain of a knot vector.
Parameters:
  order - [in] order >= 2
  cv_count - [in] cv_count >= order
  knot - [in/out] input existing knots and returns knots with new domain.
  t0 - [in]
  t1 - [in] New domain will be the interval (t0,t1).
Returns:
  True if input is valid and the returned knot vector 
  has the requested domain.  False if the input is
  invalid, in which case the input knot vector is not
  changed.
*/
ON_DECL
bool ON_SetKnotVectorDomain( 
          int order, 
          int cv_count, 
          double* knot, 
          double t0, 
          double t1 
          );

ON_DECL
bool ON_GetKnotVectorDomain(
          int,           // order (>=2)
          int,           // cv count
          const double*, // knot[] array
          double*, double*
          );

ON_DECL
bool ON_ReverseKnotVector(
          int,           // order (>=2)
          int,           // cv count
          double*        // knot[] array
          );

ON_DECL
int ON_CompareKnotVector( // returns 
                                      // -1: first < second
                                      //  0: first == second
                                      // +1: first > second
          // first knot vector
          int,           // order (>=2)
          int,           // cv count
          const double*, // knot[] array
          // second knot vector
          int,           // order (>=2)
          int,           // cv count
          const double*  // knot[] array
          );

ON_DECL
bool ON_IsValidKnotVector(
          int order,
          int cv_count, 
          const double* knot, 
          ON_TextLog* text_log = 0
          );

ON_DECL
bool ON_ClampKnotVector(
          // Sets inital/final order-2 knots to values in
          // knot[order-2]/knot[cv_count-1].
          int,           // order (>=2)
          int,           // cv count
          double*,       // knot[] array
          int            // 0 = clamp left end, 1 = right end, 2 = clamp both ends
          );

ON_DECL
bool ON_MakeKnotVectorPeriodic(
          // Sets inital and final order-2 knots to values
          // that make the knot vector periodic
          int,           // order (>=2)
          int,           // cv count
          double*        // knot[] array
          );

 /*
 Description:
   Fill in knot values for a clamped uniform knot
   vector.
 Parameters:
   order - [in] (>=2) order (degree+1) of the NURBS
   cv_count - [in] (>=order) total number of control points
       in the NURBS.
   knot - [in/out] Input is an array with room for 
       ON_KnotCount(order,cv_count) doubles.  Output is
       a clamped uniform knot vector with domain
       (0, (1+cv_count-order)*delta).
   delta - [in] (>0, default=1.0) spacing between knots.
 Returns:
   true if successful
 See Also:
   ON_NurbsCurve::MakeClampedUniformKnotVector
*/
ON_DECL
bool ON_MakeClampedUniformKnotVector(
          int order,
          int cv_count,
          double* knot,
          double delta = 1.0
          );

/*
 Description:
   Fill in knot values for a clamped uniform knot
   vector.
 Parameters:
   order - [in] (>=2) order (degree+1) of the NURBS
   cv_count - [in] (>=order) total number of control points
       in the NURBS.
   knot - [in/out] Input is an array with room for 
       ON_KnotCount(order,cv_count) doubles.  Output is
       a periodic uniform knot vector with domain
       (0, (1+cv_count-order)*delta).
   delta - [in] (>0, default=1.0) spacing between knots.
 Returns:
   true if successful
 See Also:
   ON_NurbsCurve::MakePeriodicUniformKnotVector
*/
ON_DECL
bool ON_MakePeriodicUniformKnotVector(
          int order,
          int cv_count,
          double* knot,
          double delta = 1.0
          );

ON_DECL
double ON_GrevilleAbcissa( // get Greville abcissae from knots
          int,           // order (>=2)
          const double*  // knot[] array (length = order-1)
          );

ON_DECL
bool ON_GetGrevilleAbcissae( // get Greville abcissae from knots
          int,            // order (>=2)
          int,            // cv count
          const double*,  // knot[] array
          bool,           // true for periodic case
          double*         // g[] array has length cv_count in non-periodic case
                          // and cv_count-order+1 in periodic case
          );

ON_DECL
bool ON_GetGrevilleKnotVector( // get knots from Greville abcissa
          int,           // g[] array stride (>=1)
          const double*, // g[] array
                         // if not periodic, length = cv_count
                         // if periodic, length = cv_count-order+2
          bool,          // true for periodic knots
          int,           // order (>=2)
          int,           // cv_count (>=order)
          double*        // knot[cv_count+order-2]
          );

ON_DECL
bool ON_ClampKnotVector(
        int,       // cv_dim ( = dim+1 for rational cvs )
        int,       // order (>=2)
        int,       // cv_count,
        int,       // cv_stride, 
        double*,   // cv[] NULL or array of order many cvs
        double*,   // knot[] array with room for at least knot_multiplicity new knots
        int        // end  0 = clamp start, 1 = clamp end, 2 = clamp both ends
        );

/*
Returns:
  Number of knots added.
*/
ON_DECL
int ON_InsertKnot(
        double,    // knot_value,
        int,       // knot_multiplicity, (1 to order-1 including multiplicity of any existing knots)
        int,       // cv_dim ( = dim+1 for rational cvs )
        int,       // order (>=2)
        int,       // cv_count,
        int,       // cv_stride (>=cv_dim)
        double*,   // cv[]  NULL or cv array with room for at least knot_multiplicity new cvs
        double*,   // knot[] knot array with room for at least knot_multiplicity new knots
        int*       // hint, optional hint about where to search for span to add knots to
                   // pass NULL if no hint is available
        );

/*
Description:
  Reparameterize a rational Bezier curve.
Parameters:
  c - [in]
    reparameterization constant (generally speaking, c should be > 0).
    The control points are adjusted so that 
    output_bezier(t) = input_bezier(lambda(t)), where
    lambda(t) = c*t/( (c-1)*t + 1 ).
    Note that lambda(0) = 0, lambda(1) = 1, lambda'(t) > 0, 
    lambda'(0) = c and lambda'(1) = 1/c.
  dim - [in]
  order - [in]
  cvstride - [in] (>= dim+1)
  cv - [in/out]  homogeneous rational control points
Returns:
  The cv values are changed so that
  output_bezier(t) = input_bezier(lambda(t)).
*/
ON_DECL
bool ON_ReparameterizeRationalBezierCurve(
          double c,
          int dim,
          int order,
          int cvstride,
          double* cv
          );

/*
Description:
  Use a combination of scaling and reparameterization to set two rational
  Bezier weights to specified values.
Parameters:
  dim - [in] 
  order - [in]
  cvstride - [in] ( >= dim+1)
  cv - [in/out]  homogeneous rational control points
  i0 - [in] 
  w0 - [in]
  i1 - [in]
  w1 - [in]
    The i0-th cv will have weight w0 and the i1-th cv will have weight w1.
    If v0 and v1 are the cv's input weights, then v0, v1, w0 and w1 must
    all be nonzero, and w0*v0 and w1*v1 must have the same sign.
Returns:
  true if successful
Remarks:
  The equations
    s * r^i0 = w0/v0
    s * r^i1 = w1/v1
  determine the scaling and reparameterization necessary to change v0,v1 to
  w0,w1. 

  If the input Bezier has control vertices {B_0, ..., B_d}, then the 
  output Bezier has control vertices {s*B_0, ... s*r^i * B_i, ..., s*r^d * B_d}.
*/
ON_DECL
bool ON_ChangeRationalBezierCurveWeights(
          int dim, int order, int cvstride, double* cv,
          int i0, double w0, 
          int i1, double w1
          );

/*
Description:
  Reparameterize a rational NURBS curve.
Parameters:
  c - [in]
    reparameterization constant (generally speaking, c should be > 0).
    The control points and knots are adjusted so that 
    output_nurbs(t) = input_nurbs(lambda(t)), where
    lambda(t) = c*t/( (c-1)*t + 1 ).
    Note that lambda(0) = 0, lambda(1) = 1, lambda'(t) > 0, 
    lambda'(0) = c and lambda'(1) = 1/c.
  dim - [in]
  order - [in]
  cvstride - [in] (>=dim+1)
  cv - [in/out]  homogeneous rational control points
  knot - [in/out]
    NURBS curve knots
Returns:
  The cv values are changed so that
  output_bezier(t) = input_bezier(lambda(t)).
See Also:
  ON_ChangeRationalNurbsCurveEndWeights
*/
ON_DECL
bool ON_ReparameterizeRationalNurbsCurve(
          double c, 
          int dim, 
          int order, 
          int cv_count,
          int cvstride,
          double* cv,
          double* knot
          );

/*
Description:
  Use a combination of scaling and reparameterization to set the end
  weights to the specified values.  This 
Parameters:
  dim - [in]
  order - [in]
  cvstride - [in] (>=dim+1)
  cv - [in/out] homogeneous rational control points
  knot - [in/out] (output knot vector will be clamped and internal
                   knots may be shifted.)
  w0 - [in]
  w1 - [in]
    The first cv will have weight w0 and the last cv will have weight w1.
    If v0 and v1 are the cv's input weights, then v0, v1, w0 and w1 must
    all be nonzero, and w0*v0 and w1*v1 must have the same sign.
Returns:
  true if successful
See Also:
  ON_ReparameterizeRationalNurbsCurve
*/
ON_DECL
bool ON_ChangeRationalNurbsCurveEndWeights(
          int dim, 
          int order, 
          int cv_count,
          int cvstride, 
          double* cv, 
          double* knot,
          double w0, 
          double w1
          );

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(ON_EVALUATE_NURBS_INC_)
#define ON_EVALUATE_NURBS_INC_

ON_DECL
bool ON_IncreaseBezierDegree(
        int,    // dimension 
        ON_BOOL32,   // true if Bezier is rational
        int,    // order (>=2)
        int,    // cv_stride (>=dim+1)
        double* // cv[(order+1)*cv_stride] array
        );

ON_DECL
bool ON_RemoveBezierSingAt0( // input bezier is rational with 0/0 at start
        int,    // dimension 
        int,    // order (>=2)
        int,    // cv_stride (>=dim+1)
        double* // cv[order*cv_stride] array
        );

ON_DECL
bool ON_RemoveBezierSingAt1( // input bezier is rational with 0/0 at end
        int,    // dimension 
        int,    // order (>=2)
        int,    // cv_stride (>=dim+1)
        double* // cv[order*cv_stride] array
        );

ON_DECL
double ON_EvaluateBernsteinBasis( // returns (i choose d)*(1-t)^(d-i)*t^i
        int, // degree, 
        int, // 0 <= i <= degree
        double //  t
        );

ON_DECL
void ON_EvaluatedeCasteljau(
        int,     //  dim
        int,     //  order
        int,     //  side <= 0  return left side of bezier in cv array
                 //       >  0  return right side of bezier in cv array
        int,     //  cv_stride
        double*, //  cv
        double   //  t 0 <= t <= 1
        );

ON_DECL
bool ON_EvaluateBezier(
        int,            // dimension
        ON_BOOL32,           // true if Bezier is rational
        int,            // order (>=2)
        int,            // cv_stride >= (is_rat)?dim+1:dim
        const double*,  // cv[order*cv_stride] array
        double, double, // t0,t1 = domain of bezier
        int,            // number of derivatives to compute (>=0)
        double,         // evaluation parameter
        int,            // v_stride (>=dimension)
        double*         // v[(der_count+1)*v_stride] array
        );
                                      
ON_DECL
bool ON_EvaluateNurbsBasis( 
                  int,           // order (>=1)
                  const double*, // knot[] array of 2*(order-1) knots
                  double,        // evaluation parameter
                  double*        // basis_values[] array of length order*order
                  );

ON_DECL
bool ON_EvaluateNurbsBasisDerivatives( 
                  int,           // order (>=1)
                  const double*, // knot[] array of 2*(order-1) knots
                  int,           // number of derivatives
                  double*        // basis_values[] array of length order*order
                  );                      




/*
int dim,             // dimension
                  ON_BOOL32 is_rat,         // true if NURBS is rational
                  int order,           // order
                  const double* knot,  // knot[] array of (2*order-2) doubles
                  int cv_stride,       // cv_stride >= (is_rat)?dim+1:dim
                  const double* cv,    // cv[order*cv_stride] array
                  int der_count,       // number of derivatives to compute
                  double t,            // evaluation parameter
                  int v_stride,        // v_stride (>=dimension)
                  double* v            // v[(der_count+1)*v_stride] array
                  )
        int,           // dimension
        ON_BOOL32,          // true if NURBS is rational
        int,           // order
        const double*, // knot[] array of (2*order-2) doubles
        int,           // cv_stride
        const double*, // cv[] array of order*cv_stride  doubles
        int,           // number of derivatives to compute (>=0)
        double,        // evaluation parameter
        int,           // answer_stride (>=dimension)
        double*        // answer[] array of length (ndir+1)*answer_stride
*/


ON_DECL

/*
Description:
  Evaluate a NURBS curve span.
Parameters:
  dim - [in]
    dimension (> 0).
  is_rat - [in] 
    true or false.
  order - [in]
    order=degree+1 (order>=2)
  knot - [in] NURBS knot vector.
    NURBS knot vector with 2*(order-1) knots, knot[order-2] != knot[order-1]
  cv_stride - [in]
  cv - [in]
    For 0 <= i < order the i-th control vertex is

          cv[n],...,cv[n+(is_rat?dim:dim+1)], 

    where n = i*cv_stride.  If is_rat is true the cv is
    in homogeneous form.
  der_count - [in] 
    number of derivatives to evaluate (>=0)
  t - [in] 
    evaluation parameter
  v_stride - [in]
  v - [out]
    An array of length v_stride*(der_count+1). The evaluation 
    results are returned in this array.

              P = v[0],...,v[m_dim-1]
              Dt = v[v_stride],...
              Dtt = v[2*v_stride],...
              ...

            In general, Dt^i returned in v[n],...,v[n+m_dim-1], where

              n = v_stride*i.
    
Returns:
  True if successful.
See Also:
  ON_NurbsCurve::Evaluate
  ON_EvaluateNurbsSurfaceSpan
  ON_EvaluateNurbsCageSpan
*/
bool ON_EvaluateNurbsSpan( 
        int dim,
        int is_rat,
        int order,
        const double* knot,
        int cv_stride,
        const double* cv,
        int der_count,
        double t,
        int v_stride,
        double* v
        );

/*
Description:
  Evaluate a NURBS surface bispan.
Parameters:
  dim - [in] >0
  is_rat - [in] true of false
  order0 - [in] >= 2
  order1 - [in] >= 2
  knot0 - [in] 
    NURBS knot vector with 2*(order0-1) knots, knot0[order0-2] != knot0[order0-1]
  knot1 - [in]
    NURBS knot vector with 2*(order1-1) knots, knot1[order1-2] != knot1[order1-1]
  cv_stride0 - [in]
  cv_stride1 - [in]
  cv - [in]
    For 0 <= i < order0 and  0 <= j < order1, the (i,j) control vertex is

          cv[n],...,cv[n+(is_rat?dim:dim+1)], 

    where n = i*cv_stride0 + j*cv_stride1.  If is_rat is true the cv is
    in homogeneous form.
   
  der_count - [in] (>=0)
  s - [in]
  t - [in] (s,t) is the evaluation parameter
  v_stride - [in] (>=dim)
  v - [out] An array of length v_stride*(der_count+1)*(der_count+2)/2.
            The evaluation results are stored in this array.

              P = v[0],...,v[m_dim-1]
              Ds = v[v_stride],...
              Dt = v[2*v_stride],...
              Dss = v[3*v_stride],...
              Dst = v[4*v_stride],...
              Dtt = v[5*v_stride],...

            In general, Ds^i Dt^j is returned in v[n],...,v[n+m_dim-1], where

              n = v_stride*( (i+j)*(i+j+1)/2 + j).

Returns:
  True if succcessful.
See Also:
  ON_NurbsSurface::Evaluate
  ON_EvaluateNurbsSpan
  ON_EvaluateNurbsCageSpan
*/
ON_DECL
bool ON_EvaluateNurbsSurfaceSpan(
        int dim,
        int is_rat,
        int order0, 
        int order1,
        const double* knot0,
        const double* knot1,
        int cv_stride0,
        int cv_stride1,
        const double* cv,
        int der_count,
        double s,
        double t,
        int v_stride,
        double* v
        );
            


/*
Description:
  Evaluate a NURBS cage trispan.
Parameters:
  dim - [in] >0
  is_rat - [in] true of false
  order0 - [in] >= 2
  order1 - [in] >= 2
  order2 - [in] >= 2
  knot0 - [in] 
    NURBS knot vector with 2*(order0-1) knots, knot0[order0-2] != knot0[order0-1]
  knot1 - [in]
    NURBS knot vector with 2*(order1-1) knots, knot1[order1-2] != knot1[order1-1]
  knot2 - [in]
    NURBS knot vector with 2*(order1-1) knots, knot2[order2-2] != knot2[order2-1]
  cv_stride0 - [in]
  cv_stride1 - [in]
  cv_stride2 - [in]
  cv - [in]
    For 0 <= i < order0, 0 <= j < order1, and 0 <= k < order2, 
    the (i,j,k)-th control vertex is

          cv[n],...,cv[n+(is_rat?dim:dim+1)], 

    where n = i*cv_stride0 + j*cv_stride1 *k*cv_stride2.  
    If is_rat is true the cv is in homogeneous form.
   
  der_count - [in] (>=0)
  r - [in]
  s - [in]
  t - [in] (r,s,t) is the evaluation parameter
  v_stride - [in] (>=dim)
  v - [out] An array of length v_stride*(der_count+1)*(der_count+2)*(der_count+3)/6.
            The evaluation results are stored in this array.

              P = v[0],...,v[m_dim-1]
              Dr = v[v_stride],...
              Ds = v[2*v_stride],...
              Dt = v[3*v_stride],...
              Drr = v[4*v_stride],...
              Drs = v[5*v_stride],...
              Drt = v[6*v_stride],...
              Dss = v[7*v_stride],...
              Dst = v[8*v_stride],...
              Dtt = v[9*v_stride],...

            In general, Dr^i Ds^j Dt^k is returned in v[n],...,v[n+dim-1], where

               d = (i+j+k)
               n = v_stride*( d*(d+1)*(d+2)/6 + (j+k)*(j+k+1)/2 + k) 

Returns:
  True if succcessful.
See Also:
  ON_NurbsCage::Evaluate
  ON_EvaluateNurbsSpan
  ON_EvaluateNurbsSurfaceSpan
*/
ON_DECL
bool ON_EvaluateNurbsCageSpan(
        int dim,
        int is_rat,
        int order0, int order1, int order2,
        const double* knot0,
        const double* knot1,
        const double* knot2,
        int cv_stride0, int cv_stride1, int cv_stride2,
        const double* cv,
        int der_count,
        double t0, double t1, double t2,
        int v_stride, 
        double* v
        );


ON_DECL
bool ON_EvaluateNurbsDeBoor( // for expert users only - no support available
        int,            // cv_dim ( dim+1 for rational cvs )
        int,            // order (>=2)
        int,            // cv_stride (>=cv_dim)
        double*,        // cv array - values changed to result of applying De Boor's algorithm
        const double*,  // knot array
        int,            // side,
                        //    -1  return left side of B-spline span in cv array
                        //    +1  return right side of B-spline span in cv array
                        //    -2  return left side of B-spline span in cv array
                        //        Ignore values of knots[0,...,order-3] and assume
                        //        left end of span has a fully multiple knot with
                        //        value "mult_k".
                        //    +2  return right side of B-spline span in cv array
                        //        Ignore values of knots[order,...,2*order-2] and
                        //        assume right end of span has a fully multiple
                        //        knot with value "mult_k".
        double,         // mult_k - used when side is +2 or -2.  See above for usage.
        double          // t
                        //    If side < 0, then the cv's for the portion of the NURB span to
                        //    the LEFT of t are computed.  If side > 0, then the cv's for the
                        //    portion the span to the RIGHT of t are computed.  The following
                        //    table summarizes the restrictions on t:
                        //
                        //     value of side         condition t must satisfy
                        //        -2                    mult_k < t and mult_k < knots[order-1]
                        //        -1                    knots[order-2] < t
                        //        +1                    t < knots[order-1]
                        //        +2                    t < mult_k and knots[order-2] < mult_k
        );


ON_DECL
bool ON_EvaluateNurbsBlossom(int, // cvdim,
                             int, // order, 
                             int, // cv_stride,
                             const double*, //CV, size cv_stride*order
                             const double*, //knot, nondecreasing, size 2*(order-1)
                             // knot[order-2] != knot[order-1]
                             const double*, //t, input parameters size order-1
                             double* // P

                             // DeBoor algorithm with different input at each step.
                             // returns false for bad input.
                            );


ON_DECL
void ON_ConvertNurbSpanToBezier(
        int,       // cvdim (dim+1 for rational curves)
        int,       // order, 
        int,       // cvstride (>=cvdim)
        double*,   // cv array - input has NURBS cvs, output has Bezier cvs
        const double*, // (2*order-2) knots for the NURBS span
        double,        // t0, NURBS span parameter of start point
        double         // t1, NURBS span parameter of end point
        );
#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(ON_TEXTLOG_INC_)
#define ON_TEXTLOG_INC_

class ON_CLASS ON_TextLog
{
public:
  /*
  Description:
    Create a text log that dumps to the virtual function
    void ON_TextLog::AppendText().
  */
  ON_TextLog();

  /*
  Description:
    Create a text log that dumps to an ASCII file.
  Parameters:
    fp - [in] Pointer to an open ASCII text file.  The file
              pointer must remain valid as long as the text
              log is in use.
  */
  ON_TextLog( FILE* fp); // dump to open ASCII text file

  /*
  Description:
    Create a text log that dumps to a string.
  Parameters:
    s - [in] String that must exist as long as
             the text log is in use.
  */
  ON_TextLog( ON_wString& s );

  virtual ~ON_TextLog();

  void SetDoubleFormat( const char* ); // default is %g
  void GetDoubleFormat( ON_String& ) const;

  void SetFloatFormat( const char* ); // default is %g
  void GetFloatFormat( ON_String& ) const;

  void PushIndent();
  void PopIndent();
  int IndentSize() const; //  0: one tab per indent
                          // >0: number of spaces per indent
  void SetIndentSize(int);
  
  void PrintWrappedText( const char*, int = 60 );    // last arg is maximum line length
  void PrintWrappedText( const wchar_t*, int = 60 ); // last arg is maximum line length

  /*
  Description:
    Print a formatted ASCII string of up to 2000 characters.
  Parameters:
    format - [in] NULL terminated format control string 
  Remarks:
    To print strings longer than 2000 characters, you must
    use ON_TextLog::PrintString.
  See Also:
    ON_TextLog::PrintString
  */
  void Print( const char* format, ... );

  /*
  Description:
    Print a formatted INICODE string of up to 2000 characters.
  Parameters:
    format - [in] NULL terminated format control string 
  Remarks:
    To print strings longer than 2000 characters, you must
    use ON_TextLog::PrintString.
  See Also:
    ON_TextLog::PrintString
  */
  void Print( const wchar_t* format, ... );

  void Print( float );
  void Print( double );
  void Print( const ON_2dPoint& );
  void Print( const ON_3dPoint& );
  void Print( const ON_4dPoint& );
  void Print( const ON_2dVector& );
  void Print( const ON_3dVector& );
  void Print( const ON_Xform& );
  void Print( const ON_UUID& );
  void Print( const ON_COMPONENT_INDEX& );

  /*
  Description:
    Print an unformatted UNICODE string of any length.
  Parameters:
    string - [in]
  */
  void Print( const ON_wString& string );

  /*
  Description:
    Print an unformatted ASCII string of any length.
  Parameters:
    string - [in]
  */
  void Print( const ON_String& string );

  void Print( const ON_3dPointArray&, const char* = NULL );
  void Print( 
         const ON_Matrix&, 
         const char* = NULL, // optional preamble
         int = 0             // optional number precision
    );

  // printing utilities
  /*
  Description:
    Same as calling Print("\n");
  */
  void PrintNewLine();

  /*
  Description:
    Print an unformatted ASCII string of any length.
  Parameters:
    s - [in] NULL terminated ASCII string.
  */
  void PrintString( const char* s );

  /*
  Description:
    Print an unformatted UNICODE string of any length.
  Parameters:
    s - [in] NULL terminated UNICODE string.
  */
  void PrintString( const wchar_t* s );

  void PrintRGB( const ON_Color& );

  void PrintTime( const struct tm& );

  void PrintPointList( 
    int,               // dim
    ON_BOOL32,              // true for rational points
    int,               // count
    int,               // stride
    const double*,     // point[] array
    const char* = NULL // optional preabmle
    );

  void PrintPointGrid( 
    int,               // dim
    ON_BOOL32,              // true for rational points
    int, int,          // point_count0, point_count1
    int, int,          // point_stride0, point_stride1
    const double*,     // point[] array
    const char* = NULL // optional preabmle
    );
    
  void PrintKnotVector( 
    int,             // order
    int,             // cv_count
    const double*    // knot[] array
    );

  ON_TextLog& operator<<( const char* );
  ON_TextLog& operator<<( char );
  ON_TextLog& operator<<( short );
  ON_TextLog& operator<<( int );
  ON_TextLog& operator<<( float );
  ON_TextLog& operator<<( double );
  ON_TextLog& operator<<( const ON_2dPoint& );
  ON_TextLog& operator<<( const ON_3dPoint& );
  ON_TextLog& operator<<( const ON_4dPoint& );
  ON_TextLog& operator<<( const ON_2dVector& );
  ON_TextLog& operator<<( const ON_3dVector& );
  ON_TextLog& operator<<( const ON_Xform& );

protected:
  FILE* m_pFile;
  ON_wString* m_pString;

  
  /*
  Description:
    If the ON_TextLog(ON_wString& wstr) constructor was used, the
    default appends s to wstr.  If the ON_TextLog(FILE* fp) 
    constructor was used, the default calls fputs( fp, s).
    In all other cases, the default calls printf("%s",s).
  Parameters:
    s - [in];
  */
  virtual
  void AppendText(
        const char* s
        );

  /*
  Description:
    If the ON_TextLog(ON_wString& wstr) constructor was used, the
    default appends s to wstr.  In all other cases, the default 
    converts the string to an ON_String and calls the ASCII
    version AppendText(const char*).
  Parameters:
    s - [in];
  */
  virtual
  void AppendText(
        const wchar_t* s
        );
                  
private:
  ON_String m_indent;
  ON_String m_double_format;
  ON_String m_double2_format;
  ON_String m_double3_format;
  ON_String m_double4_format;
  ON_String m_float_format;
  ON_String m_float2_format;
  ON_String m_float3_format;
  ON_String m_float4_format;

  ON_String m_line;

  int m_beginning_of_line; // 0
  int m_indent_size;       // 0 use tabs, > 0 = number of spaces per indent level

private:
  // no implementation
  ON_TextLog( const ON_TextLog& );
  ON_TextLog& operator=( const ON_TextLog& );

};


#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_ZLIB_INC_)
#define OPENNURBS_ZLIB_INC_

// If you are using opennurbs as a statically linked library, then
// you may make calls to the same zlib that opennurbs uses.  This
// zlib is compiled with z_ symbol projectection.  All the necessary
// header files are included by opennurbs.h.
// 
// If you are using opennurbs as a DLL or writing a Rhino plug-in
// and you want to use the same zlib that opennurbs uses, then
// compile opennurbs_zlib_memory.cpp into your application
// and statically link with the zlib library. All the necessary
// header files are included by opennurbs.h.


/*#if !defined(Z_PREFIX)*/
/* decorates zlib functions with a "z_" prefix to prevent symbol collision. */
/*#define Z_PREFIX*/
/*#endif*/

#if !defined(MY_ZCALLOC)
/* have zlib use oncalloc() and onfree() for memory managment*/
#define MY_ZCALLOC
#endif

#include <zlib.h>

#if defined(WIN32) && defined(WIN64)
/* zlib.h includes zconf.h which defines WIN32 */
#undef WIN32
#endif

ON_BEGIN_EXTERNC
voidpf zcalloc (voidpf, unsigned, unsigned);
void  zcfree (voidpf, voidpf);
ON_END_EXTERNC

class ON_CLASS ON_CompressedBuffer
{
public:
  ON_CompressedBuffer();
  ~ON_CompressedBuffer();
  ON_CompressedBuffer(const ON_CompressedBuffer& src);
  ON_CompressedBuffer& operator=(const ON_CompressedBuffer& src);

  /*
  Description:
    Compress inbuffer.
  Parameters:
    sizeof__inbuffer - [in]
       Number of bytes in inbuffer.
    inbuffer - [in]
       Uncompressed information.
    sizeof_element - [out]
       This parameter only matters if the buffer will be compressed,
       and decompressed on CPUs with different endianness.  If this
       is the case, then the types in the buffer need to have the
       same size (2,4, or 8).  
  Returns:
    True if inbuffer is successfully compressed.
  */
  bool Compress(
          size_t sizeof__inbuffer,  // sizeof uncompressed input data
          const void* inbuffer,     // uncompressed input data
          int sizeof_element
          );

  /*
  Description:
    Uncompress the contents of this ON_CompressedBuffer.
  Parameters:
    outbuffer - [in/out]
       This buffer must have at least SizeOfUncompressedBuffer() bytes.
       If the function returns true, then the uncopressed information
       is stored in this buffer.
    bFailedCRC - [out]
       If not null, then this boolean is set to true if the CRC 
       of the uncompressed information has changed.
  Returns:
    True if uncompressed information is returned in outbuffer.
  */
  bool Uncompress( // read and uncompress
          void* outbuffer,           // uncompressed output data returned here
          int* bFailedCRC
          ) const;

  /*
  Description:
    Destroy the current informtion in the ON_CompressedBuffer 
    so the class can be reused.
  */
  void Destroy();

  bool Write( ON_BinaryArchive& binary_archive ) const;
  bool Read( ON_BinaryArchive& binary_archive );

  /////////////////////////////////////////////////
  //
  // Implementation
  //
  bool CompressionInit( struct ON_CompressedBufferHelper* ) const;
  bool CompressionEnd( struct ON_CompressedBufferHelper* ) const;
  size_t DeflateHelper( // returns number of bytes written
        struct ON_CompressedBufferHelper*,
        size_t sizeof___inbuffer,  // sizeof uncompressed input data ( > 0 )
        const void* in___buffer     // uncompressed input data ( != NULL )
        );
  bool InflateHelper(
        struct ON_CompressedBufferHelper*,
        size_t sizeof___outbuffer,  // sizeof uncompressed data
        void* out___buffer          // buffer for uncompressed data
        ) const;
  bool WriteChar( 
        size_t count, 
        const void* buffer 
        );

  size_t     m_sizeof_uncompressed;
  size_t     m_sizeof_compressed;
  ON__UINT32 m_crc_uncompressed;
  ON__UINT32 m_crc_compressed;
  int        m_method; // 0 = copied, 1 = compressed
  int        m_sizeof_element;
  size_t     m_buffer_compressed_capacity;
  void*      m_buffer_compressed;
};

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_RTREE_INC_)
#define OPENNURBS_RTREE_INC_

/*
The opennurbs rtree code is a modifed version of the
free and unrestricted R-tree implementation obtianed from 
http://www.superliminal.com/sources/sources.htm

The first lines on the website indicate the code is free and unrestricted:

  Free Source Code
  Here are a few useful bits of free source code. 
  You're completely free to use them for any purpose whatsoever.
  All I ask is that if you find one to be particularly valuable, 
  then consider sending feedback. Please send bugs and suggestions too. 
  Enjoy 

The readme.txt file included with the R-tree source says

  LICENSE:
    Entirely free for all uses. Enjoy!

The original authors are 

AUTHORS
 * 1983 Original algorithm and test code by Antonin Guttman and Michael Stonebraker, UC Berkely
 * 1994 ANCI C ported from original test code by Melinda Green - melinda@superliminal.com
 * 1995 Sphere volume fix for degeneracy problem submitted by Paul Brook
 * 2004 Templated C++ port by Greg Douglas

The opennurbs version adds some custom memory allocation and replaces
the leaf iterator.  The rest of the changes are cosmetic.

*/



// Minimum and maximum number of elements 
// in ON_RTreeNode::m_branch[].
// must have ON_RTree_MAX_NODE_COUNT > ON_RTree_MIN_NODE_COUNT
#define ON_RTree_MIN_NODE_COUNT 2
#define ON_RTree_MAX_NODE_COUNT 6

/*
In a test of a sphere mesh with mesh: 8385 vertices, 8192 polygons
and ON_RTree_MAX_NODE_COUNT = 3, 4, 5, and 6, the memory use was 
most efficient with ON_RTree_MAX_NODE_COUNT=6

Memory Usage MAX_NODE_COUNT = 3
  ON_RTree: 1212 KB (1241136) (352 wasted)
  ON_RTree: 7036 nodes, 5881 unused branches (321 KB) 0.835844 per node

Memory Usage MAX_NODE_COUNT = 4
  ON_RTree: 1152 KB (1179720) (5568 wasted)
  ON_RTree: 5051 nodes, 6962 unused branches (380 KB) 1.37834 per node

Memory Usage MAX_NODE_COUNT = 5
  ON_RTree: 1040 KB (1065504) (11808 wasted)
  ON_RTree: 3655 nodes, 6429 unused branches (351 KB) 1.75896 per node

Memory Usage MAX_NODE_COUNT = 6
  ON_RTree:  995 KB (1019592) (3440 wasted)
  ON_RTree: 2951 nodes, 6564 unused branches (358 KB) 2.22433 per node
*/

// This struct is used instead of ON_BoundingBox to avoid calling
// constructors.
struct ON_RTreeBBox
{
  double m_min[3];
  double m_max[3];
};

struct ON_RTreeSphere
{
  double m_point[3];
  double m_radius;
};

struct ON_RTreeCapsule
{
  double m_point[2][3];
  double m_radius;
  double m_domain[2];
};

struct ON_RTreeBranch
{
  ON_RTreeBBox m_rect;

  // If ON_RTreeNode.m_level > 0, then m_child points to a child node.
  // If ON_RTreeNode.m_level == 0, then m_id identifies the leaf element.
  union
  {
    struct ON_RTreeNode* m_child;
    ON__INT_PTR m_id;
  };
};

struct ON_RTreeLeaf
{
  ON_RTreeBBox m_rect;
  ON__INT_PTR m_id;
};

// The ON_RTreeNode is used at root, branch and leaf nodes.
// When m_level > 0, the node is a branch.
// When m_level = 0, the node is a leaf.
struct ON_RTreeNode
{
  inline bool IsInternalNode() const
    { return (m_level > 0); }  // internal nodes have m_level > 0
  inline bool IsLeaf() const
    { return (m_level == 0); } // branch nodes have m_level = 0

  // m_level must be a signed int to insure signed compares work correctly
  int m_level;  // =0 at leaf nodes, > 0 at branch nodes

  // The m_branch[] array contains m_count elements
  // 0 <= m_count <= ON_RTree_MAX_NODE_COUNT
  // m_count must be a signed int to insure signed compares work correctly
  int m_count; 
  ON_RTreeBranch m_branch[ON_RTree_MAX_NODE_COUNT];
};

struct ON_RTreeSearchResult
{
  int m_capacity;   // m_id[] array capacity (search terminates when m_count == m_capacity)
  int m_count;      // number of elements in m_id[]
  ON__INT_PTR* m_id; // m_id[] = array of search results.
};

class ON_CLASS ON_RTreeMemPool
{
public:
  ON_RTreeMemPool( ON_MEMORY_POOL* heap, size_t leaf_count );
  ~ON_RTreeMemPool();

  ON_RTreeNode* AllocNode();
  void FreeNode(ON_RTreeNode* node);

  struct ON_RTreeListNode* AllocListNode();
  void FreeListNode(struct ON_RTreeListNode* list_node);

  void DeallocateAll();

  /*
  Returns:
    Total number of bytes of heap memory allocated.
  */
  size_t SizeOf() const;

  /*
  Returns:
    Number of bytes of heap memory not currently in use.
  */
  size_t SizeOfUnusedBuffer() const;

private:
  void GrowBuffer();

  struct Blk
  {
    struct Blk* m_next;
  };

  // linked list of unused ON_RTreeNode 
  struct Blk* m_nodes;
  // linked list of unused ON_RTreeListNode
  struct Blk* m_list_nodes;

  // buffer for new allocations
  unsigned char* m_buffer;
  size_t m_buffer_capacity;

  struct Blk* m_blk_list;   // linked list used to free all allocated memory
  size_t m_sizeof_blk;      // total amount of memory in each block.

  ON_MEMORY_POOL* m_heap;
  size_t m_sizeof_heap; // total amount of heap memory in this rtree
};

////////////////////////////////////////////////////////////////
//
// ON_RTreeIterator
//
//   The ON_RTreeIterator class can be used to iterate each leaf 
//   in an ON_RTree.
//
class ON_CLASS ON_RTreeIterator
{
public:
  /*
  Description:
    Construct an empty iterator.  Call Initialize() to attach
    the iterator to an R-tree.
  Remark:
    Any calls to ON_RTree::Insert() or ON_RTree::Remove() that modify
    an R-tree being iterated invalidate the iterator.  The iterator
    must be re-initialized before being used again.

    There is no connection between the order elements are inserted
    in an R-tree and the order the elements are iterated by an
    iterator.    
  */
  ON_RTreeIterator();
  ON_RTreeIterator(const class ON_RTree& a_rtree);

  ~ON_RTreeIterator();

  /*
  Description:
    Initialize an iterator to iterate every leaf in the rtree.
  Parameters:
    a_rtree - [in]
      R-tree to iterate
  Example:
    See the comment for ON_RTreeIterator::First().
  Returns:
    True if a_rtree has at least one element.
  Remarks:
    Any calls to ON_RTree::Insert() or ON_RTree::Remove() that modify
    this node or its children will invalidate this iterator and it
    must be re-initialized.

    There is no connection between the order elements are inserted
    in an R-tree and the order the elements are iterated by an
    iterator.    
  */
  bool Initialize(const class ON_RTree& a_rtree);

  /*
  Description:
    Initialize an iterator to iterate every leaf on or below a_node.
  Parameters:
    a_node - [in]
      R-tree node to iterate
  Example:
    See the comment for ON_RTreeIterator::First().
  Returns:
    True if a_node has at least one element.
  Remarks:
    Any calls to ON_RTree::Insert() or ON_RTree::Remove() that modify
    this node or its children will invalidate this iterator and it
    must be re-initialized.

    There is no connection between the order elements are inserted
    in an R-tree and the order the elements are iterated by an
    iterator.    
  */
  bool Initialize(const struct ON_RTreeNode* a_node);

  /*
  Description:
    Get the value of the current leaf element. Calling Value()
    does not increment or decrement the iterator.
  Example:
    See the comment for ON_RTreeIterator::First().
  Return:
    Null pointer if there are no more leaves to iterate
    A pointer to the current R-tree leaf.  When there are no more leaves,
    the returned pointer is null.
  */
  const ON_RTreeBranch* Value() const;

  /*
  Description:
    Reset the iterator so the current leaf is the first leaf in
    the R-tree.  The Initialize() functions automatically do
    this, but First() can be called if an iterator needs to be
    used more than once or to make code easy to read and understand.
  Example:
    Iterate every leaf in an R-tree.

          ON_RTree rtree;
          ...
          ON_RtreeIterator rit(rtree);
          const ON_RTreeBranch* rtree_leaf;
          for ( rit.First(); 0 != (rtree_leaf = rit.Value()); rit.Next() )
          {
            // leaf id           = rtree_leaf->m_id
            // leaf bounding box = rtree->m_rect
          }

  Returns:
    True if a call to Value() will return a non-null pointer.
  See Also:
    ON_RTreeIterator::Last();
  */
  bool First();

  /*
  Description:
    Increment the iterator to the next leaf in the R-tree.
  Example:
    See the comment for ON_RTreeIterator::First()
  Returns:
    True if a call to Value() will return a non-null pointer.
    False if there is not a next leaf and all susequent calls to
    Value() will return null.
  See Also:
    ON_RTreeIterator::Prev();
  */
  bool Next();


  /*
  Description:
    Set the iterator so the current leaf is the last leaf in the R-tree.

  Example:
    Iterate an R-tree in reverse order.

          ON_RTree rtree;
          ...
          ON_RTreeIterator rit(rtree);
          const ON_RTreeBranch* rtree_leaf;
          for ( rit.Last(); 0 != (rtree_leaf = rit.Value()); rit.Prev() )
          {
            // leaf id           = rtree_leaf->m_id
            // leaf bounding box = rtree->m_rect
          }

  Returns:
    True if a call to Value() will return a non-null pointer.
  See Also:
    ON_RTreeIterator::First();
  */
  bool Last();

  /*
  Description:
    Decrement the iterator to the previous leaf in the R-tree.
  Example:
    See the comment for ON_RTreeIterator::Last()
  Returns:
    True if a call to Value() will return a non-null pointer.
    False if there is not a previous leaf and all susequent calls to
    Value() will return null.
  See Also:
    ON_RTreeIterator::Next();
  */
  bool Prev();

private:
  enum { MAX_STACK = 32 }; //  Max stack size. Allows almost n^32 where n is number of branches in node
  
  struct StackElement
  {
    const struct ON_RTreeNode* m_node;
    int m_branchIndex; // must be a signed int to insure signed compares work correctly
  };

  bool PushChildren(struct StackElement* sp, bool bFirstChild);

  StackElement  m_stack[MAX_STACK]; // stack
  StackElement* m_sp;               // stack pointer (null or points into m_stack[])
  const ON_RTreeNode* m_root;       // root of tree being iterated
};


class ON_CLASS ON_RTree
{
public:
  ON_RTree( ON_MEMORY_POOL* heap = 0, size_t leaf_count = 0 );
  ~ON_RTree();

  /*
  Description:
    Create an R-tree with an element for each face in the mesh.
    The element id is set to the index of the face.
  Parameters:
    mesh - [in]
  Returns:
    True if successful.
  */
  bool CreateMeshFaceTree( const class ON_Mesh* mesh );
  
  /*
  Description:
    Insert an element into the RTree.
  Parameters:
    a_min - [in]
    a_max - [in]
      3d bounding box of the element.  The values in a_min[3] and a_max[3]
      must satisfy
      a_min[0] <= a_max[0], 
      a_min[1] <= a_max[1], and
      a_min[1] <= a_max[1].
    a_dataId - [in]
      id of the element.  This can be either a pointer or an integer id.
  Returns:
    True if element was successfully inserted.
  Remarks:
    Calling Insert() or Remove() invalidates any ON_RTreeIterator
    used to iterate this rtree. 
  */
  bool Insert(const double a_min[3], const double a_max[3], void* a_element_id);
  bool Insert(const double a_min[3], const double a_max[3], int a_element_id);
  bool Insert2d(const double a_min[2], const double a_max[2], void* a_element_id);
  bool Insert2d(const double a_min[2], const double a_max[2], int a_element_id);
  
  /*
  Description:
    Remove an element from the RTree.
  Parameters:
    a_min - [in]
    a_max - [in]
      3d bounding box of the element.  The values in a_min[3] and a_max[3]
      must satisfy
      a_min[0] <= a_max[0], 
      a_min[1] <= a_max[1], and
      a_min[2] <= a_max[2].
    a_dataId - [in]
      id of the element.  This can be either a pointer or an integer id.
  Returns:
    True if element was successfully removed.
  Remarks:
    Calling Insert() or Remove() invalidates any ON_RTreeIterator
    used to iterate this rtree. 
  */
  bool Remove(const double a_min[3], const double a_max[3], void* a_elementId);
  bool Remove(const double a_min[3], const double a_max[3], int a_elementId);
  bool Remove2d(const double a_min[2], const double a_max[2], void* a_elementId);
  bool Remove2d(const double a_min[2], const double a_max[2], int a_elementId);
  
  /*
  Description:
    Remove all elements from the R-tree.
  */
  void RemoveAll();

  /*
  Description:
    Search the R-tree for all elements whose bounding boxes overlap
    a_rect.
  Parameters:
    a_rect - [in/out]
      The version of search that has ON_RTreeBBox* a_rect as the first
      argument, allows you to shrink the a_rect as the search progresses.
      This is useful for doing things like searching for closest points.
      If you want to shrink a_rect, you must use a_context to pass it
      to the resultCallback function and shrink it in the resultCallback
      function. In the callback, the modified rect must be contained
      in the previous rect.
    a_sphere - [in/out]
      The version of search that has ON_RTreeSphere* a_sphere as the first
      argument, allows you to shrink the a_sphere as the search progresses.
      This is useful for doing things like searching for closest points.
      If you want to shrink a_sphere, you must use a_context to pass it
      to the resultCallback function and shrink it in the resultCallback
      function. In the callback, the modified sphere must be contained
      in the previous sphere.
    a_capsule - [in/out]
      The version of search that has ON_RTreeSphere* a_capsule as the first
      argument, allows you to shrink the a_capsule as the search progresses.
      This is useful for doing things like searching for closest points.
      If you want to shrink a_capsule, you must use a_context to pass it
      to the resultCallback function and shrink it in the resultCallback
      function. In the callback, the modified capsule must be contained
      in the previous capsule.
    a_min - [in]
    a_max - [in]
      (a_min,a_max) is the bounding box of the search region.
    a_results - [out]
      The ids of elements that overlaps the search region.
    resultCallback - [in]
      A function to call when leaf nodes overlap.
    a_context - [in]
      pointer passed to the resultCallback() function.
  Returns:
    True if entire tree was searched.  It is possible no results were found.
  Remarks:
    If you are using a Search() that uses a resultCallback() function,
    then return true to keep searching and false to terminate the search.
  */
  bool Search( 
    ON_RTreeSphere* a_sphere,
    bool ON_MSC_CDECL resultCallback(void* a_context, ON__INT_PTR a_id), 
    void* a_context
    ) const;

  bool Search( 
    ON_RTreeCapsule* a_capsule,
    bool ON_MSC_CDECL resultCallback(void* a_context, ON__INT_PTR a_id), 
    void* a_context
    ) const;

  bool Search( 
    ON_RTreeBBox* a_rect,
    bool ON_MSC_CDECL resultCallback(void* a_context, ON__INT_PTR a_id), 
    void* a_context
    ) const;

  /*
  Description:
    Search the R-tree for all elements whose bounding boxes overlap
    the set of points between to parallel planes.
  Parameters:
    a_plane_eqn - [in]
    a_min - [in]
    a_max - [in]
      The region between the parallel planes is the set point points
      where the value of the plane equation is >= a_min and <= a_max.
    resultCallback - [in]
      A function to call when leaf nodes overlap the region between
      the parallel planes.
    a_context - [in]
      pointer passed to the resultCallback() function.
  Returns:
    True if entire tree was searched.  It is possible no results were found.
  Remarks:
    If you are using a Search() that uses a resultCallback() function,
    then return true to keep searching and false to terminate the search.
  */
  bool Search(
    const double a_plane_eqn[4],
    double a_min,
    double a_max,
    bool ON_MSC_CDECL resultCallback(void* a_context, ON__INT_PTR a_id), 
    void* a_context
    ) const;

  bool Search(const double a_min[3], const double a_max[3],
    bool ON_MSC_CDECL resultCallback(void* a_context, ON__INT_PTR a_id), void* a_context 
    ) const;

	bool Search(const double a_min[3], const double a_max[3],
    ON_RTreeSearchResult& a_result 
    ) const;

	bool Search(const double a_min[3], const double a_max[3],
    ON_SimpleArray<ON_RTreeLeaf>& a_result 
    ) const;

  bool Search(const double a_min[3], const double a_max[3],
    ON_SimpleArray<void*>& a_result 
    ) const;

  bool Search(const double a_min[3], const double a_max[3],
    ON_SimpleArray<int>& a_result 
    ) const;

  bool Search2d(const double a_min[2], const double a_max[2],
    bool ON_MSC_CDECL resultCallback(void* a_context, ON__INT_PTR a_id), void* a_context
    ) const;

	bool Search2d(const double a_min[2], const double a_max[2],
    ON_RTreeSearchResult& a_result
    ) const;

	bool Search2d(const double a_min[2], const double a_max[2],
    ON_SimpleArray<ON_RTreeLeaf>& a_result
    ) const;

  bool Search2d(const double a_min[2], const double a_max[2],
    ON_SimpleArray<void*>& a_result
    ) const;

  bool Search2d(const double a_min[2], const double a_max[2],
    ON_SimpleArray<int>& a_result
    ) const;

  /*
  Description:
    Search two R-trees for all pairs elements whose bounding boxes overlap.
  Parameters:
    a_rtreeA - [in]
    a_rtreeB - [in]
    tolerance - [in]
      If the distance between a pair of bounding boxes is <= tolerance, 
      then the pair is added to a_result[].
    a_result - [out]
      Pairs of ids of elements who bounding boxes overlap.
  Returns:
    True if entire tree was searched.  It is possible no results were found.
  */
  static bool Search( 
          const ON_RTree& a_rtreeA,
          const ON_RTree& a_rtreeB, 
          double tolerance,
          ON_SimpleArray<ON_2dex>& a_result
          );

  /*
  Description:
    Search two R-trees for all pairs elements whose bounding boxes overlap.
  Parameters:
    a_rtreeA - [in]
    a_rtreeB - [in]
    tolerance - [in]
      If the distance between a pair of bounding boxes is <= tolerance, 
      then resultCallback() is called.
    resultCallback - [out]
      callback function
    a_context - [in] argument passed through to resultCallback().
  Returns:
    True if entire tree was searched.  It is possible no results were found.
  */
  static bool Search( 
          const ON_RTree& a_rtreeA,
          const ON_RTree& a_rtreeB, 
          double tolerance,
          void ON_MSC_CDECL resultCallback(void* a_context, ON__INT_PTR a_idA, ON__INT_PTR a_idB),
          void* a_context
          );

  /*
  Description:
    Search two R-trees for all pairs elements whose bounding boxes overlap.
  Parameters:
    a_rtreeA - [in]
    a_rtreeB - [in]
    tolerance - [in]
      If the distance between a pair of bounding boxes is <= tolerance, 
      then resultCallback() is called.
    resultCallback - [out]
      callback function
      Return true for the search to continue and false to terminate the search.
    a_context - [in] argument passed through to resultCallback().
  Returns:
    True if entire tree was searched.  It is possible no results were found.
  */
  static bool Search( 
          const ON_RTree& a_rtreeA,
          const ON_RTree& a_rtreeB, 
          double tolerance,
          bool ON_MSC_CDECL resultCallback(void* a_context, ON__INT_PTR a_idA, ON__INT_PTR a_idB),
          void* a_context
          );
  /*
  Returns:
    Number of elements (leaves).
  Remark:
    No internal count is maintained, so this function traverses the 
    tree to count the leaves.  If efficiency is important, save the
    result.
  */
  int ElementCount();

  /*
  Returns:
    Pointer to the root node.
  */
  const ON_RTreeNode* Root() const;
  
  /*
  Returns:
    Bounding box of the entire R-tree;
  */
  ON_BoundingBox BoundingBox() const;

  /*
  Returns:
    Number of bytes of heap memory used by this R-tree.
  */
  size_t SizeOf() const;

private:
  void SplitNode(ON_RTreeNode*, ON_RTreeBranch*, ON_RTreeNode**);
  bool AddBranch(ON_RTreeBranch*, ON_RTreeNode*, ON_RTreeNode**);
  bool InsertRectRec(ON_RTreeBBox*, ON__INT_PTR, ON_RTreeNode*, ON_RTreeNode**, int);
  bool InsertRect(ON_RTreeBBox*, ON__INT_PTR, ON_RTreeNode**, int);
  void LoadNodes(ON_RTreeNode*, ON_RTreeNode*, struct ON_RTreePartitionVars*);
  bool RemoveRect(ON_RTreeBBox*, ON__INT_PTR, ON_RTreeNode**);
  bool RemoveRectRec(ON_RTreeBBox*, ON__INT_PTR, ON_RTreeNode*, struct ON_RTreeListNode**);
  void ReInsert(ON_RTreeNode*, struct ON_RTreeListNode**);
  void RemoveAllRec(ON_RTreeNode*);
  ON_RTreeNode* m_root;
  size_t m_reserved;
  ON_RTreeMemPool m_mem_pool;
};

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_MAPPING_CHANNEL_INC_)
#define OPENNURBS_MAPPING_CHANNEL_INC_

///////////////////////////////////////////////////////////////////////////////
//
// Class ON_MappingChannel
// 
// Description:
//   ON_3dmObjectAttributes uses ON_MappingChannel to record 
//   which texture mapping function to use when applying a texture
//   with a matching mapping channel id.
//   When an object is rendered, if the material has textures and
//   ON_Texture::m_mapping_channel_id = ON_MappingChannel::m_mapping_channel_id,
//   then the mapping with id m_mapping_id is used to map the texture.
//   Otherwise, the mesh m_T[] texture coordinates are used to
//   apply the texture.
//
class ON_CLASS ON_MappingChannel
{
public:
  ON_MappingChannel();
  void Default();
  int Compare( const ON_MappingChannel& other ) const;
  bool Write( ON_BinaryArchive& archive ) const;
  bool Read( ON_BinaryArchive& archive );

  ON_UUID m_mapping_id;  // Identifies an ON_TextureMapping

  // RUNTIME textrure mapping table index.
  // If -1, it needs to be set.  This value is not saved int files.
  int m_mapping_index;

  // ON_Texture's with a matching m_mapping_channel_id value
  // use the mapping identified by m_mapping_id.  This id
  // must be > 0 and <= 2147483647 (0x7FFFFFFF)
  int m_mapping_channel_id;

  // The default value of m_object_xform is the identity.
  // When an object that uses this mapping is transformed
  // by "T", m_object_xform is updated using the formula
  // m_object_xform = T*m_object_xform.  If texture coordinates
  // are lost and need to be recalculated and m_object_xform
  // is not the identity, then m_object_xform should be passed
  // to ON_TextureMapping::Evaluate() as the mesh_xform parameter.
  // When validating mapping coordinates, m_object_xform itself 
  // be passed to HasMatchingTextureCoordinates() as the
  // object_transform parameter.
  ON_Xform m_object_xform;
};

#if defined(ON_DLL_TEMPLATE)
// This stuff is here because of a limitation in the way Microsoft
// handles templates and DLLs.  See Microsoft's knowledge base 
// article ID Q168958 for details.
#pragma warning( push )
#pragma warning( disable : 4231 )
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_MappingChannel>;
#pragma warning( pop )
#endif

///////////////////////////////////////////////////////////////////////////////
//
// Class ON_MaterialRef
// 
// Description:
//   ON_3dmObjectAttributes uses ON_MaterialRef to record which
//   rendering material and mappings a rendering plug-in wants to 
//   use.  This allows different rendering plug-ins to have different 
//   materials on the same object.  The values of
//   ON_3dmObjectAttributes.m_material_index and 
//   ON_3dmObjectAttributes.m_matrial_source reflect the settings
//   of the renderer that is currently active.
//

class ON_CLASS ON_MappingRef
{
public:
  ON_MappingRef();
  void Default();
  int Compare( const ON_MappingRef& other ) const;
  bool Write( ON_BinaryArchive& archive ) const;
  bool Read( ON_BinaryArchive& archive );

  bool IsValid( ON_TextLog* text_log ) const;


  bool Transform( const ON_Xform& xform );

  ON_UUID m_plugin_id;   // Identifies a rendering plugin

  /*
  Parameters:
    mapping_channel_id - [in]
    mapping_id - [in]
      ON_TextureMapping id
  Returns:
    A pointer to the plug-in's mapping channel, if there
    is one. Otherwise NULL is returned.
  */
  const ON_MappingChannel* MappingChannel( 
    int mapping_channel_id
    ) const;

  const ON_MappingChannel* MappingChannel( 
    const ON_UUID& mapping_id
    ) const;


  /*
  Parameters:
    mapping_channel_id - [in]
    mapping_id - [in]
      ON_TextureMapping id
  Returns:
    True if the mapping channel was added or a pefect
    match already existed.  False if a mapping channel 
    with a different mapping_id already exists for this
    plug-in and channel.
  */
  bool AddMappingChannel(
    int mapping_channel_id,
    const ON_UUID& mapping_id
    );

  /*
  Parameters:
    mapping_channel_id - [in]
    mapping_id - [in]
      ON_TextureMapping id
  Returns:
    True if a matching mapping channel was deleted.
  */
  bool DeleteMappingChannel(
    int mapping_channel_id
    );

  bool DeleteMappingChannel(
    const ON_UUID& mapping_id
    );

  /*
  Parameters:
    old_mapping_channel_id - [in]
    new_mapping_channel_id - [in]
  Returns:
    True if a matching mapping channel was found and changed.
  */
  bool ChangeMappingChannel(
    int old_mapping_channel_id,
    int new_mapping_channel_id
    );

  // Use AddMappingChannel() if you  want to add an 
  // element to this array.
  //
  // Every mapping channel in this array must have
  // a distinct value of ON_MappingChannel.m_mapping_channel_id
  ON_SimpleArray<ON_MappingChannel> m_mapping_channels;
};

class ON_CLASS ON_MaterialRef
{
public:
  // If m_material_id = ON_MaterialRef::material_from_layer,
  // then the object's layer determine the material.
  // See ON::material_from_layer.
  //static const ON_UUID material_from_layer; // TOD0 - remove this

  // If m_material_id = ON_MaterialRef::material_from_layer,
  // then the object's parent determine the material.
  // See ON::material_from_parent.
  //static const ON_UUID material_from_parent; // TODO - remove this

  ON_MaterialRef();
  void Default();
  int Compare( const ON_MaterialRef& other ) const;
  bool Write( ON_BinaryArchive& archive ) const;
  bool Read( ON_BinaryArchive& archive );

  ON_UUID m_plugin_id;   // Identifies a rendering plugin

  ON_UUID m_material_id; // Identifies an ON_Material
  
  // If nil, then m_material_id is used for front and back faces
  ON_UUID m_material_backface_id; // Identifies an ON_Material

  ON::object_material_source MaterialSource() const;
  unsigned char m_material_source; // ON::object_material_source values
  unsigned char m_reserved1;
  unsigned char m_reserved2;
  unsigned char m_reserved3;

  // RUNTIME material table index for m_material_id.
  // This value is not saved in files.  If -1, then it
  // needs to be set.
  int m_material_index;

  // RUNTIME material table index for m_material_id.
  // This value is not saved in files.  If -1, then it
  // needs to be set.
  int m_material_backface_index;
};

#if defined(ON_DLL_TEMPLATE)
// This stuff is here because of a limitation in the way Microsoft
// handles templates and DLLs.  See Microsoft's knowledge base 
// article ID Q168958 for details.
#pragma warning( push )
#pragma warning( disable : 4231 )
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ON_MaterialRef>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ON_MappingRef>;
#pragma warning( pop )
#endif

#endif


/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_RENDERING_INC_)
#define OPENNURBS_RENDERING_INC_


class ON_CLASS ON_RenderingAttributes
{
public:
  ON_RenderingAttributes();
  void Default();
  int Compare( const ON_RenderingAttributes& other ) const;
  bool Write( ON_BinaryArchive& archive ) const;
  bool Read( ON_BinaryArchive& archive );

  bool IsValid( ON_TextLog* text_log ) const;


  const ON_MaterialRef* MaterialRef( const ON_UUID& plugin_id ) const;

  ON_ClassArray<ON_MaterialRef> m_materials;
};

class ON_CLASS ON_ObjectRenderingAttributes : public ON_RenderingAttributes
{
public:
  ON_ObjectRenderingAttributes();
  void Default();
  int Compare( const ON_ObjectRenderingAttributes& other ) const;
  bool Write( ON_BinaryArchive& archive ) const;
  bool Read( ON_BinaryArchive& archive );

  bool IsValid( ON_TextLog* text_log ) const;

  /*
  Description:
    Update mapping channel transformations.
  Parameters:
    xform - [in]
      Transformation applied to parent object.
  Returns:
    True is successful.  False if there are mapping channels
    and xform cannot be inverted.
  */
  bool Transform( const ON_Xform& xform );

  /*
  Parameters:
    plugin_id - [in]
  Returns:
    A pointer to the plug-in's mapping reference, if there
    is one. Otherwise NULL is returned.
  */
  const ON_MappingRef* MappingRef( 
    const ON_UUID& plugin_id 
    ) const;

  /*
  Parameters:
    plugin_id - [in]
  Returns:
    If a mapping ref exists, it is returned.  Otherwise
    one is added.
  */
  ON_MappingRef* AddMappingRef( 
    const ON_UUID& plugin_id 
    );

  /*
  Parameters:
    plugin_id - [in]
  Returns:
    If a mapping ref exists, it is returned.  Otherwise
    one is added.
  */
  bool DeleteMappingRef( 
    const ON_UUID& plugin_id 
    );


  /*
  Parameters:
    plugin_id - [in]
    mapping_channel_id - [in]
    mapping_id - [in]
      ON_TextureMapping id
  Returns:
    A pointer to the plug-in's mapping channel, if there
    is one. Otherwise NULL is returned.
  */
  const ON_MappingChannel* MappingChannel( 
    const ON_UUID& plugin_id, 
    int mapping_channel_id
    ) const;

  const ON_MappingChannel* MappingChannel( 
    const ON_UUID& plugin_id, 
    const ON_UUID& mapping_id
    ) const;


  /*
  Parameters:
    plugin_id - [in]
    mapping_channel_id - [in]
    mapping_id - [in]
      ON_TextureMapping id
  Returns:
    True if the mapping channel was added or a pefect
    match already existed.  False if a mapping channel 
    with a different mapping_id already exists for this
    plug-in and channel.
  */
  bool AddMappingChannel(
    const ON_UUID& plugin_id, 
    int mapping_channel_id,
    const ON_UUID& mapping_id
    );

  /*
  Parameters:
    plugin_id - [in]
    mapping_channel_id - [in]
    mapping_id - [in]
      ON_TextureMapping id
  Returns:
    True if a matching mapping channel was deleted.
  */
  bool DeleteMappingChannel(
    const ON_UUID& plugin_id, 
    int mapping_channel_id
    );

  bool DeleteMappingChannel(
    const ON_UUID& plugin_id, 
    const ON_UUID& mapping_id
    );

  /*
  Parameters:
    plugin_id - [in]
    old_mapping_channel_id - [in]
    new_mapping_channel_id - [in]
  Returns:
    True if a matching mapping channel was found and changed.
  */
  bool ChangeMappingChannel(
    const ON_UUID& plugin_id, 
    int old_mapping_channel_id,
    int new_mapping_channel_id
    );

  // Use AddMappingRef() or AddMappingChannel() if you 
  // want to add an element to this array.
  //
  // Every mapping ref in this array must have
  // a distinct value of ON_MappingRef.m_plugin_id.
  ON_ClassArray<ON_MappingRef> m_mappings;

  /*
  Parameters:
    bEnable - [in]
      false - (default)
       Do not generate bitmap textures that 
       approximate procedural textures.
      true - 
       generate bitmap textures that approximate
       procedural textures and use these for
       quick previews.
  Returns:
    True if advancded texture preview is enabled.
  */
  void EnableAdvancedTexturePreview(bool b);

  /*
  Returns:
    True if advancded texture preview is enabled.
  */
  bool AdvancedTexturePreview() const;

  bool m_bCastsShadows;    // default is true
  bool m_bReceivesShadows; // default is true

private:
  // m_bits encodes 8 true/false settings
  unsigned char m_bits; // (m_bits & 1) == AdvancedTexturePreview();

  unsigned char m_reserved1;
};

#if defined(ON_DLL_TEMPLATE)
// This stuff is here because of a limitation in the way Microsoft
// handles templates and DLLs.  See Microsoft's knowledge base 
// article ID Q168958 for details.
#pragma warning( push )
#pragma warning( disable : 4231 )
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ON_RenderingAttributes>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ON_ObjectRenderingAttributes>;
#pragma warning( pop )
#endif


#endif

/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(ON_ARCHIVE_INC_)
#define ON_ARCHIVE_INC_

class ON_CLASS ON_FileStream
{
public:
  /*
  Description:
    Portable wrapper for C runtime fopen().
  Parameters:
    filename - [in]
    mode - [in]
  Remarks:
    Use the ON_FileStream static functions for reading, writing, 
    seeking, position finding with the FILE pointer returned
    by this function.
  */
  static FILE* Open( const wchar_t* filename, const wchar_t* mode );

  /*
  Description:
    Portable wrapper for C runtime fopen().
  Parameters:
    filename - [in]
    mode - [in]
  Remarks:
    Use the ON_FileStream static functions for reading, writing, 
    seeking, position finding with the FILE pointer returned
    by this function.
  */
  static FILE* Open( const char* filename, const char* mode );
  
  /*
  Description:
    Portable wrapper for C runtime fclose().
  Parameters:
    fp - [in]
      FILE pointer returned by ON_FileStream::Open().
  Returns:
       0: successful
      -1: null fp parameter
    != 0: fclose() failure code
  */
  static int Close( FILE* fp );

  /*
  Description:
    Portable wrapper for C runtime ftell().
  Parameters:
    fp - [in]
      FILE pointer returned by ON_FileStream::Open().
  Returns:
    >= 0: current file position
      -1: an error occured
  */
  static ON__INT64 CurrentPosition( FILE* fp );

  /*
  Description:
    Portable wrapper for C runtime fseek(fp,offset,SEEK_CUR).
  Parameters:
    fp - [in]
      FILE pointer returned by ON_FileStream::Open().
    offset - [in]
  */
  static bool SeekFromCurrentPosition( FILE* fp, ON__INT64 offset );

  /*
  Description:
    Portable wrapper for C runtime fseek(fp,offset,SEEK_SET).
  Parameters:
    fp - [in]
      FILE pointer returned by ON_FileStream::Open().
    offset - [in]
  */
  static bool SeekFromStart( FILE* fp, ON__INT64 offset );

  /*
  Description:
    Portable wrapper for C runtime fseek(fp,offset,SEEK_END).
  Parameters:
    fp - [in]
      FILE pointer returned by ON_FileStream::Open().
    offset - [in]
  */
  static bool SeekFromEnd( FILE* fp, ON__INT64 offset );

  /*
  Description:
    Portable wrapper for C runtime fseek(fp,offset,origin).
  Parameters:
    fp - [in]
      FILE pointer returned by ON_FileStream::Open().
    offset - [in]
    origin - [in]
      SEEK_SET (0): seek from beginning of file.  
      SEEK_CUR (1): seek from current position of file pointer.
      SEEK_END (2): seek from end of file.
  */
  static bool Seek( FILE* fp, ON__INT64 offset, int orgin );

  /*
  Description:
    Portable wrapper for C runtime fread(buffer,1,count,fp).
  Parameters:
    fp - [in]
      FILE pointer returned by ON_FileStream::Open()
    count - [in]
      number of bytes to read.
    buffer - [out]
      read bytes are stored in this buffer
  Returns:
    number of bytes read
  */
  static ON__UINT64 Read( FILE* fp, ON__UINT64 count, void* buffer );

  /*
  Description:
    Portable wrapper for C runtime fwrite(buffer,1,count,fp).
  Parameters:
    fp - [in]
      FILE pointer returned by ON_FileStream::Open()
    count - [in]
      number of bytes to write
    buffer - [in]
      data to be written
  Returns:
    number of bytes written.
  */
  static ON__UINT64 Write( FILE* fp, ON__UINT64 count, const void* buffer );

  /*
  Description:
    Portable wrapper for C runtime fflush(fp).
  Parameters:
    fp - [in]
      FILE pointer returned by ON_FileStream::Open().
  Returns:
    true if flush was successful.  False if an error occured.
  */
  static bool Flush( FILE* fp );

  /*
  Description:
    Portable wrapper for C runtime fstat().
  Parameters:
    fp - [in]
      FILE pointer returned by ON_FileStream::Open().
    file_size - [out]
      If file_size is not null, the the size of the file
      in bytes returned here
    file_creation_time - [out]
      If file_creation_time is not null, then the time the file 
      was created is returned here as the number of seconds since
      midnight January 1, 1970.
    file_last_modified_time - [out]
      If file_last_modified_time is not null, then the time the file
      was last modified is returned here as the number of seconds
      since midnight January 1, 1970.
  Returns:
    true if the query was successful.  False if an error occured.
  */
  static bool GetFileInformation( 
    FILE* fp,
    ON__UINT64* file_size,
    ON__UINT64* file_create_time,
    ON__UINT64* file_last_modified_time
    );
};

class ON_CLASS ON_FileIterator
{
public:
  ON_FileIterator();
  ~ON_FileIterator();
  void Destroy();

  /*
  Description:
    Find the first matching file in the directory.
  Parameters:
    directory_name - [in]
      The directory to look in.
    file_name_filter - [in]
      If this paramter is null, then the iteration
      includes all names in the directory.
      The file name to search for. This parameter can 
      include wildcard characters, such as an
      asterisk (*) or a question mark (?). For example,
      "\rootdir\subdir\*.*"  will iterate all files in
      the \rootdir\subdir\ directory.

  Example:
          // Iterate through the files in a directory named "\rootdir\subdir"
          FILE* fp = 0;
          ON_FileIterator fit;
          const char* directory = "\\rootdir\\subdir";
          for ( const wchar_t* filename = fit.FirstFile( directory, "*.3dm" );
                0 != filename;
                filename = fit.NextFile()
              )
          {
            if ( fit.CurrentFileIsDirectory() )
              continue;
            ON_String fullpath = directory;
            fullpath += '\\';
            fullpath += filename;
            FILE* fp = ON_FileStream::Open(fullpath,"rb");
            if ( 0 == fp )
            {
              continue;
            }
            ...
            ON_FileStream::Close(fp);
            fp = 0;
          }
        }

  Returns:
    NULL if no matching files are present in the directory.
  */
  const wchar_t* FirstFile( 
    const wchar_t* directory_name, 
    const wchar_t* file_name_filter
    );

  const wchar_t* FirstFile( 
    const char* directory_name, 
    const char* file_name_filter
    );

  /*
  Description:
    Find the next matching file in the directory.
  Returns:
    NULL if no more matching files are present in the directory.
  */
  const wchar_t* NextFile();

  const wchar_t* CurrentFileName() const;

  ON__UINT64 CurrentFileSize() const;

  /*
  Returns 
    true if the current "file" is a directory.
  */
  bool CurrentFileIsDirectory() const;

  /*
  Returns 
    true if the current file or directory is hidden.
    This means its name begins with a '.' or it's
    Windows hidden attribute is true.
  */
  bool CurrentFileIsHidden() const;

  bool GetCurrentFullPathFileName( ON_wString& filename ) const;

  /*
  Returns:
    File creation time in seconds since January 1, 1970
  */
  ON__UINT64 CurrentFileCreateTime() const;

  /*
  Returns:
    File last modified time in seconds since January 1, 1970
  */
  ON__UINT64 CurrentFileLastModifiedTime() const;

  /*
  Returns:
    File last access time in seconds since January 1, 1970
  */
  ON__UINT64 CurrentFileLastAccessTime() const;

  /*
  Returns:
    Number of matching files returned so far.
  */
  ON__UINT64 Count() const;

private:
  // Used by Windows ::Find
  ON__UINT64 m_count;
  ON_wString m_directory;

#if defined(ON_COMPILER_MSC)
  ON__UINT32 m_file_attributes_mask;
  HANDLE m_h;
  WIN32_FIND_DATA m_fd;
#else
  ON_wString m_ws_file_name_filter;
  ON_String m_utf8_file_name_filter;
  DIR* m_dir;
  struct dirent m_dirent;
  char m_dirent_name_buffer[NAME_MAX+1]; // < this field provide storage for m_dirent.d_name[]

  // information about the current file
  wchar_t m_current_name[1024];
  ON__UINT64 m_current_file_attributes; // 1 = regular file, 2 = directory
  ON__UINT64 m_current_file_size;
  ON__UINT64 m_current_file_create_time;
  ON__UINT64 m_current_last_modified_time;
  ON__UINT64 m_current_last_access_time;
#endif
};


/////////////////////////////////////////////////////////////////////
//
// ON_Buffer 
//

typedef void (*ON_Buffer_ErrorHandler)(class ON_Buffer*);

class ON_CLASS ON_Buffer
{
public:
  ON_Buffer();
  ~ON_Buffer();

  ON_Buffer(const ON_Buffer& src);
  ON_Buffer& operator=(const ON_Buffer& src);

  /*
  Description:
    Compare contents of buffers.
  Paramters:
    a - [in]
    b - [in]
  Returns:
    -1: a < b
     0: a == b
     1: a > b
  */
  static int Compare( const ON_Buffer& a, const ON_Buffer& b );

  void Destroy();
  void EmergencyDestroy();

  /*
  Returns:
    True if Size() == CurrentPosition().
  Remarks:
    It is possible to seek beyond the end of the buffer.
    In this case, the current position will be past the end
    of the buffer and AtEnd() will return false.
  */
  bool AtEnd() const;

  /*
  Returns:
    Number of bytes currently in the buffer.
  Remarks:
    It is possible to seek beyond the end of the buffer.
    In this case, the current position will be past the end
    of the buffer and CurrentPosition() will be greater than
    Size().
  */
  ON__UINT64 Size() const;

  /*
  Returns:
    32-bit CRC of the buffer contents.
  Remarks:
    
  */
  ON__UINT32 CRC32( ON__UINT32 current_remainder ) const;


  /*
  Returns:
    Current position in the buffer.
  Remarks:
    It is possible to seek beyond the end of the buffer.
    In this case, the current position will be past the end
    of the buffer and CurrentPosition() will be greater than
    Size().
  */
  ON__UINT64 CurrentPosition() const;
  
  /*
  Parameters:
    size - [in]
      number of bytes to write.
    buffer - [in]
      values to write.
  Returns:
    Number of bytes written buffer.
  */
  ON__UINT64 Write( ON__UINT64 size, const void* buffer );

  /*
  Parameters:
    size - [in]
      number of bytes to read.
    buffer - [out]
      read values are returned in buffer.
  Returns:
    Number of bytes read into buffer. For example, 
    if CurrentPosition() <= Size() and 
    size > (Size() - CurrentPosition()) and
    buffer is not null, then the value
    (Size() - CurrentPosition()) is returned.
  Remarks:
    If the size parameter is zero, then nothing is done.
    When CurrentPosition() <= Size(), attempts to read more 
    than (Size() - CurrentPosition()) bytes do not generate 
    an error. When CurrentPosition() > Size(), any attempt
    to read generates an error.
  */
  ON__UINT64 Read( ON__UINT64 size, void* buffer );

  enum
  {
    seek_from_beginning_of_file = 0,
    seek_from_current_position = 1,
    seek_from_end_of_file = 2
  };

  /*
  Parameters:
    offset - [in]
      number of bytes to seek from origin
    origin - [in]
      initial position.
        0 (SEEK_SET) Seek from beginning of file.
        1 (SEEK_CUR) Seek from current position.
        2 (SEEK_END) Seek from end of file.
  Returns:
    True if successful.
    False if the seek would result in a file position
    before the beginning of the file. If false is
    returned, the current position is not changed.
  Remarks:
    Seeking beyond the end of the buffer is succeeds.
    Seeking before the beginning of the buffer fails.
  */
  bool Seek( 
    ON__INT64 offset, 
    int origin 
    );

  /*
  Parameters:
    offset - [in] (>= 0)
      number of bytes to seek from the start of the buffer.
  Returns:
    True if successful.
    False if the seek would result in a file position
    before the beginning of the file. If false is
    returned, the current position is not changed.
  Remarks:
    Seeking beyond the end of the buffer is succeeds.
    Seeking before the beginning of the buffer fails.
  */
  bool SeekFromStart( ON__INT64 offset ); 

  /*
  Parameters:
    offset - [in]
      number of bytes to seek from the current position.
  Returns:
    True if successful.
    False if the seek would result in a file position
    before the beginning of the file. If false is
    returned, the current position is not changed.
  Remarks:
    Seeking beyond the end of the buffer is succeeds.
    Seeking before the beginning of the buffer fails.
  */
  bool SeekFromCurrentPosition( ON__INT64 offset ); 

  /*
  Parameters:
    offset - [in]
      number of bytes to seek from the end fo the buffer.
  Returns:
    True if successful.
    False if the seek would result in a file position
    before the beginning of the file. If false is
    returned, the current position is not changed.
  Remarks:
    Seeking beyond the end of the buffer is succeeds.
    Seeking before the beginning of the buffer fails.
  */
  bool SeekFromEnd( ON__INT64 offset ); 

  /*
  Parameters:
    buffer_size - [in]
      new size of buffer.
  Returns:
    True if successful.    
  Remarks:
    The current position is not changed and may be beyond the
    end of the file. Use Seek to set the current position after
    calling ChangeSize().
  */
  bool ChangeSize( ON__UINT64 buffer_size );

  /*
  Description:
    Return unused memory to heap.
  Remarks:
    Call this function after creating an ON_Buffer that will persist for
    and extended amount of time. There are never more than 16 pages of
    unsued memory (16*4096 bytes on most computers) in an ON_Buffer.
    Compact() can be called at any time, but calling Compact() the then
    writing at the end of the buffer is not an efficient use of time
    or memory.
  */
  bool Compact();

  /*
  Returns
    True if the ON_Buffer is valid.
  */
  bool IsValid( const ON_TextLog* text_log ) const;

  /*
  Returns:
    Value that identifies most recent error.
    0: no error
    1: attempt to seek to a negative position
  */
  ON__UINT32 LastError() const;
  
  void ClearLastError();

  ON_Buffer_ErrorHandler ErrorHandler() const;
  
  void SetErrorHandler(ON_Buffer_ErrorHandler error_handler);

  /*
  Description:
    Use WriteToBinaryArchive() to save an entire ON_Buffer inside
    a binary archive.  Use ReadFromBinaryArchive() to retrieve
    the ON_Buffer from the ON_BinaryArchive.
  */
  bool WriteToBinaryArchive( ON_BinaryArchive& ) const;

  /*
  Description:
    Use ReadFromBinaryArchive() to retrieve an entire ON_Buffer
    that was written using WriteToBinaryArchive().
  */
  bool ReadFromBinaryArchive( ON_BinaryArchive& );

  /*
  Description:
    Compress this buffer

  Parameters:
    compressed_buffer - [out]
      (The reference can be *this)
  
  Example:

        // compress a buffer in place
        ON_Buffer buffer;
        buffer = ...;
        if ( !buffer.Compress(buffer) )
        {
           // compression failed
        }
        else
        {
           // buffer is now compressed
        }

  Returns:
    True if successful.  False if failed.
  */
  bool Compress( ON_Buffer& compressed_buffer ) const;

  /*
  Description:
    Uncompress this buffer which must have been compressed using
    ON_Buffer::Compress().

  Parameters:
    uncompressed_buffer - [out]
      (The reference can be *this)

  Example:
        // silly example that compresses and then uncompresses a buffer in place
        // to show how to call the functions.
        ON_Buffer buffer;
        buffer = ...; // buffer is in it uncompressed form
        if ( buffer.Compress(buffer) )
        {
           // buffer is now compressed
           if ( buffer.Uncompress(buffer) )
           {
              // buffer is uncompressed again.
           }
        }

  Returns:
    True if successful.  False if failed.
  */
  bool Uncompress( ON_Buffer& uncompressed_buffer ) const;

private:

  ON__UINT64 m_buffer_size; // total number of bytes in the buffer
  ON__UINT64 m_current_position;

  struct ON_BUFFER_SEGMENT* m_first_segment;
  struct ON_BUFFER_SEGMENT* m_last_segment;
  struct ON_BUFFER_SEGMENT* m_current_segment;
  bool SetCurrentSegment(bool);
  void Copy( const ON_Buffer& );

  ON_MEMORY_POOL* m_heap;
  ON_Buffer_ErrorHandler m_error_handler;

  ON__UINT32 m_last_error;
  unsigned char m_reserved[12];
};

/////////////////////////////////////////////////////////////////////
//
// ON_BinaryArchive 
//      virtual class for CPU independent serialization
//
// ON_BinaryFile
//      simple class for CPU independent binary file I/O
//      includes optional CRC support
//

class ON_Object;
class ON_Group;
class ON_Font;
class ON_DimStyle;
class ON_Arc;
class ON_ObjectAttributes;
class ON_InstanceDefinition;
class ON_HatchPattern;
class ON_Linetype;

struct ON_3DM_CHUNK
{
  size_t m_offset; // In read or write_using_fseek mode, this is the
                   // file position of first byte after chunk's length.
                   // In write_using_buffer mode, this of the m_buffer[]
                   // position of first byte after chunk's length.
  unsigned int m_typecode;
  int m_value;
  int m_do_length; // true if chunk is a long chunk with length
  ON__UINT16 m_do_crc16; // 16 bit CRC using CCITT polynomial
  ON__UINT16 m_crc16;
  ON__UINT32 m_do_crc32; // 32 bit CRC
  ON__UINT32 m_crc32;
};

struct ON_3DM_BIG_CHUNK
{
  ON__UINT64 m_big_offset; // In read or write_using_fseek mode, this is the
                           // file position of first byte after chunk's length.
                           // In write_using_buffer mode, this of the m_buffer[]
                           // position of first byte after chunk's length.

  ON__UINT64 Length() const; // 0 for short chunks

  ON__INT64 m_big_value;
  ON__UINT32 m_typecode;

  ON__UINT8 m_bLongChunk; // true if chunk is a long chunk and m_big_value is a length.
  ON__UINT8 m_reserved1;
  ON__UINT8 m_reserved2;
  ON__UINT8 m_reserved3;

  // CRC settings
  ON__UINT8 m_do_crc16; // true (1) if we are calculating 16 bit CRC
  ON__UINT8 m_do_crc32; // true (1) if we are calculating 32 bit CRC
  ON__UINT16 m_crc16; // current 16 bit CRC value
  ON__UINT32 m_crc32; // current 32 bit CRC value
};

bool ON_IsLongChunkTypecode(ON__UINT32 typecode);

#if defined(ON_DLL_TEMPLATE)
// This stuff is here because of a limitation in the way Microsoft
// handles templates and DLLs.  See Microsoft's knowledge base 
// article ID Q168958 for details.
#pragma warning( push )
#pragma warning( disable : 4231 )
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_3DM_CHUNK>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_3DM_BIG_CHUNK>;
#pragma warning( pop )
#endif

class ON_Light;
class ON_Bitmap;
class ON_TextureMapping;
class ON_Material;
class ON_Layer;
class ON_3dmProperties;
class ON_3dmSettings;
class ON_3dmObjectAttributes;
class ON_3dmGoo;

class ON_BinaryArchive;

// Used int ON_3dmProperties::Read() to set ON_BinaryArchive.m_3dm_opennurbs_version
// Do not call directly. 
void ON_SetBinaryArchiveOpenNURBSVersion(ON_BinaryArchive&,int);

class ON_CLASS ON_BinaryArchive // use for generic serialization of binary data
{
public:
  ON_BinaryArchive( ON::archive_mode );
  virtual ~ON_BinaryArchive();

  virtual 
  size_t CurrentPosition( // current offset (in bytes) into archive ( like ftell() )
                ) const = 0; 
  virtual 
  bool SeekFromCurrentPosition( // seek from current position ( like fseek( ,SEEK_CUR) )
                int // byte offset ( >= -CurrentPostion() )
                ) = 0; 
  virtual 
  bool SeekFromStart(  // seek from current position ( like fseek( ,SEEK_SET) )
                size_t // byte offset ( >= 0 )
                ) = 0;
  virtual 
  bool AtEnd() const = 0; // true if at end of file

  bool BigSeekFromStart( ON__UINT64 offset );
  bool BigSeekForward( ON__UINT64 offset );
  bool BigSeekBackward( ON__UINT64 offset );
  bool BigSeekFromCurrentPosition( ON__INT64 offset );

  /*
  Description:
    Tool for swapping bytes when doing I/O on
    using big endian CPUs.
  Remarks:
    3dm files are always saved with little endian byte order.
  See Also:
    ON_BinaryArchive::Endian
  */
  static
  bool ToggleByteOrder(
    int, // number of elements
    int, // size of element (2,4, or 8)
    const void*,  // source buffer
    void*         // destination buffer (can be same a source buffer)
    );

  static
  const char* TypecodeName( unsigned int tcode );

  static
  char* ON_TypecodeParse( unsigned int tcode, char* typecode_name, size_t max_length );

  bool ReadMode() const;  // true if reading is permitted
  bool WriteMode() const; // true if writing is permitted
  
  /*
  Returns:
     Endian-ness of the cpu reading this file.
  Remarks:
    3dm files are alwasy saved with little endian byte order.
  */
  ON::endian Endian() const; // endian-ness of cpu

  int BadCRCCount() const; // number of chunks read with bad CRC 

  bool ReadByte( size_t, void* ); // must fail if mode is not read or readwrite

  bool WriteByte( size_t, const void* ); // must fail if mode is not write or readwrite

  /*
  Description:
    Expert user function that uses Read() to load a buffer.
  Paramters:
    sizeof_buffer - [in] number of bytes to attempt to read.
    buffer - [out] read bytes are stored in this buffer
  Returns:
    Number of bytes actually read, which may be less than
    sizeof_buffer if the end of file is encountered.
  */
  ON__UINT64 ReadBuffer( ON__UINT64 sizeof_buffer, void* buffer );

  /*
  Description:
    Expert user function to control CRC calculation while reading and writing.
    Typically this is used when seeking around and reading/writing information
    in non-serial order.
  Parameters:
    bEnable  - [in]
  Returns:
    Current state of CRC calculation.  Use the returned value to restore the
    CRC calculation setting after you are finished doing your fancy pants
    expert IO.
  */
  bool EnableCRCCalculation( bool bEnable );

  // ReadCompressedBuffer()/WriteCompressedBuffer() use zlib 1.1.3
  // to inflate/deflate the data buffer.
  // Care must be used to get an endian independent file.  
  // See ON_Mesh::Read()/ON_Mesh::Write() for an example of an endian
  // independent use of compression. See also ToggleByteOrder() and Endian().
  //
  // To read data archived by WriteCompressedBuffer( sizeof_buffer, buffer )
  // do something like:
  //
  //   size_t sizeof_buffer = 0;
  //   ReadCompressedBufferSize(&sizeof_buffer);
  //   buffer = something with sizeof_buffer bytes.
  //   int bFailedCRC = false;
  //   bool ok = ReadCompressedBuffer( sizeof_buffer, buffer, &bFailedCRC );
  //


  /*
  Description:
    Red the size of a compressed buffer.
  Parameters:
    sizeof__outbuffer - [out] size of the uncompressed buffer in bytes
  Returns:
    True if read was successful.
  */
  bool ReadCompressedBufferSize( size_t* sizeof__outbuffer );

  /*
  Description:
    Read compressed information from an archive and uncompress it.
  Parameters:
    sizeof__outbuffer - [in] size of the uncompressed buffer in bytes
    outbuffer - [out] uncompressed buffer returned here
    bFailedCRC - [out] true if cyclic redundancy check fails
                      on uncompressed buffer

  Example:

          size_t sizeof_buffer = 0;
          ReadCompressedBufferSize(&sizeof_buffer);
          buffer = ...; // something with sizeof_buffer bytes.
          int bFailedCRC = false;
          bool ok = ReadCompressedBuffer( sizeof_buffer, buffer, &bFailedCRC );

  Returns:
    True if read was successful.  You need to check the value
    of bFailedCRC to see if the information that was read is valid.
  */
  bool ReadCompressedBuffer(
          size_t sizeof__outbuffer,
          void* outbuffer,
          int* bFailedCRC
          );

  /*
  Description:
    Compress buffer and write the compressed information to the archive.
  Parameters:
    sizeof__inbuffer - [in] size of the uncompressed buffer in bytes
    inbuffer - [in] uncompressed buffer
  Returns:
    True if write was successful.
  */
  bool WriteCompressedBuffer(
    size_t sizeof__inbuffer,
    const void* inbuffer
    );

  bool ReadBool( bool* );

	bool ReadChar(    // Read an array of 8 bit chars
			size_t,       // number of chars to read
			char*    
			);  
	bool ReadChar(    // Read an array of 8 bit unsigned chars
			size_t,       // number of unsigned chars to read
			unsigned char*    
			);  
	bool ReadChar(    // Read a single 8 bit char
			char*    
			);  
	bool ReadChar(    // Read a single 8 bit unsigned char
			unsigned char*    
			);  

	bool ReadShort(   // Read an array of 16 bit shorts
			size_t,       // number of shorts to read
			short*    
			);  
	bool ReadShort(   // Read an array of 16 bit unsigned shorts
			size_t,       // number of shorts to read
			unsigned short*    
			);  
	bool ReadShort(   // Read a single 16 bit short
			short*    
			);  
	bool ReadShort(   // Read a single 16 bit unsigned short
			unsigned short*    
			);  

	bool ReadInt( // Read an array of 32 bit integers
			size_t,	      // number of ints to read
			int*      
			); 
	bool ReadInt( // Read an array of 32 bit integers
			size_t,	      // number of ints to read
			unsigned int*      
			); 
	bool ReadInt( // Read a single 32 bit integer
			int*      
			); 
	bool ReadInt( // Read a single 32 bit unsigned integer
			unsigned int*      
			); 

	bool ReadBigInt( // Read an array of 64 bit integers
			size_t,	      // number of ints to read
			ON__INT64*      
			); 
	bool ReadBigInt( // Read an array of 64 bit integers
			size_t,	      // number of ints to read
			ON__UINT64*      
			); 
	bool ReadBigInt( // Read a single 64 bit integer
			ON__INT64*      
			); 
	bool ReadBigInt( // Read a single 64 bit unsigned integer
			ON__UINT64*      
			); 

	bool ReadLong( // Read an array of 32 bit integers
			size_t,	      // number of ints to read
			long*      
			); 
	bool ReadLong( // Read an array of 32 bit integers
			size_t,	      // number of ints to read
			unsigned long*      
			); 
	bool ReadLong( // Read a single 32 bit integer
			long*      
			); 
	bool ReadLong( // Read a single 32 bit unsigned integer
			unsigned long*      
			); 
	bool ReadSize( // Read a single size_t
			size_t*
			); 

  bool ReadBigSize( size_t* ); // 64 bits
  
  bool ReadBigTime( time_t* ); // UCT seconds since 1 January 1970 (64 bits)


	bool ReadFloat(   // Read an array of floats
			size_t,       // number of floats
			float*
			);
	bool ReadFloat(   // Read a single float
			float*
			);
	bool ReadDouble(  // Read an array of IEEE doubles
			size_t,       // number of doubles
			double*
			);
	bool ReadDouble(  // Read a single double
			double*
			);

  bool ReadColor(
    ON_Color&
    );

  bool ReadPoint (
    ON_2dPoint&
    );
  bool ReadPoint (
    ON_3dPoint&
    );
  bool ReadPoint (
    ON_4dPoint&
    );
  bool ReadVector (
    ON_2dVector&
    );
  bool ReadVector (
    ON_3dVector&
    );

  bool ReadBoundingBox(ON_BoundingBox&);

  bool ReadXform(ON_Xform&);

  bool ReadPlaneEquation(ON_PlaneEquation&);

  bool ReadPlane(ON_Plane&);

  bool ReadLine(ON_Line&);

  bool ReadArc(ON_Arc&);

  bool ReadCircle(ON_Circle&);

  bool ReadInterval( ON_Interval& );

  bool ReadUuid( ON_UUID& );

  bool ReadDisplayMaterialRef( ON_DisplayMaterialRef& );

  bool ReadLinetypeSegment( ON_LinetypeSegment& );

  // All times are stored in coordinated universal time
  // ( a.k.a GMT, UTC ).  Use ANSI C time() and gmtime() calls.
  bool ReadTime( struct tm& );

  /*
  Parameters:
    str_array_count - [out]
      Number of elements in the string array. All ON_BinaryArchive string
      WriteString() functions write a null terminator to the file and
      the null terminator is included in the count. This means that
      if a string has a non-zero element, then str_array_count >= 2.
  Remarks:
    Modify your code to use ReadStringUTF8ElementCount() when reading
    UTF-8 encoded strings and ReadStringUTF16ElementCount()
    when reading UTF-16 encoded strings.
  */
  ON_DEPRECATED bool ReadStringSize(
      size_t* str_array_count
      );

  /*
  Parameters:
    string_utf8_element_count - [out]
      Number of bytes in the string array. All ON_BinaryArchive string
      WriteString() functions write a null terminator to the file and
      the null terminator is included in string_element_count. This means
      that if opennurbs wrote the string, either string_element_count = 0
      or string_element_count >= 2.
  */
  bool ReadStringUTF8ElementCount(
    size_t* string_utf8_element_count
    );

  /*
  Parameters:
    string_utf16_element_count - [out]
      Number of elements in the string array. All ON_BinaryArchive string
      WriteString() functions write a null terminator to the file and
      the null terminator is included in string_element_count. This means
      that if opennurbs wrote the string, either string_element_count = 0
      or string_element_count >= 2.
  */
  bool ReadStringUTF16ElementCount(
    size_t* string_utf16_element_count
    );


  /*
  Parameters:
    str_array_count - [in]
      Number of char elements in str_array[], including the null
      terminator.  The value of str_array_count is returned by
      ReadCharStringElementCount().
    str_array - [in/out]
      Pass in an array with at least str_array_count elements.
      If true is returned and str_array_count > 0,
      then str_array[str_array_count-1] = 0. All strings with
      char elements written by Rhino are UTF-8 encoded
      unicode strings.
  */
  bool ReadString(
      size_t str_array_count,
      char* str_array
      );

  /*
  Parameters:
    str_array_count - [in]
      Number of unsignd char elements in str_array[], including
      the null terminator. The value of str_array_count is returned
      by ReadCharStringElementCount().
    str_array - [in/out]
      Pass in an array with at least str_array_count elements.
      If true is returned and str_array_count > 0,
      then str_array[str_array_count-1] = 0. All strings with
      unsigned char elements written by Rhino are UTF-8 encoded 
      unicode strings.
  */
  bool ReadString(
      size_t str_array_count,
      unsigned char* str_array
      );

  /*
  Parameters:
    str_array_count - [in]
      Number of unsigned short elements in str_array[],
      including the null terminator. The value of 
      str_array_count is returned by ReadWideCharStringElementCount().
    str_array - [in/out]
      Pass in an array with at least str_array_count elements.
      If true is returned and str_array_count > 0,
      then str_array[str_array_count-1] = 0. All strings with
      unsigned short elements written by Rhino are UTF-16 encoded
      unicode strings.
  */
  bool ReadString(
      size_t str_array_count,
      unsigned short*  str_array
      );

  bool ReadString( ON_String& sUTF8 );

  bool ReadString( ON_wString& s );

  bool ReadComponentIndex( ON_COMPONENT_INDEX& );

  bool ReadArray( ON_SimpleArray<bool>& );
  bool ReadArray( ON_SimpleArray<char>& );
  bool ReadArray( ON_SimpleArray<short>& );
  bool ReadArray( ON_SimpleArray<int>& );
  bool ReadArray( ON_SimpleArray<float>& );
  bool ReadArray( ON_SimpleArray<double>& );
  bool ReadArray( ON_SimpleArray<ON_Color>& );
  bool ReadArray( ON_SimpleArray<ON_2dPoint>& );
  bool ReadArray( ON_SimpleArray<ON_3dPoint>& );
  bool ReadArray( ON_SimpleArray<ON_4dPoint>& );
  bool ReadArray( ON_SimpleArray<ON_2dVector>& );
  bool ReadArray( ON_SimpleArray<ON_3dVector>& );
  bool ReadArray( ON_SimpleArray<ON_Xform>& );
  bool ReadArray( ON_SimpleArray<ON_2fPoint>& );
  bool ReadArray( ON_SimpleArray<ON_3fPoint>& );
  bool ReadArray( ON_SimpleArray<ON_4fPoint>& );
  bool ReadArray( ON_SimpleArray<ON_2fVector>& );
  bool ReadArray( ON_SimpleArray<ON_3fVector>& );
  bool ReadArray( ON_SimpleArray<ON_UUID>& );
  bool ReadArray( ON_SimpleArray<ON_UuidIndex>& );
  bool ReadArray( ON_SimpleArray<ON_SurfaceCurvature>& );
  bool ReadArray( ON_ClassArray<ON_String>& );
  bool ReadArray( ON_ClassArray<ON_wString>& );
  bool ReadArray( ON_SimpleArray<ON_DisplayMaterialRef>& );
  bool ReadArray( ON_SimpleArray<ON_LinetypeSegment>& );  
  bool ReadArray( ON_SimpleArray<ON_MappingChannel>& );
  bool ReadArray( ON_ClassArray<ON_MaterialRef>& );
  bool ReadArray( ON_ClassArray<ON_MappingRef>& );
  bool ReadArray( ON_ClassArray<class ON_ObjRef>& );
  bool ReadArray( ON_SimpleArray<class ON_ObjRef_IRefID>& );
  bool ReadArray( ON_SimpleArray<class ON_ClippingPlaneInfo>& );
  bool ReadArray( ON_ObjectArray<class ON_Layer>& );
  bool ReadArray( ON_SimpleArray<class ON_Layer*>& );

  bool WriteBool( bool );

  bool WriteChar(    // Write an array of 8 bit chars
			size_t,       // number of chars to write
			const char*    
			);  
	bool WriteChar(    // Write an array of 8 bit unsigned chars
			size_t,       // number of unsigned chars to write
			const unsigned char*    
			);  
	bool WriteChar(    // Write a single 8 bit char
			char
			);  

	bool WriteShort(   // Write an array of 16 bit shorts
			size_t,       // number of shorts to write
			const short*    
			);  
	bool WriteShort(   // Write an array of 16 bit unsigned shorts
			size_t,       // number of shorts to write
			const unsigned short*    
			);  
	bool WriteShort(   // Write a single 16 bit short
			short
			);  

	bool WriteInt( // Write an array of 32 bit integers
			size_t,	      // number of ints to write
			const int*      
			); 
	bool WriteInt( // Write an array of 32 bit integers
			size_t,	      // number of ints to write
			const unsigned int*      
			); 
	bool WriteInt( // Write a single 32 bit integer
			int    
			); 
	bool WriteInt( // Write a single 32 bit unsigned integer
			unsigned int
			); 

	bool WriteBigInt( // Write an array of 64 bit integers
			size_t,	      // number of ints to write
			const ON__INT64*      
			); 
	bool WriteBigInt( // Write an array of 64 bit integers
			size_t,	      // number of ints to write
			const ON__UINT64*      
			); 
	bool WriteBigInt( // Write a single 64 bit integer
			ON__INT64    
			); 
	bool WriteBigInt( // Write a single 64 bit unsigned integer
			ON__UINT64
			); 

	bool WriteLong( // Write an array of 32 bit integers
			size_t,	      // number of ints to write
			const long*      
			); 
	bool WriteLong( // Write an array of 32 bit integers
			size_t,	      // number of ints to write
			const unsigned long*      
			); 
	bool WriteLong( // Write a single 32 bit integer
			long    
			); 
	bool WriteLong( // Write a single 32 bit unsigned integer
			unsigned long
			); 
	bool WriteSize( // Write a single size_t
			size_t
			); 

  bool WriteBigSize( size_t ); // 64 bits 
  
  bool WriteBigTime( time_t ); // UCT seconds since 1 January 1970 (64 bits)

	bool WriteFloat(   // Write a number of IEEE floats
			size_t,       // number of doubles
			const float*
			);
	bool WriteFloat(   // Write a single float
			float
			);
	bool WriteDouble(  // Write a single double
      size_t,
			const double*
			);
	bool WriteDouble(  // Write a single double
			double
			);

  bool WriteColor (
    const ON_Color&
    );

  bool WritePoint (
    const ON_2dPoint&
    );
  bool WritePoint (
    const ON_3dPoint&
    );
  bool WritePoint (
    const ON_4dPoint&
    );
  bool WriteVector (
    const ON_2dVector&
    );
  bool WriteVector (
    const ON_3dVector&
    );

  bool WriteBoundingBox(const ON_BoundingBox&);

  bool WriteXform(const ON_Xform&);

  bool WritePlaneEquation(const ON_PlaneEquation&);

  bool WritePlane(const ON_Plane&);

  bool WriteLine(const ON_Line&);

  bool WriteArc(const ON_Arc&);

  bool WriteCircle(const ON_Circle&);

  bool WriteInterval( const ON_Interval& );

  bool WriteUuid( const ON_UUID& );

  bool WriteDisplayMaterialRef( const ON_DisplayMaterialRef& );

  bool WriteLinetypeSegment( const ON_LinetypeSegment& );

  // All times are stored in universal coordinated time
  // ( a.k.a GMT, UCT ).  Use ANSI C time() and gmtime() calls.
  bool WriteTime( const struct tm& );

  /*
  Parameters:
    sUTF8 - [in]
      A null terminated UTF-8 encoded unicode string.
  Remarks:
    To read a string written with WriteString(const char*),
    call ReadStringUTF8ElementCount(&string_utf8_element_count)
    to get the number of char elements written in the file,
    obtain a buffer with at least string_utf8_element_count
    char elements and then call 
    ReadString(string_utf8_element_count,buffer) to read the
    char elements.

    If 0 == sUTF8 or 0 == SUTF8[0], a 4 byte int with
    value = 0 is written, otherwise a 4 byte int with
    value = strlen + 1 is written, followed by the string,
    followed by the null terminator.
  */
  bool WriteString(
      const char* sUTF8         
      );

  /*
  Parameters:
    sUTF8 - [in]
      A null terminated UTF-8 encoded unicode string.
  Remarks:
    To read a string written with WriteString(const unsigned char*),
    call ReadStringUTF8ElementCount(&string_utf8_element_count) to
    get the number of unsigned char elements written in the file,
    obtain a buffer with at least string_utf8_element_count
    unsigned char elements and then call 
    ReadString(string_utf8_element_count,buffer) to read the 
    unsigned charelements.

    If 0 == sUTF8 or 0 == SUTF8[0], a 4 byte int with
    value = 0 is written, otherwise a 4 byte int with
    value = strlen + 1 is written, followed by the string,
    followed by the null terminator.
  */
  bool WriteString(
      const unsigned char* sUTF8
      );

  /*
  Parameters:
    sUTF16 - [in]
      A null terminated UTF-16 encoded unicode string.
  Remarks:
    To read a string written with WriteString(const unsigned short*),
    call ReadStringUTF16ElementCount(&string_utf16_element_count) to
    get the number of unsigned short elements written in the file,
    obtain a buffer with at least string_utf16_element_count
    unsigned short elements and then call 
    ReadString(string_utf16_element_count,buffer) to read the
    unsigned short elements.

    If 0 == sUTF8 or 0 == SUTF8[0], a 4 byte int with
    value = 0 is written, otherwise a 4 byte int with
    value = strlen + 1 is written, followed by the string,
    followed by the null terminator.
  */
  bool WriteString(
      const unsigned short* sUTF16
      );
  
  bool WriteString( const ON_String& sUTF8 );

  bool WriteString( const ON_wString& s);

  bool WriteComponentIndex( const ON_COMPONENT_INDEX& );

  bool WriteArray( const ON_SimpleArray<bool>& );
  bool WriteArray( const ON_SimpleArray<char>& );
  bool WriteArray( const ON_SimpleArray<short>& );
  bool WriteArray( const ON_SimpleArray<int>& );
  bool WriteArray( const ON_SimpleArray<float>& );
  bool WriteArray( const ON_SimpleArray<double>& );

  bool WriteArray( const ON_SimpleArray<ON_Color>& );

  bool WriteArray( const ON_SimpleArray<ON_2dPoint>& );
  bool WriteArray( const ON_SimpleArray<ON_3dPoint>& );
  bool WriteArray( const ON_SimpleArray<ON_4dPoint>& );
  bool WriteArray( const ON_SimpleArray<ON_2dVector>& );
  bool WriteArray( const ON_SimpleArray<ON_3dVector>& );

  bool WriteArray( const ON_SimpleArray<ON_2fPoint>& );
  bool WriteArray( const ON_SimpleArray<ON_3fPoint>& );
  bool WriteArray( const ON_SimpleArray<ON_4fPoint>& );
  bool WriteArray( const ON_SimpleArray<ON_2fVector>& );
  bool WriteArray( const ON_SimpleArray<ON_3fVector>& );
  bool WriteArray( const ON_SimpleArray<ON_Xform>& );
  bool WriteArray( const ON_SimpleArray<ON_UUID>& );
  bool WriteArray( const ON_SimpleArray<ON_UuidIndex>& );
  bool WriteArray( const ON_SimpleArray<ON_SurfaceCurvature>& );
  bool WriteArray( const ON_ClassArray<ON_String>& );
  bool WriteArray( const ON_ClassArray<ON_wString>& );
  bool WriteArray( const ON_SimpleArray<ON_DisplayMaterialRef>& );
  bool WriteArray( const ON_SimpleArray<ON_LinetypeSegment>& );  
  bool WriteArray( const ON_SimpleArray<ON_MappingChannel>& );
  bool WriteArray( const ON_ClassArray<ON_MaterialRef>& );
  bool WriteArray( const ON_ClassArray<ON_MappingRef>& );
  bool WriteArray( const ON_ClassArray<class ON_ObjRef>& );
  bool WriteArray( const ON_SimpleArray<class ON_ObjRef_IRefID>& );
  bool WriteArray( const ON_SimpleArray<class ON_ClippingPlaneInfo>& );
  bool WriteArray( int count, const class ON_Layer* );
  bool WriteArray( int count, const class ON_Layer*const* );

  /////////////////////////////////////////////////////
  //
  // Read/Write classes derived from ON_Object
  //

  /*
  Description:
    Reads and object from a 3dm archive;
  Parameters:
    ppObject - [out]  object is allocated and a pointer to the
                      allocated object is returned as *ppObject;
  Returns:
    0: failure - unable to read object because of file IO problems
    1: success
    3: unable to read object because it's UUID is not registered
       this could happen in cases where old code is attempting to read
       new objects.
  */
  int ReadObject( 
         ON_Object** ppObject
         );


  /*
  Description:
    Reads and object from a 3dm archive.
  Parameters:
    object - [in] The value of object.ON_ClassId()->Uuid() must
                  exactly match the class uuid in of the next
                  object in the archive.
  Returns:
    0: failure - unable to read object because of file IO problems.
    1: success
    2: unable to read object because the class id in the archive
       did not match pObject->ClassId.
  */
  int ReadObject( 
         ON_Object& object
         );

  bool WriteObject( const ON_Object* ); // writes object definition
  bool WriteObject( const ON_Object& ); // writes object definition


  ///////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////
  //
  // 3DM Interface - ignore if not reading/writing a 3DM file
  //                 this is here so that the infrastructure
  //                 for writing 3dm archives is available for
  //                 any type of serialization device.
  //
  bool EnableSave3dmRenderMeshes( ON_BOOL32 = true ); // returns previous state
  bool Save3dmRenderMeshes() const;

  bool EnableSave3dmAnalysisMeshes( ON_BOOL32 = true ); // returns previous state
  bool Save3dmAnalysisMeshes() const;
  
  bool EnableSaveUserData( ON_BOOL32 = true ); // returns previous state
  bool SaveUserData() const;
  
  /*
  Returns:
    50 (The Rhino 5.0 opennurbs file version.)
    This is the value of version to pass to ON_BinaryArchive
    functions like Write3dmStartSection() when you want to use the 
    the current opennurbs version number and you do not want to have
    to update your code when this version number changes.    
  */
  static int CurrentArchiveVersion();

  ///////////////////////////////////////////////////////////////////
  // Step 1: REQUIRED - Write/Read Start Section
  //

  /*
  Parameters:
    version - [in]
       0, 2, 3, 4, 5 or 50 (5 is treated as 50)
       
       If version is 0, then the value of ON_BinaryArchive::CurrentArchiveVersion()
       is used.

       Use either 0 or the value of ON_BinaryArchive::CurrentArchiveVersion()
       for the version parameter when you want your code to write the most 
       up to date file version. 

    sStartSectionComment - [in]
      NULL or ASCII string with application name, et cetera.
      This information is primarily used when debugging files
      that contain problems.  McNeel and Associates stores
      application name, application version, compile date, 
      and the OS in use when file was written.
  */
  bool Write3dmStartSection( 
        int version,
        const char* sStartSectionComment
        );

  /*
  Parameters:
    version - [out]
       .3dm file version (2, 3, 4, 5 or 50)
    sStartSectionComment - [out]
      string passed to Write3dmStartSection()
  */
  bool Read3dmStartSection( 
        int* version,
        ON_String& sStartSectionComment
        );

  ///////////////////////////////////////////////////////////////////
  // Step 2: REQUIRED - Write/Read properties table
  //
  bool Write3dmProperties(
        const ON_3dmProperties&
        );
  bool Read3dmProperties(
        ON_3dmProperties&
        );

  ///////////////////////////////////////////////////////////////////
  // Step 3: REQUIRED - Write/Read settings table
  //
  bool Write3dmSettings(
        const ON_3dmSettings&
        );
  bool Read3dmSettings(
        ON_3dmSettings&
        );

  ///////////////////////////////////////////////////////////////////
  // Step 4: REQUIRED - Write/Read bitmap table (it can be empty)
  //
  bool BeginWrite3dmBitmapTable();
  bool Write3dmBitmap( const ON_Bitmap& );
  bool EndWrite3dmBitmapTable();

  bool BeginRead3dmBitmapTable();
  int  Read3dmBitmap(   // returns 0 at end of light table
                        //         1 bitmap successfully read
            ON_Bitmap** // bitmap returned here
            );
  bool EndRead3dmBitmapTable();

  ///////////////////////////////////////////////////////////////////
  // Step 5: REQUIRED - Write/Read render material table (it can be empty)
  //
  bool BeginWrite3dmTextureMappingTable();
  bool Write3dmTextureMapping( const ON_TextureMapping& );
  bool EndWrite3dmTextureMappingTable();

  bool BeginRead3dmTextureMappingTable();
  int  Read3dmTextureMapping( // returns 0 at end of table
            ON_TextureMapping** // layer returned here
            );
  bool EndRead3dmTextureMappingTable();

  ///////////////////////////////////////////////////////////////////
  // Step 6: REQUIRED - Write/Read render material table (it can be empty)
  //
  bool BeginWrite3dmMaterialTable();
  bool Write3dmMaterial( const ON_Material& );
  bool EndWrite3dmMaterialTable();

  bool BeginRead3dmMaterialTable();
  int  Read3dmMaterial( // returns 0 at end of table
            ON_Material** // layer returned here
            );
  bool EndRead3dmMaterialTable();

  ///////////////////////////////////////////////////////////////////
  // Step 7: REQUIRED - Write/Read linetype table (it can be empty)
  //
  bool BeginWrite3dmLinetypeTable();
  bool Write3dmLinetype( const ON_Linetype&);
  bool EndWrite3dmLinetypeTable();

  bool BeginRead3dmLinetypeTable();
  int  Read3dmLinetype(ON_Linetype**);
  bool EndRead3dmLinetypeTable();

  ///////////////////////////////////////////////////////////////////
  // Step 8: REQUIRED - Write/Read layer table (it can be empty)
  //
  bool BeginWrite3dmLayerTable();
  bool Write3dmLayer( const ON_Layer& );
  bool EndWrite3dmLayerTable();

  bool BeginRead3dmLayerTable();
  int  Read3dmLayer( // returns 0 at end of table
            ON_Layer** // layer returned here
            );
  bool EndRead3dmLayerTable();

  ///////////////////////////////////////////////////////////////////
  // Step 9: REQUIRED - Write/Read group table (it can be empty)
  //
  bool BeginWrite3dmGroupTable();
  bool Write3dmGroup( const ON_Group& );
  bool EndWrite3dmGroupTable();

  bool BeginRead3dmGroupTable();

  // Description:
  //   Reads groups from group table.  If the group definition is
  //   read, a group is created by calling new ON_Group(),
  //   initialized with values stored in the archive, and 
  //   returned.
  //
  // Parameters:
  //   ppGroup - If the group definition is
  //   read, a group is created by calling new ON_Group(),
  //   initialized with values stored in the archive, and 
  //   a pointer to the new group is returned in *ppGroup.
  //
  // Returns:
  //
  //   @untitled table
  //   0     at the end of the group table
  //   1     group definition was successfully read
  //   -1    archive is corrupt at this point
  //
  // Example:
  //   Calls to Read3dmGroup need to be bracketed by calls
  //   to BeginRead3dmGroupTable() / EndRead3dmGroupTable().
  //
  //           archive.BeginRead3dmGroupTable();
  //           ON_Group* pGroup;
  //           int rc = 1;
  //           while(rc==1)
  //           { //
  //             pGroup = 0;
  //             archive.Read3dmGroup(&pGroup);
  //             if ( pGroup )
  //               do something with pGroup
  //           } //
  //           archive.EndRead3dmGroupTable();
  //      
  int  Read3dmGroup(
            ON_Group** // ppGroup
            );

  bool EndRead3dmGroupTable();


  ///////////////////////////////////////////////////////////////////
  // Step 10: REQUIRED - Write/Read font table (it can be empty)
  //
  bool BeginWrite3dmFontTable();
  bool Write3dmFont( const ON_Font& );
  bool EndWrite3dmFontTable();

  bool BeginRead3dmFontTable();

  // Description:
  //   Reads fonts from font table.  If the font definition is
  //   read, a font is created by calling new ON_Font(),
  //   initialized with values stored in the archive, and 
  //   returned.
  //
  // Parameters:
  //   ppFont - If the font definition is
  //   read, a font is created by calling new ON_Font(),
  //   initialized with values stored in the archive, and 
  //   a pointer to the new font is returned in *ppFont.
  //
  // Returns:
  //
  //   @untitled table
  //   0     at the end of the font table
  //   1     font definition was successfully read
  //   -1    archive is corrupt at this point
  //
  // Example:
  //   Calls to Read3dmFont need to be bracketed by calls
  //   to BeginRead3dmFontTable() / EndRead3dmFontTable().
  //
  //           archive.BeginRead3dmFontTable();
  //           int rc = 1;
  //           ON_Font* pFont;
  //           while(rc==1)
  //           { //
  //             pFont = 0;
  //             archive.Read3dmFont(&pFont);
  //             if ( pFont )
  //               do something with pFont
  //           } //
  //           archive.EndRead3dmFontTable();
  //      
  int Read3dmFont(
            ON_Font** // ppFont
            );

  bool EndRead3dmFontTable();


  ///////////////////////////////////////////////////////////////////
  // Step 11: REQUIRED - Write/Read dimstyle table (it can be empty)
  //
  bool BeginWrite3dmDimStyleTable();
  bool Write3dmDimStyle( const ON_DimStyle& );
  bool EndWrite3dmDimStyleTable();

  bool BeginRead3dmDimStyleTable();

  // Description:
  //   Reads annotation dimension styles from dimension style table.
  //   If the dimension style definition is read, 
  //   a dimension style is created by calling new ON_DimStyle(),
  //   initialized with values stored in the archive, and 
  //   returned.
  //
  // Parameters:
  //   ppDimStyle - If the dimstyle definition is
  //   read, a dimstyle is created by calling new ON_DimStyle(),
  //   initialized with values stored in the archive, and 
  //   a pointer to the new dimstyle is returned in *ppDimStyle.
  //
  // Returns:
  //
  //   @untitled table
  //   0     at the end of the dimension style table
  //   1     dimension style definition was successfully read
  //   -1    archive is corrupt at this point
  //
  // Example:
  //   Calls to Read3dmDimStyle need to be bracketed by calls
  //   to BeginRead3dmDimStyleTable() / EndRead3dmDimStyleTable().
  //
  //           archive.BeginRead3dmDimStyleTable();
  //           int rc = 1;
  //           ON_DimStyle* pDimStyle;
  //           while(rc==1)
  //           { //
  //             pDimStyle = 0;
  //             archive.Read3dmDimStyle(&pDimStyle);
  //             if ( pDimStyle )
  //               do something with pDimStyle
  //           } //
  //           archive.EndRead3dmDimStyleTable();
  //      
  int Read3dmDimStyle(
            ON_DimStyle** // ppDimStyle
            );

  bool EndRead3dmDimStyleTable();


  ///////////////////////////////////////////////////////////////////
  // Step 12: REQUIRED - Write/Read render light table (it can be empty)
  //
  bool BeginWrite3dmLightTable();
  bool Write3dmLight( const ON_Light&,
         const ON_3dmObjectAttributes* // optional
         );
  bool EndWrite3dmLightTable();

  bool BeginRead3dmLightTable();
  int  Read3dmLight(  // returns 0 at end of light table
                      //         1 light successfully read
                      //        -1 if file is corrupt
            ON_Light**, // light returned here
            ON_3dmObjectAttributes* // optional - if NOT NULL, object attributes are
                                    //            returned here
            );
  bool EndRead3dmLightTable();


  ///////////////////////////////////////////////////////////////////
  // Step 13: REQUIRED - Write/Read hatch pattern table (it can be empty)
  //
  bool BeginWrite3dmHatchPatternTable();
  bool Write3dmHatchPattern( const ON_HatchPattern&);
  bool EndWrite3dmHatchPatternTable();

  bool BeginRead3dmHatchPatternTable();
  int  Read3dmHatchPattern(ON_HatchPattern**);
  bool EndRead3dmHatchPatternTable();

  ///////////////////////////////////////////////////////////////////
  // Step 14: REQUIRED - Write/Read instance definition table (it can be empty)
  //
  bool BeginWrite3dmInstanceDefinitionTable();
  bool Write3dmInstanceDefinition( const ON_InstanceDefinition& );
  bool EndWrite3dmInstanceDefinitionTable();

  bool BeginRead3dmInstanceDefinitionTable();

  /*
   Description:
     Reads instance definitions from instance defintion table.
  
   Parameters:
     ppInstanceDefinition - If an instance defintion is
     read, an instance defintion is created by calling new 
     ON_InstanceDefinition(), initialized with values stored
     in the archive, and a pointer to the new instance defintion
     is returned in *ppInstanceDefinition.
  
   Returns:
  
     @untitled table
     0     at the end of the instance defintion table
     1     instance defintion was successfully read
     -1    archive is corrupt at this point
  
   Example:
     Calls to Read3dmInstanceDefinition need to be bracketed by calls
     to BeginRead3dmInstanceDefinitionTable() / EndRead3dmInstanceDefinitionTable().
  
             archive.BeginRead3dmInstanceDefinitionTable();
             int rc = 1;
             ON_InstanceDefinition* pInstanceDefinition;
             while(rc==1)
             { 
               pInstanceDefinition = 0;
               archive.Read3dmInstanceDefinition(&pInstanceDefinition);
               if ( pInstanceDefinition )
                 do something with pInstanceDefinition
             } 
             archive.EndRead3dmInstanceDefinitionTable();
  */      
  int Read3dmInstanceDefinition(
            ON_InstanceDefinition** // ppInstanceDefinition
            );

  bool EndRead3dmInstanceDefinitionTable();

  ///////////////////////////////////////////////////////////////////
  // Step 15: REQUIRED - Write/Read geometry and annotation table (it can be empty)
  //
  bool BeginWrite3dmObjectTable();
  bool Write3dmObject( 
         const ON_Object&,
         const ON_3dmObjectAttributes* // optional
         );
  bool EndWrite3dmObjectTable();

  bool BeginRead3dmObjectTable();
  int  Read3dmObject( // returns 0 at end of object table
                      //         1 if object is read
                      //         2 if object is skipped because it does not match filter
                      //        -1 if file is corrupt
          ON_Object**, // object returned here (NULL if skipped)
          ON_3dmObjectAttributes*, // optional - if NOT NULL, object attributes are
                                   //            returned here
          unsigned int = 0 // optional filter made by setting ON::object_type bits
          );  // returns NULL at end of object table
  bool EndRead3dmObjectTable();

  ///////////////////////////////////////////////////////////////////
  // Step 16: REQUIRED - Write/Read history record table (it can be empty)
  //
  bool BeginWrite3dmHistoryRecordTable();
  bool Write3dmHistoryRecord( 
         const class ON_HistoryRecord&
         );
  bool EndWrite3dmHistoryRecordTable();

  bool BeginRead3dmHistoryRecordTable();

  /*
  Returns:
           0 at end of object table
           1 if object is read
          -1 if file is corrupt
  */
  int  Read3dmHistoryRecord(
          class ON_HistoryRecord*&
          );
  bool EndRead3dmHistoryRecordTable();

  ///////////////////////////////////////////////////////////////////
  // Step 17: OPTIONAL - Write/Read 0 or more user tables
  //

  /*
  Description:
    Write the user table header information that must precede
    the user table information written by a plug-in.
  Parameters:
    plugin_id - [in]
    bSavingGoo - [in]
      Set to false if a plug-in will be used to write
      the user table.  Set to true if a user table written by
      a missing plug-in is being resaved. In this case,
      goo_3dm_version and goo_opennurbs_version must also be
      set.  In practice, you should use Write3dmAnonymousUserTableRecord()
      to handle writing "goo" and use this function only when
      the plug-in in present.
    goo_3dm_version - [in]
      If bSavingGoo is false, this parameter must be zero and
      ON_BinaryArchive::Archive3dmVersion() will be used.
      If bSavingGoo is true, this parameter must be the version of 
      the 3dm archive (1,2,3,4,5,50,...) the plug-in code used to 
      write the user table.
    goo_opennurbs_version - [in]
      If bSavingGoo is false, this parameter must be zero and
      ON_BinaryArchive::ArchiveOpenNURBSVersion() will be used.
      If bSavingGoo is true, this parameter must be the version
      of the opennurbs (YYYYMMDDN) the plug-in code used to 
      write the user table.
  Returns:
    True if the the user information can be written.
    False if user informtion should not be written.
  */
  bool BeginWrite3dmUserTable(
    const ON_UUID& plugin_id,
    bool bSavingGoo,
    int goo_3dm_version,
    int goo_opennurbs_version
    );

  bool EndWrite3dmUserTable();

  /*
  Description:
    If Read3dmAnaonymousUserTable() was used to read ON_3dmGoo because a 
    plug-in was not present, then use Write3dmAnonymousUserTableRecord()
    to put than information back into the archive.
    Write3dmAnonymousUserTableRecord() writes the entire record.
    Do NOT call BeginWrite3dmUserTable() / EndWrite3dmUserTable() when
    using Write3dmAnonymousUserTableRecord().
  Parameters:
    plugin_id - [in]
    goo_version - [in]
      The version of the archive (1,2,3,4,5,50,...) that was used when
      the plug-in wrote the user table.
    goo_opennurbs_version - [in]
      The version of opennurbs ( YYYMMDDN ) that was used when the 
      plug-in wrote the user table.
    goo - [in]
  Returns:
    True if the goo was written or skipped because it could not be robustly
    saved.  False if a catastrophic IO error occured.
  */
  bool Write3dmAnonymousUserTableRecord( 
    const ON_UUID& plugin_id,
    int goo_3dm_version,
    int goo_opennurbs_version,
    const ON_3dmGoo& goo
    );

  // OBSOLETE - use BeginWrite3dmUserTable(plugin_id, bSavingGoo, 3dm_version, opennurbs_version )
  ON_DEPRECATED bool BeginWrite3dmUserTable( const ON_UUID& );

  // OBSOLETE - use Write3dmAnonymousUserTableRecord(plugin_id, ..., goo)
  ON_DEPRECATED bool Write3dmAnonymousUserTable( const ON_3dmGoo& );

  /*
  Parameters:
    plugin_id - [out] 
      id of plug-in that wrote the user table
    bLastSavedAsGoo - [out] 
      True if this table was saved into this archive as goo because
      the plug-in was not present at the time of the save.
    archive_3dm_version - [out]
      Version of the archive the plug-in wrote to.  When bLastSavedAsGoo
      is true, this number can be different from Archive3dmVersion().
    archive_opennurbs_version - [out]
      Version of opennurbs the plug-in used to write the archive.  
      When bLastSavedAsGoo is true, this number can be different 
      from ArchiveOpenNURBSVersion().     
  Returns:
    False when there are no more user tables or an IO error occurs.
  */
  bool BeginRead3dmUserTable(
    ON_UUID& plugin_id,
    bool* bLastSavedAsGoo,
    int* archive_3dm_version,
    int* archive_opennurbs_version
    );

  /*
  Description:
    If the plug-in that wrote the user table is not present and you need
    to read and resave the user table, then use Read3dmAnonymousUserTable()
    to load the information into "goo".
    If you do not need to resave the information, then simply call EndRead3dmUserTable()
    to skip over this table.
  */
  bool Read3dmAnonymousUserTable( 
    int archive_3dm_version,
    int archive_opennurbs_version,
    ON_3dmGoo& goo
    );

  bool EndRead3dmUserTable();

  // OBSOLETE - use BeginRead3dmUserTable( plugin_id, bLastSavedAsGoo, archive_3dm_version, ... )
  ON_DEPRECATED bool BeginRead3dmUserTable(
    ON_UUID&
    );

  // OBSOLETE - use Read3dmAnonymousUserTable( archive_3dm_version, archive_opennurbs_version, goo )
  ON_DEPRECATED bool Read3dmAnonymousUserTable( ON_3dmGoo& );




  ///////////////////////////////////////////////////////////////////
  // Step 18: REQUIRED when writing / OPTIONAL when reading
  //         Write end of file marker.  This information is primarily
  //         used when debugging files to make sure the end of the file
  //         hasn't been cut off.
  //

  // Description:
  //   Writes a TCODE_ENDOFFILE chunk that contains the number
  //   of bytes in the archive.
  //
  // Returns:
  //   true if successful, false if unable to write to archive.
  bool Write3dmEndMark();

  // Description:
  //   Checks for a TCODE_ENDOFFILE chunk at the current position.
  //   If it finds one, it reads it and returns the number
  //   of bytes in the archive.  Comparing this number with
  //   the current file position can help detect files that
  //   have been damaged by loosing sections.
  //
  // Parameters:
  //   sizeof_archive - [out] number of bytes written to archive
  //
  // Returns:
  //   true if successful, false if unable to find or read
  //   a TCODE_ENDOFFILE chunk.
  bool Read3dmEndMark( 
           size_t* // sizeof_archive
           );

  ///////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////
  // Low level tools to  Write/Read chunks. See opennurbs_3dm.h for details
  // about the structure of chunks.  Every chunk must begin with a
  // call to BeginWrite/ReadChunk().
  // If BeginWriteChunk()/BeginReadChunk() returns true, then
  // you must call EndWrite/ReadChunk() or cease using the archive.

  // Description:
  //   Writes a chunk header containing 4 byte typecode and value.
  //
  // Parameters:
  //   typecode - [in] a TCODE_* number from opennurbs_3dm.h
  //   value    - [in] if (typecode&TCODE_SHORT) is nonzero, then
  //              this is the value to be saved.  Othewise, pass
  //              a zero and the EndWrite3dmChunk() call will
  //              store the length of the chunk.
  //
  // Returns:
  //   true if write was successful.
  bool BeginWrite3dmChunk(
        unsigned int, // typecode
        int // value
        );

  bool BeginWrite3dmBigChunk(
        ON__UINT32 typecode,
        ON__INT64 value
        );

  /*
  Description:
    Begins writing a chunk.
  Parameters:
    tcode - [in] chunk's typecode from opennurbs_3dm.h.  This cannot be a short tcode.
    major_version - [in] ( >= 1)
    minor_version - [in] ( >= 0 )
  Returns:
    True if input was valid and chunk was started.  In this case
    You must call EndWrite3dmChunk(), even if something goes wrong
    while you attempt to write the contents of the chunk.
    False if input was not valid or the write failed.
  */
  bool BeginWrite3dmChunk(
        unsigned int tcode,
        int major_version,
        int minor_version
        );


  // updates length in chunk header
  bool EndWrite3dmChunk();

  bool Write3dmGoo( const ON_3dmGoo& ); // call to write "goo"

  // OBSOLETE - Use BeginRead3dmBigChunk()
  ON_DEPRECATED bool BeginRead3dmChunk(
        unsigned int*,   // typecode from opennurbs_3dm.h
        int*             // value
        );

  // When the end of the 3dm file is reached, BeginReadChunk() will
  // return true with a typecode of TCODE_ENDOFFILE.
  bool BeginRead3dmBigChunk(
        unsigned int*,   // typecode from opennurbs_3dm.h
        ON__INT64*       // value
        );
  /*
  Description:
    Begins reading a chunk that must be in the archive at this location.
  Parameters:
    expected_tcode - [in] chunk's typecode from opennurbs_3dm.h
    major_version - [out] 
    minor_version - [out] 
  Returns:
    True if beginning of the chunk was read.  In this case
    You must call EndRead3dmChunk(), even if something goes wrong
    while you attempt to read the interior of the chunk.
    False if the chunk did not exist at the current location in the file.
  */
  bool BeginRead3dmChunk(
        unsigned int expected_tcode,
        int* major_version,
        int* minor_version
        );

  /*
  Description:
    Calling this will skip rest of stuff in chunk if it was only partially read.
  Parameters:
    bSupressPartiallyReadChunkWarning - [in]
      Generally, a call to ON_WARNING is made when a chunk is partially
      read.  If bSupressPartiallyReadChunkWarning is true, then
      no warning is issued for partially read chunks.
  */
  bool EndRead3dmChunk(); 
  bool EndRead3dmChunk(bool bSupressPartiallyReadChunkWarning); 


  ///////////////////////////////////////////////////////////////////
  //
  // Tools for dictionary IO (used in .NET)
  //

  /*
  Description:
    Begins writing a dictionary.
  Parameters:
    dictionary_id - [in]
    version - [in]
      It is suggested that you use YYYYMMDD as the version number.
    dictionary_name - [in]
      You may pass NULL.
  Remarks:
    Begins a new chunk with tcode TCODE_DICTIONARY and then writes
    a TCODE_DICTIONARY_ID chunk containing the id, version and name.
    After calling this function, you may either write entries by
    calling
      BeginWriteDictionaryEntry(); 
      write entry definition...
      EndWriteDictionaryEntry();
    or you may finish writing the dictionay by calling
      EndWriteDictionary();
  */
  bool BeginWriteDictionary(
          ON_UUID dictionary_id,
          unsigned int version,
          const wchar_t* dictionary_name
          );
  /*
  Description:
    Begins writing a dictionary entry.
  Parameters:
    de_type - [in]
    entry_name - [in]
  Returns:
    true 
      Entry header was written and you must call EndWriteDictionary()
      after writing the entry data.
    false 
      Failed to write entry header.  Do not call EndWriteDictionary().
  Remarks:
    Begins a new chunk with tcode TCODE_DICTIONARY_ENTRY,
    then writes the int, and then writes the string.
  */
  bool EndWriteDictionary();

  /*
  Description:
    Begins writing a dictionary entry.
  Parameters:
    de_type - [in]
    entry_name - [in]
  Returns:
    true 
      Entry header was written and you must call EndWriteDictionary()
      after writing the entry data.
    false 
      Failed to write entry header.  Do not call EndWriteDictionary().
  Remarks:
    Begins a new chunk with tcode TCODE_DICTIONARY_ENTRY,
    then writes the int, and then writes the string.
  */
  bool BeginWriteDictionaryEntry(
          int de_type, 
          const wchar_t* entry_name
          );
  bool EndWriteDictionaryEntry();

  bool BeginReadDictionary(
          ON_UUID* dictionary_id,
          unsigned int* version,
          ON_wString& dictionary_name
          );
  bool EndReadDictionary();

  /*
  Description:
    Begin reading a dictionary entry.
  Parameters:
    de_type - [out]
    entry_name - [out]
  Returns:
    0: serious IO error
    1: success
        read information and then call EndReadDictionaryEntry()
    2: at end of dictionary
  */
  int BeginReadDictionaryEntry(
          int* de_type, 
          ON_wString& entry_name
          );
  bool EndReadDictionaryEntry();

  bool Read3dmGoo( ON_3dmGoo& ); // Call to read "goo"

  // OBSOLETE - Use PeekAt3dmBigChunkType()
  ON_DEPRECATED bool PeekAt3dmChunkType( // does not change file position
        unsigned int*,   // typecode from opennurbs_3dm.h
        int*             // value
        );

  bool PeekAt3dmBigChunkType( // does not change file position
        ON__UINT32* typecode,
        ON__INT64* big_value
        );

  bool Seek3dmChunkFromStart( 
        // beginning at the start of the active chunk, search portion of
        // archive included in active chunk for the start of a subchunk 
        // with the specified type.
        // if true is returned, then the position is set so the next call to
        // BeginRead3dmChunk() will read a chunk with the specified typecode
        unsigned int    // typecode from opennurbs_3dm.h
        );
  bool Seek3dmChunkFromCurrentPosition( 
        // beginning at the current position, search portion of archive
        // included in active chunk for the start of a subchunk with the
        // specified type.
        // if true is returned, then the position is set so the next call to
        // BeginRead3dmChunk() will read a chunk with the specified typecode
        unsigned int    // typecode from opennurbs_3dm.h
        );

  // A chunk version is a single byte that encodes a major.minor 
  // version number.  Useful when creating I/O code for 3dm chunks
  // that may change in the future.  Increment the minor version 
  // number if new information is added to the end of the chunk. 
  // Increment the major version if the format of the chunk changes
  // in some other way.
  bool Write3dmChunkVersion(
    int, // major // 0 to 15
    int  // minor // 0 to 16
    );
  bool Read3dmChunkVersion(
    int*, // major // 0 to 15
    int*  // minor // 0 to 16
    );

  /*
  Description:
    Low level tool to writes user data attached to the 
    object.  This function should never be called
    directly.
  Parameters:
    object - [in]
  Returns:
    True if successful.
  */
  bool WriteObjectUserData( const ON_Object& object );

  /*
  Description:
    Low level tool to read user data and attach it to
    the object.  This function should never be called
    directly.
  Parameters:
    object - [in/out]
  Returns:
    True if successful.
  */
  bool ReadObjectUserData( ON_Object& object );

  /*
  Description:
    If a 3dm archive is being read or written, then this is the
    version of the 3dm archive format (1, 2, 3, 4 or 5).
  Returns:
    @untitle table
    0     a 3dm archive is not being read/written
    1     a version 1 3dm archive is being read/written
    2     a version 2 3dm archive is being read/written
    3     a version 3 3dm archive is being read/written
    4     a version 4 3dm archive is being read/written
    5     an old version 5 3dm archive is being read
    50    a version 5 3dm archive is being read/written
  See Also:
    ON_BinaryArchive::ArchiveOpenNURBSVersion
  */
  int Archive3dmVersion() const;

  /*
  Description:
    If a 3dm archive is being read, then this is the version
    of openNURBS that was used to write the archive.  This value
    is only available after ON_BinaryArchive::Read3dmProperties
    is called.
  See Also:
    ON_BinaryArchive::Archive3dmVersion
    ON_BinaryArchive::Read3dmProperties
  Returns:
    Version of openNURBS used to write the archive.  The openNURBS
    version is the value returned by ON::Version.
  See Also:
    ON::Version
    ON_BinaryArchive::Read3dmProperties
    ON_BinaryArchive::Archive3dmVersion
  Remarks:
    This value is rarely needed.  You probably want to
    use ON_BinaryArchive::Archive3dmVersion.
  */
  int ArchiveOpenNURBSVersion() const;

  /*
  Description:
    When a 3dm archive is saved from an MFC application that
    supports Windows linking/embedding, the first 5kb to 1mb
    of the file contains information that is put there by MFC.
    ArchiveStartOffset() returns the offset into the file where
    the 3dm archive actually begins. The call to 
    ON_BinaryArchive::Read3dmStartSection() calculates this
    offset and stores the value in m_3dm_start_section_offset.
  Returns:
    Offset into the binary "file" where the actual 3dm archive
    begins.
  Remarks:
    Generally, this value can be ignored. This function is
    a diagnostice tool that is used to analyzed damaged files.
  */
  size_t ArchiveStartOffset() const;

  enum table_type
  {
    no_active_table = 0,
    properties_table,
    settings_table,
    bitmap_table,
    texture_mapping_table,
    material_table,
    linetype_table,
    layer_table,
    light_table,
    object_table,
    group_table,
    font_table,
    dimstyle_table,
    hatchpattern_table,
    instance_definition_table,
    historyrecord_table,
    user_table
  };

  /*
  Description:
    Expert user function for reading damaged files.
  Parameters:
    chunk - [out] current chunk.
  Returns:
    Level of the chunk or 0 if there is no current
    chunk.
  */
  int GetCurrentChunk(ON_3DM_CHUNK& chunk) const;
  int GetCurrentChunk(ON_3DM_BIG_CHUNK& big_chunk) const;

  /*
  Description:
    Expert user function for reading damaged files.  The search starts
    at the beginning of the file.
  Parameters:
    tcode_table - [in] typecode of the table
    tcode_record - [in] typecode of the record
    class_uuid - [in] id of the opennurbs class in the record
    min_length_data - [in] minimum size of the opennurbs class data
  Returns:
    True if the table start is found.  In this case the current
    position of the archive is at the start of the table and
    the standared BeginRead3dm...Table() function can be used.
    False if the table start is not found.
  */
  bool FindTableInDamagedArchive(
          unsigned int tcode_table,
          unsigned int tcode_record,
          ON_UUID class_uuid,
          int min_length_data
          );

  /*
  Description:
    Expert user function for studying contents of a file.
    The primary use is as an aid to help dig through files
    that have been damaged (bad disks, transmission errors, etc.)
    If an error is found, a line that begins with the word
    "ERROR" is printed.
  Parameters:
    text_log - [in] place to print informtion
    recursion_depth - [in] simply a counter
        to aid in debugging.
  Returns:
    0 if something went wrong, otherwise the typecode
    of the chunk that was just studied.
  */
  unsigned int 
  Dump3dmChunk(
        ON_TextLog& text_log, 
        int recursion_depth = 0
        );

protected:

  /*
  Description:
    Works like the C runtrim fread().
  Returns:
    actual number of bytes read (like fread())
  */
  virtual
  size_t Read( size_t, void* ) = 0; 

  /*
  Description:
    Works like the C runtrim fwrite().
  Returns:
    actual number of bytes written (like fwrite())
  */
  virtual
  size_t Write( size_t, const void* ) = 0;

  /*
  Description:
    Force Write() to flush any buffered data to physical archive.
  Returns:
    True if succesful or if there is nothing to flush.  False if
    information could not be flushed.
  */
  virtual
  bool Flush() = 0;

  /*
  Description:
    When ON_BinaryArchive::ReadObject() encounters userdata and
    the user data class id is not present,  LoadUserDataApplication
    is called to load the application that created user data.
  Returns:
    0 - could not load the application
    1 - successfully loaded the application
    2 - the application was already loaded
  */
  virtual
  int LoadUserDataApplication( 
    ON_UUID application_id 
    );

  bool SetArchive3dmVersion(int);

private:
  // 16 bit integer IO
  bool WriteInt8( size_t, const ON__INT8* );
  bool ReadInt8( size_t, ON__INT8* );

  // 16 bit integer IO
  bool WriteInt16( size_t, const ON__INT16* );
  bool ReadInt16( size_t, ON__INT16* );

  // 32 bit integer IO
  bool WriteInt32( size_t, const ON__INT32* );
  bool ReadInt32( size_t, ON__INT32* );

  // 64 bit integer IO
  bool WriteInt64( size_t, const ON__INT64* );
  bool ReadInt64(  size_t, ON__INT64* );

  bool BeginWrite3dmTable( 
    unsigned int // tcode
    );
  bool EndWrite3dmTable( 
    unsigned int // tcode
    );
  bool BeginRead3dmTable( 
    unsigned int // tcode
    );
  bool EndRead3dmTable( 
    unsigned int // tcode
    );
  
  bool Read3dmV1Layer( ON_Layer*& );
  int  Read3dmV1Light(  // returns 0 at end of light table
                      //         1 light successfully read
                      //        -1 if file is corrupt
            ON_Light**, // light returned here
            ON_3dmObjectAttributes* // optional - if NOT NULL, object attributes are
                                    //            returned here
            );
  int Read3dmV1Material( ON_Material** );
  int  Read3dmV1Object( // returns 0 at end of object table
                      //         1 if object is read
                      //         2 if object is skipped because it does not match filter
                      //        -1 if file is corrupt
          ON_Object**, // object returned here (NULL if skipped)
          ON_3dmObjectAttributes*, // optional - if NOT NULL, object attributes are
                                   //            returned here
          unsigned int = 0 // optional filter made by setting ON::object_type bits
          );  // returns NULL at end of object table

  bool Read3dmV1AttributesOrMaterial( 
            ON_3dmObjectAttributes*,    // attributes,
            ON_Material*,      // material,
            ON_BOOL32&,             // bHaveMat
            unsigned int,      // end_mark_tcode 
            class ON__3dmV1_XDATA* = 0 // v1 "xdata"
            );
  bool Read3dmV1String( ON_String& );
  int  Read3dmV1LayerIndex( const char* ) const;

public:
  // helpers for reading V1 objects
  bool ReadV1_TCODE_RH_POINT(ON_Object**,ON_3dmObjectAttributes*);
  bool ReadV1_TCODE_MESH_OBJECT(ON_Object**,ON_3dmObjectAttributes*);
  bool ReadV1_TCODE_LEGACY_CRV(ON_Object**,ON_3dmObjectAttributes*);
  bool ReadV1_TCODE_LEGACY_FAC(ON_Object**,ON_3dmObjectAttributes*);
  bool ReadV1_TCODE_LEGACY_SHL(ON_Object**,ON_3dmObjectAttributes*);
  bool ReadV1_TCODE_RHINOIO_OBJECT_NURBS_CURVE(ON_Object**,ON_3dmObjectAttributes*);
  bool ReadV1_TCODE_RHINOIO_OBJECT_NURBS_SURFACE(ON_Object**,ON_3dmObjectAttributes*);
  bool ReadV1_TCODE_RHINOIO_OBJECT_BREP(ON_Object**,ON_3dmObjectAttributes*);
  bool ReadV1_TCODE_ANNOTATION(unsigned int,ON_Object**,ON_3dmObjectAttributes*);

private:
  ON::archive_mode Mode() const; // current read/write mode
  void UpdateCRC( size_t, const void* );
  int ReadObjectHelper(ON_Object**);

  int m_3dm_version;
  int m_3dm_v1_layer_index;
  int m_3dm_v1_material_index;

  // The bits in m_error_message_mask are used to mask errors
  // when we know we are doing something that may generate an
  // error.
  //
  // bit 0x00000001
  //   V1 files do not have a table structure and are read using
  //   multiple passes and there are valid situations where a 
  //   4 byte read is attempted at the end of a file.
  //
  // bit 0x00000002
  //   Some v1 files do not have an end mark.  When reading
  //   these v1 files bit 0x02 is set.
  //
  // bit 0x00000004
  //   Requested read may go beyond end of file.
  //   One situation where this happens is when a table is not at the 
  //   expected location in a file, 

  unsigned int m_error_message_mask;
protected:
  unsigned int ErrorMessageMask() const;
  /*
  Paramters:
    sizeof_request - [in] 
      value of count parameter passed to virtual Read() function.
    sizeof_read - [in]
      number of bytes actually read by the virtual Read() function.
  Returns:
    True if a call to Read() is permitted to ask for more bytes
    than are left in the file.  This value varies as the file
    is read and must be checked at each failure.
  */
  bool MaskReadError( ON__UINT64 sizeof_request, ON__UINT64 sizeof_read ) const;
private:


  // When a 3DM archive is read, m_3dm_opennurbs_version records the version of
  // OpenNURBS used to create the archive.  Otherwise, m_3dm_opennurbs_version
  // is zero.
  //
  // Read3dmProperties() sets this to the version of OpenNURBS that was
  // used to write file file.  If the file was created using a version
  // of OpenNURBS before 200012210, this number will be zero.
  //
  // Write3dmProperties() stores the value returned by ON::Version() in
  // the archive's properties table.
  friend void ON_SetBinaryArchiveOpenNURBSVersion(ON_BinaryArchive&,int);
  int m_3dm_opennurbs_version;

  // When a 3dm archive is saved from an MFC application that supports
  // Windows linking/embedding, the first 5kb to 1mb of the file contains
  // information that is put there by MFC.  m_3dm_start_section_offset
  // records the offset into the file where the 3dm archive actually begins.
  size_t m_3dm_start_section_offset;

  table_type m_active_table;

  table_type TableTypeFromTypecode( unsigned int ); // table type from tcode

  ON_SimpleArray<ON_3DM_BIG_CHUNK> m_chunk;

  // stack of chunks
  bool PushBigChunk( ON__UINT32 typecode, ON__INT64 value );

  bool WriteChunkTypecode( ON__UINT32 );
  bool ReadChunkTypecode( ON__UINT32* );
  bool WriteChunkValue( ON__UINT32 typecode, ON__INT64 );
  bool WriteChunkLength( ON__UINT64 );
  bool ReadChunkValue( ON__UINT32 typecode, ON__INT64* value64 );
  bool FindMisplacedTable( 
        ON__UINT64 filelength,
        const ON__UINT32 table_tocde,
        const ON__UINT32 table_record_record,
        const ON_UUID class_uuid,
        const ON__UINT64 min_length_data
        );

  bool ReadObjectUserDataAnonymousChunk(
          const ON__UINT64 length_TCODE_ANONYMOUS_CHUNK,
          const int archive_3dm_version,
          const int archive_opennurbs_version,
          class ON_UserData* ud );

public:
  size_t SizeofChunkLength() const;

private:
  bool WriteEOFSizeOfFile( ON__UINT64 );
  bool ReadEOFSizeOfFile( ON__UINT64* );

  bool m_bDoChunkCRC; // true if active chunk crc status should be checked
                      // and updated.
  int m_bad_CRC_count; // number of chunks that have a bad crc


private:
  // compressed buffer I/O uses zlib 1.1.3 inflate()/deflate()
  struct
  {
    ON::archive_mode mode; // ON::read = read and inflate,  ON::write = deflate and write
    enum
    {
      sizeof_x_buffer = 16384
    };
    unsigned char    buffer[sizeof_x_buffer];
    z_stream         strm;
  } m_zlib;

  // returns number of bytes written
  size_t WriteDeflate(
        size_t,         // sizeof uncompressed input data
        const void*  // uncompressed input data
        );
  bool ReadInflate(
        size_t,  // sizeof uncompressed input data
        void* // buffer to hold uncompressed data
        );
  bool CompressionInit();
  void CompressionEnd();

private:
  // endian-ness of the cpu reading this file.
  // 3dm files are alwasy saved with little endian byte order.
  ON::endian m_endian;

  ON::archive_mode m_mode;

  // 3dm write options
  bool m_bSaveUserData; // true to save user data (increases file size)
  bool m_bSavePreviewImage;    // true to save 200x200 preview bitmap (increases file size)
  bool m_bEmbedTextureBitmaps; // true to embed texture, bump, trace, and wallpaper bitmaps (increases file size)
  bool m_bSaveRenderMeshes;    // true to save meshes used to render B-rep objects (increases file size)
  bool m_bSaveAnalysisMeshes;  // true to save meshes used in surface analysis (increases file size)

  // ids of plug-ins that support saving older (V3) versions
  // of user data.  This information is filled in from the
  // list of plug-ins passed in whenteh settings are saved.
  ON_SimpleArray< ON_UUID > m_V3_plugin_id_list;

  struct ON__3dmV1LayerIndex* m_V1_layer_list;

  // prohibit default construction, copy construction, and operator=
  ON_BinaryArchive();
  ON_BinaryArchive( const ON_BinaryArchive& ); // no implementation
  ON_BinaryArchive& operator=( const ON_BinaryArchive& ); // no implementation

};

class ON_CLASS ON_3dmGoo
{
  // used to store goo
public:
  ON_3dmGoo();
  ~ON_3dmGoo();
  ON_3dmGoo( const ON_3dmGoo& );
  ON_3dmGoo& operator=( const ON_3dmGoo& );

  void Dump(ON_TextLog&) const;

  unsigned int m_typecode;
  int m_value;
  unsigned char* m_goo;
  ON_3dmGoo* m_next_goo;
  ON_3dmGoo* m_prev_goo;
};


class ON_CLASS ON_BinaryFile : public ON_BinaryArchive
{
public:
  ON_BinaryFile( ON::archive_mode );

  /*
  Description:
    Create an ON_BinaryArchive that reads/writes from an ordinary file.
  Parameters:
    mode - [in]
    fp - [in]
      If a file is being read, fp is the pointer returned 
      from ON_FileStream::Open(...,"rb").
      If a file is being written, fp is the pointer returned 
      from ON_FileStream::Open(...,"wb").
  */
  ON_BinaryFile( ON::archive_mode, FILE* fp );

  virtual ~ON_BinaryFile();

  // ON_BinaryArchive overrides
  size_t CurrentPosition() const; 
  bool SeekFromCurrentPosition(int);
  bool SeekFromStart(size_t);
  bool AtEnd() const;

  // fseek from end (since the file has an end)
  bool SeekFromEnd( int ); 

  //////////
  // To use custom memory buffering instead of relying
  // on fread()/fwrite()'s build in buffering, call
  // EnableMemoryBuffer() with the buffer size immediately
  // after constructing the ON_BinaryFile.  There appear
  // to be enough bugs in existing Windows NT/2000 NETWORK
  // I/O that using this hack will speed up I/O by factors
  // of 10 to 100.
  void EnableMemoryBuffer(
         int=16384 // capacity of memory buffer
         );

protected:
  size_t Read( size_t, void* );
  size_t Write( size_t, const void* );
  bool Flush();

private:
  // Implementation
  FILE* m_fp;

  // if m_memory_buffer_capacity is zero, then Write() uses
  // fwrite() directly.  If m_memory_buffer_capacity is
  // greater than zero, then Write() buffers its results
  // into m_memory_buffer.  This is provided to work around
  // bugs in some networks that result in extremely slow
  // performance when seeking is used.
  size_t m_memory_buffer_capacity;
  size_t m_memory_buffer_size;
  size_t m_memory_buffer_ptr;
  unsigned char* m_memory_buffer;

private:
  // prohibit default construction, copy construction, and operator=
  ON_BinaryFile( ); // no implementation
  ON_BinaryFile( const ON_BinaryFile& ); // no implementation
  ON_BinaryFile& operator=( const ON_BinaryFile& ); // no implementation
};

class ON_CLASS ON_BinaryArchiveBuffer : public ON_BinaryArchive
{
public:
  /*
  Description:
    Create an ON_BinaryArchive that reads/writes from an ON_Buffer.
  Parameters:
    mode - [in]
    buffer - [in]
  Remarks:
    If a non-null buffer is specifed, then do not call SetBuffer()
  */
  ON_BinaryArchiveBuffer( ON::archive_mode, ON_Buffer* buffer );

  virtual ~ON_BinaryArchiveBuffer();

  /*
  Description:
    If the ON_BinaryArchiveBuffer class is created with the constructor
    that has a single "mode" parameter, then use SetBuffer()
    to specify the buffer to read/write from before using
    the ON_BinaryArchiveBuffer.
  Parameters:
    buffer - [in]
  Returns:
    True if the buffer is set.  Once the buffer is set it
    cannot be changed.
  */
  bool SetBuffer( ON_Buffer* buffer );

  /*
  Returns:
    Buffer being read/written. 
  */
  ON_Buffer* Buffer() const;

  // virtual ON_BinaryArchive overrides
  size_t CurrentPosition() const; 
  bool SeekFromCurrentPosition(int);
  bool SeekFromStart(size_t);
  bool AtEnd() const;

  bool SeekFromEnd( ON__INT64 ); 

protected:
  size_t Read( size_t, void* );
  size_t Write( size_t, const void* );
  bool Flush();

private:
  // Buffer being read/written.
  ON_Buffer* m_buffer;

private:
  // prohibit use - you should specify a buffer.
  ON_BinaryArchiveBuffer( ON::archive_mode );
private:
  // prohibit default construction, copy construction, and operator=
  ON_BinaryArchiveBuffer( ); // no implementation
  ON_BinaryArchiveBuffer( const ON_BinaryArchiveBuffer& ); // no implementation
  ON_BinaryArchiveBuffer& operator=( const ON_BinaryArchiveBuffer& ); // no implementation
};


class ON_CLASS ON_Read3dmBufferArchive : public ON_BinaryArchive
{
public:

  /*
  Description:
    Construct an ON_BinaryArchive for reading information from a memory buffer.
  Parameters:
    sizeof_buffer - [in] size of buffer in bytes (>0)
    buffer - [in] memory buffer containing binary archive
    bCopyBuffer - [in]
      true - copy the input buffer.  
          Useful when the buffer may be destroyed while this class is still in use.
      false - Do not copy the input buffer.  
          In this case you are responsible for making certain the input buffer 
          is valid while this class is in use.
    archive_3dm_version  - [in] (1,2,3,4 or 5)
    archive_opennurbs_version - [in] YYYYMMDDn
  */
  ON_Read3dmBufferArchive( 
    size_t sizeof_buffer, 
    const void* buffer,
    bool bCopyBuffer,
    int archive_3dm_version,
    int archive_opennurbs_version
    );

  ~ON_Read3dmBufferArchive();

  /*
  Returns: 
     value of m_sizeof_buffer
  */
  size_t SizeOfBuffer() const;

  /*
  Returns: 
     value of m_buffer
  */
  const void* Buffer() const;

  // ON_BinaryArchive overrides
  size_t CurrentPosition() const; 
  bool SeekFromCurrentPosition(int); 
  bool SeekFromStart(size_t);
  bool AtEnd() const;

protected:
  // ON_BinaryArchive overrides
  size_t Read( size_t, void* ); // return actual number of bytes read (like fread())
  size_t Write( size_t, const void* );
  bool Flush();

private:
  void* m_p;
  const unsigned char* m_buffer;
  size_t m_sizeof_buffer;
  size_t m_buffer_position;
  ON__INT_PTR m_reserved1;
  ON__INT_PTR m_reserved2;
  ON__INT_PTR m_reserved3;
  ON__INT_PTR m_reserved4;

private:
  // prohibit use - no implementation
  ON_Read3dmBufferArchive(); 
  ON_Read3dmBufferArchive( const ON_Read3dmBufferArchive& );
  ON_Read3dmBufferArchive& operator=(const ON_Read3dmBufferArchive&);
};

class ON_CLASS ON_Write3dmBufferArchive : public ON_BinaryArchive
{
public:

  /*
  Description:
    Construct an ON_BinaryArchive for writing information to a memory buffer.
  Parameters:
    initial_sizeof_buffer - [in] 
      initial size of buffer in bytes (>=0)
      If you are unable to estimate the size you will need, pass in zero.
    max_sizeof_buffer - [in] 
      maximum size of buffer in bytes (>=0)
      If max_sizeof_buffer > 0 and the amount of information saved 
      requires a buffer larger than this size, then writing fails. 
      If max_sizeof_buffer <= 0, then no buffer size limits are enforced.
    archive_3dm_version  - [in] (0, ,2,3,4 or 50)
      Pass 0 or ON_BinaryArchive::CurrentArchiveVersion() to write the
      version of opennurbs archives used by lastest version of Rhino.
    archive_opennurbs_version - [in] YYYYMMDDn
  */
  ON_Write3dmBufferArchive( 
    size_t initial_sizeof_buffer, 
    size_t max_sizeof_buffer, 
    int archive_3dm_version,
    int archive_opennurbs_version
    );

  ~ON_Write3dmBufferArchive();

  /*
  Returns: 
     Size of the archive in bytes.
  */
  size_t SizeOfArchive() const;

  /*
  Returns: 
     value of m_sizeof_buffer
  */
  size_t SizeOfBuffer() const;

  /*
  Returns: 
     value of m_buffer.
     SizeOfArchive() reports the number of bytes
     written to this buffer.
     SizeOfBuffer() reports the number of bytes
     allocated in this buffer.
     
  */
  const void* Buffer() const;

  /*
  Returns:
    The pointer to the buffer and sets all 
    members on this archive back to zero.
    The caller is responsible for calling onfree() on
    the pointer when finished with the buffer.
  */
  void* HarvestBuffer();

  // ON_BinaryArchive overrides
  size_t CurrentPosition() const; 
  bool SeekFromCurrentPosition(int); 
  bool SeekFromStart(size_t);
  bool AtEnd() const;

protected:
  // ON_BinaryArchive overrides
  size_t Read( size_t, void* ); 
  size_t Write( size_t, const void* ); // return actual number of bytes written (like fwrite())
  bool Flush();

private:
  void AllocBuffer(size_t);
  void* m_p;
  unsigned char* m_buffer;
  size_t m_sizeof_buffer;
  const size_t m_max_sizeof_buffer;
  size_t m_sizeof_archive;
  size_t m_buffer_position;
  ON__INT_PTR m_reserved1;
  ON__INT_PTR m_reserved2;
  ON__INT_PTR m_reserved3;
  ON__INT_PTR m_reserved4;

private:
  // prohibit use - no implementation
  ON_Write3dmBufferArchive(); 
  ON_Write3dmBufferArchive( const ON_Write3dmBufferArchive& );
  ON_Write3dmBufferArchive& operator=(const ON_Write3dmBufferArchive&);
};

/*
Description:
  Create a simple archive that contains a single geometric object.
Parameters:
  archive - [in] destination archive.
  version - [in] (0, 2, 3, 4, or 50) format version.archive version number.
      Version 2 format can be read by Rhino 2 and Rhino 3.  Version
      3 format can be read by Rhino 3.
      Pass 0 or ON_BinaryArchive::CurrentArchiveVersion() to write
      the latest version of archives supported by Rhino.
  object - [in] object to be saved in the archive's object table.
      This is typically some type of ON_Curve, ON_Surface, ON_Mesh,
      or ON_Brep.
Returns:
  @untitled table
  true     archive successfully written.
  false    archive not successfully written.
Example:

          const char* filename = "myfile.3dm";
          FILE* fp = ON::OpenFile( filename, "wb" );
          ON_BinaryFile file( fp, ON::write3dm );
          ON_BOOL32 ok = ON_WriteArchive( archive, geometry );
          ON::CloseFile( fp );

Remarks:
  The object table in the archive will contain a single
  object.
*/
ON_DECL
bool ON_WriteOneObjectArchive( 
          ON_BinaryArchive& archive,
          int version,
          const ON_Object& object
          );

#endif

/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2007 Robert McNeel & Associates. All rights reserved.
// Rhinoceros is a registered trademark of Robert McNeel & Assoicates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(ON_MASSPROP_INC_)
#define ON_MASSPROP_INC_

/*
Description:
  This class is used to returned results of 
  mass properties calculations.
*/
class ON_CLASS ON_MassProperties
{
public:
  ON_MassProperties();
  ~ON_MassProperties();

  // Set values to constructor defaults.
  void Create();

  /*
  Description:
    Prints a text description of the mass properties
    information.
  Parameters:
    dump - [in] target for text dump information.
  */
  void Dump( ON_TextLog& dump ) const;


  /*
  Description:
    Sum a list of mass properties together to get
    an aggregate mass.
  Parameters:
    count - [in] number of elements in the summands array.
    summands - [in] array of mass properties to add
    bAddTo - [in] if true, then the summands are added to
                  the existing mass.
  Returns:
    True if successful.
  */
  bool Sum(
    int count,
    const ON_MassProperties* summands,
    bool bAddTo = false
    );


  // Determines what type of "mass" is returned.
  // 1 = length, 2 = area, 3 = volume
  int m_mass_type;
  int m__reserved;

  // These flags are set to true if the calcluation was
  // successful.  If a flag is false, the corresponding
  // values should not be used.
  bool m_bValidMass;
  bool m_bValidCentroid;
  bool m_bValidFirstMoments;
  bool m_bValidSecondMoments;
  bool m_bValidProductMoments;
  bool m__bReserved1;
  bool m__bReserved2;
  bool m__bReserved3;



  // MASS - length, area, or volume of object
  //      = integral of "dm" over the object
  double m_mass;
  double m_mass_err; // uncertainty in calculation

  // CENTROID - in world coordinate system
  double m_x0;      // = m_world_x / m_mass
  double m_x0_err;
  double m_y0;      // = m_world_y / m_mass
  double m_y0_err;
  double m_z0;      // = m_world_z / m_mass
  double m_z0_err;




  // FIRST MOMENTS - with respect to world coordinate system
  // integral of "x dm" over the length/area/volume
  double m_world_x;
  double m_world_x_err; // uncertainty in calculation

  // integral of "y dm" over the length/area/volume
  double m_world_y;
  double m_world_y_err; // uncertainty in calculation

  // integral of "z dm" over the length/area/volume
  double m_world_z;
  double m_world_z_err; // uncertainty in calculation

  // SECOND MOMENTS - with respect to world coordinate system
  // integral of "xx dm" over the length/area/volume
  double m_world_xx;
  double m_world_xx_err; // uncertainty in calculation
  // integral of "yy dm" over the length/area/volume
  double m_world_yy;
  double m_world_yy_err; // uncertainty in calculation
  // integral of "zz dm" over the length/area/volume
  double m_world_zz;
  double m_world_zz_err; // uncertainty in calculation

  // PRODUCT MOMENTS - with respect to world coordinate system
  // integral of "xy dm" over the length/area/volume
  double m_world_xy;
  double m_world_xy_err; // uncertainty in calculation
  // integral of "yz dm" over the length/area/volume
  double m_world_yz;
  double m_world_yz_err; // uncertainty in calculation
  // integral of "zx dm" over the length/area/volume
  double m_world_zx;
  double m_world_zx_err; // uncertainty in calculation



  
  // The "centroid coordinate system" (ccs) is the
  // coordinate system with origin at the centroid and
  // axes parallel to the world coordinate axes.

  // SECOND MOMENTS - with respect to centroid coordinate system
  // integral of "xx dm" over the length/area/volume
  double m_ccs_xx;
  double m_ccs_xx_err; // uncertainty in calculation
  // integral of "yy dm" over the length/area/volume
  double m_ccs_yy;
  double m_ccs_yy_err; // uncertainty in calculation
  // integral of "zz dm" over the length/area/volume
  double m_ccs_zz;
  double m_ccs_zz_err; // uncertainty in calculation

  // PRODUCT MOMENTS - with respect to centroid coordinate system
  // integral of "xy dm" over the length/area/volume
  double m_ccs_xy;
  double m_ccs_xy_err; // uncertainty in calculation
  // integral of "yz dm" over the length/area/volume
  double m_ccs_yz;
  double m_ccs_yz_err; // uncertainty in calculation
  // integral of "zx dm" over the length/area/volume
  double m_ccs_zx;
  double m_ccs_zx_err; // uncertainty in calculation


  double m__reserved1;
  double m__reserved2;
  double m__reserved3;
  double m__reserved4;
  double m__reserved5;
  double m__reserved6;
  double m__reserved7;
  double m__reserved8;


  // FUNCTIONAL INTERFACE for those who wish to ignore error terms.

  /*
  Returns:
    Centroid of object.
  */
  ON_3dPoint Centroid() const;

  /*
  Description:
    Returns length of the curve if the mass properties
    calculation was a length calculation.
  Returns:
    Length of the curve if m_mass_type = 1 and zero
    otherwise.
  */
  double Length() const;

  /*
  Description:
    Returns area of the surface or mesh if the mass properties
    calculation was an area calculation.
  Returns:
    Area of the surface or mesh if m_mass_type = 2 and zero
    otherwise.
  */
  double Area() const;

  /*
  Description:
    Returns volume of the solid if the mass properties
    calculation was a volume calculation.
  Returns:
    Volume of the solid if m_mass_type = 3 and zero
    otherwise.
  */
  double Volume() const;

  /*
  Description:
    If m_bValidFirstMoments is true, then the world
    coordinate first moments are returned in a vector
    (m_world_x,m_world_y,m_world_z)
    If m_bValidFirstMoments is false, then (0,0,0) is
    returned.
  Returns:
    First moments with respect to world coordinate system.
    WorldCoordFirstMoments().x = integral of x dm
    WorldCoordFirstMoments().y = integral of y dm
    WorldCoordFirstMoments().z = integral of z dm
  */
  ON_3dVector WorldCoordFirstMoments() const;

  /*
  Description:
    If m_bValidSecondMoments is true, then the world
    coordinate second moments are returned in a vector
    (m_world_xx,m_world_yy,m_world_zz)
    If m_bValidSecondMoments is false, then (0,0,0) is
    returned.
  Returns:
    Second moments with respect to world coordinate system.
    WorldCoordSecondMoments().x = integral of x^2 dm
    WorldCoordSecondMoments().y = integral of y^2 dm
    WorldCoordSecondMoments().z = integral of z^2 dm
  See Also:
    CentroidCoordSecondMoments
  */
  ON_3dVector WorldCoordSecondMoments() const;

  /*
  Description:
    Calculates the moments of inertia about world
    coordinate axes.  
  Returns:
    Moments of inertia with respect to world coordinate system.
    WorldCoordMomentsOfInertia().x = integral of (y^2 + z^2) dm
    WorldCoordMomentsOfInertia().y = integral of (z^2 + x^2) dm
    WorldCoordMomentsOfInertia().z = integral of (z^2 + y^2) dm
  Remarks:
    What is meant by "moments of intertia" varies widely in 
    textbooks and papers.  The values returned here
    are the integrals listed in the Returns section.
    Some applications may want the values from
    WorldCoordSecondMoments() instead of the values
    returned here.
  */
  ON_3dVector WorldCoordMomentsOfInertia() const;

  /*
  Description:
    Calculates the radii of gyration about world
    coordinate axes.
  Returns:
    Radii of gyration with respect to world coordinate system.
    WorldCoordRadiiOfGyration().x = sqrt(integral of (y^2 + z^2) dm/M)
    WorldCoordRadiiOfGyration().y = sqrt(integral of (z^2 + x^2) dm/M)
    WorldCoordRadiiOfGyration().z = sqrt(integral of (z^2 + y^2) dm/M)
  Remarks:
    What is meant by "radii of gyration" varies widely in 
    textbooks and papers.  The values returned here
    are the integrals listed in the Returns section.
  */
  ON_3dVector WorldCoordRadiiOfGyration() const;

  /*
  Description:
    If moments are valid, then the 3x3 inertia matrix with respect
    to world coordinates is returned.  This matrix is sometimes
    called the "intertia tensor".
  Parameters:
    martix - [in] If you want to fill in an existing matrix, 
                  pass a pointer to that matrix.  Otherwise
                  a matrix will be created and returned.
    returned.
  Returns:
    The inertia matrix or NULL if the moments are not valid.

          m_world_xx  m_world_xy  m_world_xz
          m_world_xy  m_world_yy  m_world_yz
          m_world_xz  m_world_yz  m_world_zz
  See Also:
    CentroidCoordIntertiaMatrix
  */
  ON_Matrix* WorldCoordIntertiaMatrix( 
                ON_Matrix* matrix = NULL 
                ) const;

  /*
  Description:
    Calculates the principal moments and principal
    axes with repect to world coordinates.  These are
    simply the eigenvalues and eigenvectors of the
    woorld coordinate inertia matrix.
  Parameters:
    pxx - [out] principal moment
    Ax - [out] principal axis for pxx
    pyy - [out] principal moment
    Ay - [out] principal axis for pyy
    pzz - [out] principal moment
    Az - [out] principal axis for pzz
  Returns:
    True if successful.
  See Also:
    CentroidCoordPrincipalMoments
  */
  bool WorldCoordPrincipalMoments( 
                double* pxx, ON_3dVector& Ax,
                double* pyy, ON_3dVector& Ay,
                double* pzz, ON_3dVector& Az
                ) const;

  /*
  Description:
    If m_bValidSecondMoments is true, then the centroid
    coordinate second moments are returned in a vector
    (m_ccs_xx,m_ccs_yy,m_ccs_zz)
    If m_bValidSecondMoments is false, then (0,0,0) is
    returned.
  Returns:
    Second moments with respect to centroid coordinate system.
    CentroidCoordSecondMoments().x = integral of (x-x0)^2 dm
    CentroidCoordSecondMoments().y = integral of (y-y0)^2 dm
    CentroidCoordSecondMoments().z = integral of (z-z0)^2 dm
    where (x0,y0,z0) = centroid.
  See Also:
    WorldCoordSecondMoments
  */
  ON_3dVector CentroidCoordSecondMoments() const;

  /*
  Description:
    Calculates the moments of inertia about centroid
    coordinate axes.  
  Returns:
    Moments of inertia with respect to centroid coordinate system.
    WorldCoordMomentsOfInertia().x = integral of ((y-y0)^2 + (z-z0)^2) dm
    WorldCoordMomentsOfInertia().y = integral of ((z-z0)^2 + (x-x0)^2) dm
    WorldCoordMomentsOfInertia().z = integral of ((z-z0)^2 + (y-y0)^2) dm
    where (x0,y0,z0) = centroid.
  Remarks:
    What is meant by "moments of intertia" varies widely in 
    textbooks and papers.  The values returned here
    are the integrals listed in the Returns section.
    Some applications may want the values from
    WorldCoordSecondMoments() instead of the values
    returned here.
  */
  ON_3dVector CentroidCoordMomentsOfInertia() const;

  /*
  Description:
    Calculates the radii of gyration about centroid
    coordinate axes.
  Returns:
    Radii of gyration with respect to centroid coordinate system.
    CentroidCoordRadiiOfGyration().x 
      = sqrt(integral of ((y-y0)^2 + (z-z0)^2) dm/M)
    CentroidCoordRadiiOfGyration().y 
      = sqrt(integral of ((z-z0)^2 + (x-x0)^2) dm/M)
    CentroidCoordRadiiOfGyration().z 
      = sqrt(integral of ((z-z0)^2 + (y-y0)^2) dm/M)
    where (x0,y0,z0) = centroid.
  Remarks:
    What is meant by "radii of gyration" varies widely in 
    textbooks and papers.  The values returned here
    are the integrals listed in the Returns section.
  */
  ON_3dVector CentroidCoordRadiiOfGyration() const;

  /*
  Description:
    If moments are valid, then the 3x3 inertia matrix with respect
    to centroid coordinates is returned.  This matrix is sometimes
    called the "intertia tensor".
  Parameters:
    martix - [in] If you want to fill in an existing matrix, 
                  pass a pointer to that matrix.  Otherwise
                  a matrix will be created and returned.
    returned.
  Returns:
    The inertia matrix or NULL if the moments are not valid.

          m_ccs_xx  m_ccs_xy  m_ccs_xz
          m_ccs_xy  m_ccs_yy  m_ccs_yz
          m_ccs_xz  m_ccs_yz  m_ccs_zz
  See Also:
    WorldCoordIntertiaMatrix
  */
  ON_Matrix* CentroidCoordIntertiaMatrix( 
                ON_Matrix* matrix = NULL 
                ) const;

  /*
  Description:
    Calculates the principal moments and principal
    axes with repect to centroid coordinates.  These are
    simply the eigenvalues and eigenvectors of the
    centroid coordinate inertia matrix.
  Parameters:
    pxx - [out] principal moment
    Ax - [out] principal axis for pxx
    pyy - [out] principal moment
    Ay - [out] principal axis for pyy
    pzz - [out] principal moment
    Az - [out] principal axis for pzz
  Returns:
    True if successful.
  See Also:
    WorldCoordPrincipalMoments
  */
  bool CentroidCoordPrincipalMoments( 
                double* pxx, ON_3dVector& Ax,
                double* pyy, ON_3dVector& Ay,
                double* pzz, ON_3dVector& Az
                ) const;

};

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(ON_ARC_INC_)
#define ON_ARC_INC_

/*
Description:
	An ON_Arc is a subcurve of 3d circle.
Details:
	The curve is parameterized by	an angle expressed in radians.   For an IsValid() arc
	the total subtended angle 	AngleRadians() = Domain()(1) - Domain()(0) must satisfy
				0< AngleRadians() <2*Pi .

	The parameterization of the ON_Arc is inherited from the ON_Circle it is derived from.
	In particular
			 t -> center + cos(t)*radius*xaxis + sin(t)*radius*yaxis
	where xaxis and yaxis, (part of ON_Circle::m_plane) form an othonormal frame of the plane
	containing the circle.
*/
class ON_CLASS ON_Arc : public ON_Circle
{
public:
  // Create a radius one arc with angle = 2*pi
  ON_Arc();

  /*
  Description:
    Construct an arc from a circle and an angle in radians
  Parameters:
    circle - [in]
    angle_in_radians - [in]
  */
  ON_Arc(
    const ON_Circle& circle,
    double angle_in_radians
    );

  /*
  Parameters:
    circle - [in]
    angle_interval_in_radians - [in] increasing angle interval
       in radians with angle_interval_in_radians.Length() <= 2.0*ON_PI.
  */
  ON_Arc(
    const ON_Circle& circle,
    ON_Interval angle_interval_in_radians
    );

  /*
  Description:
    Construct an arc from a plane, radius and an angle in radians.
    The center of the arc is at the plane's origin.
  Parameters:
    plane - [in]
      circle is in this plane with center at m_origin
    center - [in]
      circle's center point
    radius - [in]
    angle_in_radians - [in]
  */
  ON_Arc(
    const ON_Plane& plane,
    double radius,
    double angle_in_radians
    );

  /*
  Description:
    Construct an arc parallel to the world XY plane from a
    center point, radius, and angle in radians.
    The arc starts at center+(radius,0,0).
  Parameters:
    center - [in]
    radius - [in]
    angle_in_radians - [in]
  */
  ON_Arc(
    const ON_3dPoint& center,
    double radius,
    double angle_in_radians
    );

  /*
  Description:
    Construct an arc parallel to plane from a center point, 
    radius, and angle in radians.  
    The arc starts at center+radius*plane.xaxis.
  Parameters:
    plane - [in]
      The plane x, y and z axis are used to defines the circle
      plane's x, y and z axis.  The plane origin is ignorned.
    center - [in]
      circle's center point
    radius - [in]
    angle_in_radians - [in]
  */
  ON_Arc(
    const ON_Plane& plane,
    const ON_3dPoint& center,
    double radius,
    double angle_in_radians
    );

  /*
  Description:
    Construct an arc that passes through three 2d points.
  Parameters:
    start_point - [in]
    interior_point - [in]
    end_point - [in]
  */
  ON_Arc(
    const ON_2dPoint& start_point,
    const ON_2dPoint& interior_point,
    const ON_2dPoint& end_point
    );

  /*
  Description:
    Construct an arc that passes through three 3d points.
  Parameters:
    start_point - [in]
    interior_point - [in]
    end_point - [in]
  */
  ON_Arc(
    const ON_3dPoint& start_point,
    const ON_3dPoint& interior_point,
    const ON_3dPoint& end_point
    );

  /*
  Description:
    Create an arc from a circle and an angle in radians
  Parameters:
    circle - [in]
    angle_in_radians - [in]
  Returns:
    true if input is valid and a valid arc is created.
  */
  bool Create(
    const ON_Circle& circle,
    double angle_in_radians
    );

  /*
  Description:
    Create an arc from a circle and an increasing angle interval
  Parameters:
    circle - [in]
    angle_interval_in_radians - [in] increasing angle interval in radians
              with angle_interval_in_radians.Length() <= 2.0*ON_PI
  Returns:
    true if input is valid and a valid arc is created.
  */
  bool Create(
    const ON_Circle& circle,
    ON_Interval angle_interval_in_radians
    );

  /*
  Description:
    Create an arc from a plane, radius and an angle in radians.
    The center of the arc is at the plane's origin.
  Parameters:
    plane - [in]
      circle is in this plane with center at m_origin
    center - [in]
      circle's center point
    radius - [in]
    angle_in_radians - [in]
  */
  bool Create(
    const ON_Plane& plane,
    double radius,
    double angle_in_radians
    );

 /*
  Description:
    Create an arc parallel to the world XY plane from a
    center point, radius, and angle in radians.
    The arc starts at center+(radius,0,0).
  Parameters:
    center - [in]
    radius - [in]
    angle_in_radians - [in]
  */
  bool Create(
    const ON_3dPoint& center,
    double radius,
    double angle_in_radians
    );

  /*
  Description:
    Create an arc parallel to plane from a center point, 
    radius, and angle in radians.  
    The arc starts at center+radius*plane.xaxis.
  Parameters:
    plane - [in]
      The plane x, y and z axis are used to defines the circle
      plane's x, y and z axis.  The plane origin is ignorned.
    center - [in]
      circle's center point
    radius - [in]
    angle_in_radians - [in]
  */
  bool Create(
    const ON_Plane& plane,
    const ON_3dPoint& center,
    double radius,
    double angle_in_radians
    );

  /*
  Description:
    Create an arc that passes through three 2d points.
  Parameters:
    start_point - [in]
    interior_point - [in]
    end_point - [in]
  */
  bool Create(
    const ON_2dPoint& start_point,
    const ON_2dPoint& interior_point,
    const ON_2dPoint& end_point
    );

  /*
  Description:
    Create an arc that passes through three 3d points.
  Parameters:
    start_point - [in]
    interior_point - [in]
    end_point - [in]
  */
  bool Create(
    const ON_3dPoint& start_point,
    const ON_3dPoint& interior_point,
    const ON_3dPoint& end_point
    );

  /*
  Description:
    Create an arc from a 2d start point, 2d start direction 
    and a 2d end point.
  Parameters:
    start_point - [in]
    dir_at_start - [in]
    end_point - [in]
  */
  bool Create(
    const ON_2dPoint& start_point,
    const ON_2dVector& dir_at_start,
    const ON_2dPoint& end_point
    );

  /*
  Description:
    Create an arc from a 3d start point, 3d start direction 
    and a 3d end point.
  Parameters:
    start_point - [in]
    dir_at_start - [in]
    end_point - [in]
  */
  bool Create(
    const ON_3dPoint& start_point,
    const ON_3dVector& dir_at_start,
    const ON_3dPoint& end_point
    );

  ON_Arc& operator=( const ON_Circle& );


  ~ON_Arc();

  // Description:
  //   Creates a text dump of the arc listing the normal, center
  //   radius, start point, end point, and angle.
  // Remarks:
  //   Dump() is intended for debugging and is not suitable
  //   for creating high quality text descriptions of an
  //   arc.
  void Dump( ON_TextLog& dump ) const;

  // Description:
  //   Checks an arc to make sure it is valid.
	// Detail:
	//	 Radius>0 and 0<AngleRadians()<=2 ON_PI
  // Returns:
  //   true if the arc is valid.
  bool IsValid() const;

  // Description:
  //   Get arc's 3d axis aligned bounding box.
  // Returns:
  //   3d bounding box.
  ON_BoundingBox BoundingBox() const;

  // Description:
  //   Get arc's 3d axis aligned bounding box or the
  //   union of the input box with the arc's bounding box.
  // Parameters:
  //   bbox - [in/out] 3d axis aligned bounding box
  //   bGrowBox - [in] (default=false)
  //     If true, then the union of the input bbox and the
  //     arc's bounding box is returned in bbox.
  //     If false, the arc's bounding box is returned in bbox.
  // Returns:
  //   true if arc has bounding box and calculation was successful.
  bool GetBoundingBox(
         ON_BoundingBox& bbox,
         int bGrowBox = false
         ) const;

  /*
	Description:
    Get tight bounding box.
	Parameters:
		tight_bbox - [in/out] tight bounding box
		bGrowBox -[in]	(default=false)
      If true and the input tight_bbox is valid, then returned
      tight_bbox is the union of the input tight_bbox and the
      arc's tight bounding box.
		xform -[in] (default=NULL)
      If not NULL, the tight bounding box of the transformed
      arc is calculated.  The arc is not modified.
	Returns:
    True if a valid tight_bbox is returned.
  */
	bool GetTightBoundingBox(
			ON_BoundingBox& tight_bbox,
      int bGrowBox = false,
			const ON_Xform* xform = 0
      ) const;

  // Returns:
  //   true if the arc is a complete circle; i.e., the arc's
  //   angle is 360 degrees.
  bool IsCircle() const;

  // Returns:
  //   The arc's subtended angle in radians.
  double AngleRadians() const;

  // Returns:
  //   The arc's subtended angle in degrees.
  double AngleDegrees() const;


  /*
  Description:
    Get evaluation domain.
  Returns:
    Evaluation domain (same as DomainRadians()).
  */
  ON_Interval Domain() const;

  // Returns:
  //   The arc's domain in radians.
  ON_Interval DomainRadians() const;

  // Returns:
  //   The arc's domain in degrees.
  ON_Interval DomainDegrees() const;

  // Description:
  //   Set arc's subtended angle in radians.
  // Parameters:
  //   angle_in_radians - [in] 0 <= angle_in_radians <= 2.0*ON_PI
  //
  bool SetAngleRadians(
    double angle_in_radians
    );

  /*
  Description:
    Set arc's angle interval in radians.
  Parameters:
    angle_in_radians - [in] increasing interval with
                            start and end angle in radians.
                            Length of the interval <= 2.0*ON_PI.
  Returns:
    true if successful.
  */
  bool SetAngleIntervalRadians(
    ON_Interval angle_in_radians
    );

  // Description:
  //   Set arc's domain as a subdomain of the circle.
  // Parameters:
  //   domain_radian - [in]   0 < domain_radian[1] - domain_radian[0] <= 2.0 * ON*PI
  //
  bool Trim(
    ON_Interval domain_radian
    );

  // Description:
  //   Set arc's subtended angle in degrees.
  // Parameters:
  //   angle_in_degrees - [in] 0 < angle_in_degrees <= 360
  bool SetAngleDegrees(
    double angle_in_degrees
    );

  // Returns:
  //   Point at start of the arc.
  ON_3dPoint StartPoint() const;


  // Returns:
  //   Point at middle of the arc.
  ON_3dPoint MidPoint() const;

  // Returns:
  //   Point at end of the arc.
  ON_3dPoint EndPoint() const;

  // Description:
  //   Get the point on the arc that is closest to test_point.
  // Parameters:
  //   test_point - [in]
  //   t - [out] parameter (in radians) of the point on the arc that
  //       is closest to test_point.  If test_point is the center
  //       of the arc, then the starting point of the arc is
  //       (arc.Domain()[0]) returned.
  bool ClosestPointTo(
         const ON_3dPoint& test_point,
         double* t
         ) const;

  // Description:
  //   Get the point on the arc that is closest to test_point.
  // Parameters:
  //   test_point - [in]
  // Returns:
  //   The point on the arc that is closest to test_point.
  //   If test_point is the center of the arc, then the
  //   starting point of the arc is returned.
  ON_3dPoint ClosestPointTo(
         const ON_3dPoint& test_point
         ) const;

  // Returns:
  //   Length of the arc = radius*(subtended angle in radians).
  double Length() const;

  /*
  Returns:
    Area of the arc's sector.  
  Remarks:
    The arc's sector is the region bounded by the arc,
    the line segment from the arc's end to the center,
    and the line segment from the center to the arc's
    start.
  */
  double SectorArea() const;

  /*
  Returns:
    Area centroid of the arc's sector.  
  Remarks:
    The arc's sector is the region bounded by the arc,
    the line segment from the arc's end to the center,
    and the line segment from the center to the arc's
    start.
  */
  ON_3dPoint SectorAreaCentroid() const;

  /*
  Returns:
    Area of the arc's segment.
  Remarks:
    The arc's segment is the region bounded by the arc and
    the line segment from the arc's end to the arc's start.
  */
  double SegmentArea() const;

  /*
  Returns:
    Area centroid of the arc's segment.  
  Remarks:
    The arc's segment is the region bounded by the arc and
    the line segment from the arc's end to the arc's start.
  */
  ON_3dPoint SegmentAreaCentroid() const;

  // Description:
  //   Reverse the orientation of the arc.  Changes the domain
  //   from [a,b] to [-b.-a].
  bool Reverse();

  // Description:
  //   Get a rational degree 2 NURBS curve representation
  //   of the arc.  Note that the parameterization of NURBS curve
  //   does not match  arc's transcendental parameterization.
  //   Use GetRadianFromNurbFormParameter() and
  //   GetParameterFromRadian() to convert between the NURBS curve
  //   parameter and the transcendental parameter
  // Parameters:
  //   nurbs_curve - [out] nurbs_curve returned here.
  // Returns:
  //   0 for failure and 2 for success.
  int GetNurbForm(
        ON_NurbsCurve& nurbs_curve
        ) const;

  /*
  Description:
    Convert a NURBS curve arc parameter to a arc radians parameter.
  Parameters:
    nurbs_parameter - [in]
    arc_radians_parameter - [out]
  Example:

          ON_Arc arc = ...;
          double nurbs_t = 1.2345; // some number in interval (0,2.0*ON_PI).
          double arc_t;
          arc.GetRadianFromNurbFormParameter( nurbs_t, &arc_t );

          ON_NurbsCurve nurbs_curve;
          arc.GetNurbsForm( nurbs_curve );
          arc_pt = arc.PointAt(arc_t);
          nurbs_pt = nurbs_curve.PointAt(nurbs_t);
          // arc_pt and nurbs_pt will be the same

  Remarks:
    The NURBS curve parameter is with respect to the NURBS curve
    created by ON_Arc::GetNurbForm.  At nurbs parameter values of
    0.0, 0.5*ON_PI, ON_PI, 1.5*ON_PI, and 2.0*ON_PI, the nurbs
    parameter and radian parameter are the same.  At all other
    values the nurbs and radian parameter values are different.
  See Also:
    ON_Arc::GetNurbFormParameterFromRadian
  */
  bool GetRadianFromNurbFormParameter(
        double nurbs_parameter,
        double* arc_radians_parameter
        ) const;

  /*
  Description:
    Convert a arc radians parameter to a NURBS curve arc parameter.
  Parameters:
    arc_radians_parameter - [in] 0.0 to 2.0*ON_PI
    nurbs_parameter - [out]
  Example:

          ON_Arc arc = ...;
          double arc_t = 1.2345; // some number in interval (0,2.0*ON_PI).
          double nurbs_t;
          arc.GetNurbFormParameterFromRadian( arc_t, &nurbs_t );

          ON_NurbsCurve nurbs_curve;
          arc.GetNurbsForm( nurbs_curve );
          arc_pt = arc.PointAt(arc_t);
          nurbs_pt = nurbs_curve.PointAt(nurbs_t);
          // arc_pt and nurbs_pt will be the same

  Remarks:
    The NURBS curve parameter is with respect to the NURBS curve
    created by ON_Arc::GetNurbForm.  At radian values of
    0.0, 0.5*ON_PI, ON_PI, 1.5*ON_PI, and 2.0*ON_PI, the nurbs
    parameter and radian parameter are the same.  At all other
    values the nurbs and radian parameter values are different.
  See Also:
    ON_Arc::GetNurbFormParameterFromRadian
  */
  bool GetNurbFormParameterFromRadian(
        double arc_radians_parameter,
        double* nurbs_parameter
        ) const;

private:
  friend bool ON_BinaryArchive::ReadArc( ON_Arc& );
  friend bool ON_BinaryArchive::WriteArc( const ON_Arc& );

  // increasing interval with start and end angle in radians
  ON_Interval m_angle;
};

#endif

/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

////////////////////////////////////////////////////////////////
//
//   virtual base class for all openNURBS objects
//
////////////////////////////////////////////////////////////////

#if !defined(OPENNURBS_OBJECT_INC_)
#define OPENNURBS_OBJECT_INC_


class ON_ClassId; // used for runtime class identification

////////////////////////////////////////////////////////////////
//
// Runtime class id
//

// Description:
//   Every class derived from ON_Object has a class id that records
//   its class name, baseclass name, and class uuid.  The 
//   ON_OBJECT_DECLARE and ON_OBJECT_IMPLEMENT macros generate
//   the code that creates and initializes class ids.
//
//   The ON_Object::IsKindOf() and ON_Object::Cast() functions
//   use these class ids.
class ON_CLASS ON_ClassId
{
public:

  // Description:
  //   This constructor is called to initialize each class id.
  //   The call is generated by the ON_OBJECT_IMPLEMENT macro.
  //
  // Parameters:
  //   sClassName - [in] name of the class (like ON_Geometry)
  //   sBaseClassName - [in] name of baseclass (like ON_Object)
  //   create - [in] function to create a new object(like CreateNewON_Geometry())
  //   copy - [in] function to copy
  //   sUUID - [in] UUID in registry format from Windows guidgen.exe
  ON_ClassId( 
          const char* sClassName,
          const char* sBaseClassName,
          ON_Object* (*create)(),
          const char* sUUID
           );

  ON_ClassId( 
          const char* sClassName,
          const char* sBaseClassName,
          ON_Object* (*create)(),
          bool (*copy)(const ON_Object*,ON_Object* ),
          const char* sUUID
           );

  ~ON_ClassId();

  // Description: 
  //   Gets a class's ON_ClassId from the class's name.
  // Parameters:
  //   sClassName - [in] name of class
  // Returns: 
  //   Pointer to the class's ON_ClassId.
  // Example:
  //   const ON_ClassId* brep_id = ON_CLassId::ClassId("ON_Brep");
  static const ON_ClassId* ClassId( 
          const char* sClassName
          );

  // Description: 
  //   Gets a class's ON_ClassId from the class's uuid.
  // Parameters:
  //   class_uuid - [in] uuid for the class
  // Returns: 
  //   Pointer to the class's ON_ClassId.
  // Example:
  //   ON_UUID brep_uuid = ON_UuidFromString("60B5DBC5-E660-11d3-BFE4-0010830122F0");
  //   const ON_ClassId* brep_id = ON_CLassId::ClassId(brep_uuid);
  static const ON_ClassId* ClassId( 
          ON_UUID class_uuid
          );

  // Description:
  //   Each class derived from ON_Object has a corresponding ON_ClassId
  //   stored in a linked list and the class is marked with an integer
  //   value.  ON_ClassId::IncrementMark() increments the value used to
  //   mark new classes and returns the new marking value.
  // Returns:
  //   Value that will be used to mark all future ON_ClassIds.
  static int IncrementMark();
  static int CurrentMark();
  static const ON_ClassId* LastClassId();

  // Description:
  //   Each class derived from ON_Object has a corresponding
  //   ON_ClassId stored in a linked list.  If a class definition
  //   is going to disappear (which happens when the derived object
  //   definition is in a DLL that uses openNURBS as a DLL and the 
  //   DLL containing the derived object's definition is unloaded),
  //   then the class's ON_ClassId needs to be removed from the class 
  //   list.  ON_ClassId::Purge( mark ) removes all ON_ClassIds with a
  //   a prescribed mark and returns the number of classes that
  //   were purged.  
  // Parameters:
  //   mark - [in] All ON_ClassIds with this mark will be purged.
  // Returns:
  //   Number of classes that were purged.
  // Example:
  //   // Call ON_ClassId::IncrementMark() BEFORE loading MY.DLL.
  //   int my_dll_classid_mark = ON_ClassId::IncrementMark();
  //   load MY.DLL with classes derived from ON_Object
  //   ...
  //   // Call ON_ClassId::Purge() BEFORE unloading MY.DLL.
  //   ON_ClassId::Purge( my_dll_classid_mark );
  //   unload MY.DLL
  static int Purge(int mark);
  static bool PurgeAfter(const ON_ClassId* pClassId);

  // Description:
  //   Dumps the ON_ClassId list
  // Parameters:
  //   dump - [in] destination for the text dump.
  static void Dump( 
    ON_TextLog& dump
    );

  // Returns:
  //   class name
  const char* ClassName() const;

  // Returns:
  //   base class name
  const char* BaseClassName() const;
  
  // Returns:
  //   base class id
  const ON_ClassId* BaseClass() const;

  // Description:
  //   Determine if the class associated with this ON_ClassId
  //   is derived from another class.
  // Parameters:
  //   potential_parent - [in] Class to test as parent.
  // Returns:
  //   true if this is derived from potential_parent.
	ON_BOOL32 IsDerivedFrom( 
    const ON_ClassId* potential_parent
    ) const;

  // Descrption:
  //   Create an instance of the class associated with
  //   class id.
  // Returns:
  //   Instance of the class id's class.
  ON_Object* Create() const;

  // Returns:
  //   class uuid
  ON_UUID Uuid() const;

  /*
  Description:
    Opennurbs classes have a mark value of 0.  Core Rhino
    classes have a mark value of 1.  Rhino plug-in classes
    have a mark value of > 1.
  Returns:
    Class mark value
  */
  int Mark() const;

  unsigned int ClassIdVersion() const;

private:
  static ON_ClassId* m_p0;     // first id in the linked list of class ids
  static ON_ClassId* m_p1;     // last id in the linked list of class ids
  static int m_mark0;  // current mark value
  ON_ClassId* m_pNext;         // next in the linked list of class ids
  const ON_ClassId* m_pBaseClassId;  // base class id
  char m_sClassName[80];              
  char m_sBaseClassName[80];
  ON_Object* (*m_create)();
  ON_UUID m_uuid;
  int m_mark; // bit 0x80000000 is used to indicate new extensions

private:
  // no implementaion to prohibit use
  ON_ClassId();
  ON_ClassId( const ON_ClassId&);
  ON_ClassId& operator=( const ON_ClassId&);

  void ConstructorHelper( 
          const char* sClassName, 
          const char* sBaseClassName, 
          const char* sUUID
          );

  // This is a temporary way to add simple virtual functions
  // to ON_Object without breaking the SDK.  At V6 these will
  // be redone to be ordinary virtual functions.
  friend class ON_Object;
  unsigned int m_class_id_version; 
  bool (*m_copy)(const ON_Object*,ON_Object*); // on version 1 class ids
  void* m_f2;
  void* m_f3;
  void* m_f4;
  void* m_f5;
  void* m_f6;
  void* m_f7;
  void* m_f8;
};

// Description:
//   Macro to easily get a pointer to the ON_ClassId for a
//   given class;
//
// Example:
//
//          const ON_ClassId* brep_class_id = ON_CLASS_ID("ON_Brep");
//
#define ON_CLASS_ID( cls ) ON_ClassId::ClassId( #cls )

/*
Description:
  Expert user function to get the value of ON_ClassId::m_uuid
  of the last instance of ON_ClassId to call ON_ClassId::Create().
  This function was created to support Rhino's .NET SDK.
  This function returns the value of a static id in
  opennurbs_object.cpp and is NOT thread safe.
Returns:
  Value of ON_ClassId::m_uuid of the instance of ON_ClassId that
  most recently called ON_ClassId::Create().
*/
ON_DECL
ON_UUID ON_GetMostRecentClassIdCreateUuid();

/*
All classes derived from ON_Object must have 

  ON_OBJECT_DECLARE( <classname> );

as the first line in their class definition an a corresponding

  ON_VIRTUAL_OBJECT_IMPLEMENT( <classname>, <basclassname>, <classuuid> );

or 

  ON_OBJECT_IMPLEMENT( <classname>, <basclassname>, <classuuid> );

in a .CPP file.
*/
#define ON_OBJECT_DECLARE( cls )                                \
  protected:                                                    \
    static void* m_s_##cls##_ptr;                               \
  public:                                                       \
    static const ON_ClassId m_##cls##_class_id;                 \
    /*record used for ON_Object runtime type information*/      \
                                                                \
    static cls * Cast( ON_Object* );                            \
    /*Description: Similar to C++ dynamic_cast*/                \
    /*Returns: object on success. NULL on failure*/             \
                                                                \
    static const cls * Cast( const ON_Object* );                \
    /*Description: Similar to C++ dynamic_cast*/                \
    /*Returns: object on success. NULL on failure*/             \
                                                                \
    virtual const ON_ClassId* ClassId() const;                  \
    /*Description:*/                                            \
                                                                \
  private:                                                      \
    virtual ON_Object* DuplicateObject() const;                 \
    /*used by Duplicate to create copy of an object.*/          \
                                                                \
    static bool Copy##cls( const ON_Object*, ON_Object* );      \
    /* used by ON_Object::CopyFrom copy object into this. */    \
    /* In V6 Copy##cls will vanish and be replaced with   */    \
    /* virtual bool CopyFrom( const ON_Object* src )      */    \
                                                                \
  public:                                                       \
    cls * Duplicate() const                                     \
    /*Description: Expert level tool - no support available.*/  \
    /*If this class is derived from CRhinoObject, use CRhinoObject::DuplicateRhinoObject instead*/

// Objects derived from ON_Object that do not have a valid new, operator=, 
// or copy constructor must use ON_VIRTUAL_OBJECT_IMPLEMENT instead of
// ON_OBJECT_IMPLEMENT.  Objects defined with ON_VIRTUAL_OBJECT_IMPLEMENT
// cannot be serialized using ON_BinaryArchive::ReadObject()/WriteObject()
// or duplicated using ON_Object::Duplicate().
//
// The Cast() and ClassId() members work on objects defined with either
// ON_VIRTUAL_OBJECT_IMPLEMENT or ON_OBJECT_IMPLEMENT.
#define ON_VIRTUAL_OBJECT_IMPLEMENT( cls, basecls, uuid ) \
  const ON_ClassId cls::m_##cls##_class_id(#cls,#basecls,0,0,uuid);\
  cls * cls::Cast( ON_Object* p) {return(cls *)Cast((const ON_Object*)p);} \
  const cls * cls::Cast( const ON_Object* p) {return(p&&p->IsKindOf(&cls::m_##cls##_class_id))?(const cls *)p:0;} \
  const ON_ClassId* cls::ClassId() const {return &cls::m_##cls##_class_id;} \
  ON_Object* cls::DuplicateObject() const {return 0;} \
  bool cls::Copy##cls( const ON_Object*, ON_Object* ) {return false;} \
  cls * cls::Duplicate() const {return static_cast<cls *>(DuplicateObject());} \
  void* cls::m_s_##cls##_ptr = 0

// Objects derived from ON_Object that use ON_OBJECT_IMPLEMENT must
// have a valid operator= and copy constructor.  Objects defined with
// ON_OBJECT_IMPLEMENT may be serialized using 
// ON_BinaryArchive::ReadObject()/WriteObject()
// and duplicated by calling ON_Object::Duplicate().
#define ON_OBJECT_IMPLEMENT( cls, basecls, uuid ) \
  static ON_Object* CreateNew##cls() {return new cls();} \
  const ON_ClassId cls::m_##cls##_class_id(#cls,#basecls,CreateNew##cls,cls::Copy##cls,uuid);\
  cls * cls::Cast( ON_Object* p) {return(cls *)Cast((const ON_Object*)p);} \
  const cls * cls::Cast( const ON_Object* p) {return(p&&p->IsKindOf(&cls::m_##cls##_class_id))?(const cls *)p:0;} \
  const ON_ClassId* cls::ClassId() const {return &cls::m_##cls##_class_id;} \
  ON_Object* cls::DuplicateObject() const {cls* p = new cls(); if (p) *p=*this; return p;} \
  bool cls::Copy##cls( const ON_Object* src, ON_Object* dst ){cls* d;const cls* s;if (0!=(s=cls::Cast(src))&&0!=(d=cls::Cast(dst))) {d->cls::operator=(*s);return true;}return false;} \
  cls * cls::Duplicate() const {return static_cast<cls *>(DuplicateObject());} \
  void* cls::m_s_##cls##_ptr = 0

#define ON__SET__THIS__PTR(ptr) if (ptr) *((void**)this) = ptr

class ON_UserData;

class ON_CLASS ON_UserString
{
public:
  ON_UserString();
  ~ON_UserString();
  ON_wString m_key;
  ON_wString m_string_value;

  void Dump(ON_TextLog& text_log) const;
  bool Write(ON_BinaryArchive&) const;
  bool Read(ON_BinaryArchive&);
};

#if defined(ON_DLL_TEMPLATE)
// This stuff is here because of a limitation in the way Microsoft
// handles templates and DLLs.  See Microsoft's knowledge base 
// article ID Q168958 for details.
#pragma warning( push )
#pragma warning( disable : 4231 )
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ON_UserString>;
#pragma warning( pop )
#endif

/*
Description:
  When ON_Object::IsValid() fails and returns false, ON_IsNotValid()
  is called.  This way, a developer can put a breakpoint in
  ON_IsNotValid() and stop execution at the exact place IsValid()
  fails.
Returns:
  false;
*/
ON_DECL
bool ON_IsNotValid();

////////////////////////////////////////////////////////////////

// Description:
//   Pure virtual base class for all classes that must provide
//   runtime class id or support object level 3DM serialization
class ON_CLASS ON_Object
{
  /////////////////////////////////////////////////////////////////
  //
  // Any object derived from ON_Object should have a
  //   ON_OBJECT_DECLARE(ON_...);
  // as the last line of its class definition and a
  //   ON_OBJECT_IMPLEMENT( ON_..., ON_baseclass );
  // in a .cpp file.
  //
  // These macros declare and implement public members
  //
  // static ON_ClassId m_ON_Object;
  // static cls * Cast( ON_Object* );
  // static const cls * Cast( const ON_Object* );
  // virtual const ON_ClassId* ClassId() const;
  ON_OBJECT_DECLARE(ON_Object);
public:

  /*
  Description:
    Copies src into this, if possible.
  Parameters:
    src - [in]
  Returns:
    True if this->operator= could be called to copy src.
  Remarks:
    This should be virtual function declared in the
    ON_OBJECT_DECLARE macro along the lines of DuplicateObject()
    but is was added after the SDK was frozen (adding virtual
    functions breaks the SDK).  In V6, the function will work
    the same but be implemented like DuplicateObject();
  */
  bool CopyFrom( const ON_Object* src );

public:

  ON_Object();
  ON_Object( const ON_Object& );
  ON_Object& operator=( const ON_Object& );
  virtual ~ON_Object();

  /*
  Description:
    Sets m_user_data_list = 0.
  */
  void EmergencyDestroy();

  /*
  Description:
    The MemoryRelocate() function is called when an 
    object's location in memory is changed.  For 
    example, if an object resides in a chunk of 
    memory that is grown by calling a realloc
    that has to allocate a new chunk and
    copy the contents of the old chunk to the
    new chunk, then the location of the object's
    memory changes.  In practice this happens when
    classes derived from ON_Object are stored
    in dynamic arrays, like the default implementation
    of ON_ObjectArray<>'s that use realloc to grow
    the dynamic array.
  */
  virtual 
  void MemoryRelocate();

  /*
  Description:
    Low level tool to test if an object is derived
    from a specified class.
  Parameters:
    pClassId - [in] use classname::ClassId()
  Returns:
    true if the instantiated object is derived from the
    class whose id is passed as the argument.
  Example:

          ON_Object* p = ....;
          if ( p->IsKindOf( ON_NurbsCurve::ClassId() ) )
          {
            it's a NURBS curve
          }

  Remarks:
    The primary reason for IsKindOf() is to support the
    static Cast() members declared in the ON_OBJECT_DECLARE
    macro.  If we determine that dynamic_cast is properly 
    supported and implemented by all supported compilers, 
    then IsKindOf() may dissappear.  If an application needs
    to determine if a pointer points to a class derived from
    ON_SomeClassName, then call 
    ON_SomeClassName::Cast(mystery pointer) and check for 
    a non-null return.
  */
  ON_BOOL32 IsKindOf( 
        const ON_ClassId* pClassId
        ) const;

  /*
  Description:
    Tests an object to see if its data members are correctly
    initialized.
  Parameters:
    text_log - [in] if the object is not valid and text_log
        is not NULL, then a brief englis description of the
        reason the object is not valid is appened to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     object is valid
    false    object is invalid, uninitialized, etc.
  */
  virtual
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const = 0;

  /*
  Description:
    Creates a text dump of the object.
  Remarks:
    Dump() is intended for debugging and is not suitable
    for creating high quality text descriptions of an
    object.

    The default implementations of this virtual function 
    prints the class's name.
  */
  virtual
  void Dump( ON_TextLog& ) const;

  /*
  Returns:
    An estimate of the amount of memory the class uses in bytes.
  */
  virtual
  unsigned int SizeOf() const;

  /*
  Description:
    Returns a CRC calculated from the information that defines
    the object.  This CRC can be used as a quick way to see
    if two objects are not identical.
  Parameters:
    current_remainder - [in];
  Returns:
    CRC of the information the defines the object.
  */
  virtual
  ON__UINT32 DataCRC(ON__UINT32 current_remainder) const;

  /*
  Description:
    Low level archive writing tool used by ON_BinaryArchive::WriteObject().
  Parameters:
    binary_archive - archive to write to
  Returns:
    Returns true if the write is successful.
  Remarks:
    Use ON_BinaryArchive::WriteObject() to write objects.
    This Write() function should just write the specific definition of
    this object.  It should not write and any chunk typecode or length
    information.  

    The default implementation of this virtual function returns 
    false and does nothing.
  */
  virtual
  ON_BOOL32 Write(
         ON_BinaryArchive& binary_archive
       ) const;

  /*
  Description:
    Low level archive writing tool used by ON_BinaryArchive::ReadObject().
  Parameters:
    binary_archive - archive to read from
  Returns:
    Returns true if the read is successful.
  Remarks:
    Use ON_BinaryArchive::ReadObject() to read objects.
    This Read() function should read the objects definition back into
    its data members.

    The default implementation of this virtual function returns 
    false and does nothing.
  */
  virtual
  ON_BOOL32 Read(
         ON_BinaryArchive& binary_archive
       );

  /*
  Description:
    Useful for switch statements that need to differentiate
    between basic object types like points, curves, surfaces,
    and so on.

  Returns: 
    ON::object_type enum value.

    @untitled table
    ON::unknown_object_type      unknown object
    ON::point_object             derived from ON_Point
    ON::pointset_object          some type of ON_PointCloud, ON_PointGrid, ...
    ON::curve_object             derived from ON_Curve
    ON::surface_object           derived from ON_Surface
    ON::brep_object              derived from ON_Brep
    ON::extrusion_object         derived from ON_Extrusion
    ON::mesh_object              derived from ON_Mesh
    ON::layer_object             derived from ON_Layer
    ON::material_object          derived from ON_Material
    ON::light_object             derived from ON_Light
    ON::annotation_object        derived from ON_Annotation,
    ON::userdata_object          derived from ON_UserData
    ON::text_dot                 derived from ON_TextDot

  Remarks:
    The default implementation of this virtual function returns
    ON::unknown_object_type
  */
  virtual
  ON::object_type ObjectType() const;



  /*
  Description:
    All objects in an opennurbs model have an id
    ( ON_Layer.m_layer_id, ON_Font.m_font_id, 
      ON_Material.m_material_id, ON_3dmObjectAttributes.m_uuid
      ).
  Returns:
    The id used to identify the object in the openurbs model.
  */
  virtual
  ON_UUID ModelObjectId() const;

  //////////////////////////////////////////////////////////////////
  //
  // BEGIN: User string support
  //

  /*
  Description:
    Attach a user string to the object.  This information will
    perisist through copy construction, operator=, and file IO.
  Parameters:
    key - [in] id used to retrieve this string.
    string_value - [in] 
      If NULL, the string with this id will be removed.
  Returns:
    True if successful.
  */
  bool SetUserString( 
    const wchar_t* key, 
    const wchar_t* string_value 
    );

  /*
  Description:
    Append entries to the user string list
  Parameters:
    count - [in]
      number of element in us[] array
    user_strings - [in]
      entries to append.
    bReplace - [in]
      If bReplace is true, then existing entries with the same key are
      updated with the new entry's value.  If bReplace is false, then
      existing entries are not updated.
  Returns:
    Number of entries added, deleted, or modified.
  */
  int SetUserStrings( int count, const ON_UserString* user_strings, bool bReplace );

  /*
  Description:
    Get user string from the object.
  Parameters:
    key - [in] id used to retrieve the string.
    string_value - [out]
  Returns:
    True if a string with id was found.
  */
  bool GetUserString( 
    const wchar_t* key, 
    ON_wString& string_value 
    ) const;

  /*
  Description:
    Get a list of all user strings on the object.
  Parameters:
    user_strings - [out]
      user strings are appended to this list.
  Returns:
    Number of elements appended to the user_strings list.
  */
  int GetUserStrings( 
    ON_ClassArray<ON_UserString>& user_strings 
    ) const;

  /*
  Description:
    Get a list of all user string keys on the object.
  Parameters:
    user_string_keys - [out]
      user string keys are appended to this list.
  Returns:
    Number of elements appended to the user_strings list.
  */
  int GetUserStringKeys( 
    ON_ClassArray<ON_wString>& user_string_keys 
    ) const;

  /*
  Returns:
    Number of user strings on the object.
  */
  int UserStringCount() const;

  //
  // END: User string support
  //
  //////////////////////////////////////////////////////////////////

  /////////////////////////////////////////////////////////////////
  //
  // User data provides a standard way for extra information to
  // be attached to any class derived from ON_Object.  The attached
  // information can persist and be transformed.  If you use user
  // data, please carefully read all the comments from here to the
  // end of the file.
  //

  /*
  Description:
    Attach user data to an object.
  Parameters:
    pUserData - [in] user data to attach to object.
        The ON_UserData pointer passed to AttachUserData()
        must be created with new.  
  Returns:
    If true is returned, then ON_Object will delete the user
    data when appropriate.  If false is returned, then data 
    could not be attached and caller must delete.  
  Remarks:
    AttachUserData() will fail if the user data's m_userdata_uuid
    field is nil or not unique.
  */
  ON_BOOL32 AttachUserData( 
          ON_UserData* pUserData 
          );

  /*
  Description:
    Remove user data from an object.
  Parameters:
    pUserData - [in] user data to attach to object.
        The ON_UserData pointer passed to DetachUserData()
        must have been previously attached using 
        AttachUserData().  
  Returns:
    If true is returned, then the user data was
    attached to this object and it was detached.  If false
    is returned, then the user data was not attached to this
    object to begin with.  In all cases, you can be assured
    that the user data is no longer attached to "this".
  Remarks:
    Call delete pUserData if you want to destroy the user data.
  */
  ON_BOOL32 DetachUserData(
          ON_UserData* pUserData 
          );


  /*
  Description:
    Get a pointer to user data.
  Parameters:
    userdata_uuid - [in] value of the user data's 
       m_userdata_uuid field.
  Remarks:
    The returned user data is still attached to the object.
    Deleting the returned user data will automatically remove
    the user data from the object.
  */
  ON_UserData* GetUserData( 
          const ON_UUID& userdata_uuid
          ) const;

  /*
  Description:
    PurgeUserData() removes all user data from object.  
  Remarks:
    Use delete GetUserData(...) to destroy a single piece
    of user data.
  */
  void PurgeUserData();

  /*
  Description:
    User data is stored as a linked list of ON_UserData
    classes.  FirstUserData gets the first item in the
    linked list.  This is the most recent item attached
    using AttachUserData().
  Remark:
    To iterate through all the user data on an object, 
    call FirstUserData() and then use ON_UserData::Next()
    to traverse the list.
  */
  ON_UserData* FirstUserData() const;

  /*
  Description:
    Objects derived from ON_Geometry must call
    TransformUserData() in their Transform() member function.
  Parameters:
    xform - [in] transformation to apply to user data
  */
  void TransformUserData( 
    const ON_Xform& xform
    );

  /*
  Description:
    Expert user tool that copies user data that has a positive 
    m_userdata_copycount from the source_object to this.
  Parameters:
    source_object - [in] source of user data to copy
  Remarks:
    Generally speaking you don't need to use CopyUserData().
    Simply rely on ON_Object::operator=() or the copy constructor
    to do the right thing.
  */
  void CopyUserData( 
    const ON_Object& source_object 
    );

  /*
  Description:
    Expert user tool Moves user data from source_object 
    to this, including user data with a nil m_userdata_copycount.
    Deletes any source user data with a duplicate m_userdata_uuid
    on this.
  */
  void MoveUserData( 
    ON_Object& source_object 
    );


  /////////////////////////////////////////////////////////////////
  //
  // Expert interface
  //

  /*
  Description:
    Expert user function.  If you are using openNURBS in its
    default configuration to read and write 3dm archives,
    you never need to call this function.
    Many objects employ lazy creation of (runtime) caches
    that save information to help speed geometric calculations.
    This function will destroy all runtime information.
  Parameters:
    bDelete - [in] if true, any cached information is properly
                   deleted.  If false, any cached information
                   is simply discarded.  This is useful when
                   the cached information may be in alternate
                   memory pools that are managed in nonstandard
                   ways.
  */
  virtual
  void DestroyRuntimeCache( bool bDelete = true );

private:
  friend int ON_BinaryArchive::ReadObject( ON_Object** );
  friend bool ON_BinaryArchive::WriteObject( const ON_Object& );
  friend bool ON_BinaryArchive::ReadObjectUserData( ON_Object& );
  friend bool ON_BinaryArchive::WriteObjectUserData( const ON_Object& );
  friend class ON_UserData;
  ON_UserData* m_userdata_list;
};

#endif

/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_USERDATA_INC_)
#define OPENNURBS_USERDATA_INC_

class ON_CLASS ON_UserData : public ON_Object
{
  ON_OBJECT_DECLARE(ON_UserData);
public:
  ON_UserData();
  ON_UserData(const ON_UserData&);
  ON_UserData& operator=(const ON_UserData&);

  //////////
  // The destructor automatically removes the user data
  // from ON_Object::m_userdata_list.
  ~ON_UserData();

  /*
  Description:
    Tests an object to see if its data members are correctly
    initialized.
  Parameters:
    text_log - [in] if the object is not valid and text_log
        is not NULL, then a brief englis description of the
        reason the object is not valid is appened to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     object is valid
    false    object is invalid, uninitialized, etc.
  Remarks:
    Overrides virtual ON_Object::IsValid
  */
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  /*
  Description:
    Overrides virtual ON_Object::Dump().
    Prints class name, description, and uuid.
  Parameters:
    text_log - [in] Information is sent to this text log.
  Remarks:
  */
  void Dump( ON_TextLog& text_log ) const;

  /*
  Description:
    Overrides virtual ON_Object::SizeOf().
  Returns:
    Approximate number of bytes this class uses.
  */
  unsigned int SizeOf() const;

  ////////
  // Returns object that owns the user data
  ON_Object* Owner() const;

  ////////
  // Used for traversing list of user data attached
  // to an object.
  ON_UserData* Next() const;

  ////////
  // Returns the class id which is not necessarily the 
  // same as m_userdata_uuid.
  ON_UUID UserDataClassUuid() const; 

  //////////
  // Returns true if the user data is anonymous.  This happens
  // when the user data class is not defined at the time the
  // user data is read from an archive.  For example, if a class
  // derived from ON_UserData is defined in application A
  // but is not defined in application B, then the class can be
  // defined when an archive is written by A but not exist when
  // an archive is read by B.  In this case, the
  // user data is not lost, it is just read as ON_UnknownUserData
  // by application B.  If application B saves the parent
  // object in an archive, the unknown user data is resaved in
  // a form that can be read by application A.
  ON_BOOL32 IsUnknownUserData() const;

  /*
  Parameters:
    description - [out] description of user data shown in 
                        object properties dump.
  Returns:
    True if user data class is ready.
  */
  virtual 
  ON_BOOL32 GetDescription( ON_wString& description );

  /*
  Description:
    User will persist in binary archives if Archive() returns
    true, m_application_uuid is not nil, and the virtual Read() 
    and Write() are functions are overridden.

  Returns:
    true if user data should persist in binary archives.
    false if the user data should not be save in binary archives.

  Remarks:
    The default implementation returns false.  If you override
    ON_UserData::Archive so that it returns true, then your 
    constructor must set m_application_uuid, you must override
    the virtual ON_Object::Read and ON_Object::Write functions and
    you must CAREFULLY TEST your code.

    ON_UserData requires expert programming and testing skills.

    YOU SHOULD READ AND UNDERSTAND EVERY COMMENT IN THIS 
    HEADER FILE IN BEFORE ATTEMPTING TO USE ON_UserData.
  */
  virtual 
  ON_BOOL32 Archive() const; 

  /*
  Description:
    If Transform() return false, then the userdata is destroyed when 
    its parent object is transformed.  The default Transform() 
    updates m_userdata_xform and returns true. 
    Carefully read the comments above m_userdata_xform
  */
  virtual 
  ON_BOOL32 Transform( const ON_Xform& ); 

  /*
  Description:
    This uuid is the value that must be passed to 
    ON_Object::GetUserData() to retrieve 
    this piece of user data.
  */
  ON_UUID m_userdata_uuid;

  /*
  Description:
    This uuid is used to identify the application that
    created this piece of user data.  In the case of
    Rhino, this is the id of the plug-in that created
    the user data. User data with a nil application id
    will not be saved in 3dm archives.
  */
  ON_UUID m_application_uuid;

  ////////
  // If m_userdata_copycount is 0, user data is not copied when 
  // object is copied.  If > 0, user data is copied and m_copycount
  // is incremented when parent object is copied. The user data's 
  // operator=() is used to copy.  
  // The default ON_UserData::ON_UserData() constructor sets 
  // m_userdata_copycount to zero.
  unsigned int m_userdata_copycount;  

  ////////
  // Updated if user data is attached to a piece of geometry that is
  // transformed and the virtual ON_UserData::Transform() is not 
  // overridden.  If you override ON_UserData::Transform() and want
  // m_userdata_xform to be updated, then call the 
  // ON_UserData::Transform() in your override.
  // The default constructor sets m_userdata_xform to the identity.
  ON_Xform m_userdata_xform; 

private: // don't look and don't touch - these may change
  friend int ON_BinaryArchive::ReadObject( ON_Object** );
  friend bool ON_BinaryArchive::WriteObject( const ON_Object& );
  friend bool ON_BinaryArchive::ReadObjectUserData( ON_Object& );
  friend bool ON_BinaryArchive::WriteObjectUserData( const ON_Object& );
  friend class ON_Object;
  ON_Object* m_userdata_owner; 
  ON_UserData* m_userdata_next;
};

class ON_CLASS ON_UnknownUserData : public ON_UserData
{
  ON_OBJECT_DECLARE(ON_UnknownUserData);
  // used to hold user data will application class is not loaded
  // at time data is read
public:
  ON_UnknownUserData();
  ON_UnknownUserData(const ON_UnknownUserData&);
  ~ON_UnknownUserData();
  ON_UnknownUserData& operator=(const ON_UnknownUserData&);

  // ON_Object overrides

  /*
  Description:
    Tests an object to see if its data members are correctly
    initialized.
  Parameters:
    text_log - [in] if the object is not valid and text_log
        is not NULL, then a brief englis description of the
        reason the object is not valid is appened to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     object is valid
    false    object is invalid, uninitialized, etc.
  Remarks:
    Overrides virtual ON_Object::IsValid
  */
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  void Dump( ON_TextLog& ) const;
  ON_BOOL32 Write( ON_BinaryArchive& ) const;
  ON_BOOL32 Read( ON_BinaryArchive& );

  unsigned int SizeOf() const; // return amount of memory used by user data
  ON_BOOL32 GetDescription( ON_wString& ); // description of user data
  ON_BOOL32 Archive() const; 

  // Convert unknown user data to actual user data.  Useful if
  // definition of actual user data is dynamically linked after
  // archive containing user data is read.
  ON_UserData* Convert() const;

  /*
  Description:
    This is the uuid of the missing class.  This uuid
    is the 3rd parameter to the ON_OBJECT_IMPLEMENT()
    macro of the missing class.
  */
  ON_UUID m_unknownclass_uuid;
  int m_sizeof_buffer;
  void* m_buffer;

  // These version numbers are set when unknown user data is read
  // from a file record the version of the 3dm archive and the 
  // version of opennurbs that were used when the plug-in wrote
  // the user data.
  //   This information was added in to V5 opennurbs 200910190.
  // For files written with earlier versions of opennurbs, these
  // values are set from the archive containing the user data. 
  // The purpose of this version information is to have it accompany
  // unknown user data so that if is is eventually read by the plug-in
  // an ON_BinaryArchive with correct version information can be
  // passed to the plug-in's reading code.  In archives, these values
  // are stored in the TCODE_USER_TABLE_RECORD_HEADER chunk.
  int m_3dm_version; // 3dm archive version (0,1,2,3,4,5,50,...)
  int m_3dm_opennurbs_version; // 0 or YYYYMMDDN
};

class ON_CLASS ON_UserStringList : public ON_UserData
{
  ON_OBJECT_DECLARE(ON_UserStringList);
public:

  ON_UserStringList();
  ~ON_UserStringList();

  // override virtual ON_Object::Dump function
  void Dump( ON_TextLog& text_log ) const;

  // override virtual ON_Object::SizeOf function
  unsigned int SizeOf() const;

  // override virtual ON_Object::DataCRC function
  ON__UINT32 DataCRC(ON__UINT32 current_remainder) const;

  // override virtual ON_Object::Write function
  ON_BOOL32 Write(ON_BinaryArchive& binary_archive) const;

  // override virtual ON_Object::Read function
  ON_BOOL32 Read(ON_BinaryArchive& binary_archive);

  // override virtual ON_UserData::GetDescription function
  ON_BOOL32 GetDescription( ON_wString& description );

  // override virtual ON_UserData::Archive function
  ON_BOOL32 Archive() const; 

  /*
  Description:
    Add, replace or remove a user string.
  Parameters:
    key - [in]
      must be a non-empty string.  If an entry with the same key
      (case insensitive compares are used) exists, the existing
      entry is updated.
    string_value - [in]
      If string_value is empty and an entry with a matching key
      exists, the entry is deleted.
  Returns:
    True if the key is valid.
  */
  bool SetUserString( const wchar_t* key, const wchar_t* string_value );

  bool GetUserString( const wchar_t* key, ON_wString& string_value ) const;

  /*
  Description:
    Append entries to the user string list
  Parameters:
    count - [in]
      number of element in us[] array
    us - [in]
      entries to append.
    bReplace - [in]
      If bReplace is true, then existing entries with the same key are
      updated with the new entry's value.  If bReplace is false, then
      existing entries are not updated.
  Returns:
    Number of entries added, deleted, or modified.
  */
  int SetUserStrings( int count, const ON_UserString* us, bool bReplace );

  ON_ClassArray<ON_UserString> m_e;
};

class ON_CLASS ON_UserDataHolder : public ON_Object
{
public:
  /*
  Description:
    Transfers the user data from source_object to "this".
    When MoveUserDataFrom() returns source_object will not 
    have any user data.  If "this" had user data when 
    MoveUserDataFrom() was called, then that user data is
    destroyed.
  Parameters:
    source_object - [in] The "const" is a lie.  It is
      there because, in practice the source object is frequently
      const and const_cast ends up being excessively used.
  Returns:
    True if source_object had user data that was transfered
    to "this".  False if source_object had no user data.
    In any case, any user data that was on the input "this"
    is destroyed.
  */
  bool MoveUserDataFrom( const ON_Object& source_object );

  /*
  Description:
    Transfers the user data on "this" to source_object.
    When MoveUserDataTo() returns "this" will not have any
    user data.
  Parameters:
    source_object - [in] The "const" is a lie.  It is
      there because, in practice the source object is generally
      const and const_cast ends up being constantly used.
    bAppend - [in] if true, existing user data on source_object
      is left unchanged.  If false, existing user data on source_object
      is destroyed, even when there is no user data on "this".
  Returns:
    True if "this" had user data that was transfered to source_object.
    In any case, any user data that was on the input "this"
    is destroyed.
  */
  bool MoveUserDataTo(  const ON_Object& source_object, bool bAppend );

  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;
};

/*
Description:
  An ON_DocumentUserStringList object is saved in the list of user
  tables.  The Rhino SetDocumentText and GetDocumentText
  commands use the ON_Object SetUserString, GetUserString,
  GetUserStrings, GetUserStringKeys functions on an 
  ON_DocumentUserStringList class to manage the tag-value pairs of 
  strings.
*/
class ON_CLASS ON_DocumentUserStringList : public ON_Object
{
  ON_OBJECT_DECLARE(ON_DocumentUserStringList);
public:
  ON_DocumentUserStringList();
  ~ON_DocumentUserStringList();

  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;
  void Dump( ON_TextLog& ) const;
  ON__UINT32 DataCRC(ON__UINT32 current_remainder) const;
  ON_BOOL32 Write(ON_BinaryArchive& binary_archive) const;
  ON_BOOL32 Read(ON_BinaryArchive& binary_archive);

  // Use the
  //   ON_Object::SetUserString()
  //   ON_Object::GetUserString()
  //   ON_Object::GetUserStrings()
  //   ON_Object::GetUserStringKeys()
  //   ON_Object::UserStringCount()
  // functions to access and modify user string information.
};

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

////////////////////////////////////////////////////////////////
//
//   virtual base class for all geomtric objects
//
////////////////////////////////////////////////////////////////

#if !defined(OPENNURBS_GEOMETRY_INC_)
#define OPENNURBS_GEOMETRY_INC_

class ON_Brep;

////////////////////////////////////////////////////////////////

// Description:
//   Base class for all geometry classes that must
//   provide runtime class id.  Provides interface
//   for common geometric operations like finding bounding
//   boxes and transforming.
//
class ON_CLASS ON_Geometry : public ON_Object
{
  // Any object derived from ON_Geometry should have a
  //   ON_OBJECT_DECLARE(ON_...);
  // as the last line of its class definition and a
  //   ON_OBJECT_IMPLEMENT( ON_..., ON_baseclass );
  // in a .cpp file.
  //
  // See the definition of ON_Object for details.
  ON_OBJECT_DECLARE(ON_Geometry);

public:
  ON_Geometry();
  ON_Geometry(const ON_Geometry&);
  ON_Geometry& operator=(const ON_Geometry&);
  virtual ~ON_Geometry();

  // Description: 
  //   Get object's 3d axis aligned bounding box.
  // Returns:
  //   3d bounding box.
  // Remarks:
  //   Uses virtual GetBBox() function to calculate the result.
  ON_BoundingBox BoundingBox() const;

  // Description:
  //   Get object's 3d axis aligned bounding box or the
  //   union of the input box with the object's bounding box.
  // Parameters:
  //   bbox - [in/out] 3d axis aligned bounding box
  //   bGrowBox - [in] (default=false) 
  //     If true, then the union of the input bbox and the 
  //     object's bounding box is returned in bbox.  
  //     If false, the object's bounding box is returned in bbox.
  // Returns:
  //   true if object has bounding box and calculation was successful.
  // Remarks:
  //   Uses virtual GetBBox() function to calculate the result.
  ON_BOOL32 GetBoundingBox(
         ON_BoundingBox& bbox,
         int bGrowBox = false
         ) const;

  // Description:
  //   Get corners of object's 3d axis aligned bounding box
  //   or the union of the input box with the object's bounding
  //   box.
  // Parameters:
  //   bbox_min - [in/out] minimum corner of the 3d bounding box
  //   bbox_max - [in/out] maximum corner of the 3d bounding box
  //   bGrowBox - [in] (default=false) 
  //     If true, then the union of the input bbox and the 
  //     object's bounding box is returned.
  //     If false, the object's bounding box is returned.
  // Returns:
  //   true if successful.
  ON_BOOL32 GetBoundingBox(
         ON_3dPoint& bbox_min,
         ON_3dPoint& bbox_max,
         int bGrowBox = false
         ) const;

  // Description:
  //   Rotates the object about the specified axis.  A positive
  //   rotation angle results in a counter-clockwise rotation
  //   about the axis (right hand rule).
  // Parameters:
  //   sin_angle - [in] sine of rotation angle
  //   cos_angle - [in] sine of rotation angle
  //   rotation_axis - [in] direction of the axis of rotation
  //   rotation_center - [in] point on the axis of rotation
  // Returns:
  //   true if object successfully rotated
  // Remarks:
  //   Uses virtual Transform() function to calculate the result.
  ON_BOOL32 Rotate(
        double sin_angle,
        double cos_angle,
        const ON_3dVector& rotation_axis,
        const ON_3dPoint& rotation_center
        );

  // Description:
  //   Rotates the object about the specified axis.  A positive
  //   rotation angle results in a counter-clockwise rotation
  //   about the axis (right hand rule).
  // Parameters:
  //   rotation_angle - [in] angle of rotation in radians
  //   rotation_axis - [in] direction of the axis of rotation
  //   rotation_center - [in] point on the axis of rotation
  // Returns:
  //   true if object successfully rotated
  // Remarks:
  //   Uses virtual Transform() function to calculate the result.
  ON_BOOL32 Rotate(
        double rotation_angle,
        const ON_3dVector& rotation_axis,
        const ON_3dPoint& rotation_center
        );

  // Description:
  //   Translates the object along the specified vector.
  // Parameters:
  //   translation_vector - [in] translation vector
  // Returns:
  //   true if object successfully translated
  // Remarks:
  //   Uses virtual Transform() function to calculate the result.
  ON_BOOL32 Translate( 
    const ON_3dVector& translation_vector
    );

  // Description:
  //   Scales the object by the specified facotor.  The scale is
  //   centered at the origin.
  // Parameters:
  //   scale_factor - [in] scale factor
  // Returns:
  //   true if object successfully scaled
  // Remarks:
  //   Uses virtual Transform() function to calculate the result.
  ON_BOOL32 Scale( 
    double scale_factor
    );

  // Description:
  //   Dimension of the object.
  // Returns:
  //   Dimension of the object.
  // Remarks:
  //   The dimension is typically three.  For parameter space trimming
  //   curves the dimension is two.  In rare cases the dimension can
  //   be one or greater than three.
  virtual 
  int Dimension() const = 0;

  // Description:
  //   This is the virtual function that actually calculates axis
  //   aligned bounding boxes.
  // Parameters:
  //   boxmin - [in/out] array of Dimension() doubles
  //   boxmax - [in/out] array of Dimension() doubles
  //   bGrowBox - [in] (default=false) 
  //     If true, then the union of the input bbox and the 
  //     object's bounding box is returned in bbox.  
  //     If false, the object's bounding box is returned in bbox.
  // Returns:
  //   true if object has bounding box and calculation was successful
  virtual
  ON_BOOL32 GetBBox(
         double* boxmin,
         double* boxmax,
         int bGrowBox = false
         ) const = 0;

  /*
	Description:
    Get tight bounding box.
	Parameters:
		tight_bbox - [in/out] tight bounding box
		bGrowBox -[in]	(default=false)			
      If true and the input tight_bbox is valid, then returned
      tight_bbox is the union of the input tight_bbox and the 
      curve's tight bounding box.
		xform -[in] (default=NULL)
      If not NULL, the tight bounding box of the transformed
      geometry is calculated.  The geometry is not modified.
	Returns:
    True if a valid tight_bbox is returned.
  Remarks:
    In general, GetTightBoundingBox is slower that BoundingBox,
    especially when xform is not null.
  */
  virtual
	bool GetTightBoundingBox( 
			ON_BoundingBox& tight_bbox, 
      int bGrowBox = false,
			const ON_Xform* xform = 0
      ) const;

  // Description:
  //   Some objects cache bounding box information.
  //   If you modify an object, then call ClearBoundingBox()
  //   to inform the object that any cached bounding boxes
  //   are invalid.  
  //
  // Remarks:
  //   Generally, ClearBoundingBox() overrides
  //   simply invalidate a cached bounding box and then wait
  //   for a call to GetBBox() before recomputing the bounding box.
  //
  //   The default implementation does nothing.
  virtual
  void ClearBoundingBox();

  /*
  Description:
    Transforms the object.
 
  Parameters:
    xform - [in] transformation to apply to object.
      If xform.IsSimilarity() is zero, then you may
      want to call MakeSquishy() before calling
      Transform.
 
  Remarks:
    When overriding this function, be sure to include a call
    to ON_Object::TransformUserData() which takes care of 
    transforming any ON_UserData that may be attached to 
    the object.

  See Also:
    ON_Geometry::IsDeformable();

  Remarks:
    Classes derived from ON_Geometry should call
    ON_Geometry::Transform() to handle user data
    transformations and then transform their
    definition.
  */
  virtual
  ON_BOOL32 Transform( 
         const ON_Xform& xform
         );

  /*
  Returns:
    True if object can be accuratly modified with 
    "squishy" transformations like projections, 
    shears, an non-uniform scaling.
  See Also:
    ON_Geometry::MakeDeformable();
  */
  virtual
  bool IsDeformable() const;

  /*
  Description:
    If possible, converts the object into a form that can
    be accuratly modified with "squishy" transformations
    like projections, shears, an non-uniform scaling.
  Returns:
    False if object cannot be converted to a deformable
    object.  True if object was already deformable or
    was converted into a deformable object.
  See Also:
    ON_Geometry::IsDeformable();
  */
  virtual
  bool MakeDeformable();

  // Description:
  //   Swaps object coordinate values with indices i and j.
  //
  // Parameters:
  //   i - [in] coordinate index
  //   j - [in] coordinate index
  //
  // Remarks:
  //   The default implementation uses the virtual Transform() 
  //   function to calculate the result.  If you are creating
  //   an object where Transform() is slow, coordinate swapping
  //   will be frequently used, and coordinate swapping can
  //   be quickly accomplished, then override this function.
  //
  // Example:
  //
  //          ON_Point point(7,8,9);
  //          point.SwapCoordinates(0,2);
  //          // point = (9,8,7)
  virtual
  ON_BOOL32 SwapCoordinates(
        int i,
        int j
        );

  /*
  Description:
    Query an object to see if it has an ON_Brep form.
  Result:
    Returns true if the virtual ON_Geometry::BrepForm can compute
    an ON_Brep representation of this object.
  Remarks:
    The default implementation of ON_Geometry::BrepForm returns 
    false.
  See Also
    ON_Geometry::BrepForm
  */
  virtual
  ON_BOOL32 HasBrepForm() const;

  /*
  Description:
    If possible, BrepForm() creates a brep form of the
    ON_Geometry. 
  Parameters:
    brep - [in] if not NULL, brep is used to store the brep
        form of the geometry.
  Result:
    Returns a pointer to on ON_Brep or NULL.  If the brep
    parameter is not NULL, then brep is returned if the
    geometry has a brep form and NULL is returned if the
    geometry does not have a brep form.
  Remarks:
    The caller is responsible for managing the brep memory.
  See Also
    ON_Geometry::HasBrepForm
  */
  virtual
  ON_Brep* BrepForm( ON_Brep* brep = NULL ) const;

  /*
  Description:
    If this piece of geometry is a component in something
    larger, like an ON_BrepEdge in an ON_Brep, then this
    function returns the component index.
  Returns:
    This object's component index.  If this object is
    not a sub-piece of a larger geometric entity, then
    the returned index has 
    m_type = ON_COMPONENT_INDEX::invalid_type
    and
    m_index = -1.
  */
  virtual
  ON_COMPONENT_INDEX ComponentIndex() const;

  /*
  Description:
    Evaluate the location of a point from the object
    reference.
  Parameters:
    objref - [in]
    point - [out]
      If the evaluation cannot be performed, ON_UNSET_POINT
      is returned.
  Returns:
    True if successful.
  */
  virtual
  bool EvaluatePoint( const class ON_ObjRef& objref, ON_3dPoint& P ) const;
};

#endif

/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

////////////////////////////////////////////////////////////////
//
//   Definition of virtual parametric curve
//
////////////////////////////////////////////////////////////////

#if !defined(OPENNURBS_CURVE_INC_)
#define OPENNURBS_CURVE_INC_

class ON_Curve;
class ON_Plane;
class ON_Arc;
class ON_NurbsCurve;
class ON_CurveTree;


////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////


class ON_CLASS ON_MeshCurveParameters
{
public:
  ON_MeshCurveParameters();

  // If main_seg_count <= 0, then both these parameters are ignored.
  // If main_seg_count > 0, then sub_seg_count must be >= 1.  In this
  // case the curve will be broken into main_seg_count equally spaced
  // chords. If needed, each of these chords can be split into as many
  // sub_seg_count sub-parts if the subdivision is necessary for the
  // mesh to meet the other meshing constraints.  In particular, if
  // sub_seg_count = 0, then the curve is broken into main_seg_count
  // pieces and no further testing is performed.
  int m_main_seg_count; 
  int m_sub_seg_count;

  int m_reserved1;
  int m_reserved2;

  // Maximum angle (in radians) between unit tangents at adjacent
  // vertices.
  double m_max_ang_radians;

  // Maximum permitted value of 
  // distance chord midpoint to curve) / (length of chord)
  double m_max_chr;

  // If max_aspect < 1.0, the parameter is ignored. 
  // If 1 <= max_aspect < sqrt(2), it is treated as if 
  // max_aspect = sqrt(2).
  // This parameter controls the maximum permitted value of
  // (length of longest chord) / (length of shortest chord)
  double m_max_aspect;

  // If tolerance = 0, the parameter is ignored.
  // This parameter controls the maximum permitted value of the
  // distance from the curve to the mesh.  
  double m_tolerance;

  // If m_min_edge_length = 0, the parameter is ignored.
  // This parameter controls the minimum permitted edge length.
  double m_min_edge_length;
  
  // If max_edge_length = 0, the parameter is ignored.
  // This parameter controls the maximum permitted edge length.
  double m_max_edge_length;

  double m_reserved3;
  double m_reserved4;
};

class ON_CLASS ON_Curve : public ON_Geometry
{
  // pure virtual class for curve objects

  // Any object derived from ON_Curve should have a
  //   ON_OBJECT_DECLARE(ON_...);
  // as the last line of its class definition and a
  //   ON_OBJECT_IMPLEMENT( ON_..., ON_baseclass );
  // in a .cpp file.
  //
  // See the definition of ON_Object for details.
  ON_OBJECT_DECLARE(ON_Curve);

public:
  // virtual ON_Object::DestroyRuntimeCache override
  void DestroyRuntimeCache( bool bDelete = true );

public:
  ON_Curve();
  ON_Curve(const ON_Curve&);
  ON_Curve& operator=(const ON_Curve&);
  virtual ~ON_Curve();

  // virtual ON_Object::SizeOf override
  unsigned int SizeOf() const;

  // virtual ON_Geometry override
  bool EvaluatePoint( const class ON_ObjRef& objref, ON_3dPoint& P ) const;

  /*
  Description:
    Get a duplicate of the curve.
  Returns:
    A duplicate of the curve.  
  Remarks:
    The caller must delete the returned curve.
    For non-ON_CurveProxy objects, this simply duplicates the curve using
    ON_Object::Duplicate.
    For ON_CurveProxy objects, this duplicates the actual proxy curve 
    geometry and, if necessary, trims and reverse the result to that
    the returned curve's parameterization and locus match the proxy curve's.
  */
  virtual
  ON_Curve* DuplicateCurve() const;

  // Description:
  //   overrides virtual ON_Object::ObjectType.
  // Returns:
  //   ON::curve_object
  ON::object_type ObjectType() const;

  /*
	Description:
    Get tight bounding box of the curve.
	Parameters:
		tight_bbox - [in/out] tight bounding box
		bGrowBox -[in]	(default=false)			
      If true and the input tight_bbox is valid, then returned
      tight_bbox is the union of the input tight_bbox and the 
      curve's tight bounding box.
		xform -[in] (default=NULL)
      If not NULL, the tight bounding box of the transformed
      curve is calculated.  The curve is not modified.
	Returns:
    True if the returned tight_bbox is set to a valid 
    bounding box.
  */
	bool GetTightBoundingBox( 
			ON_BoundingBox& tight_bbox, 
      int bGrowBox = false,
			const ON_Xform* xform = 0
      ) const;

  ////////////////////////////////////////////////////////////////////
  // curve interface

  // Description:
  //   Gets domain of the curve
  // Parameters:
  //   t0 - [out]
  //   t1 - [out] domain is [*t0, *t1]
  // Returns:
  //   true if successful.
  ON_BOOL32 GetDomain( double* t0, double* t1 ) const;

  // Returns:
  //   domain of the curve.
  virtual 
  ON_Interval Domain() const = 0;

  /*
  Description:
    Set the domain of the curve.
  Parameters:
    domain - [in] increasing interval
  Returns:
    true if successful.
  */
  bool SetDomain( ON_Interval domain );

  // Description:
  //   Set the domain of the curve
  // Parameters:
  //   t0 - [in]
  //   t1 - [in] new domain will be [t0,t1]
  // Returns:
  //   true if successful.
  virtual
  ON_BOOL32 SetDomain( 
        double t0, 
        double t1 
        );


  /*
  Description:
    If this curve is closed, then modify it so that
    the start/end point is at curve parameter t.
  Parameters:
    t - [in] curve parameter of new start/end point.  The
             returned curves domain will start at t.
  Returns:
    true if successful.
  */
  virtual 
  ON_BOOL32 ChangeClosedCurveSeam( 
            double t 
            );

  /*
  Description:
    Change the dimension of a curve.
  Parameters:
    desired_dimension - [in]
  Returns:
    true if the curve's dimension was already desired_dimension
    or if the curve's dimension was successfully changed to
    desired_dimension.
  */
  virtual
  bool ChangeDimension(
          int desired_dimension
          );


  // Description:
  //   Get number of nonempty smooth (c-infinity) spans in curve
  // Returns:
  //   Number of nonempty smooth (c-infinity) spans.
  virtual 
  int SpanCount() const = 0;

  // Description:
  //   Get number of parameters of "knots".
  // Parameters:
  //   knots - [out] an array of length SpanCount()+1 is filled in
  //       with the parameters where the curve is not smooth (C-infinity).
  // Returns:
  //   true if successful
  virtual
  ON_BOOL32 GetSpanVector(
        double* knots
        ) const = 0; // 

  //////////
  // If t is in the domain of the curve, GetSpanVectorIndex() returns the 
  // span vector index "i" such that span_vector[i] <= t <= span_vector[i+1].
  // The "side" parameter determines which span is selected when t is at the
  // end of a span.
  virtual
  ON_BOOL32 GetSpanVectorIndex(
        double t ,               // [IN] t = evaluation parameter
        int side,                // [IN] side 0 = default, -1 = from below, +1 = from above
        int* span_vector_index,  // [OUT] span vector index
        ON_Interval* span_domain // [OUT] domain of the span containing "t"
        ) const;

  // Description:
  //   Returns maximum algebraic degree of any span
  //   or a good estimate if curve spans are not algebraic.
  // Returns:
  //   degree
  virtual 
  int Degree() const = 0; 

  // Description:
  //   Returns maximum algebraic degree of any span
  //   or a good estimate if curve spans are not algebraic.
  // Returns:
  //   degree
  virtual 
  ON_BOOL32 GetParameterTolerance( // returns tminus < tplus: parameters tminus <= s <= tplus
         double t,       // [IN] t = parameter in domain
         double* tminus, // [OUT] tminus
         double* tplus   // [OUT] tplus
         ) const;

  // Description:
  //   Test a curve to see if the locus if its points is a line segment.
  // Parameters:
  //   tolerance - [in] // tolerance to use when checking linearity
  // Returns:
  //   true if the ends of the curve are farther than tolerance apart
  //   and the maximum distance from any point on the curve to
  //   the line segment connecting the curve's ends is <= tolerance.
  virtual
  ON_BOOL32 IsLinear(
        double tolerance = ON_ZERO_TOLERANCE 
        ) const;

  /*
  Description:
    Several types of ON_Curve can have the form of a polyline including
    a degree 1 ON_NurbsCurve, an ON_PolylineCurve, and an ON_PolyCurve
    all of whose segments are some form of polyline.  IsPolyline tests
    a curve to see if it can be represented as a polyline.
  Parameters:
    pline_points - [out] if not NULL and true is returned, then the
        points of the polyline form are returned here.
    t - [out] if not NULL and true is returned, then the parameters of
        the polyline points are returned here.
  Returns:
    @untitled table
    0        curve is not some form of a polyline
    >=2      number of points in polyline form
  */
  virtual
  int IsPolyline(
        ON_SimpleArray<ON_3dPoint>* pline_points = NULL,
        ON_SimpleArray<double>* pline_t = NULL
        ) const;

  // Description:
  //   Test a curve to see if the locus if its points is an arc or circle.
  // Parameters:
  //   plane - [in] if not NULL, test is performed in this plane
  //   arc - [out] if not NULL and true is returned, then arc parameters
  //               are filled in
  //   tolerance - [in] tolerance to use when checking
  // Returns:
  //   ON_Arc.m_angle > 0 if curve locus is an arc between
  //   specified points.  If ON_Arc.m_angle is 2.0*ON_PI, then the curve
  //   is a circle.
  virtual
  ON_BOOL32 IsArc(
        const ON_Plane* plane = NULL,
        ON_Arc* arc = NULL,
        double tolerance = ON_ZERO_TOLERANCE
        ) const;

  /*
  Description:
  Parameters:
    t - [in] curve parameter
    plane - [in]
      if not NULL, test is performed in this plane
    arc - [out]
      if not NULL and true is returned, then arc parameters
       are filled in
    tolerance - [in]
      tolerance to use when checking
    t0 - [out]
      if not NULL, and then *t0 is set to the parameter
      at the start of the G2 curve segment that was
      tested.
    t1 - [out]
      if not NULL, and then *t0 is set to the parameter
      at the start of the G2 curve segment that was
      tested.
  Returns:
    True if the paramter t is on a arc segment of the curve.
  */
  bool IsArcAt( 
    double t, 
    const ON_Plane* plane = 0,
    ON_Arc* arc = 0,
    double tolerance = ON_ZERO_TOLERANCE,
    double* t0 = 0, 
    double* t1 = 0
    ) const;

  virtual
  bool IsEllipse(
      const ON_Plane* plane = NULL,
      ON_Ellipse* ellipse = NULL,
      double tolerance = ON_ZERO_TOLERANCE
      ) const;

  // Description:
  //   Test a curve to see if it is planar.
  // Parameters:
  //   plane - [out] if not NULL and true is returned,
  //                 the plane parameters are filled in.
  //   tolerance - [in] tolerance to use when checking
  // Returns:
  //   true if there is a plane such that the maximum distance from
  //   the curve to the plane is <= tolerance.
  virtual
  ON_BOOL32 IsPlanar(
        ON_Plane* plane = NULL,
        double tolerance = ON_ZERO_TOLERANCE
        ) const;

  // Description:
  //   Test a curve to see if it lies in a specific plane.
  // Parameters:
  //   test_plane - [in]
  //   tolerance - [in] tolerance to use when checking
  // Returns:
  //   true if the maximum distance from the curve to the
  //   test_plane is <= tolerance.
  virtual
  ON_BOOL32 IsInPlane(
        const ON_Plane& test_plane,
        double tolerance = ON_ZERO_TOLERANCE
        ) const = 0;

  /*
  Description:
    Decide if it makes sense to close off this curve by moving 
    the endpoint to the start based on start-end gap size and length
    of curve as approximated by chord defined by 6 points.
  Parameters:
    tolerance - [in] maximum allowable distance between start and end.
                     if start - end gap is greater than tolerance, returns false
    min_abs_size - [in] if greater than 0.0 and none of the interior sampled
                     points are at least min_abs_size from start, returns false.
    min_rel_size - [in] if greater than 1.0 and chord length is less than 
                     min_rel_size*gap, returns false.
  Returns:
    true if start and end points are close enough based on above conditions.
  */

  bool IsClosable(
        double tolerance,
        double min_abs_size = 0.0,
        double min_rel_size = 10.0
        ) const;

  // Description:
  //   Test a curve to see if it is closed.
  // Returns:
  //   true if the curve is closed.
  virtual 
  ON_BOOL32 IsClosed() const;

  // Description:
  //   Test a curve to see if it is periodic.
  // Returns:
  //   true if the curve is closed and at least C2 at the start/end.
  virtual 
  ON_BOOL32 IsPeriodic() const;

  /*
  Description:
    Search for a derivatitive, tangent, or curvature 
    discontinuity.
  Parameters:
    c - [in] type of continity to test for.
    t0 - [in] Search begins at t0. If there is a discontinuity
              at t0, it will be ignored.  This makes it 
              possible to repeatedly call GetNextDiscontinuity
              and step through the discontinuities.
    t1 - [in] (t0 != t1)  If there is a discontinuity at t1 is 
              will be ingored unless c is a locus discontinuity
              type and t1 is at the start or end of the curve.
    t - [out] if a discontinuity is found, then *t reports the
          parameter at the discontinuity.
    hint - [in/out] if GetNextDiscontinuity will be called 
       repeatedly, passing a "hint" with initial value *hint=0
       will increase the speed of the search.       
    dtype - [out] if not NULL, *dtype reports the kind of 
        discontinuity found at *t.  A value of 1 means the first 
        derivative or unit tangent was discontinuous.  A value 
        of 2 means the second derivative or curvature was 
        discontinuous.  A value of 0 means teh curve is not
        closed, a locus discontinuity test was applied, and
        t1 is at the start of end of the curve.
        If 'c', the type of continuity to test for 
        is ON::Gsmooth_continuous and the curvature changes 
        from curved to 0 or 0 to curved and there is no 
        tangency kink dtype is returns 3
    cos_angle_tolerance - [in] default = cos(1 degree) Used only
        when c is ON::G1_continuous or ON::G2_continuous.  If the
        cosine of the angle between two tangent vectors is 
        <= cos_angle_tolerance, then a G1 discontinuity is reported.
    curvature_tolerance - [in] (default = ON_SQRT_EPSILON) Used 
        only when c is ON::G2_continuous.  If K0 and K1 are 
        curvatures evaluated from above and below and 
        |K0 - K1| > curvature_tolerance, then a curvature 
        discontinuity is reported.
  Returns:
    Parametric continuity tests c = (C0_continuous, ..., G2_continuous):

      true if a parametric discontinuity was found strictly 
      between t0 and t1. Note well that all curves are 
      parametrically continuous at the ends of their domains.

    Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):

      true if a locus discontinuity was found strictly between
      t0 and t1 or at t1 is the at the end of a curve.
      Note well that all open curves (IsClosed()=false) are locus
      discontinuous at the ends of their domains.  All closed 
      curves (IsClosed()=true) are at least C0_locus_continuous at 
      the ends of their domains.
  */
  virtual
  bool GetNextDiscontinuity( 
                  ON::continuity c,
                  double t0,
                  double t1,
                  double* t,
                  int* hint=NULL,
                  int* dtype=NULL,
                  double cos_angle_tolerance=ON_DEFAULT_ANGLE_TOLERANCE_COSINE,
                  double curvature_tolerance=ON_SQRT_EPSILON
                  ) const;

  /*
  Description:
    Test continuity at a curve parameter value.
  Parameters:
    c - [in] type of continuity to test for. Read ON::continuity
             comments for details.
    t - [in] parameter to test
    hint - [in] evaluation hint
    point_tolerance - [in] if the distance between two points is
        greater than point_tolerance, then the curve is not C0.
    d1_tolerance - [in] if the difference between two first derivatives is
        greater than d1_tolerance, then the curve is not C1.
    d2_tolerance - [in] if the difference between two second derivatives is
        greater than d2_tolerance, then the curve is not C2.
    cos_angle_tolerance - [in] default = cos(1 degree) Used only when
        c is ON::G1_continuous or ON::G2_continuous.  If the cosine
        of the angle between two tangent vectors 
        is <= cos_angle_tolerance, then a G1 discontinuity is reported.
    curvature_tolerance - [in] (default = ON_SQRT_EPSILON) Used only when
        c is ON::G2_continuous or ON::Gsmooth_continuous.  
        ON::G2_continuous:
          If K0 and K1 are curvatures evaluated
          from above and below and |K0 - K1| > curvature_tolerance,
          then a curvature discontinuity is reported.
        ON::Gsmooth_continuous:
          If K0 and K1 are curvatures evaluated from above and below
          and the angle between K0 and K1 is at least twice angle tolerance
          or ||K0| - |K1|| > (max(|K0|,|K1|) > curvature_tolerance,
          then a curvature discontinuity is reported.
  Returns:
    true if the curve has at least the c type continuity at 
    the parameter t.
  */
  virtual
  bool IsContinuous(
    ON::continuity c,
    double t, 
    int* hint = NULL,
    double point_tolerance=ON_ZERO_TOLERANCE,
    double d1_tolerance=ON_ZERO_TOLERANCE,
    double d2_tolerance=ON_ZERO_TOLERANCE,
    double cos_angle_tolerance=ON_DEFAULT_ANGLE_TOLERANCE_COSINE,
    double curvature_tolerance=ON_SQRT_EPSILON
    ) const;


  // Description:
  //   Reverse the direction of the curve.
  // Returns:
  //   true if curve was reversed.
  // Remarks:
  //   If reveresed, the domain changes from [a,b] to [-b,-a]
  virtual 
  ON_BOOL32 Reverse()=0;


  /*
  Description:
    Force the curve to start at a specified point.
  Parameters:
    start_point - [in]
  Returns:
    true if successful.
  Remarks:
    Some end points cannot be moved.  Be sure to check return
    code.
  See Also:
    ON_Curve::SetEndPoint
    ON_Curve::PointAtStart
    ON_Curve::PointAtEnd
  */
  virtual
  ON_BOOL32 SetStartPoint(
          ON_3dPoint start_point
          );

  /*
  Description:
    Force the curve to end at a specified point.
  Parameters:
    end_point - [in]
  Returns:
    true if successful.
  Remarks:
    Some end points cannot be moved.  Be sure to check return
    code.
  See Also:
    ON_Curve::SetStartPoint
    ON_Curve::PointAtStart
    ON_Curve::PointAtEnd
  */
  virtual
  ON_BOOL32 SetEndPoint(
          ON_3dPoint end_point
          );
  
  // Description:
  //   Evaluate point at a parameter.
  // Parameters:
  //   t - [in] evaluation parameter
  // Returns:
  //   Point (location of curve at the parameter t).
  // Remarks:
  //   No error handling.
  // See Also:
  //   ON_Curve::EvPoint
  //   ON_Curve::PointAtStart
  //   ON_Curve::PointAtEnd
  ON_3dPoint  PointAt( 
                double t 
                ) const;

  // Description:
  //   Evaluate point at the start of the curve.
  // Parameters:
  //   t - [in] evaluation parameter
  // Returns:
  //   Point (location of the start of the curve.)
  // Remarks:
  //   No error handling.
  // See Also:
  //   ON_Curve::PointAt
  ON_3dPoint  PointAtStart() const;

  // Description:
  //   Evaluate point at the end of the curve.
  // Parameters:
  //   t - [in] evaluation parameter
  // Returns:
  //   Point (location of the end of the curve.)
  // Remarks:
  //   No error handling.
  // See Also:
  //   ON_Curve::PointAt
  ON_3dPoint  PointAtEnd() const;

  // Description:
  //   Evaluate first derivative at a parameter.
  // Parameters:
  //   t - [in] evaluation parameter
  // Returns:
  //   First derivative of the curve at the parameter t.
  // Remarks:
  //   No error handling.
  // See Also:
  //   ON_Curve::Ev1Der
  ON_3dVector DerivativeAt(
                double t 
                ) const;

  // Description:
  //   Evaluate unit tangent vector at a parameter.
  // Parameters:
  //   t - [in] evaluation parameter
  // Returns:
  //   Unit tangent vector of the curve at the parameter t.
  // Remarks:
  //   No error handling.
  // See Also:
  //   ON_Curve::EvTangent
  ON_3dVector TangentAt(
                double t 
                ) const;

  // Description:
  //   Evaluate the curvature vector at a parameter.
  // Parameters:
  //   t - [in] evaluation parameter
  // Returns:
  //   curvature vector of the curve at the parameter t.
  // Remarks:
  //   No error handling.
  // See Also:
  //   ON_Curve::EvCurvature
  ON_3dVector CurvatureAt(
                double t
                ) const;

  // Description:
  //   Return a 3d frame at a parameter.
  // Parameters:
  //   t - [in] evaluation parameter
  //   plane - [out] the frame is returned here
  // Returns:
  //   true if successful
  // See Also:
  //   ON_Curve::PointAt, ON_Curve::TangentAt,
  //   ON_Curve::Ev1Der, Ev2Der
  ON_BOOL32 FrameAt( double t, ON_Plane& plane) const;

  // Description:
  //   Evaluate point at a parameter with error checking.
  // Parameters:
  //   t - [in] evaluation parameter
  //   point - [out] value of curve at t
  //   side - [in] optional - determines which side to evaluate from
  //               =0   default
  //               <0   to evaluate from below, 
  //               >0   to evaluate from above
  //   hint - [in/out] optional evaluation hint used to speed repeated evaluations
  // Returns:
  //   false if unable to evaluate.
  // See Also:
  //   ON_Curve::PointAt
  //   ON_Curve::EvTangent
  //   ON_Curve::Evaluate
  ON_BOOL32 EvPoint(
         double t,
         ON_3dPoint& point, 
         int side = 0,
         int* hint = 0
         ) const;

  // Description:
  //   Evaluate first derivative at a parameter with error checking.
  // Parameters:
  //   t - [in] evaluation parameter
  //   point - [out] value of curve at t
  //   first_derivative - [out] value of first derivative at t
  //   side - [in] optional - determines which side to evaluate from
  //               =0   default
  //               <0   to evaluate from below, 
  //               >0   to evaluate from above
  //   hint - [in/out] optional evaluation hint used to speed repeated evaluations
  // Returns:
  //   false if unable to evaluate.
  // See Also:
  //   ON_Curve::EvPoint
  //   ON_Curve::Ev2Der
  //   ON_Curve::EvTangent
  //   ON_Curve::Evaluate
  ON_BOOL32 Ev1Der(
         double t,
         ON_3dPoint& point,
         ON_3dVector& first_derivative,
         int side = 0,
         int* hint = 0
         ) const;

  // Description:
  //   Evaluate second derivative at a parameter with error checking.
  // Parameters:
  //   t - [in] evaluation parameter
  //   point - [out] value of curve at t
  //   first_derivative - [out] value of first derivative at t
  //   second_derivative - [out] value of second derivative at t
  //   side - [in] optional - determines which side to evaluate from
  //               =0   default
  //               <0   to evaluate from below, 
  //               >0   to evaluate from above
  //   hint - [in/out] optional evaluation hint used to speed repeated evaluations
  // Returns:
  //   false if unable to evaluate.
  // See Also:
  //   ON_Curve::Ev1Der
  //   ON_Curve::EvCurvature
  //   ON_Curve::Evaluate
  ON_BOOL32 Ev2Der(
         double t,
         ON_3dPoint& point,
         ON_3dVector& first_derivative,
         ON_3dVector& second_derivative,
         int side = 0,
         int* hint = 0
         ) const;

  /*
  Description:
    Evaluate unit tangent at a parameter with error checking.
  Parameters:
    t - [in] evaluation parameter
    point - [out] value of curve at t
    tangent - [out] value of unit tangent
    side - [in] optional - determines which side to evaluate from
                =0   default
                <0   to evaluate from below, 
                >0   to evaluate from above
    hint - [in/out] optional evaluation hint used to speed repeated evaluations
  Returns:
    false if unable to evaluate.
  See Also:
    ON_Curve::TangentAt
    ON_Curve::Ev1Der
  */
  ON_BOOL32 EvTangent(
         double t,
         ON_3dPoint& point,
         ON_3dVector& tangent,
         int side = 0,
         int* hint = 0
         ) const;

  /*
  Description:
    Evaluate unit tangent and curvature at a parameter with error checking.
  Parameters:
    t - [in] evaluation parameter
    point - [out] value of curve at t
    tangent - [out] value of unit tangent
    kappa - [out] value of curvature vector
    side - [in] optional - determines which side to evaluate from
                =0   default
                <0   to evaluate from below, 
                >0   to evaluate from above
    hint - [in/out] optional evaluation hint used to speed repeated evaluations
  Returns:
    false if unable to evaluate.
  See Also:
    ON_Curve::CurvatureAt
    ON_Curve::Ev2Der
    ON_EvCurvature
  */
  ON_BOOL32 EvCurvature(
         double t,
         ON_3dPoint& point,
         ON_3dVector& tangent,
         ON_3dVector& kappa,
         int side = 0,
         int* hint = 0
         ) const;

  /*
  Description:
    This evaluator actually does all the work.  The other ON_Curve
    evaluation tools call this virtual function.
  Parameters:
    t - [in] evaluation parameter ( usually in Domain() ).
    der_count - [in] (>=0) number of derivatives to evaluate
    v_stride - [in] (>=Dimension()) stride to use for the v[] array
    v - [out] array of length (der_count+1)*v_stride
        curve(t) is returned in (v[0],...,v[m_dim-1]),
        curve'(t) is retuned in (v[v_stride],...,v[v_stride+m_dim-1]),
        curve"(t) is retuned in (v[2*v_stride],...,v[2*v_stride+m_dim-1]),
        etc.
    side - [in] optional - determines which side to evaluate from
                =0   default
                <0   to evaluate from below, 
                >0   to evaluate from above
    hint - [in/out] optional evaluation hint used to speed repeated evaluations
  Returns:
    false if unable to evaluate.
  See Also:
    ON_Curve::EvPoint
    ON_Curve::Ev1Der
    ON_Curve::Ev2Der
  */
  virtual 
  ON_BOOL32 Evaluate(
         double t,
         int der_count,
         int v_stride,
         double* v,
         int side = 0,
         int* hint = 0
         ) const = 0;


  //////////
  // Find parameter of the point on a curve that is closest to test_point.
  // If the maximum_distance parameter is > 0, then only points whose distance
  // to the given point is <= maximum_distance will be returned.  Using a
  // positive value of maximum_distance can substantially speed up the search.
  // If the sub_domain parameter is not NULL, then the search is restricted
  // to the specified portion of the curve.
  //
  // true if returned if the search is successful.  false is returned if
  // the search fails.
  virtual
  bool GetClosestPoint(
          const ON_3dPoint&, // test_point
          double* t,       // parameter of local closest point returned here
          double maximum_distance = 0.0,  // maximum_distance
          const ON_Interval* sub_domain = NULL // sub_domain
          ) const;

  /*
  Description:
    Find curve's self intersection points.
  Parameters:
    x - [out]
       Intersection events are appended to this array.
    intersection_tolerance - [in]
    curve_domain - [in] optional restriction
  Returns:
    Number of intersection events appended to x.
  */
  virtual
  int IntersectSelf(
          ON_SimpleArray<ON_X_EVENT>& x,
          double intersection_tolerance = 0.0,
          const ON_Interval* curve_domain = 0
          ) const;

  /*
  Description:
    Intersect this curve with curveB.
  Parameters:
    curveB - [in]
    x - [out] Intersection events are appended to this array.
    intersection_tolerance - [in]  If the distance from a point
      on this curve to curveB is <= intersection tolerance,
      then the point will be part of an intersection event.
      If the input intersection_tolerance <= 0.0, then 0.001 is used.
    overlap_tolerance - [in] If t1 and t2 are parameters of this
      curve's intersection events and the distance from curve(t) to
      curveB is <= overlap_tolerance for every t1 <= t <= t2,
      then the event will be returened as an overlap event.
      If the input overlap_tolerance <= 0.0, then
      intersection_tolerance*2.0 is used.
    curveA_domain - [in] optional restriction on this curve's domain
    curveB_domain - [in] optional restriction on curveB domain
  Returns:
    Number of intersection events appended to x.
  */
  int IntersectCurve(
          const ON_Curve* curveB,
          ON_SimpleArray<ON_X_EVENT>& x,
          double intersection_tolerance = 0.0,
          double overlap_tolerance = 0.0,
          const ON_Interval* curveA_domain = 0,
          const ON_Interval* curveB_domain = 0
          ) const;

  /*
  Description:
    Intersect this curve with surfaceB.

  Parameters:
    surfaceB - [in]

    x - [out]
      Intersection events are appended to this array.
    intersection_tolerance - [in]
      If the distance from a point on this curve to the surface
      is <= intersection tolerance, then the point will be part
      of an intersection event, or there is an intersection event
      the point leads to. If the input intersection_tolerance <= 0.0,
      then 0.001 is used.

    overlap_tolerance - [in]
      If the input overlap_tolerance <= 0.0, then
      2.0*intersection_tolerance is used.  Otherwise, overlap
      tolerance must be >= intersection_tolerance.
      In all cases, the intersection calculation is performed
      with an overlap_tolerance that is >= intersection_tolerance.
      If t1 and t2 are curve parameters of intersection events
      and the distance from curve(t) to the surface
      is <= overlap_tolerance for every t1 <= t <= t2, then the
      event will be returned as an overlap event.

    curveA_domain - [in]
      optional restriction on this curve's domain

    surfaceB_udomain - [in]
      optional restriction on surfaceB u domain

    surfaceB_vdomain - [in]
      optional restriction on surfaceB v domain

  Returns:
    Number of intersection events appended to x.
  */
  int IntersectSurface(
          const ON_Surface* surfaceB,
          ON_SimpleArray<ON_X_EVENT>& x,
          double intersection_tolerance = 0.0,
          double overlap_tolerance = 0.0,
          const ON_Interval* curveA_domain = 0,
          const ON_Interval* surfaceB_udomain = 0,
          const ON_Interval* surfaceB_vdomain = 0
          ) const;

  /*
  Description:
    Get the length of the curve.
  Parameters:
    length - [out] length returned here.
    fractional_tolerance - [in] desired fractional precision.
        fabs(("exact" length from start to t) - arc_length)/arc_length <= fractional_tolerance
    sub_domain - [in] If not NULL, the calculation is performed on
        the specified sub-domain of the curve (must be non-decreasing)
  Returns:
    true if returned if the length calculation is successful.
    false is returned if the length is not calculated.
  Remarks:
    The arc length will be computed so that
    (returned length - real length)/(real length) <= fractional_tolerance
    More simply, if you want N significant figures in the answer, set the
    fractional_tolerance to 1.0e-N.  For "nice" curves, 1.0e-8 works
    fine.  For very high degree NURBS and NURBS with bad parameterizations,
    use larger values of fractional_tolerance.
  */
  virtual
  ON_BOOL32 GetLength(
          double* length,
          double fractional_tolerance = 1.0e-8,
          const ON_Interval* sub_domain = NULL
          ) const;

 
  /*
  Parameters:
    min_length -[in]
      minimum length of a linear span
    tolerance -[in]
      distance tolerance to use when checking linearity.
  Returns 
    true if the span is a non-degenrate line.  This means:
    - dimension = 2 or 3
    - The length of the the line segment from the span's initial 
      point to the span's control point is >= min_length.
    - The maximum distance from the line segment to the span
    is <= tolerance and the span increases monotonically
    in the direction of the line segment.
  */
  bool FirstSpanIsLinear( 
    double min_length,
    double tolerance
    ) const;

  bool LastSpanIsLinear( 
    double min_length,
    double tolerance
    ) const;

  bool FirstSpanIsLinear( 
    double min_length,
    double tolerance,
    ON_Line* span_line
    ) const;

  bool LastSpanIsLinear( 
    double min_length,
    double tolerance,
    ON_Line* span_line
    ) const;

  // Description:
  //   Removes portions of the curve outside the specified interval.
  // Parameters:
  //   domain - [in] interval of the curve to keep.  Portions of the
  //      curve before curve(domain[0]) and after curve(domain[1]) are
  //      removed.
  // Returns:
  //   true if successful.
  virtual
  ON_BOOL32 Trim(
    const ON_Interval& domain
    );

  // Description:
  //   Pure virtual function. Default returns false.
  //   Where possible, analytically extends curve to include domain.
  // Parameters:
  //   domain - [in] if domain is not included in curve domain, 
  //   curve will be extended so that its domain includes domain.  
  //   Will not work if curve is closed. Original curve is identical
  //   to the restriction of the resulting curve to the original curve domain, 
  // Returns:
  //   true if successful.
  virtual
  bool Extend(
    const ON_Interval& domain
    );

  /*
  Description:
    Splits (divides) the curve at the specified parameter.  
    The parameter must be in the interior of the curve's domain.
    The pointers passed to Split must either be NULL or point to
    an ON_Curve object of the same type.  If the pointer is NULL,
    then a curve will be created in Split().  You may pass "this"
    as left_side or right_side.
  Parameters:
    t - [in] parameter to split the curve at in the
             interval returned by Domain().
    left_side - [out] left portion of curve returned here
    right_side - [out] right portion of curve returned here
	Returns:
		true	- The curve was split into two pieces.  
		false - The curve could not be split.  For example if the parameter is
						too close to an endpoint.

  Example:
    For example, if crv were an ON_NurbsCurve, then

          ON_NurbsCurve right_side;
          crv.Split( crv.Domain().Mid() &crv, &right_side );

    would split crv at the parametric midpoint, put the left side
    in crv, and return the right side in right_side.
  */
  virtual
  ON_BOOL32 Split(
      double t,
      ON_Curve*& left_side,
      ON_Curve*& right_side
    ) const;

  /*
  Description:
    Get a NURBS curve representation of this curve.
  Parameters:
    nurbs_curve - [out] NURBS representation returned here
    tolerance - [in] tolerance to use when creating NURBS
        representation.
    subdomain - [in] if not NULL, then the NURBS representation
        for this portion of the curve is returned.
  Returns:
    0   unable to create NURBS representation
        with desired accuracy.
    1   success - returned NURBS parameterization
        matches the curve's to wthe desired accuracy
    2   success - returned NURBS point locus matches
        the curve's to the desired accuracy and the
        domain of the NURBS curve is correct.  On
        However, This curve's parameterization and
        the NURBS curve parameterization may not 
        match to the desired accuracy.  This situation
        happens when getting NURBS representations of
        curves that have a transendental parameterization
        like circles
  Remarks:
    This is a low-level virtual function.  If you do not need
    the parameterization information provided by the return code,
    then ON_Curve::NurbsCurve may be easier to use.
  See Also:
    ON_Curve::NurbsCurve
  */
  virtual
  int GetNurbForm(
        ON_NurbsCurve& nurbs_curve,
        double tolerance = 0.0,
        const ON_Interval* subdomain = NULL
        ) const;
  /*
  Description:
    Does a NURBS curve representation of this curve.
  Parameters:
  Returns:
    0   unable to create NURBS representation
        with desired accuracy.
    1   success - NURBS parameterization
        matches the curve's to wthe desired accuracy
    2   success - NURBS point locus matches
        the curve's and the
        domain of the NURBS curve is correct.  
        However, This curve's parameterization and
        the NURBS curve parameterization may not 
        match.  This situation
        happens when getting NURBS representations of
        curves that have a transendental parameterization
        like circles
  Remarks:
    This is a low-level virtual function.  
  See Also:
    ON_Curve::GetNurbForm
    ON_Curve::NurbsCurve
  */
  virtual
  int HasNurbForm() const;

  /*
  Description:
    Get a NURBS curve representation of this curve.
  Parameters:
    pNurbsCurve - [in/out] if not NULL, this ON_NurbsCurve
    will be used to store the NURBS representation
    of the curve will be returned.
    tolerance - [in] tolerance to use when creating NURBS
        representation.
    subdomain - [in] if not NULL, then the NURBS representation
        for this portion of the curve is returned.
  Returns:
    NULL or a NURBS representation of the curve.
  Remarks:
    See ON_Surface::GetNurbForm for important details about
    the NURBS surface parameterization.
  See Also:
    ON_Curve::GetNurbForm
  */
  ON_NurbsCurve* NurbsCurve(
        ON_NurbsCurve* pNurbsCurve = NULL,
        double tolerance = 0.0,
        const ON_Interval* subdomain = NULL
        ) const;

  // Description:
  //   Convert a NURBS curve parameter to a curve parameter
  //
  // Parameters:
  //   nurbs_t - [in] nurbs form parameter
  //   curve_t - [out] curve parameter
  //
  // Remarks:
  //   If GetNurbForm returns 2, this function converts the curve
  //   parameter to the NURBS curve parameter.
  //
  // See Also:
  //   ON_Curve::GetNurbForm, ON_Curve::GetNurbFormParameterFromCurveParameter
  virtual
  ON_BOOL32 GetCurveParameterFromNurbFormParameter(
        double nurbs_t,
        double* curve_t
        ) const;

  // Description:
  //   Convert a curve parameter to a NURBS curve parameter.
  //
  // Parameters:
  //   curve_t - [in] curve parameter
  //   nurbs_t - [out] nurbs form parameter
  //
  // Remarks:
  //   If GetNurbForm returns 2, this function converts the curve
  //   parameter to the NURBS curve parameter.
  //
  // See Also:
  //   ON_Curve::GetNurbForm, ON_Curve::GetCurveParameterFromNurbFormParameter
  virtual
  ON_BOOL32 GetNurbFormParameterFromCurveParameter(
        double curve_t,
        double* nurbs_t
        ) const;


  // Description:
  //   Destroys the runtime curve tree used to speed closest
  //   point and intersection calcuations.
  // Remarks:
  //   If the geometry of the curve is modified in any way,
  //   then call DestroyCurveTree();  The curve tree is 
  //   created as needed.
  void DestroyCurveTree();

  virtual
  ON_CurveTree* CreateCurveTree() const;

  /*
  Description:
    Calculate length mass properties of the curve.
  Parameters:
    mp - [out]
    bLength - [in] true to calculate length
    bFirstMoments - [in] true to calculate volume first moments,
                         length, and length centroid.
    bSecondMoments - [in] true to calculate length second moments.
    bProductMoments - [in] true to calculate length product moments.
  Returns:
    True if successful.
  */
  bool LengthMassProperties(
    ON_MassProperties& mp,
    bool bLength = true,
    bool bFirstMoments = true,
    bool bSecondMoments = true,
    bool bProductMoments = true,
    double rel_tol = 1.0e-6,
    double abs_tol = 1.0e-6
    ) const;

  /*
  Description:
    Calculate area mass properties of a curve.  The curve should
    be planar.
  Parameters:
    base_point - [in]
      A point on the plane that contians the curve.  To get
      the best results, the point should be in the near the
      curve's centroid.

      When computing the area, area centroid, or area first
      moments of a planar area whose boundary is defined by
      several curves, pass the same base_point and plane_normal
      to each call to AreaMassProperties.  The base_point must
      be in the plane of the curves.

      When computing the area second moments or area product
      moments of a planar area whose boundary is defined by several
      curves, you MUST pass the entire area's centroid as the
      base_point and the input mp parameter must contain the
      results of a previous call to
      AreaMassProperties(mp,true,true,false,false,base_point).
      In particular, in this case, you need to make two sets of
      calls; use first set to calculate the area centroid and
      the second set calculate the second moments and product
      moments.
    plane_normal - [in]
      nonzero unit normal to the plane of integration.  If a closed
      curve has counter clock-wise orientation with respect to
      this normal, the area will be positive.  If the a closed curve
      has clock-wise orientation with respect to this normal, the
      area will be negative.
    mp - [out]
    bArea - [in] true to calculate volume
    bFirstMoments - [in] true to calculate area first moments,
                         area, and area centroid.
    bSecondMoments - [in] true to calculate area second moments.
    bProductMoments - [in] true to calculate area product moments.
  Returns:
    True if successful.
  */
  bool AreaMassProperties(
    ON_3dPoint base_point,
    ON_3dVector plane_normal,
    ON_MassProperties& mp,
    bool bArea = true,
    bool bFirstMoments = true,
    bool bSecondMoments = true,
    bool bProductMoments = true,
    double rel_tol = 1.0e-6,
    double abs_tol = 1.0e-6
    ) const;

  /*
  Description:
    Mesh a curve into line segments.
  Parameters:
    mp - [in]
      Parameters that determine how the curve will be
      approximated by a polyline.
    polyline - [in]
      If not NULL, the polyline approximation will be appended
      to this polyline.
    bSkipFirstPoint - [in]
      If true, the starting point of the approximation
      will not be added to the returned polyline.  This
      parameter is useful when getting a polyline approximation
      of a sequence of contiguous curves.
    domain - [in]
      If not NULL, the polyline approximation will be restricted
      to this domain.
  Returns:
    A pointer to the polyline approximation.
  */
  class ON_PolylineCurve* MeshCurve(
    ON_MeshCurveParameters& mp,
    ON_PolylineCurve* polyline,
    bool bSkipFirstPoint,
    const ON_Interval* domain
    ) const;

  // The non-const version of MeshCurve() exists because a version of the
  // SDK was shipped with the "const" tag missing.  The non-const
  // version does not modify this.
  class ON_PolylineCurve* MeshCurve(
    ON_MeshCurveParameters& mp,
    ON_PolylineCurve* polyline,
    bool bSkipFirstPoint,
    const ON_Interval* domain
    );

  /*
	Description:
		Lookup a parameter in the m_t array, optionally using a built in snap tolerance to 
		snap a parameter value to an element of m_t.
		This function is used by some types derived from ON_Curve to snap parameter values
	Parameters:
		t-[in] parameter
		index-[out] index into m_t such that if function returns false then @table

                         (value)                              (condition)
                          -1                                     t < m_t[0] or m_t is empty
                           0 <= i <= m_t.Count()-2      m_t[i] < t < m_t[i+1]
                           m_t.Count()-1                         t > m_t[m_t.Count()-1]			 

                        if the function returns true then t is equal to, or is closest to and 
                        within  tolerance of m_t[index]. 
									
		bEnableSnap-[in] enable snapping 
		m_t-[in] Array of parameter values to snap to
		RelTol-[in] tolerance used in snapping
	
	Returns:		
		true if the t is exactly equal to (bEnableSnap==false), or within tolerance of
		(bEnableSnap==true) m_t[index]. 
  */
protected:
  bool ParameterSearch( double t, int& index, bool bEnableSnap, const ON_SimpleArray<double>& m_t, 
								double RelTol=ON_SQRT_EPSILON) const;

private:
};

#if defined(ON_DLL_TEMPLATE)
// This stuff is here because of a limitation in the way Microsoft
// handles templates and DLLs.  See Microsoft's knowledge base 
// article ID Q168958 for details.
#pragma warning( push )
#pragma warning( disable : 4231 )
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_Curve*>;
#pragma warning( pop )
#endif

class ON_CLASS ON_CurveArray : public ON_SimpleArray<ON_Curve*>
{
public:
  ON_CurveArray( int = 0 );
  ~ON_CurveArray(); // deletes any non-NULL curves

  bool Write( ON_BinaryArchive& ) const;
  bool Read( ON_BinaryArchive& );

  void Destroy(); // deletes curves, sets pointers to NULL, sets count to zero

  bool Duplicate( ON_CurveArray& ) const; // operator= copies the pointer values
                                          // duplicate copies the curves themselves

  /*
	Description:
    Get tight bounding box of the bezier.
	Parameters:
		tight_bbox - [in/out] tight bounding box
		bGrowBox -[in]	(default=false)			
      If true and the input tight_bbox is valid, then returned
      tight_bbox is the union of the input tight_bbox and the 
      tight bounding box of the bezier curve.
		xform -[in] (default=NULL)
      If not NULL, the tight bounding box of the transformed
      bezier is calculated.  The bezier curve is not modified.
	Returns:
    True if the returned tight_bbox is set to a valid 
    bounding box.
  */
	bool GetTightBoundingBox( 
			ON_BoundingBox& tight_bbox, 
      int bGrowBox = false,
			const ON_Xform* xform = 0
      ) const;
};

/*
Description:
  Trim a curve.
Parameters:
  curve - [in] curve to trim (not modified)
  trim_parameters - [in] trimming parameters
    If curve is open, then  trim_parameters must be an increasing 
    interval.If curve is closed, and trim_parameters ins a 
    decreasing interval, then the portion of the curve across the
    start/end is returned.
Returns:
  trimmed curve or NULL if input is invalid.
*/
ON_DECL
ON_Curve* ON_TrimCurve( 
            const ON_Curve& curve,
            ON_Interval trim_parameters
            );

/*
Description:
  Move ends of curves to a common point. Neither curve can be closed or an ON_CurveProxy.
  If one is an arc or polycurve with arc at end to change, and the other is not, 
  then the arc is left unchanged and the other curve is moved to the arc endpoint. 
  Otherwise, both are moved to the midpoint of the segment between the ends.
Parameters:
  Crv0 - [in] first curve to modify.
         [out] with one endpoint possibly changed.
  end0 - [in] if 0, change start of Crv0.  Otherwise change end.
  Crv1 - [in] second curve to modify.
         [out] with one endpoint possibly changed.
  end1 - [in] if 0, change start of Crv1.  Otherwise change end.
Returns:
  true if the endpoints match. Falsse otherwise,
*/
ON_DECL
bool ON_ForceMatchCurveEnds(
                            ON_Curve& Crv0, 
                            int end0, 
                            ON_Curve& Crv1, 
                            int end1
                            );

/*
Description:
  Join all contiguous curves of an array of ON_Curves.
Parameters:
  InCurves - [in] Array of curves to be joined (not modified)
  OutCurves - [out] Resulting joined curves and copies of curves that were not joined to anything
                    are appended.
  join_tol - [in] Distance tolerance used to decide if endpoints are close enough
  bPreserveDirection - [in] If true, curve endpoints will be compared to curve startpoints.
                            If false, all start and endpoints will be compared, and copies of input 
                            curves may be reversed in output.
  key     -  [out] if key is not null, InCurves[i] was joined into OutCurves[key[i]].
Returns:
  Number of curves added to Outcurves
Remarks:
  Closed curves are copied to OutCurves. 
  Curves that cannot be joined to others are copied to OutCurves.  When curves are joined, the results
  are ON_PolyCurves. All members of InCurves must have same dimension, at most 3.
  */
ON_DECL
int ON_JoinCurves(const ON_SimpleArray<const ON_Curve*>& InCurves,
                  ON_SimpleArray<ON_Curve*>& OutCurves,
                  double join_tol,
                  bool bPreserveDirection = false,
                  ON_SimpleArray<int>* key = 0
                 );


/*
Description:
  Sort a list of lines so they are geometrically continuous.
Parameters:
  line_count - [in] number of lines
  line_list  - [in] array of lines
  index       - [out] The input index[] is an array of line_count unused integers.
                      The returned index[] is a permutation of {0,1,...,line_count-1}
                      so that the list of lines is in end-to-end order.
  bReverse    - [out] The input bReverse[] is an array of line_count unused bools.
                      If the returned value of bReverse[j] is true, then
                      line_list[index[j]] needs to be reversed.
Returns:
  True if successful, false if not.
*/
ON_DECL
bool ON_SortLines( 
        int line_count, 
        const ON_Line* line_list, 
        int* index, 
        bool* bReverse 
        );

/*
Description:
  Sort a list of lines so they are geometrically continuous.
Parameters:
  line_list  - [in] array of lines
  index       - [out] The input index[] is an array of line_count unused integers.
                      The returned index[] is a permutation of {0,1,...,line_count-1}
                      so that the list of lines is in end-to-end order.
  bReverse    - [out] The input bReverse[] is an array of line_count unused bools.
                      If the returned value of bReverse[j] is true, then
                      line_list[index[j]] needs to be reversed.
Returns:
  True if successful, false if not.
*/
ON_DECL
bool ON_SortLines( 
        const ON_SimpleArray<ON_Line>& line_list,
        int* index, 
        bool* bReverse 
        );

/*
Description:
  Sort a list of open curves so end of a curve matches the start of the next curve.
Parameters:
  curve_count - [in] number of curves
  curve_list  - [in] array of curve pointers
  index       - [out] The input index[] is an array of curve_count unused integers.
                      The returned index[] is a permutation of {0,1,...,curve_count-1}
                      so that the list of curves is in end-to-end order.
  bReverse    - [out] The input bReverse[] is an array of curve_count unused bools.
                      If the returned value of bReverse[j] is true, then
                      curve_list[index[j]] needs to be reversed.
Returns:
  True if successful, false if not.
*/
ON_DECL
bool ON_SortCurves(
          int curve_count,
          const ON_Curve* const* curve_list, 
          int* index,
          bool* bReverse
          );

/*
Description:
  Sort a list of curves so end of a curve matches the start of the next curve.
Parameters:
  curve       - [in] array of curves to sort.  The curves themselves are not modified.
  index       - [out] The input index[] is an array of curve_count unused integers.
                      The returned index[] is a permutation of {0,1,...,curve_count-1}
                      so that the list of curves is in end-to-end order.
  bReverse    - [out] The input bReverse[] is an array of curve_count unused bools.
                      If the returned value of bReverse[j] is true, then
                      curve[index[j]] needs to be reversed.
Returns:
  True if successful, false if not.
*/
ON_DECL
bool ON_SortCurves( 
                   const ON_SimpleArray<const ON_Curve*>& curves, 
                   ON_SimpleArray<int>& index, 
                   ON_SimpleArray<bool>& bReverse 
                   );

/*
Description:
  Sort a list of curves so end of a curve matches the start of the next curve.
Parameters:
  curve_count - [in] number of curves
  curve       - [in] array of curve pointers
  index       - [out] The input index[] is an array of curve_count unused integers.
                      The returned index[] is a permutation of {0,1,...,curve_count-1}
                      so that the list of curves is in end-to-end order.
  bReverse    - [out] The input bReverse[] is an array of curve_count unused bools.
                      If the returned value of bReverse[j] is true, then
                      curve[index[j]] needs to be reversed.
Returns:
  True if successful, false if not.
*/
ON_DECL
bool ON_SortCurves( 
          const ON_SimpleArray<ON_Curve*>& curves, 
          ON_SimpleArray<int>& index, 
          ON_SimpleArray<bool>& bReverse 
          );

/*
Description:
  Determine the orientaion (counterclockwise or clockwise) of a closed
  planar curve.
Paramters:
  curve - [in] simple (no self intersections) closed planar curve
  xform - [in] Transformation to map the curve to the xy plane. If the
               curve is parallel to the xy plane, you may pass NULL.
Returns:
  +1: The curve's orientation is counter clockwise in the xy plane.
  -1: The curve's orientation is clockwise in the xy plane.
   0: Unable to compute the curve's orientation.
*/
ON_DECL
int ON_ClosedCurveOrientation( const ON_Curve& curve, const ON_Xform* xform );

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

////////////////////////////////////////////////////////////////
//
//   Definition of virtual parametric surface
//
////////////////////////////////////////////////////////////////

#if !defined(OPENNURBS_SURFACE_INC_)
#define OPENNURBS_SURFACE_INC_

class ON_Curve;
class ON_NurbsSurface;
class ON_SurfaceTree;

////////////////////////////////////////////////////////////////
//
//   Definition of virtual parametric surface
//
////////////////////////////////////////////////////////////////

class ON_Mesh;
class ON_MeshParameters;
class ON_PolyCurve;
class ON_CurveProxy;
class ON_Surface;

class ON_CLASS ON_Surface : public ON_Geometry
{
  ON_OBJECT_DECLARE(ON_Surface);

public:
  // virtual ON_Object::DestroyRuntimeCache override
  void DestroyRuntimeCache( bool bDelete = true );

  // pure virtual class for surface objects
public:

  // flags for isoparametric curves
  // note: odd values are all "x" = constant
  // and even values > 0 are all "y" = constant
  // ON_BrepTrim::m_iso uses these flags
  enum ISO 
  {
    not_iso = 0, // curve is not an isoparameteric curve
    x_iso   = 1, // curve is a "x" = constant (vertical) isoparametric
                 // curve in the interior of the surface's domain
    y_iso   = 2, // curve is a "y" = constant (horizontal) isoparametric
                 // curve in the interior of the surface's domain
    W_iso   = 3, // curve is a "x" = constant isoparametric curve
                 // along the west side of the surface's domain
    S_iso   = 4, // curve is a "y" = constant isoparametric curve
                 // along the south side of the surface's domain
    E_iso   = 5, // curve is a "x" = constant isoparametric curve
                 // along the east side of the surface's domain
    N_iso   = 6, // curve is a "y" = constant isoparametric curve
                 // along the north side of the surface's domain
    iso_count = 7
  };

public:
  ON_Surface();
  ON_Surface(const ON_Surface&);
  ON_Surface& operator=(const ON_Surface&);
  virtual ~ON_Surface();

  // virtual ON_Object::SizeOf override
  unsigned int SizeOf() const;

  // virtual ON_Geometry override
  bool EvaluatePoint( const class ON_ObjRef& objref, ON_3dPoint& P ) const;

  /*
  Description:
    Get a duplicate of the surface.
  Returns:
    A duplicate of the surface.  
  Remarks:
    The caller must delete the returned surface.
    For non-ON_SurfaceProxy objects, this simply duplicates the surface using
    ON_Object::Duplicate.
    For ON_SurfaceProxy objects, this duplicates the actual proxy surface 
    geometry and, if necessary, transposes the result to that
    the returned surfaces's parameterization and locus match the proxy surface's.
  */
  virtual
  ON_Surface* DuplicateSurface() const;

  //////////
  // override ON_Object::ObjectType() - returns ON::surface_object
  ON::object_type ObjectType() const;


  /////////////////////////////
  //
  // virtual ON_Geometry functions
  //

  /*
  Description:
    Overrides virtual ON_Geometry::HasBrepForm and returns true.
  Result:
    Returns true.
  See Also:
    ON_Brep::Create( ON_Surface&* )
  */
  ON_BOOL32 HasBrepForm() const;

  /*
  Description:
    Overrides virtual ON_Geometry::HasBrepForm.  
    Uses ON_Brep::Create( ON_Surface&* ) to create a brep
    form.  The surface is copied for use in the returned
    brep.
  Parameters:
    brep - [in] if not NULL, brep is used to store the brep
        form of the surface.
  Result:
    Returns a pointer to on ON_Brep or NULL.  If the brep
    parameter is not NULL, then brep is returned if the
    surface has a brep form and NULL is returned if the
    geometry does not have a brep form.
  Remarks:
    The caller is responsible for managing the brep memory.
  */
  ON_Brep* BrepForm( ON_Brep* brep = NULL ) const;

  ////////////////////////////////////////////////////////////////////
  // surface interface

  ON_BOOL32 GetDomain( 
         int dir,              // 0 gets first parameter, 1 gets second parameter
         double* t0,
         double* t1
         ) const;

  bool SetDomain( 
    int dir, // 0 sets first parameter's domain, 1 gets second parameter's domain
    ON_Interval domain
    );

  virtual
  ON_BOOL32 SetDomain( 
    int dir, // 0 sets first parameter's domain, 1 gets second parameter's domain
    double t0, 
    double t1
    );

  virtual
  ON_Interval Domain(
    int dir // 0 gets first parameter's domain, 1 gets second parameter's domain
    ) const = 0;

  /*
  Description:
    Get an estimate of the size of the rectangle that would
    be created if the 3d surface where flattened into a rectangle.
  Parameters:
    width - [out]  (corresponds to the first surface parameter)
    height - [out] (corresponds to the first surface parameter)
  Example:

          // Reparameterize a surface to minimize distortion 
          // in the map from parameter space to 3d.
          ON_Surface* surf = ...;
          double width, height;
          if ( surf->GetSurfaceSize( &width, &height ) )
          {
            srf->SetDomain( 0, ON_Interval( 0.0, width ) );
            srf->SetDomain( 1, ON_Interval( 0.0, height ) );
          }

  Returns:
    true if successful.
  */
  virtual
  ON_BOOL32 GetSurfaceSize( 
      double* width, 
      double* height 
      ) const;


  virtual 
  int SpanCount(
    int dir // 0 gets first parameter's domain, 1 gets second parameter's domain
    ) const = 0; // number of smooth nonempty spans in the parameter direction

  virtual
  ON_BOOL32 GetSpanVector( // span "knots" 
        int dir, // 0 gets first parameter's domain, 1 gets second parameter's domain
        double* span_vector // array of length SpanCount() + 1 
        ) const = 0; // 

  //////////
  // If t is in the domain of the surface, GetSpanVectorIndex() returns the 
  // span vector index "i" such that span_vector[i] <= t <= span_vector[i+1].
  // The "side" parameter determines which span is selected when t is at the
  // end of a span.
  virtual
  ON_BOOL32 GetSpanVectorIndex(
        int dir , // 0 gets first parameter's domain, 1 gets second parameter's domain
        double t,      // [IN] t = evaluation parameter
        int side,         // [IN] side 0 = default, -1 = from below, +1 = from above
        int* span_vector_index,        // [OUT] span vector index
        ON_Interval* span_interval // [OUT] domain of the span containing "t"
        ) const;

  virtual 
  int Degree( // returns maximum algebraic degree of any span 
                  // ( or a good estimate if curve spans are not algebraic )
    int dir // 0 gets first parameter's domain, 1 gets second parameter's domain
    ) const = 0; 

  virtual ON_BOOL32 GetParameterTolerance( // returns tminus < tplus: parameters tminus <= s <= tplus
         int dir,        // 0 gets first parameter, 1 gets second parameter
         double t,       // t = parameter in domain
         double* tminus, // tminus
         double* tplus   // tplus
         ) const;

  /*
  Description:
    Test a 2d curve to see if it is iso parameteric in the surface's
    parameter space.
  Parameters:
    curve - [in] curve to test
    curve_domain = [in] optional sub domain of the curve
  Returns:
    Isoparametric status of the curve.
  Remarks:
    Because it may transpose domains, ON_SurfaceProxy overrides
    this function.  All other surface classes just use
    the base class implementation.
  */
  virtual
  ISO IsIsoparametric(
        const ON_Curve& curve,
        const ON_Interval* curve_domain = NULL
        ) const;

  /*
  Description:
    Test a 2d bounding box to see if it is iso parameteric in the surface's
    parameter space.
  Parameters:
    bbox - [in] bounding box to test
  Returns:
    Isoparametric status of the bounding box.
  Remarks:
    Because it may transpose domains, ON_SurfaceProxy overrides
    this function.  All other surface classes just use
    the base class implementation.
  */
  virtual
  ISO IsIsoparametric(
        const ON_BoundingBox& bbox
        ) const;

  /*
  Description:
    Test a surface to see if it is planar.
  Parameters:
    plane - [out] if not NULL and true is returned,
                  the plane parameters are filled in.
    tolerance - [in] tolerance to use when checking
  Returns:
    true if there is a plane such that the maximum distance from
    the surface to the plane is <= tolerance.
  */
  virtual
  ON_BOOL32 IsPlanar(
        ON_Plane* plane = NULL,
        double tolerance = ON_ZERO_TOLERANCE
        ) const;

  /*
  Description:
    Determine if the surface is a portion of a sphere.
  Parameters:
    sphere - [out] if not NULL and true is returned,
      then the sphere definition is returned.
    tolerance - [in]
      tolerance to use when checking
  Returns:
    True if the surface is a portion of a sphere.                   
  */
  bool IsSphere(
        ON_Sphere* sphere = NULL,
        double tolerance = ON_ZERO_TOLERANCE
        ) const;

  /*
  Description:
    Determine if the surface is a portion of a cylinder.
  Parameters:
    cylinder - [out] if not NULL and true is returned, 
      then the cylinder definition is returned.
    tolerance - [in]
      tolerance to use when checking
  Returns:
    True if the surface is a portion of a cylinder.                   
  */
  bool IsCylinder(
        ON_Cylinder* cylinder = NULL,
        double tolerance = ON_ZERO_TOLERANCE
        ) const;

  /*
  Description:
    Determine if the surface is a portion of a cone.
  Parameters:
    cone - [out] if not NULL and true is returned, 
      then the cone definition is returned.
    tolerance - [in]
      tolerance to use when checking
  Returns:
    True if the surface is a portion of a cone.                   
  */
  bool IsCone(
        ON_Cone* cone = NULL,
        double tolerance = ON_ZERO_TOLERANCE
        ) const;

  /*
  Description:
    Determine if the surface is a portion of a torus.
  Parameters:
    torus - [out] if not NULL and true is returned,
      then the torus definition is returned.
    tolerance - [in]
      tolerance to use when checking
  Returns:
    True if the surface is a portion of a torus.                   
  */
  bool IsTorus(
        ON_Torus* torus = NULL,
        double tolerance = ON_ZERO_TOLERANCE
        ) const;

  virtual 
  ON_BOOL32 IsClosed(   // true if surface is closed in direction
        int        // dir  0 = "s", 1 = "t"
        ) const;

  virtual 
  ON_BOOL32 IsPeriodic( // true if surface is periodic in direction (default is false)
        int        // dir  0 = "s", 1 = "t"
        ) const;

  virtual
  ON_BOOL32 IsSingular( // true if surface side is collapsed to a point
        int        // side of parameter space to test
                   // 0 = south, 1 = east, 2 = north, 3 = west
        ) const;

  /*
  Returns:
    True if the surface defines a solid, like a sphere or torus.
    False if the surface does not define a solid, like a plane or cone.
  */
  bool IsSolid() const;

  /*
  Description:
    Test if a surface parameter value is at a singularity.
  Parameters:
    s - [in] surface parameter to test
    t - [in] surface parameter to test
    bExact - [in] if true, test if s,t is exactly at a singularity
      if false, test if close enough to cause numerical problems.
  Returns:
    true if surface is singular at (s,t)
  */
  bool IsAtSingularity(
    double s, 
    double t, 
    bool bExact = true
    ) const;

  /*
  Description:
    Test if a surface parameter value is at a seam.
  Parameters:
    s - [in] surface parameter to test
    t - [in] surface parameter to test
  Returns:
    0 if not a seam,
    1 if s == Domain(0)[i] and srf(s, t) == srf(Domain(0)[1-i], t)
    2 if t == Domain(1)[i] and srf(s, t) == srf(s, Domain(1)[1-i])
    3 if 1 and 2 are true.
  */
  int IsAtSeam(
    double s,
    double t
    ) const;
  
  /*
  Description:
    Search for a derivatitive, tangent, or curvature 
    discontinuity.
  Parameters:
    dir - [in] If 0, then "u" parameter is checked.  If 1, then
               the "v" parameter is checked.
    c - [in] type of continity to test for.
    t0 - [in] Search begins at t0. If there is a discontinuity
              at t0, it will be ignored.  This makes it 
              possible to repeatedly call GetNextDiscontinuity
              and step through the discontinuities.
    t1 - [in] (t0 != t1)  If there is a discontinuity at t1 is 
              will be ingored unless c is a locus discontinuity
              type and t1 is at the start or end of the curve.
    t - [out] if a discontinuity is found, then *t reports the
          parameter at the discontinuity.
    hint - [in/out] if GetNextDiscontinuity will be called 
       repeatedly, passing a "hint" with initial value *hint=0
       will increase the speed of the search.       
    dtype - [out] if not NULL, *dtype reports the kind of 
        discontinuity found at *t.  A value of 1 means the first 
        derivative or unit tangent was discontinuous.  A value 
        of 2 means the second derivative or curvature was 
        discontinuous.  A value of 0 means teh curve is not
        closed, a locus discontinuity test was applied, and
        t1 is at the start of end of the curve.
    cos_angle_tolerance - [in] default = cos(1 degree) Used only
        when c is ON::G1_continuous or ON::G2_continuous.  If the
        cosine of the angle between two tangent vectors is 
        <= cos_angle_tolerance, then a G1 discontinuity is reported.
    curvature_tolerance - [in] (default = ON_SQRT_EPSILON) Used 
        only when c is ON::G2_continuous.  If K0 and K1 are 
        curvatures evaluated from above and below and 
        |K0 - K1| > curvature_tolerance, then a curvature 
        discontinuity is reported.
  Returns:
    Parametric continuity tests c = (C0_continuous, ..., G2_continuous):

      true if a parametric discontinuity was found strictly 
      between t0 and t1. Note well that all curves are 
      parametrically continuous at the ends of their domains.

    Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):

      true if a locus discontinuity was found strictly between
      t0 and t1 or at t1 is the at the end of a curve.
      Note well that all open curves (IsClosed()=false) are locus
      discontinuous at the ends of their domains.  All closed 
      curves (IsClosed()=true) are at least C0_locus_continuous at 
      the ends of their domains.
  */
  virtual
  bool GetNextDiscontinuity( 
                  int dir,
                  ON::continuity c,
                  double t0,
                  double t1,
                  double* t,
                  int* hint=NULL,
                  int* dtype=NULL,
                  double cos_angle_tolerance=ON_DEFAULT_ANGLE_TOLERANCE_COSINE,
                  double curvature_tolerance=ON_SQRT_EPSILON
                  ) const;

  /*
  Description:
    Test continuity at a surface parameter value.
  Parameters:
    c - [in] continuity to test for
    s - [in] surface parameter to test
    t - [in] surface parameter to test
    hint - [in] evaluation hint
    point_tolerance - [in] if the distance between two points is
        greater than point_tolerance, then the surface is not C0.
    d1_tolerance - [in] if the difference between two first derivatives is
        greater than d1_tolerance, then the surface is not C1.
    d2_tolerance - [in] if the difference between two second derivatives is
        greater than d2_tolerance, then the surface is not C2.
    cos_angle_tolerance - [in] default = cos(1 degree) Used only when
        c is ON::G1_continuous or ON::G2_continuous.  If the cosine
        of the angle between two normal vectors 
        is <= cos_angle_tolerance, then a G1 discontinuity is reported.
    curvature_tolerance - [in] (default = ON_SQRT_EPSILON) Used only when
        c is ON::G2_continuous.  If K0 and K1 are curvatures evaluated
        from above and below and |K0 - K1| > curvature_tolerance,
        then a curvature discontinuity is reported.
  Returns:
    true if the surface has at least the c type continuity at the parameter t.
  */
  virtual
  bool IsContinuous(
    ON::continuity c,
    double s, 
    double t, 
    int* hint = NULL,
    double point_tolerance=ON_ZERO_TOLERANCE,
    double d1_tolerance=ON_ZERO_TOLERANCE,
    double d2_tolerance=ON_ZERO_TOLERANCE,
    double cos_angle_tolerance=ON_DEFAULT_ANGLE_TOLERANCE_COSINE,
    double curvature_tolerance=ON_SQRT_EPSILON
    ) const;

  virtual 
  ON_BOOL32 Reverse(  // reverse parameterizatrion, Domain changes from [a,b] to [-b,-a]
    int // dir  0 = "s", 1 = "t"
    ) = 0;

  virtual 
  ON_BOOL32 Transpose() = 0; // transpose surface parameterization (swap "s" and "t")

  // simple evaluation interface - no error handling
  ON_3dPoint  PointAt( double, double ) const;
  ON_3dVector NormalAt( double, double ) const;
  ON_BOOL32 FrameAt( double u, double v, ON_Plane& frame) const;

  ON_BOOL32 EvPoint( // returns false if unable to evaluate
         double u, double v,   // evaluation parameters
         ON_3dPoint& point,    // returns value of surface
         int quadrant = 0,     // optional - determines which side to evaluate from
                               //         0 = default
                               //         1 from NE quadrant
                               //         2 from NW quadrant
                               //         3 from SW quadrant
                               //         4 from SE quadrant
         int* hint = 0         // optional - evaluation hint (int[2]) used to speed
                               //            repeated evaluations
         ) const;

  ON_BOOL32 Ev1Der( // returns false if unable to evaluate
         double u, double v,   // evaluation parameters (s,t)
         ON_3dPoint& point,    // returns value of surface
         ON_3dVector& du,      // first partial derivatives (Ds)
         ON_3dVector& dv,      // (Dt)
         int quadrant = 0,     // optional - determines which side to evaluate from
                               //         0 = default
                               //         1 from NE quadrant
                               //         2 from NW quadrant
                               //         3 from SW quadrant
                               //         4 from SE quadrant
         int* hint = 0         // optional - evaluation hint (int[2]) used to speed
                               //            repeated evaluations
         ) const;

  ON_BOOL32 Ev2Der( // returns false if unable to evaluate
         double u, double v,   // evaluation parameters (s,t)
         ON_3dPoint& point,    // returns value of surface
         ON_3dVector& du,      // first partial derivatives (Ds)
         ON_3dVector& dv,      // (Dt)
         ON_3dVector& duu,     // second partial derivatives (Dss)
         ON_3dVector& duv,     // (Dst)
         ON_3dVector& dvv,     // (Dtt)
         int quadrant= 0,      // optional - determines which side to evaluate from
                               //         0 = default
                               //         1 from NE quadrant
                               //         2 from NW quadrant
                               //         3 from SW quadrant
                               //         4 from SE quadrant
         int* hint = 0         // optional - evaluation hint (int[2]) used to speed
                               //            repeated evaluations
         ) const;

  ON_BOOL32 EvNormal( // returns false if unable to evaluate
         double u, double v,   // evaluation parameters (s,t)
         ON_3dPoint& point,    // returns value of surface
         ON_3dVector& normal,  // unit normal
         int quadrant = 0,     // optional - determines which side to evaluate from
                               //         0 = default
                               //         1 from NE quadrant
                               //         2 from NW quadrant
                               //         3 from SW quadrant
                               //         4 from SE quadrant
         int* hint = 0         // optional - evaluation hint (int[2]) used to speed
                               //            repeated evaluations
         ) const;

  ON_BOOL32 EvNormal( // returns false if unable to evaluate
         double u, double v,   // evaluation parameters (s,t)
         ON_3dVector& normal,  // unit normal
         int quadrant = 0,     // optional - determines which side to evaluate from
                               //         0 = default
                               //         1 from NE quadrant
                               //         2 from NW quadrant
                               //         3 from SW quadrant
                               //         4 from SE quadrant
         int* hint = 0         // optional - evaluation hint (int[2]) used to speed
                               //            repeated evaluations
         ) const;

  ON_BOOL32 EvNormal( // returns false if unable to evaluate
         double u, double v,   // evaluation parameters (s,t)
         ON_3dPoint& point,    // returns value of surface
         ON_3dVector& du,      // first partial derivatives (Ds)
         ON_3dVector& dv,      // (Dt)
         ON_3dVector& normal,  // unit normal
         int = 0,              // optional - determines which side to evaluate from
                               //         0 = default
                               //         1 from NE quadrant
                               //         2 from NW quadrant
                               //         3 from SW quadrant
                               //         4 from SE quadrant
         int* = 0              // optional - evaluation hint (int[2]) used to speed
                               //            repeated evaluations
         ) const;

  // work horse evaluator
  virtual 
  ON_BOOL32 Evaluate( // returns false if unable to evaluate
         double u, double v,   // evaluation parameters
         int num_der,          // number of derivatives (>=0)
         int array_stride,     // array stride (>=Dimension())
         double* der_array,    // array of length stride*(ndir+1)*(ndir+2)/2
         int quadrant = 0,     // optional - determines which quadrant to evaluate from
                               //         0 = default
                               //         1 from NE quadrant
                               //         2 from NW quadrant
                               //         3 from SW quadrant
                               //         4 from SE quadrant
         int* hint = 0         // optional - evaluation hint (int[2]) used to speed
                               //            repeated evaluations
         ) const = 0;

  /*
  Description:
    Get isoparametric curve.
  Parameters:
    dir - [in] 0 first parameter varies and second parameter is constant
                 e.g., point on IsoCurve(0,c) at t is srf(t,c)
                 This is a horizontal line from left to right
               1 first parameter is constant and second parameter varies
                 e.g., point on IsoCurve(1,c) at t is srf(c,t
                 This is a vertical line from bottom to top

    c - [in] value of constant parameter 
  Returns:
    Isoparametric curve.
  Remarks:
    In this function "dir" indicates which direction the resulting
    curve runs.  0: horizontal, 1: vertical
    In the other ON_Surface functions that take a "dir"
    argument, "dir" indicates if "c" is a "u" or "v" parameter.
  */
  virtual
  ON_Curve* IsoCurve(
         int dir,
         double c
         ) const;


  /*
  Description:
    Compute a 3d curve that is the composite of a 2d curve
    and the surface map.
  Parameters:
    curve_2d - [in] a 2d curve whose image is in the surface's domain.
    tolerance - [in] the maximum acceptable distance from the returned
       3d curve to the image of curve_2d on the surface.
    curve_2d_subdomain - [in] optional subdomain for curve_2d
  Returns:
    3d curve.
  See Also:
    ON_Surface::IsoCurve
    ON_Surface::Pullback
  */
  virtual
  ON_Curve* Pushup( const ON_Curve& curve_2d,
                    double tolerance,
                    const ON_Interval* curve_2d_subdomain = NULL
                    ) const;


  /*
  Description:
    Removes the portions of the surface outside of the specified interval.

  Parameters:
    dir - [in] 0  The domain specifies an sub-interval of Domain(0)
                  (the first surface parameter).
               1  The domain specifies an sub-interval of Domain(1)
                  (the second surface parameter).
    domain - [in] interval of the surface to keep. If dir is 0, then
        the portions of the surface with parameters (s,t) satisfying
        s < Domain(0).Min() or s > Domain(0).Max() are trimmed away.
        If dir is 1, then the portions of the surface with parameters
        (s,t) satisfying t < Domain(1).Min() or t > Domain(1).Max() 
        are trimmed away.
  */
  virtual
  ON_BOOL32 Trim(
         int dir,
         const ON_Interval& domain
         );

  /*
   Description:
     Pure virtual function. Default returns false.
     Where possible, analytically extends surface to include domain.
   Parameters:
     dir - [in] 0  new Domain(0) will include domain.
                   (the first surface parameter).
                1  new Domain(1) will include domain.
                   (the second surface parameter).
     domain - [in] if domain is not included in surface domain, 
     surface will be extended so that its domain includes domain.  
     Will not work if surface is closed in direction dir. 
     Original surface is identical to the restriction of the
     resulting surface to the original surface domain, 
   Returns:
     true if successful.
     */
  virtual
  bool Extend(
    int dir,
    const ON_Interval& domain
    );


  /*
  Description:
    Splits (divides) the surface into two parts at the 
    specified parameter.

  Parameters:
    dir - [in] 0  The surface is split vertically.  The "west" side
                  is returned in "west_or_south_side" and the "east"
                  side is returned in "east_or_north_side".
               1  The surface is split horizontally.  The "south" side
                  is returned in "west_or_south_side" and the "north"
                  side is returned in "east_or_north_side".
    c - [in] value of constant parameter in interval returned
               by Domain(dir)
    west_or_south_side - [out] west/south portion of surface returned here
    east_or_north_side - [out] east/north portion of surface returned here

  Example:

          ON_NurbsSurface srf = ...;
          int dir = 1;
          ON_NurbsSurface* south_side = 0;
          ON_NurbsSurface* north_side = 0;
          srf.Split( dir, srf.Domain(dir).Mid() south_side, north_side );

  */
  virtual
  ON_BOOL32 Split(
         int dir,
         double c,
         ON_Surface*& west_or_south_side,
         ON_Surface*& east_or_north_side
         ) const;

  //////////
  // Find parameters of the point on a surface that is locally closest to
  // the test_point.  The search for a local close point starts at
  // seed parameters. If a sub_domain parameter is not NULL, then
  // the search is restricted to the specified portion of the surface.
  //
  // true if returned if the search is successful.  false is returned if
  // the search fails.
  virtual
  ON_BOOL32 GetLocalClosestPoint( const ON_3dPoint&, // test_point
          double,double,     // seed_parameters
          double*,double*,   // parameters of local closest point returned here
          const ON_Interval* = NULL, // first parameter sub_domain
          const ON_Interval* = NULL  // second parameter sub_domain
          ) const;

  /*
  Description:
    Get a NURBS surface representation of this surface.
  Parameters:
    nurbs_surface - [out] NURBS representation returned here
    tolerance - [in] tolerance to use when creating NURBS
        representation.
    s_subdomain - [in] if not NULL, then the NURBS representation
        for this portion of the surface is returned.
    t_subdomain - [in] if not NULL, then the NURBS representation
        for this portion of the surface is returned.
  Returns:
    0   unable to create NURBS representation
        with desired accuracy.
    1   success - returned NURBS parameterization
        matches the surface's to wthe desired accuracy
    2   success - returned NURBS point locus matches
        the surface's to the desired accuracy and the
        domain of the NURBS surface is correct.  On
        However, This surface's parameterization and
        the NURBS surface parameterization may not 
        match to the desired accuracy.  This situation
        happens when getting NURBS representations of
        surfaces that have a transendental parameterization
        like spheres, cylinders, and cones.
  Remarks:
    This is a low-level virtual function.  If you do not need
    the parameterization information provided by the return code,
    then ON_Surface::NurbsSurface may be easier to use.
  See Also:
    ON_Surface::NurbsSurface
  */
  virtual
  int GetNurbForm(
        ON_NurbsSurface& nurbs_surface,
        double tolerance = 0.0
        ) const;


  /*
  Description:
    Is there a NURBS surface representation of this surface.
  Parameters:
  Returns:
    0   unable to create NURBS representation
        with desired accuracy.
    1   success - NURBS parameterization
        matches the surface's
    2   success - NURBS point locus matches
        the surface's and the
        domain of the NURBS surface is correct.  
        However, This surface's parameterization and
        the NURBS surface parameterization may not 
        match.  This situation
        happens when getting NURBS representations of
        surfaces that have a transendental parameterization
        like spheres, cylinders, and cones.
  Remarks:
    This is a low-level virtual function. 
  See Also:
    ON_Surface::GetNurbForm
    ON_Surface::NurbsSurface
  */
  virtual
  int HasNurbForm() const;

  // Description:
  //   Get a NURBS surface representation of this surface.
  // Parameters:
  //   pNurbsSurface - [in/out] if not NULL, this pNurbsSurface
  //   will be used to store the NURBS representation
  //   of the surface and will be returned.
  //   tolerance - [in] tolerance to use when creating NURBS
  //       surface representation.
  //   s_subdomain - [in] if not NULL, then the NURBS representation
  //       for this portion of the surface is returned.
  //   t_subdomain - [in] if not NULL, then the NURBS representation
  //       for this portion of the surface is returned.
  // Returns:
  //   NULL or a NURBS representation of the surface.
  // Remarks:
  //   See ON_Surface::GetNurbForm for important details about
  //   the NURBS surface parameterization.
  // See Also:
  //   ON_Surface::GetNurbForm
  ON_NurbsSurface* NurbsSurface(
        ON_NurbsSurface* pNurbsSurface = NULL,
        double tolerance = 0.0,
        const ON_Interval* s_subdomain = NULL,
        const ON_Interval* t_subdomain = NULL
        ) const;

  virtual
  bool GetSurfaceParameterFromNurbFormParameter(
        double nurbs_s, double nurbs_t,
        double* surface_s, double* surface_t
        ) const;

  virtual
  bool GetNurbFormParameterFromSurfaceParameter(
        double surface_s, double surface_t,
        double* nurbs_s,  double* nurbs_t
        ) const;


  // If the geometry surface is modified in any way, then
  // call DestroySurfaceTree().
  void DestroySurfaceTree();

  virtual
  ON_SurfaceTree* CreateSurfaceTree() const;

  /*
  Description:
    Calculate area mass properties of the surface.
  Parameters:
    mp - [out]
    bArea - [in] true to calculate area
    bFirstMoments - [in] true to calculate area first moments,
                         area and area centroid.
    bSecondMoments - [in] true to calculate area second moments.
    bProductMoments - [in] true to calculate area product moments.
  Returns:
    True if successful.
  */
  bool AreaMassProperties(
    ON_MassProperties& mp,
    bool bArea = true,
    bool bFirstMoments = true,
    bool bSecondMoments = true,
    bool bProductMoments = true,
    double rel_tol = 1.0e-6,
    double abs_tol = 1.0e-6
    ) const;

  /*
  Description:
    Calculate volume mass properties of the surface.
  Parameters:
    mp - [out]
    bVolume - [in] true to calculate volume
    bFirstMoments - [in] true to calculate volume first moments,
                         volume, and volume centroid.
    bSecondMoments - [in] true to calculate volume second moments.
    bProductMoments - [in] true to calculate volume product moments.
    base_point - [in]
      If the surface is closed, then pass ON_UNSET_VALUE.

      This parameter is for expert users who are computing a
      volume whose boundary is defined by several non-closed
      breps, surfaces, and meshes.

      When computing the volume, volume centroid, or volume
      first moments of a volume whose boundary is defined by
      several breps, surfaces, and meshes, pass the same
      base_point to each call to VolumeMassProperties.

      When computing the volume second moments or volume product
      moments of a volume whose boundary is defined by several
      breps, surfaces, and meshes, you MUST pass the entire
      volume's centroid as the base_point and the input mp
      parameter must contain the results of a previous call
      to VolumeMassProperties(mp,true,true,false,false,base_point).
      In particular, in this case, you need to make two sets of
      calls; use first set to calculate the volume centroid and
      the second set calculate the second moments and product
      moments.
  Returns:
    True if successful.
  */
  bool VolumeMassProperties(
    ON_MassProperties& mp,
    bool bVolume = true,
    bool bFirstMoments = true,
    bool bSecondMoments = true,
    bool bProductMoments = true,
    ON_3dPoint base_point = ON_UNSET_POINT,
    double rel_tol = 1.0e-6,
    double abs_tol = 1.0e-6
    ) const;

  /*
  Description:
    Intersect this surface with surfaceB.

  Parameters:
    surfaceB - [in]

    x - [out]
      Intersection events are appended to this array.

    intersection_tolerance - [in]
      If the input intersection_tolerance <= 0.0, then 0.001 is used.

    overlap_tolerance - [in]
      If positive, then overlap_tolerance must be
      >= intersection_tolerance and is used to test for
      overlapping regions. If the input
      overlap_tolerance <= 0.0, then 2*intersection_tolerance
      is used.

    fitting_tolerance - [in]
      If fitting_tolerance is > 0 and >= intersection_tolerance,
      then the intersection curves are fit to this tolerance.
      If input fitting_tolerance <= 0.0 or < intersection_tolerance,
      then intersection_tolerance is used.

    surfaceA_udomain - [in]
      optional restriction on surfaceA u domain
    surfaceA_vdomain - [in]
      optional restriction on surfaceA v domain

    surfaceB_udomain - [in]
      optional restriction on surfaceB u domain
    surfaceB_vdomain - [in]
      optional restriction on surfaceB v domain
  Returns:
     Number of intersection events appended to x.
  */
  int IntersectSurface(
          const ON_Surface* surfaceB,
          ON_ClassArray<ON_SSX_EVENT>& x,
          double intersection_tolerance = 0.0,
          double overlap_tolerance = 0.0,
          double fitting_tolerance = 0.0,
          const ON_Interval* surfaceA_udomain = 0,
          const ON_Interval* surfaceA_vdomain = 0,
          const ON_Interval* surfaceB_udomain = 0,
          const ON_Interval* surfaceB_vdomain = 0
          ) const;

  /*
  Description:
    Create a cubic nurbs surface that interpolates a list of curves.

  Parameters:
    curve_count - [in]  >= 2
      number of curves

    curve_list - [in]
      array of pointers to curves.  These curves define
      the location of the The returned surface's "v" parameter

    k - [in] (0.0 <= k) or k = ON_UNSET_VALUE
      k determines how the surface's m_knot[0] values
      are calculated. Most frequently, 0.0, 0.5, or 1.0 should be used.
        0.0: uniform
        0.5: sqrt(chord length)
        1.0: chord length
          In general, when k >= 0.0, then spacing is pow(d,k), where d is the
          average distance between the curves defining the span.
        ON_UNSET_VALUE: the intepolation knot vector is explicity specified.
          The knots in the interpolated direction are specified.  You must
          understand the mathematics of NURBS surfaces to use this option.
          To specify an explicit knot vector for the interpolation, the
          nurbs_suface parameter must be non-null, and nurbs_surface->m_knot[0]
          must be an array of length 4+curve_count, and
          (nurbs_surface->m_knot[0][2], ..., nurbs_surface->m_knot[0][curve_count+1])
          must be a strictly increasing list of values.

    is_closed - [in]
      0: open
      1: closed
      2: periodic

    start_shape - [in]
    end_shape - [in]
      The start_shape and end_shape paramters determine the
      starting and ending shape of the lofted surface.
      Simple shapes:
        The simple end conditions calculate the rows of free
        control points based on the locations of the input
        curves and do not require additional input information.
          ON::cubic_loft_ec_quadratic: quadratic
          ON::cubic_loft_ec_linear: linear
          ON::cubic_loft_ec_cubic: cubic
          ON::cubic_loft_ec_natural: natrual (zero 2nd derivative)
      Explicit shapes:
        In order to specify explicit end conditions, curve_count must
        be at least 3, is_closed must be 0 or 1, the nurbs_surface
        parameter must be non-null, the nurbs_surface control
        points must be allocated, nurbs_surface->m_cv_count[0]
        must be curve_count+2, and the input curves must have nurbs
        curve formats with the same number of control points as
        nurbs_surface->m_cv_count[1]. The values of the starting
        shape points are specified in nurbs_surface->CV(1,...) and
        the values of ending shape points are specified in
        nurbs_surface->CV(curve_count,...).
        N = curve_count
          ON::cubic_loft_ec_unit_tangent: unit tangent is specified
          ON::cubic_loft_ec_1st_derivative: first derivative is specified
          ON::cubic_loft_ec_2nd_derivative: second derivative is specified
          ON::cubic_loft_ec_free_cv: free control vertex is specified

    nurbs_surface - [in]
      If not null, the result will returned in this ON_NurbsSurface.
      Typically, this paramter is used when you want to store the
      result in an ON_NurbsSurface that is on the stack.  This
      paramter is also used when you want to specify the interpolation
      knots or end conditions.

  Returns:
    If successful, a pointer to the surface is returned. If the input
    nurbs_surface parameter was null, then this surface is on the heap
    and will need to be deleted to avoid memory leaks.  If the input
    is not valid, null is returned, even when nurbs_surface is not
    null.

  Example:

    // EXAMPLE 1: Loft a surface through a list of curves
      ON_SimpleArray< const ON_Curve* > curve_list = ....;
      ON_NurbsSurface* srf = ON_Surface::CreateCubicLoft(
                     curve_list.Count(),
                     curve_list,
                     0.5 // sqrt(chord length) spacing
                     );

    // EXAMPLE 2: Create adjacent surfaces with an identical shared edge.
      // First make two curve lists with
      // curve_listA.Count() == curve_listB.Count() and
      // curve_listA[i]->PointAtEnd() == curve_listB[i]->PointAtStart()
      ON_SimpleArray< const ON_Curve* > curve_listA = ....;
      ON_SimpleArray< const ON_Curve* > curve_listB = ....;
      curve_count = curve_listA.Count();
      ON_NurbsSurface* srfA = 0;
      ON_NurbsSurface* srfB = 0;
      if ( curve_count == curve_listB.Count() )
      {
        srfA = ON_Surface::CreateCubicLoft(
                       curve_count,
                       curve_listA.Array(),
                       1.0 // chord length spacing
                       );
        if (0 != srfA)
        {
          srfB = new ON_NurbsSurface();
          int knot_count0 = srfA->KnotCount(0);
          srfB->ReserveKnotCapacity(0,knot_count0);
          memcpy(srfB->m_knot[0],srfA->m_knot[0],knot_count0*sizeof(srfB->m_knot[0][0]))
          if ( 0 == ON_Surface::CreateCubicLoft(
                         curve_count,
                         curve_listB.Array(),
                         ON_UNSET_VALUE, // knots specified in srfB->m_knot[0]
                         0, // open loft
                         ON::cubic_loft_ec_quadratic,
                         ON::cubic_loft_ec_quadratic,
                         srfB
                         ) )
            {
           // clean up to prevent memory leaks
           delete srfB;
           srfB = 0;
         }
       }
     }
  */
  static
  class ON_NurbsSurface* CreateCubicLoft(
    int curve_count,
    const ON_Curve* const* curve_list,
    double k,
    int is_closed = 0,
    ON::cubic_loft_end_condition start_shape = ON::cubic_loft_ec_quadratic,
    ON::cubic_loft_end_condition end_shape   = ON::cubic_loft_ec_quadratic,
    class ON_NurbsSurface* nurbs_surface = 0
    );
};

class ON_CLASS ON_SurfaceProperties
{
  // Surface properties
public:
  // The constructor sets all fields to zero.
  ON_SurfaceProperties();

  /*
  Parameters:
    surface - [in]
      If surface is not null, then it is used to set the surface properties.
      If surface is null, then all surface properties are set to to zero.
  Remarks:
    Does not modify the value of m_tag.
  */
  void Set( const ON_Surface* surface );

  bool m_bIsSet;           // True if Set() has been callled with a non-null surface.

  bool m_bHasSingularity;  // true if at least one m_bSingular[] setting is true.
  bool m_bIsSingular[4];   // m_bSingular[i] = ON_Surface::IsSingular(i)

  bool m_bHasSeam;         // true if at least one m_bClosed[] setting is true.
  bool m_bIsClosed[2];     // m_bClosed[i] = ON_Surface::IsClosed(i)

private:
  bool m_bReserved[7];

public:
  ON_Interval m_domain[2]; // m_domain[i] = ON_Surface.Domain(i)

private:
  unsigned char m_reserved[16];

public:
  // Last pointer passed to ON_SurfaceProperties::Set().
  const ON_Surface* m_surface;

  // The constructor sets this value to zero.
  // Nothing in opennurbs modifies or uses this value.
  ON__INT_PTR m_tag;
};

#if defined(ON_DLL_TEMPLATE)
// This stuff is here because of a limitation in the way Microsoft
// handles templates and DLLs.  See Microsoft's knowledge base 
// article ID Q168958 for details.
#pragma warning( push )
#pragma warning( disable : 4231 )
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_Surface*>;
#pragma warning( pop )
#endif

class ON_CLASS ON_SurfaceArray : public ON_SimpleArray<ON_Surface*>
{
public:
  ON_SurfaceArray( int = 0 );
  ~ON_SurfaceArray();

  ON_BOOL32 Write( ON_BinaryArchive& ) const;
  ON_BOOL32 Read( ON_BinaryArchive& );

  void Destroy(); // deletes surfaces in array and sets count to 0

  ON_BOOL32 Duplicate( ON_SurfaceArray& ) const; // operator= copies the pointer values
                                     // duplicate copies the surfaces themselves
};


#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

////////////////////////////////////////////////////////////////
//
//   defines ON_Viewport
//
////////////////////////////////////////////////////////////////

#if !defined(OPENNURBS_VIEWPORT_INC_)
#define OPENNURBS_VIEWPORT_INC_

///////////////////////////////////////////////////////////////////////////////
// Class  ON_Viewport
//
//	This object represents a viewing frustum
///////////////////////////////////////////////////////////////////////////////
class ON_CLASS ON_Viewport : public ON_Geometry 
{
	ON_OBJECT_DECLARE( ON_Viewport );
public:

  // Default z=up perspective camera direction
  static const ON_3dVector Default3dCameraDirection;

  // Construction
	ON_Viewport();
  ~ON_Viewport();
	ON_Viewport& operator=( const ON_Viewport& );

  bool IsValidCamera() const;
  bool IsValidFrustum() const;

  // ON_Object overrides //////////////////////////////////////////////////////
  //

  /*
  Description:
    Test for a valid camera, frustum, and screen port.
  Parameters:
    text_log - [in] if the object is not valid and text_log
        is not NULL, then a brief englis description of the
        reason the object is not valid is appened to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     camera, frustum, and screen port are valid.
    false    camera, frustum, or screen port is invalid.
  Remarks:
    Overrides virtual ON_Object::IsValid
  See Also:
    IsValidCamera, IsValidFrustum
  */
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  // Description:
  //   Dumps debugging text description to a text log.
  //
  // Parameters:
  //   dump_target - [in] text log
  //
  // Remarks:
  //   This overrides the virtual ON_Object::Dump() function.
  void Dump( 
    ON_TextLog& // dump_target
    ) const;

  // Description:
  //   Writes ON_Viewport defintion from a binary archive.
  //
  // Parameters:
  //   binary_archive - [in] open binary archive
  //
  // Returns:
  //   true if successful.
  //
  // Remarks:
  //   This overrides the virtual ON_Object::Write() function.
  ON_BOOL32 Write(
         ON_BinaryArchive&  // binary_archive
       ) const;


  // Description:
  //   Reads ON_Viewport defintion from a binary archive.
  //
  // Parameters:
  //   binary_archive - [in] open binary archive
  //
  // Returns:
  //   true if successful.
  //
  // Remarks:
  //   This overrides the virtual ON_Object::Read() function.
  ON_BOOL32 Read(
         ON_BinaryArchive&  // binary_archive
       );


  // ON_Geometry overrides //////////////////////////////////////////////////////
  //

  // Description:
  //   The dimension of a camera view frustum is 3.
  //
  // Returns:
  //   3
  //
  // Remarks:
  //   This is virtual ON_Geometry function.
  int Dimension() const;

  // Description:
  //   Gets bounding box of viewing frustum.
  //
  // Parameters:
  //   boxmin - [in/out] array of Dimension() doubles
  //   boxmax - [in/out] array of Dimension() doubles
  //   bGrowBox - [in] (default=false) 
  //     If true, then the union of the input bbox and the 
  //     object's bounding box is returned in bbox.  
  //     If false, the object's bounding box is returned in bbox.
  //
  // Returns:
  //   @untitled table
  //   true     Valid frustum and bounding box returned.
  //   false    Invalid camera or frustum. No bounding box returned.
  //
  // Remarks:
  //   This overrides the virtual ON_Geometry::GetBBox() function.
  ON_BOOL32 GetBBox( // returns true if successful
         double*, // boxmin
         double*, // boxmax
         ON_BOOL32 = false // bGrowBox
         ) const;

  // Description:
  //   Transforms the view camera location, direction, and up.
  //
  // Parameters:
  //   xform - [in] transformation to apply to camera.
  //
  // Returns:
  //   @untitled table
  //   true     Valid camera was transformed.
  //   false    Invalid camera, frustum, or transformation.
  //
  // Remarks:
  //   This overrides the virtual ON_Geometry::Transform() function.
  ON_BOOL32 Transform( 
         const ON_Xform& // xform
         );

  // Interface /////////////////////////////////////////////////////////////////
  //
  void Initialize();

  ON::view_projection Projection() const;

  /*
  Description:
    Unconditionally set the projection.
  Parameters:
    projection - [in]
  See Also:
    ON_Viewport::SetParallelProjection
    ON_Viewport::SetPerpectiveProjection
    ON_Viewport::SetTwoPointPerspectiveProjection    
  */
  bool SetProjection( ON::view_projection projection );

  /*
  Description:
    Use this function to change projections of valid viewports
    from persective to parallel.  It will make common additional
    adjustments to the frustum so the resulting views are similar.
    The camera location and direction will not be changed.
  Parameters:
    bSymmetricFrustum - [in]
      True if you want the resulting frustum to be symmetric.
  Remarks:
    If the current projection is parallel and bSymmetricFrustum,
    FrustumIsLeftRightSymmetric() and FrustumIsTopBottomSymmetric()
    are all equal, then no changes are made and true is returned.
  */
  bool ChangeToParallelProjection( bool bSymmetricFrustum );

  /*
  Description:
    Use this function to change projections of valid viewports
    from parallel to perspective.  It will make common additional
    adjustments to the frustum and camera location so the resulting
    views are similar.  The camera direction and target point are
    not be changed.
  Parameters:
    target_distance - [in]
      If ON_UNSET_VALUE this parameter is ignored.  Otherwise
      it must be > 0 and indicates which plane in the current 
      view frustum should be perserved.
    bSymmetricFrustum - [in]
      True if you want the resulting frustum to be symmetric.
    lens_length - [in] (pass 50.0 when in doubt)
      35 mm lens length to use when changing from parallel
      to perspective projections. If the current projection
      is perspective or lens_length is <= 0.0,
      then this parameter is ignored.
  Remarks:
    If the current projection is perspective and bSymmetricFrustum,
    FrustumIsLeftRightSymmetric() and FrustumIsTopBottomSymmetric()
    are all equal, then no changes are made and true is returned.
  */
  bool ChangeToPerspectiveProjection( 
          double target_distance,
          bool bSymmetricFrustum,
          double lens_length
          );

  /*
  Description:
    Use this function to change projections of valid viewports
    to a two point perspective.  It will make common additional
    adjustments to the frustum and camera location and direction
    so the resulting views are similar.
  Parameters:
    target_distance - [in]
      If ON_UNSET_VALUE this parameter is ignored.  Otherwise
      it must be > 0 and indicates which plane in the current 
      view frustum should be perserved.
    up - [in]
      This direction will be the locked up direction.  Pass 
      ON_3dVector::ZeroVector if you want to use the world axis
      direction that is closest to the current up direction.
      Pass CameraY() if you want to preserve the current up direction.
    lens_length - [in] (pass 50.0 when in doubt)
      35 mm lens length to use when changing from parallel
      to perspective projections. If the current projection
      is perspective or lens_length is <= 0.0,
      then this parameter is ignored.
  Remarks:
    If the current projection is perspective and 
    FrustumIsLeftRightSymmetric() is true and
    FrustumIsTopBottomSymmetric() is false, then no changes are
    made and true is returned.
  */
  bool ChangeToTwoPointPerspectiveProjection( 
          double target_distance,
          ON_3dVector up,
          double lens_length
          );

  /*
  Returns:
    True if the projection is ON::perspective_view.
  */
  bool IsPerspectiveProjection() const;

  /*
  Returns
    IsPerspectiveProjection() 
    && CameraUpIsLocked()
    && FrustumIsLeftRightSymmetric
    && !FrustumIsTopBottomSymmetric
  */
  bool IsTwoPointPerspectiveProjection() const;

  /*
  Returns:
    True if the projection is ON::parallel_view.
  */
  bool IsParallelProjection() const;

  // These return true if the current direction and up are not zero and not
  // parallel so the camera position is well defined.
  bool SetCameraLocation( const ON_3dPoint& );
  bool SetCameraDirection( const ON_3dVector& );
  bool SetCameraUp( const ON_3dVector& );

  ON_3dPoint CameraLocation() const;
  ON_3dVector CameraDirection() const;
  ON_3dVector CameraUp() const;

  bool CameraLocationIsLocked() const;
  bool CameraDirectionIsLocked() const;
  bool CameraUpIsLocked() const;
  bool FrustumIsLeftRightSymmetric() const;
  bool FrustumIsTopBottomSymmetric() const;

  void SetCameraLocationLock( bool bLockCameraLocation );
  void SetCameraDirectionLock( bool bLockCameraDirection ) ;
  void SetCameraUpLock( bool bLockCameraUp );
  void SetFrustumLeftRightSymmetry( bool bForceLeftRightSymmetry );
  void SetFrustumTopBottomSymmetry( bool bForceTopBottomSymmetry );
  void UnlockCamera(); // sets all camera locks to false
  void UnlockFrustumSymmetry(); // sets all frustum symmetry locks to false

  // returns true if current camera orientation is valid
  bool GetCameraFrame(
      double*, // CameraLocation[3]
      double*, // CameraX[3]
      double*, // CameraY[3]
      double*  // CameraZ[3]
      ) const;

  // these do not check for a valid camera orientation
  ON_3dVector CameraX() const; // unit to right vector
  ON_3dVector CameraY() const; // unit up vector
  ON_3dVector CameraZ() const; // unit vector in -CameraDirection

  
  bool IsCameraFrameWorldPlan( 
      // Returns true if the camera direction = some world axis.
      // The indices report which axes are used.  For a "twisted"
      // plan view it is possible to have zero x and y indices.
      // This function returns true if and only if the "z" index
      // is non-zero.
      //
      // Indices are +/-1 = world +/-x, +/-2 = world +/-y, +/-3 = world +/-z,
      int*, // if true and plan is axis aligned, view x index, else 0
      int*, // if true and plan is axis aligned, view y index, else 0
      int*  // if true, view z index, else 0
      );

  bool GetCameraExtents( 
      // returns bounding box in camera coordinates - this is useful information
      // for setting view frustrums to include the point list
      int,           // count = number of 3d points
      int,           // stride = number of doubles to skip between points (>=3)
      const double*, // 3d points in world coordinates
      ON_BoundingBox& cambbox, // bounding box in camera coordinates
      int bGrowBox = false   // set to true if you want to enlarge an existing camera coordinate box
      ) const;

  bool GetCameraExtents( 
      // returns bounding box in camera coordinates - this is useful information
      // for setting view frustrums to include the point list
      const ON_BoundingBox&, // world coordinate bounding box
      ON_BoundingBox& cambbox, // bounding box in camera coordinates
      int bGrowBox = false   // set to true if you want to enlarge an existing camera coordinate box
      ) const;

  bool GetCameraExtents( 
      // returns bounding box in camera coordinates - this is useful information
      // for setting view frustrums to include the point list
      ON_3dPoint&,     // world coordinate bounding sphere center
      double,          // world coordinate bounding sphere radius
      ON_BoundingBox& cambox, // bounding box in camera coordinates
      int bGrowBox = false     // set to true if you want to enlarge an existing camera coordinate box
      ) const;

  /*
  Description:
    Set the view frustum.  If FrustumSymmetryIsLocked() is true
    and left != -right or bottom != -top, then they will be
    adjusted so the resulting frustum is symmetric.
  */
  bool SetFrustum(
        double left,   // 
        double right,  //   ( left < right )
        double bottom, // 
        double top,    //   ( bottom < top )
        double near_dist,   // 
        double far_dist     //   ( 0 < near_dist < far_dist ) // ignored by Rhino version 1.0
        );
  bool GetFrustum(
        double* left,        // 
        double* right,       // (left < right)
        double* bottom,      // 
        double* top,         // (bottom < top)
        double* near_dist = NULL, // 
        double* far_dist = NULL   // (0 < near_dist < far_dist)
        ) const;

  // SetFrustumAspect() changes the larger of the frustum's widht/height
  // so that the resulting value of width/height matches the requested
  // aspect.  The camera angle is not changed.  If you change the shape
  // of the view port with a call SetScreenPort(), then you generally 
  // want to call SetFrustumAspect() with the value returned by 
  // GetScreenPortAspect().
  bool SetFrustumAspect( double );

  // Returns frustum's width/height
  bool GetFrustumAspect( double& ) const;

  // Returns world coordinates of frustum's center
  bool GetFrustumCenter( double* ) const;

  // The near clipping plane stored in the Rhino 1.0 file is frequently very
  // small and useless for high quality z-buffer based rendering.  The far
  // clipping value is not stored in the file.  Use these functions to set
  // the frustum's near and far clipping planes to appropriate values.
  double FrustumLeft() const;
  double FrustumRight() const;
  double FrustumBottom() const;
  double FrustumTop() const;
  double FrustumNear() const;
  double FrustumFar() const;

  /*
  Returns:
    frustum right - frustum left
  */
  double FrustumWidth() const; // right - left

  /*
  Returns:
    frustum right - frustum left
  */
  double FrustumHeight() const; // top - bottom

  /*
  Returns:
    Minimum of fabs(FrustumWidth()) and fabs(FrustumHeight())
  */
  double FrustumMinimumDiameter() const;

  /*
  Returns:
    Maximum of fabs(FrustumWidth()) and fabs(FrustumHeight())
  */
  double FrustumMaximumDiameter() const;


  bool SetFrustumNearFar(       
         const double* bboxmin,  // 3d bounding box min
         const double* bboxmax   // 3d bounding box max
         );
  bool SetFrustumNearFar( 
         const double* center,  // 3d bounding sphere center
         double radius         // 3d bounding sphere radius
         );
  bool SetFrustumNearFar( 
         double near_dist, // ( > 0 )
         double far_dist   // 
         );

  /*
  Description:
    If needed, adjust the current frustum so it has the 
    specified symmetries and adjust the camera location
    so the target plane remains visible.
  Parameters:
    bLeftRightSymmetric - [in]
      If true, the frustum will be adjusted so left = -right.
    bTopBottomSymmetric - [in]
      If true, the frustum will be adjusted so top = -bottom.
    target_distance - [in]
      If projection is not perspective or target_distance 
      is ON_UNSET_VALUE, this this parameter is ignored. 
      If the projection is perspective and target_distance 
      is not ON_UNSET_VALUE, then it must be > 0.0 and
      it is used to determine which plane in the old
      frustum will appear unchanged in the new frustum.
  bool
    Returns true if the returned viewport has a frustum
    with the specified symmetries.
  */
  bool ChangeToSymmetricFrustum( 
    bool bLeftRightSymmetric, 
    bool bTopBottomSymmetric,
    double target_distance
    );

  /*
  Description:
    Get near and far clipping distances of a point
  Parameters:
    point - [in] 
    near_dist - [out] 
      near distance of the point (can be < 0)
    far_dist - [out] 
      far distance of the point (can be equal to near_dist)
    bGrowNearFar - [in]
      If true and input values of near_dist and far_dist
      are not ON_UNSET_VALUE, the near_dist and far_dist
      are enlarged to include bbox.
  Returns:
    True if the point is ing the view frustum and
    near_dist/far_dist were set.
    False if the bounding box does not intesect the
    view frustum.
  */
  bool GetPointDepth(       
         ON_3dPoint point,
         double* near_dist,
         double* far_dist,
         bool bGrowNearFar=false
         ) const;

  /*
  Description:
    Get the view plane depth of a point
  Parameters:
    point - [in] 
    view_plane_depth - [out] 
      positive values are in front of the camera and negative
      values are behind the camera.
      If 0 <= point_depth < FrustumNear(), the point's view
      plane is between the camera and the frustum's near plane.
      If point_depth > FrustumFar(), the point's view
      plane is farther from the camera and the frustum's far plane.
  Returns:
    True if the point is ing the view frustum and
    near_dist/far_dist were set.
    False if the bounding box does not intesect the
    view frustum.
  */
  bool GetPointDepth(       
       ON_3dPoint point,
       double* view_plane_depth
       ) const;

  /*
  Description:
    Get near and far clipping distances of a bounding box.
  Parameters:
    bbox - [in] 
      bounding box
    near_dist - [out] 
      near distance of the box
      This value can be zero or negative when the camera
      location is inside bbox.
    far_dist - [out] 
      far distance of the box
      This value can be equal to near_dist, zero or negative 
      when the camera location is in front of the bounding box.
    bGrowNearFar - [in]
      If true and input values of near_dist and far_dist
      are not ON_UNSET_VALUE, the near_dist and far_dist
      are enlarged to include bbox.
  Returns:
    True if the bounding box intersects the view frustum and
    near_dist/far_dist were set.
    False if the bounding box does not intesect the view frustum.
  Remarks:
    This function ignores the current value of the viewport's 
    near and far settings. If the viewport is a perspective
    projection, the it intersects the semi infinite frustum
    volume with the bounding box and returns the near and far
    distances of the intersection.  If the viewport is a parallel
    projection, it instersects the infinte view region with the
    bounding box and returns the near and far distances of the
    projection.
  */
  bool GetBoundingBoxDepth(       
         ON_BoundingBox bbox,
         double* near_dist,
         double* far_dist,
         bool bGrowNearFar=false
         ) const;

  /*
  Description:
    Get near and far clipping distances of a bounding sphere.
  Parameters:
    sphere - [in] 
      bounding sphere
    near_dist - [out] 
      near distance of the sphere (can be < 0)
    far_dist - [out] 
      far distance of the sphere (can be equal to near_dist)
    bGrowNearFar - [in]
      If true and input values of near_dist and far_dist
      are not ON_UNSET_VALUE, the near_dist and far_dist
      are enlarged to include bbox.
  Returns:
    True if the sphere intersects the view frustum and
    near_dist/far_dist were set.
    False if the sphere does not intesect the view frustum.
  */
  bool GetSphereDepth( 
         ON_Sphere sphere,
         double* near_dist,
         double* far_dist,
         bool bGrowNearFar=false
         ) const;

  /*
  Description:
    Set near and far clipping distance subject to constraints.
  Parameters:
    near_dist - [in] (>0) desired near clipping distance
    far_dist - [in] (>near_dist) desired near clipping distance
    min_near_dist - [in] 
      If min_near_dist <= 0.0, it is ignored.
      If min_near_dist > 0 and near_dist < min_near_dist, 
      then the frustum's near_dist will be increased to 
      min_near_dist.
    min_near_over_far - [in] 
      If min_near_over_far <= 0.0, it is ignored.
      If near_dist < far_dist*min_near_over_far, then
      near_dist is increased and/or far_dist is decreased
      so that near_dist = far_dist*min_near_over_far.
      If near_dist < target_dist < far_dist, then near_dist
      near_dist is increased and far_dist is decreased so that
      projection precision will be good at target_dist.
      Otherwise, near_dist is simply set to 
      far_dist*min_near_over_far.
    target_dist - [in]  
      If target_dist <= 0.0, it is ignored.
      If target_dist > 0, it is used as described in the
      description of the min_near_over_far parameter.
    relative_depth_bias - [in]
      If relative_depth_bias <= 0.0, it is ignored.
      If relative_depth_bias > 0, it is assumed that
      the requested near_dist and far_dist were calculated
      assuming no depth bias and the values will be
      appropriately adjusted to ensure the frustum's 
      near and far clipping planes will not clip biased
      objects.
  */
  bool SetFrustumNearFar( 
         double near_dist,
         double far_dist,
         double min_near_dist,
         double min_near_over_far,
         double target_dist
         );

  bool SetFrustumNearFar( 
         double near_dist,
         double far_dist,
         double min_near_dist,
         double min_near_over_far,
         double target_dist,
         double relative_depth_bias
         );

  // Description:
  //   Get near clipping plane.
  //
  //  near_plane - [out] near clipping plane if camera and frustum
  //      are valid.  The plane's frame is the same as the camera's
  //      frame.  The origin is located at the intersection of the
  //      camera direction ray and the near clipping plane. The plane's
  //      normal points out of the frustum towards the camera
  //      location.
  //
  // Returns:
  //   true if camera and frustum are valid.
  bool GetNearPlane( 
    ON_Plane& near_plane 
    ) const;

  bool GetNearPlaneEquation( 
    ON_PlaneEquation& near_plane_equation 
    ) const;

  // Description:
  //   Get far clipping plane.
  //
  //  far_plane - [out] far clipping plane if camera and frustum
  //      are valid.  The plane's frame is the same as the camera's
  //      frame.  The origin is located at the intersection of the
  //      camera direction ray and the far clipping plane. The plane's
  //      normal points into the frustum towards the camera location.
  //
  // Returns:
  //   true if camera and frustum are valid.
  bool GetFarPlane( 
    ON_Plane& far_plane 
    ) const;

  bool GetFarPlaneEquation( 
    ON_PlaneEquation& far_plane_equation 
    ) const;

  /*
  Description:
    Get the plane that is a specified distance from the camera.
    This plane is parallel to the frustum's near and far planes.
  Parameters:
    view_plane_depth - [in]
      The distance from the camera location to the view plane. 
      Positive distances are in front of the camera and
      negative distances are behind the camera.
      A value of FrustumNear() will return the frustum's
      near plane and a valud of FrustumFar() will return
      the frustum's far plane.
    view_plane - [out]
      View plane
    view_plane_equation - [out]
      Equation of the view plane.
  Returns:
    True if the camera and frustum are valid and view_plane
    was calculated.  False otherwise.
  */
  bool GetViewPlane( 
    double view_plane_depth,
    ON_Plane& view_plane 
    ) const;

  bool GetViewPlaneEquation( 
    double view_plane_depth,
    ON_PlaneEquation& view_plane_equation 
    ) const;

  /*
  Description:
  Get left world frustum clipping plane.
  Parameters:
    left_plane - [out] 
      frustum left side clipping plane.  The normal points
      into the visible region of the frustum.  If the projection
      is perspective, the origin is at the camera location,
      otherwise the origin isthe point on the plane that is
      closest to the camera location.
  Returns:
    True if camera and frustum are valid and plane was set.
  */
  bool GetFrustumLeftPlane( 
    ON_Plane& left_plane 
    ) const;

  bool GetFrustumLeftPlaneEquation( 
    ON_PlaneEquation& left_plane_equation 
    ) const;

  /*
  Description:
  Get right world frustum clipping plane.
  Parameters:
    right_plane - [out] 
      frustum right side clipping plane.  The normal points
      into the visible region of the frustum.  If the projection
      is perspective, the origin is at the camera location,
      otherwise the origin isthe point on the plane that is
      closest to the camera location.
  Returns:
    True if camera and frustum are valid and plane was set.
  */
  bool GetFrustumRightPlane( 
    ON_Plane& right_plane 
    ) const;

  bool GetFrustumRightPlaneEquation( 
    ON_PlaneEquation& right_plane_equation 
    ) const;

  /*
  Description:
  Get right world frustum clipping plane.
  Parameters:
    right_plane - [out] 
      frustum bottom side clipping plane.  The normal points
      into the visible region of the frustum.  If the projection
      is perspective, the origin is at the camera location,
      otherwise the origin isthe point on the plane that is
      closest to the camera location.
  Returns:
    True if camera and frustum are valid and plane was set.
  */
  bool GetFrustumBottomPlane( 
    ON_Plane& bottom_plane 
    ) const;

  bool GetFrustumBottomPlaneEquation( 
    ON_PlaneEquation& bottom_plane_equation 
    ) const;
  /*
  Description:
  Get right world frustum clipping plane.
  Parameters:
    top_plane - [out] 
      frustum top side clipping plane.  The normal points
      into the visible region of the frustum.  If the projection
      is perspective, the origin is at the camera location,
      otherwise the origin isthe point on the plane that is
      closest to the camera location.
  Returns:
    True if camera and frustum are valid and plane was set.
  */
  bool GetFrustumTopPlane( 
    ON_Plane& top_plane 
    ) const;

  bool GetFrustumTopPlaneEquation( 
    ON_PlaneEquation& top_plane_equation 
    ) const;

  // Description:
  //   Get corners of near clipping plane rectangle.
  //
  // Parameters:
  //   left_bottom - [out] 
  //   right_bottom - [out]
  //   left_top - [out]
  //   right_top - [out]
  //
  // Returns:
  //   true if camera and frustum are valid.
  bool GetNearRect( 
          ON_3dPoint& left_bottom,
          ON_3dPoint& right_bottom,
          ON_3dPoint& left_top,
          ON_3dPoint& right_top
          ) const;

  // Description:
  //   Get corners of far clipping plane rectangle.
  //
  // Parameters:
  //   left_bottom - [out] 
  //   right_bottom - [out]
  //   left_top - [out]
  //   right_top - [out]
  //
  // Returns:
  //   true if camera and frustum are valid.
  bool GetFarRect( 
          ON_3dPoint& left_bottom,
          ON_3dPoint& right_bottom,
          ON_3dPoint& left_top,
          ON_3dPoint& right_top
          ) const;

  /*
  Description:
    Get the world coordinate corners of the rectangle of
    a view plane that is a specified distance from the camera.
    This rectangle is parallel to the frustum's near and far planes.
  Parameters:
    view_plane_depth - [in]
      The distance from the camera location to the view plane. 
      Positive distances are in front of the camera and
      negative distances are behind the camera.
      A value of FrustumNear() will return the frustum's
      near rectangle and a valud of FrustumFar() will return
      the frustum's far rectangle.
    left_bottom - [out]
    right_bottom - [out]
    left_top - [out]
    right_top - [out]
  Returns:
    True if the camera and frustum are valid and view_plane
    was calculated.  False otherwise.
  */
  bool GetViewPlaneRect(
          double view_plane_depth,
          ON_3dPoint& left_bottom,
          ON_3dPoint& right_bottom,
          ON_3dPoint& left_top,
          ON_3dPoint& right_top
          ) const;


  /*
  Description:
    Location of viewport in pixels.
    These are provided so you can set the port you are using
    and get the appropriate transformations to and from
    screen space.
  Parameters:
    port_left - [in]
    port_right - [in] (port_left != port_right)
    port_bottom - [in]
    port_top - [in] (port_top != port_bottom)
    port_near - [in]
    port_far - [in]
  Example:

          // For a Windows window
          int width = width of window client area in pixels;
          int height = height of window client area in pixels;
          port_left = 0;
          port_right = width;
          port_top = 0;
          port_bottom = height;
          port_near = 0;
          port_far = 1;
          SetScreenPort( port_left, port_right, 
                         port_bottom, port_top, 
                         port_near, port_far );

  Returns:
    true if input is valid.
  See Also:
    ON_Viewport::GetScreenPort
  */
  bool SetScreenPort(
        int port_left,
        int port_right,
        int port_bottom,
        int port_top,
        int port_near = 0,
        int port_far = 0
        );

  bool GetScreenPort(
        int* left,
        int* right,         //( port_left != port_right )
        int* port_bottom,
        int* port_top,      //( port_bottom != port_top)
        int* port_near=NULL,  
        int* port_far=NULL   
        ) const;

  /* 
  Returns:
    abs(port_right - port_left)
  */
  int ScreenPortWidth() const;

  /* 
  Returns:
    abs(port_bottom - port_top)
  */
  int ScreenPortHeight() const;

  bool GetScreenPortAspect( double& ) const; // port's |width/height|

  bool GetCameraAngle( 
          double* half_diagonal_angle, // 1/2 of diagonal subtended angle
          double* half_vertical_angle, // 1/2 of vertical subtended angle
          double* half_horizontal_angle // 1/2 of horizontal subtended angle
          ) const;
  bool GetCameraAngle( 
          double* half_smallest_angle  // 1/2 of smallest subtended view angle
          ) const;
  bool SetCameraAngle( 
          double half_smallest_angle // 1/2 of smallest subtended view angle
                  // 0 < angle < pi/2
          );

  // These functions assume the camera is horizontal and crop the
  // film rather than the image when the aspect of the frustum
  // is not 36/24.  (35mm film is 36mm wide and 24mm high.)
  //
  // The SetCamera35mmLensLength() preserves camera location,
  // changes the frustum, but maintains the frsutrum's aspect.
  bool GetCamera35mmLensLength( 
    double* lens_length 
    ) const;
  bool SetCamera35mmLensLength( 
    double lens_length 
    );

  // Same as GetCamera35mmLensLength() with "lens" misspelled.
  bool GetCamera35mmLenseLength( 
    double* lens_length 
    ) const;

  // Same as SetCamera35mmLensLength() with "lens" misspelled.
  bool SetCamera35mmLenseLength( 
    double lens_length 
    );

  bool GetXform( 
         ON::coordinate_system srcCS,
         ON::coordinate_system destCS,
         ON_Xform& matrix      // 4x4 transformation matrix (acts on the left)
         ) const;

  /*
  Description:
    Get the world coordinate line in the view frustum
    that projects to a point on the screen.
  Parameters:
    screenx - [in]
    screeny - [in] (screenx,screeny) = screen location
    world_line - [out] 3d world coordinate line segment
           starting on the near clipping plane and ending 
           on the far clipping plane.
  Returns:
    true if successful. 
    false if view projection or frustum is invalid.
  */
  bool GetFrustumLine( 
            double screenx, 
            double screeny, 
            ON_Line& world_line
            ) const;

  // display tools
  bool GetWorldToScreenScale( 
    const ON_3dPoint& point_in_frustum, // [in]  point in viewing frustum.
    double* pixels_per_unit             // [out] scale = number of pixels per world unit at the 3d point
    ) const;

  bool GetCoordinateSprite(
         int,        // size in pixels of coordinate sprite axes
         int, int,   // screen (x,y) for sprite origin
         int[3],     // returns depth order for axes
         double [3][2]  // screen coords for axes ends
         ) const;

  // Use Extents() as a quick way to set a viewport to so that bounding
  // volume is inside of a viewports frusmtrum.
  // The view angle is used to determine the position of the camera.
  bool Extents( 
         double half_view_angle,        // 1/2 smallest subtended view angle
                        // (0 < angle < pi/2)
         const ON_BoundingBox& world_bbox// 3d world coordinate bounding box
         );
  bool Extents( 
         double half_view_angle,        // 1/2 smallest subtended view angle
                        // (0 < angle < pi/2)
         const ON_3dPoint& center, // 3d world coordinate bounding sphere center
         double radius        // 3d sphere radius
         );

  ////////////////////////////////////////////////////////////////////////
  // View changing from screen input points.  Handy for
  // using a mouse to manipulate a view.
  //

  //////////
  // ZoomToScreenRect() may change camera and frustum settings
  bool ZoomToScreenRect(
         int screen_x0, 
         int screen_y0,  // (x,y) screen coords of a rectangle corner
         int screen_x1, 
         int screen_y1   // (x,y) screen coords of opposite rectangle corner
         );

  //////////
  // DollyCamera() does not update the frustum's clipping planes.
  // To update the frustum's clipping planes call DollyFrustum(d)
  // with d = dollyVector o cameraFrameZ.  To convert screen locations
  // into a dolly vector, use GetDollyCameraVector().
  bool DollyCamera( // Does not update frustum.  To update frustum use 
                    // DollyFrustum(d) with d = dollyVector o cameraFrameZ
          const ON_3dVector& dolly_vector // dolly vector in world coordinates
          );

  //////////
  // Gets a world coordinate dolly vector that can be passed to
  // DollyCamera().
  bool GetDollyCameraVector(
         int screen_x0, 
         int screen_y0,  // (x,y) screen coords of start point
         int screen_x1, 
         int screen_y1,  // (x,y) screen coords of end point
         double proj_plane_dist,      // distance of projection plane from camera.
                      // When in doubt, use 0.5*(frus_near+frus_far).
         ON_3dVector& dolly_vector // world coordinate dolly vector returned here
         ) const;

  //////////
  // Moves frustum's clipping planes
  bool DollyFrustum(
          double dolly_distance // distance to move in camera direction
          );

  /*
  Description:
    Apply scaling factors to parallel projection clipping coordinates
    by setting the m_clip_mod transformation.  
  Parameters:
    x - [in] x > 0
    y - [in] y > 0
  Example:
    If you want to compress the view projection across the viewing
    plane, then set x = 0.5, y = 1.0, and z = 1.0.
  Returns:
    True if successful.
    False if input is invalid or the view is a perspective view.
  */
  bool SetViewScale( double x, double y );
  void GetViewScale( double* x, double* y ) const;

  /*
  Description:
    Gets the m_clip_mod transformation;
  Returns:
    value of the m_clip_mod transformation.
  */
  ON_Xform ClipModXform() const;

  /*
  Description:
    Gets the m_clip_mod_inverse transformation;
  Returns:
    value of the m_clip_mod_inverse transformation.
  */
  ON_Xform ClipModInverseXform() const;

  /*
  Returns:
    True if clip mod xform is identity.
  */
  bool ClipModXformIsIdentity() const;

  /*
  Description:
    Return a point on the central axis of the view frustum.
    This point is a good choice for a general purpose target point.
  Parameters:
    target_distance - [in]
      If target_distance > 0.0, then the distance from the returned
      point to the camera plane will be target_distance. Note that
      if the frustum is not symmetric, the distance from the
      returned point to the camera location will be larger than
      target_distanct.
      If target_distance == ON_UNSET_VALUE and the frustum
      is valid with near > 0.0, then 0.5*(near + far) will be used
      as the target_distance.
  Returns:
    A point on the frustum's central axis.  If the viewport or input
    is not valid, then ON_3dPoint::UnsetPoint is returned.
  */
  ON_3dPoint FrustumCenterPoint( double target_distance ) const;

  /*
  Returns:
    The current value of the target point.  This point does not play
    a role in the view projection calculations.  It can be used as a 
    fixed point when changing the camera so the visible regions of the
    before and after frustums both contain the region of interest.
  Remarks:
    The default constructor sets this point on ON_3dPoint::UnsetPoint.
    You must explicitly call one SetTargetPoint() functions to set
    the target point.
  */
  ON_3dPoint TargetPoint() const;

  /*
  Description:
    Set the target point.
  Parameters:
    target_point - [in]
      When in doubt, the point returned by FrustumCenterPoint(ON_UNSET_VALUE)
      is a good choice.
  Remarks:
    The default constructor sets this point on ON_3dPoint::UnsetPoint.
    You must explicitly call one SetTargetPoint() functions to set
    the target point.
  */
  bool SetTargetPoint( ON_3dPoint target_point );

  /*
  Description:
    Get the distance from the target point to the camera plane.
    Note that if the frustum is not symmetric, then this distance
    is shorter than the distance from the target to the camera location.
  Parameters:
    bUseFrustumCenterFallback - [in]
      If bUseFrustumCenterFallback is false and the target point is
      not valid, then ON_UNSET_VALUE is returned.
      If bUseFrustumCenterFallback is true and the frustum is valid
      and current target point is not valid or is behind the camera,
      then 0.5*(near + far) is returned.
  Returns:
    Shortest signed distance from camera plane to target point.
    If the target point is on the visible side of the camera,
    a positive value is returned.  ON_UNSET_VALUE is returned
    when the input of view is not valid.
  */
  double TargetDistance( bool bUseFrustumCenterFallback ) const;

  /*
  Description:    
    Get suggested values for setting the perspective minimum
    near distance and minimum near/far ratio.
  Parameters:      
    camera_location - [in]
    depth_buffer_bit_depth - [in]
      typically 32, 24, 16 or 8, but any positive value can be 
      passed in.
    min_near_dist - [out]
      Suggest value for passing to SetPerspectiveMinNearDist().     
    min_near_over_far - [out]
      Suggest value for passing to SetPerspectiveMinNearOverFar().     
  */
  static void GetPerspectiveClippingPlaneConstraints( 
        ON_3dPoint camera_location,
        unsigned int depth_buffer_bit_depth,
        double* min_near_dist,
        double* min_near_over_far
        );

  /*
  Description:
    Calculate the value to add to homogeneous "z" clipping coordinate
    that corresponds to moving the corresponding euclidean camera
    coordinate by relative_depth_bias*(far - near).
  Parameters:
    relative_depth_bias - [in]
      signed relative bias. 
      = 0: no bias, 
      > 0: bias towards frustum's near clipping plane
      < 0: bias towards frustum's far clipping plane
      When you have curves and points that are "on" shaded objects,
      values around 1/256 work well to move the wire objects
      in front of or behind shaded objects.
    clip_z [-in]
    clip_w [-in]
      clip_z and clip_w are the homogeneous "w" and "w" coordinates
      of a homogeneous clipping coordinate point.
  Returns:
    The clipping coordinate depth bias to add to the z-clipping
    coordinate that corresponds to adding cam_depth_bias
    to the z camera coordinate.
  Remarks:
    For perspective views, this bias is largest in the vicinity
    of the frustum's near clipping plane and smallest in the
    vicinity of the frustum's far clipping plane.
    For orthographic projectsions, this bias is constant.
  */
  double ClipCoordDepthBias(
    double relative_depth_bias,
    double clip_z, 
    double clip_w
    ) const;

  /*
  Description:
    Calculate a transformation to apply to clipping coordinates to
    bias their depth.

  Parameters:
    relative_depth_bias - [in]
      signed relative bias. 
      = 0: no bias, 
      > 0: bias towards frustum's near clipping plane
      < 0: bias towards frustum's far clipping plane
      When you have curves and points that are "on" shaded objects,
      values around 1/512 work well to move the wire objects
      in front of or behind shaded objects.

    clip_bias - [out]
      clip_bias = cam2clip * delta * clip2cam,
      where delta = 1 0 0 0 
                    0 1 0 0
                    0 0 1 D
                    0 0 0 1
      and D = relative_depth_bias*(far-near).

  Returns:
    True if the function worked.  False if the frustum settings
    are not valild, in which cate the identity matrix is returned.

  Remarks:
    The inverse of the transformations returned by 
    GetClipCoordDepthBiasXform(+r,...) is the transformation
    returned by GetClipCoordDepthBiasXform(-r,...).
  */
  bool GetClipCoordDepthBiasXform( 
    double relative_depth_bias,
    ON_Xform& clip_bias
    ) const;

  /*
  Description:
    Set suggested the perspective minimum near distance and
    minimum near/far ratio to the suggested values returned
    by GetPerspectiveClippingPlaneConstraints().
  Parameters:
    depth_buffer_bit_depth - [in]
      typically 32, 24, 16 or 8, but any positive value can be 
      passed in.
  */
  void SetPerspectiveClippingPlaneConstraints(
        unsigned int depth_buffer_bit_depth
        );

  /*
  Description:
    Expert user function to control the minimum
    ratio of near/far when perspective projections
    are begin used.
  Parameters:
    min_near_over_far - [in]
  Remarks:
    This is a runtime setting and is not saved in 3dm files.
  */
  void SetPerspectiveMinNearOverFar(double min_near_over_far);

  /*
  Description:
    Expert user function to get the minimum runtime
    value of near/far when perspective projections
    are begin used.
  Returns:
    The minimum permitted value of near/far when perspective 
    projections are begin used.
  Remarks:
    This is a runtime setting and is not saved in 3dm files.
  */
  double PerspectiveMinNearOverFar() const;

  /*
  Description:
    Expert user function to control the minimum
    value of near when perspective projections
    are begin used.
  Parameters:
    min_near_dist - [in]
  Remarks:
    This is a runtime setting and is not saved in 3dm files.
  */
  void SetPerspectiveMinNearDist(double min_near_dist);

  /*
  Description:
    Expert user function to get the minimum
    value of near when perspective projections
    are begin used.
  Returns:
    The minimum permitted value of near when perspective 
    projections are begin used.
  Remarks:
    This is a runtime setting and is not saved in 3dm files.
  */
  double PerspectiveMinNearDist() const;
  
  /*
  Description:
    Sets the viewport's id to the value used to 
    uniquely identify this viewport.
  Parameters:
    viewport_id - [in]    
  Returns:
    True if the viewport's id was successfully set
    and false otherwise (ie. the viewport uuid has
    already been set).
  Remarks:
    There is no approved way to change the viewport 
    id once it is set in order to maintain consistency
    across multiple viewports and those routines that 
    manage them.
  */
  bool  SetViewportId(const ON_UUID& viewport_id );

  ON_UUID ViewportId(void) const;

  /*
  Description:
    EXPERT USER function to change the viewport's id.
    If you change the id, you risk damaging display
    and visibility relationships in the model.
  Parameters:
    viewport_id - [in]    
  */
  void ChangeViewportId(const ON_UUID& viewport_id);
  
protected:

  // These boolean status flags are set to true when
  // the associated fields contain valid values.
  bool m_bValidCamera;
  bool m_bValidFrustum;
  bool m_bValidPort;
  unsigned char m_reserved1;

  // Camera Settings: ///////////////////////////////////////////////

  // perspective or parallel projection
  ON::view_projection m_projection;

  //   Camera location, direction and orientation (in world coordinates).
  //   These values are used to set the camera frame vectors CamX, CamY,
  //   CamZ.  If bValidCamera is true, then the CamX, CamY and CamZ
  //   vectors are properly initialized and should be used
  //   instead of CamDir[] and CamUp[].  The frame vectors CamX, CamY, CamZ
  //   are always a right handed orthonormal frame.  The CamDir
  //   and CamUp vectors contain the values passed to SetViewCamera().

  // If true and the camera is valid, then the corresponding camera
  // parameter will not be changed by view editing functions. This
  // permits user interface to easily preserve important camera
  // features without having to perform excessive calculations.
  bool m_bLockCamUp;
  bool m_bLockCamDir;
  bool m_bLockCamLoc;
  unsigned char m_frustum_symmetry_flags; // 0 != (flags & 1) top/bottom symmetry enforced
                                          // 0 != (flags & 2) left/right symmetry enforced.
  ON_3dPoint m_CamLoc;  // camera location
  ON_3dVector m_CamDir; // from camera towards view (nonzero and not parallel to m_CamUp)
  ON_3dVector m_CamUp;  // (nonzero and not parallel to m_CamDir)

  // The camera frame vectors are properly initialized by SetCamera()
  ON_3dVector m_CamX;
  ON_3dVector m_CamY;
  ON_3dVector m_CamZ;

  // View Frustum Settings: ///////////////////////////////////////
  //   left, right are camera X coords on near clipping plane
  //   bottom, top are camera Y coords on near clipping plane
  //   near = distance from camera to near clipping plane
  //   far = distance from camera to far clipping plane
  double m_frus_left,   m_frus_right; // frus_left < frus_right 
  double m_frus_bottom, m_frus_top;   // frus_bottom < frus_top 
  double m_frus_near,   m_frus_far;   // frus_near < frus_far 
                                      // in perspective, 0 < frus_near
  

  // Device View Port Box Settings: ( in display device coordinates ) ////
  //   The point (left,bottom,-near), in camera coordinates, of the view
  //   frustum is mapped to pixel coordinate (port_left,port_bottom,port_near).
  //   The point (right,top,-far), in camera coordinates, of the view frustum 
  //   is mapped to pixel coordinate (port_right,port_top,port_far).
  int m_port_left,   m_port_right; // port_left != port_right
  int m_port_bottom, m_port_top;   // port_bottom != port_top  
                                   // In many situations including Windows,
                                   // port_left = 0,
                                   // port_right = viewport width-1,
                                   // port_top = 0,
                                   // port_bottom = viewport height-1.
  int m_port_near,   m_port_far;   // (If you want an 8 bit z-buffer with 
                                   // z=255 being "in front of" z=0, then
                                   // set port_near = 255 and port_far = 0.)


  // The location of this point has no impact on the 
  // view projection. It is simply a suggestion for a 
  // fixed point when views are rotated or the isometric 
  // depth when perpsective views are dollied.  The default
  // is ON_UNSET_POINT.
  ON_3dPoint m_target_point;

private:
  // When this id matches the viewport id saved in an ON_DisplayMaterialRef
  // list in ON_3dmObjectAttributes, then the the display material is used
  // for that object in this view.
  ON_UUID m_viewport_id;

  bool SetCameraFrame(); // used to set m_CamX, m_CamY, m_CamZ

  // This transform is used to tweak the clipping 
  // coordinates.  The default is the identity.  
  // Modify this transformation when you need to do
  // things like z-buffer bias, non-uniform viewplane
  // scaling, and so on.

  /*
  Description:
    Sets the m_clip_mod transformation;
  Parameters:
    clip_mod_xform - [in] invertable transformation
  */
  bool SetClipModXform( ON_Xform clip_mod_xform );
  ON_Xform m_clip_mods;
  ON_Xform m_clip_mods_inverse;

  // Runtime values that depend on the graphics hardware being used.
  // These values are not saved in 3dm files.
  double m__MIN_NEAR_DIST;
  double m__MIN_NEAR_OVER_FAR;

public:
  static const double DefaultNearDist;        // 0.005
  static const double DefaultFarDist;         // 1000.0
  static const double DefaultMinNearDist;     // 0.0001
  static const double DefaultMinNearOverFar;  // 0.0001
};

ON_DECL
bool 
ON_GetViewportRotationAngles( 
    const ON_3dVector&, // X, // X,Y,Z must be a right handed orthonormal basis
    const ON_3dVector&, // Y, 
    const ON_3dVector&, // Z,
    double*, // angle1, // returns rotation about world Z
    double*, // angle2, // returns rotation about world X ( 0 <= a2 <= pi )
    double*  // angle3  // returns rotation about world Z
    );

ON_DECL
bool
ON_ViewportFromRhinoView( // create ON_Viewport from legacy Rhino projection info
        ON::view_projection, // projection,
        const ON_3dPoint&, // rhvp_target, // 3d point
        double, // rhvp_angle1 in radians
        double, // rhvp_angle2 in radians
        double, // rhvp_angle3 in radians
        double, // rhvp_viewsize,     // > 0
        double, // rhvp_cameradist,   // > 0
        int, // screen_width, 
        int, // screen_height,
        ON_Viewport&
        );

/*
Description:
  Calculate the corners of the polygon that is the
  intersection of a view frustum with and infinte plane.
Parameters:
  vp - [in] defines view frustum
  plane_equation - [in] defined infinte plane
  points  - [out] corners of the polygon.
    If true is returned and points.Count() is zero, then
    the plane missed the frustum.  Note that the start/end
    point is not duplicated in the list.
Returns:
  True if input was valid, false otherwise.  Note that
  even when true is returned, the returned points.Count()
  may be zero if the plane and frustum do not intersect.
*/
ON_DECL
bool
ON_IntersectViewFrustumPlane(
          const ON_Viewport& vp,
          const ON_PlaneEquation& plane_equation, 
          ON_SimpleArray<ON_3dPoint>& points 
          );

#endif

/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

////////////////////////////////////////////////////////////////
//
//   defines ON_TextureMapping
//
////////////////////////////////////////////////////////////////

#if !defined(OPENNURBS_TEXTURE_MAPPING_INC_)
#define OPENNURBS_TEXTURE_MAPPING_INC_

///////////////////////////////////////////////////////////////////////////////
//
// Class ON_TextureMapping
//
class ON_Line;
class ON_BrepFace;
class ON_3dPoint;

typedef int  ( *TEXMAP_INTERSECT_LINE_SURFACE )( const ON_Line*, const ON_BrepFace*, ON_SimpleArray<ON_X_EVENT>& );
typedef bool ( *TEXMAP_BREP_FACE_CLOSEST_POINT )( const ON_BrepFace*, const ON_3dPoint*, ON_3dPoint& );

class ON_CLASS ON_TextureMapping : public ON_Object
{
public:
	ON_OBJECT_DECLARE(ON_TextureMapping);

	ON_TextureMapping();
	~ON_TextureMapping();

	// The copy constructor and operator= overrides are needed
  // to ensure m_geometry is properly copied.
	ON_TextureMapping(const ON_TextureMapping& src);
	ON_TextureMapping& operator=(const ON_TextureMapping& src);

  // overrides virtual ON_Object::IsValid
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  // overrides virtual ON_Object::Dump
  void Dump( ON_TextLog& ) const;

  // overrides virtual ON_Object::SizeOf
  unsigned int SizeOf() const;

  // overrides virtual ON_Object::Write
  ON_BOOL32 Write(
         ON_BinaryArchive& binary_archive
       ) const;

  // overrides virtual ON_Object::Read
  ON_BOOL32 Read(
         ON_BinaryArchive& binary_archive
       );

  void Default();

  virtual
  ON_UUID ModelObjectId() const;

	/*
	Determines whether the mapping, as currently set up, requires vertex normals to be present on the
	mesh in order to evaluate the mapping correctly.
		*/
	bool RequiresVertexNormals() const;
	bool IsPeriodic(void) const;

  /*
  Description:
	  Create a mapping that will convert surface parameters into 
    normalized (0,1)x(0,1) texture coordinates.
	*/
	bool SetSurfaceParameterMapping(void);

  /*
  Description:
    Create a planar projection texture mapping.
  Parameters:
    plane - [in]
    dx - [in]  portion of the plane's x axis that is mapped to [0,1]
               (can be a decreasing interval)               
    dy - [in]  portion of the plane's x axis that is mapped to [0,1]
               (can be a decreasing interval)               
    dz - [in]  portion of the plane's x axis that is mapped to [0,1]
               (can be a decreasing interval)       
    projection_method - [in] 
        1: Closest point mapping.
          A target point P is mapped to the point on the plane
          that is closest to P.  The target normal is ignored.
        2: Target line mapping.  A target point-vector pair
          (P, N), are mapped to the point on the plane
          where the line through P, parallel to N, intersects
          the plane.  If the line is parallel to the plane,
          the closest point mapping is used.
  Example:
    Create a mapping that maps the world axis aligned rectangle in
    the world yz plane with corners at (0,3,5) and (0,7,19) to the
    texture coordinate unit square.

          ON_3dVector plane_xaxis(0.0,1.0,0.0);
          ON_3dVector plane_yaxis(0.0,0,0,1.0);
          ON_3dPoint plane_origin(0.0,2.0,4.0);
          ON_Plane plane(plane_origin,plane_xaxis,plane_yaxis);
          ON_Interval dx( 0.0, 7.0 - 3.0);
          ON_Interval dy( 0.0, 19.0 - 5.0);
          ON_Interval dz( 0.0, 1.0 );
          ON_TextureMapping mapping;
          mapping.CreatePlaneMapping(plane,dx,dy,dz);

  Returns:
    True if input is valid.
  */
  bool SetPlaneMapping(
            const ON_Plane& plane,
            const ON_Interval& dx,
            const ON_Interval& dy,
            const ON_Interval& dz
            );

  /*
  Description:
    Create a cylindrical projection texture mapping.
  Parameters:
    cylinder - [in]  
        cylinder in world space used to define a cylindrical
        coordinate system.  The angular parameter maps (0,2pi)
        to texture "u" (0,1), The height parameter maps 
        (height[0],height[1]) to texture "v" (0,1), and 
        the radial parameter maps (0,r) to texture "w" (0,1).
    bIsCapped - [in]
        If true, the cylinder is treated as a finite
        capped cylinder.          
  Returns:
    True if input is valid.
  Remarks:
    When the cylinder is capped and m_texture_space = divided, 
    the cylinder is mapped to texture space as follows:
      The side is mapped to 0 <= "u" <= 2/3.
      The bottom is mapped to 2/3 <= "u" <= 5/6.
      The top is mapped to 5/6 <= "u" <= 5/6.
    This is the same convention box mapping uses.
  */
	bool SetCylinderMapping( 
		 const ON_Cylinder& cylinder,
		 bool bIsCapped
	);

  /*
  Description:
    Create a spherical projection texture mapping.
  Parameters:
    sphere - [in]  
        sphere in world space used to define a spherical
        coordinate system. The longitude parameter maps
        (0,2pi) to texture "u" (0,1).  The latitude paramter
        maps (-pi/2,+pi/2) to texture "v" (0,1).
        The radial parameter maps (0,r) to texture "w" (0,1).
  Returns:
    True if input is valid.
  */
	bool SetSphereMapping( 
		 const ON_Sphere& sphere
	);

  /*
  Description:
    Create a box projection texture mapping.
  Parameters:
    plane - [in]  
        The sides of the box the box are parallel to the 
        plane's coordinate planes.  The dx, dy, dz intervals
        determine the location of the sides.
    dx - [in]
       Determines the location of the front and back planes.
       The vector plane.xaxis is perpendicular to these planes
       and they pass through plane.PointAt(dx[0],0,0) and
       plane.PointAt(dx[1],0,0), respectivly.
    dy - [in]
       Determines the location of the left and right planes.
       The vector plane.yaxis is perpendicular to these planes
       and they pass through plane.PointAt(0,dy[0],0) and
       plane.PointAt(0,dy[1],0), respectivly.
    dz - [in] 
       Determines the location of the top and bottom planes.
       The vector plane.zaxis is perpendicular to these planes
       and they pass through plane.PointAt(0,0,dz[0]) and
       plane.PointAt(0,0,dz[1]), respectivly.
    bIsCapped - [in]
        If true, the box is treated as a finite
        capped box.          
  Returns:
    True if input is valid.
  Remarks:
    When m_texture_space = divided, the box is mapped to texture 
    space as follows:

    If the box is not capped, then each side maps to 1/4 of the texture map.

          v=1+---------+---------+---------+---------+
             | x=dx[1] | y=dy[1] | x=dx[0] | y=dy[0] |
             | Front   | Right   | Back    | Left    |
             | --y->   | <-x--   | <-y--   | --x->   |
          v=0+---------+---------+---------+---------+
            0/4 <=u<= 1/4 <=u<= 2/4 <=u<= 3/4 <=u<= 4/4

    If the box is capped, then each side and cap gets 1/6 of the texture map.

          v=1+---------+---------+---------+---------+---------+---------+
             | x=dx[1] | y=dy[1] | x=dx[0] | y=dy[0] | z=dx[1] | z=dz[0] |
             | Front   | Right   | Back    | Left    | Top     |  Bottom |
             | --y->   | <-x--   | <-y--   | --x->   | --x->   | --x->   |
          v=0+---------+---------+---------+---------+---------+---------+
            0/6 <=u<= 1/6 <=u<= 2/6 <=u<= 3/6 <=u<= 4/6 <=u<= 5/6 <=u<= 6/6 
  */
	bool SetBoxMapping( 
		 const ON_Plane& plane,
		 ON_Interval dx,
		 ON_Interval dy,
		 ON_Interval dz,
     bool bIsCapped
	);

	/*
  Description:
    Get plane mapping parameters from this texture mapping.
  Parameters:
    plane - [out]
    dx - [out]
      Portion of the plane's x axis that is mapped to [0,1]
    dy - [out]
      Portion of the plane's y axis that is mapped to [0,1]
    dz - [out]
      Portion of the plane's z axis that is mapped to [0,1]
  Returns:
	  True if valid plane mapping parameters were returned.
  Remarks:
    NOTE WELL:
      Generally, GetMappingPlane will not return the same
      parameters passed to SetPlaneMapping.  However, the
      location of the plane will be the same.
	*/
	bool GetMappingPlane(
		 ON_Plane& plane,
		 ON_Interval& dx,
		 ON_Interval& dy,
		 ON_Interval& dz
	   ) const;

	/*
  Description:
	  Get a cylindrical projection parameters from this texture mapping.
	Parameters:
	  cylinder - [out]  
  Returns:
	  True if a valid cylinder is returned.
  Remarks:
    Generally, GetMappingCylinder will not return the same
    parameters passed to SetCylinderMapping.  However, the
    location of the cylinder will be the same.  
    If this mapping is not cylindrical, the cylinder will
    approximate the actual mapping primitive.
	*/
	bool GetMappingCylinder( 
		 ON_Cylinder& cylinder
	) const;

	/*
  Description:
	  Get a spherical projection parameters from this texture mapping.
	Parameters:
	  sphere - [out]  
  Returns:
	  True if a valid sphere is returned.
  Remarks:
    Generally, GetMappingShere will not return the same
    parameters passed to SetSphereMapping.  However, the
    location of the sphere will be the same.
    If this mapping is not cylindrical, the cylinder will
    approximate the actual mapping primitive.
	*/
	bool GetMappingSphere( 
		 ON_Sphere& sphere
	) const;

	/*
	Get a box projection from the texture mapping.
	Parameters:
	plane - [out]  
		The center of the box is at plane.origin and the sides
		of the box are parallel to the plane's coordinate planes.
	dx - [out]
	   The "front" and "back" sides of the box are in spanned
	   by the vectors plane.yaxis and plane.zaxis.  The back
	   plane contains the point plane.PointAt(dx[0],0,0) and
	   the front plane contains the point plane.PointAt(dx[1],0,0).
	dy - [out]
	   The "left" and "right" sides of the box are in spanned
	   by the vectors plane.zaxis and plane.xaxis.  The left
	   plane contains the point plane.PointAt(0,dx[0],0) and
	   the back plane contains the point plane.PointAt(0,dy[1],0).
	dz - [out] 
	   The "top" and "bottom" sides of the box are in spanned
	   by the vectors plane.xaxis and plane.yaxis.  The bottom
	   plane contains the point plane.PointAt(0,0,dz[0]) and
	   the top plane contains the point plane.PointAt(0,0,dz[1]).
  Returns:
	  True if a valid box is returned.
  Remarks:
    Generally, GetMappingBox will not return the same
    parameters passed to SetBoxMapping.  However, the
    location of the box will be the same.
	*/
	bool GetMappingBox( 
		 ON_Plane& plane,
		 ON_Interval& dx,
		 ON_Interval& dy,
		 ON_Interval& dz
	) const;


  /*
  Description:
    Reverses the texture in the specified direction.
  Parameters:
    dir - [in] 0 = reverse "u", 1 = reverse "v", 2 = reverse "w".
  Remarks:
    Modies m_uvw so that the spedified direction transforms
    the texture coordinate t to 1-t.
  Returns:
    True if input is valid.
  */
  bool ReverseTextureCoordinate( int dir );

  /*
  Description:
    Swaps the specified texture coordinates.
  Parameters:
    i - [in]
    j - [in]
  Remarks:
    Modifies m_uvw so that the specified texture coordinates are swapped.
  Returns:
    True if input is valid.
  */
  bool SwapTextureCoordinate( int i, int j );

  /*
  Description:
    Tiles the specified texture coordinates.
  Parameters:
    dir - [in] 0 =  "u", 1 = "v", 2 = "w".
    count - [in] number of tiles
    offset - [in] offset of the tile
  Remarks:
    Modies m_uvw so that the specified texture coordinate is
    tiled.
  Returns:
    True if input is valid.
  */
  bool TileTextureCoordinate( int dir, double count, double offset );

  /*
  Description:
    Evaluate the mapping to get a texture coordinate.
  Parameters:
    P - [in] Vertex location
    N - [in] If the mapping projection is ray_projection,
             then this is the vertex unit normal.  Otherwise
             N is ignored.
    T - [out] Texture coordinate (u,v,w)

    P_xform -[in] 
      Transformation to be applied to P before performing
      the mapping calculation.
    N_xform - [in] 
      Transformation to be applied to N before performing
      the mapping calculation.  One way to calculate N_xform
      is to use the call P_xform::GetVectorTransform(N_xform).

  Returns:
    Nonzero if evaluation is successful.  When the mapping
    is a box or capped cylinder mapping, the value indicates 
    which side was evaluated.

      Cylinder mapping:
        1 = cylinder wall, 2 = bottom cap, 3 = top cap
      Box mapping:
        1 = front
        2 = right
        3 = back
        4 = left
        5 = bottom
        6 = top        

  See Also:
    ON_TextureMapping::GetTextureCoordinates
    ON_Mesh::SetTextureCoordinates
  */
  virtual
  int Evaluate( 
    const ON_3dPoint& P,
    const ON_3dVector& N,
    ON_3dPoint* T
    ) const;

  virtual
  int Evaluate( 
    const ON_3dPoint& P,
    const ON_3dVector& N,
    ON_3dPoint* T,
	  const ON_Xform& P_xform,
    const ON_Xform& N_xform
    ) const;

  int EvaluatePlaneMapping( 
    const ON_3dPoint& P,
    const ON_3dVector& N,
    ON_3dPoint* T
    ) const;

  int EvaluateSphereMapping( 
    const ON_3dPoint& P,
    const ON_3dVector& N,
    ON_3dPoint* T
    ) const;

  int EvaluateCylinderMapping( 
    const ON_3dPoint& P,
    const ON_3dVector& N,
    ON_3dPoint* T
    ) const;

  int EvaluateBoxMapping( 
    const ON_3dPoint& P,
    const ON_3dVector& N,
    ON_3dPoint* T
    ) const;

  /*
  Description:
    Quickly check to see if a mesh or tag has texture coordinates
    set by this mapping.
  Parameters:
    mesh - [in]
    tag - [in]
    object_xform - [in] (optional)
      If this transform is not NULL, then true will be
      returned only if the mapping function is the same and
      the tag's m_mesh_xform field is the same as mesh_xform.
      This parameter is typically NULL or the value of 
      ON_MappingRef::m_object_xform.
  Returns:
    True if the meshes texture coordinates were set by this
    mapping.
  */
  bool HasMatchingTextureCoordinates( 
         const ON_Mesh& mesh,
         const ON_Xform* object_xform = 0
         ) const; 
  bool HasMatchingTextureCoordinates( 
         const class ON_MappingTag& tag,
         const ON_Xform* object_xform = 0
         ) const; 

  /*
  Description:
    Get texture coordinates.  This calculation is
    expensive.  When possible, use a MappingMatch()
    query to avoid unnecessary calculations.
  Parameters:
    mesh - [in]
    T - [out] Texture coordinates returned here.
    mesh_xform - [in] (optional)
      If the mesh has been transformed since the texture mapping was set 
      up, pass the transformation here.  Typically this is the value
      of ON_Mesh::m_mapping_xform or ON_MappingRef::m_object_xform
    bLazy - [in]
      If true and the mesh.m_T[] values were calculated using
      this mapping, they are simply copied to the T[] array
      and no calculations are performed.  If you are calling
      the 3d point version and you care about the z-coordinate,
      then do not use the lazy option (meshes only store
      2d texture coordinates).
    Tside - [out]
      In the case of divided textures, side information is returned
      here if a lazy mapping is not done.  Otherwise Tside->Count()
      will be zero.
      Cylinder mapping:
        1 = cylinder wall, 2 = bottom cap, 3 = top cap
      Box mapping:
        1 = front
        2 = right
        3 = back
        4 = left
        5 = bottom
        6 = top        
  Example:
    
          ON_TextureMapping mapping = ...;
          const ON_Mesh* mesh = ...;
          bool bLazy = true;
          ON_SimpleArray<ON_3dPoint> T(mesh->VertexCount());
          T.SetCount(mesh->m_VertexCount());
          if ( !mapping.GetTextureCoordinates(mesh,3,3,&T[0].x,bLazy) )
            T.SetCount(0).

  Returns:
    True if successful.
  */
  bool GetTextureCoordinates( 
    const ON_Mesh& mesh, 
    ON_SimpleArray<ON_3fPoint>& T,
		const ON_Xform* mesh_xform = 0,
    bool bLazy = false,
    ON_SimpleArray<int>* Tside = 0
    ) const;

  bool GetTextureCoordinates( 
    const ON_Mesh& mesh, 
    ON_SimpleArray<ON_2fPoint>& T,
		const ON_Xform* mesh_xform = 0,
    bool bLazy = false,
    ON_SimpleArray<int>* Tside = 0
    ) const;

public:
  // The only reliable and persistent way to reference texture 
  // mappings is by the mapping_id.  If the mapping id is
  // set to m_srfp_mapping_id, then all other mapping settings
  // are ignored.
  ON_UUID m_mapping_id;

  // Runtime texture mapping table index. 
  // This value is NOT SAVED IN 3DM FILES.
  // This value is constant for each runtime instance of Rhino,
  // but can change each time a model is loaded or saved.  
  // Once a texture mapping is in the CRhinoDoc material table,
  // its id and index never change in that instance of Rhino.
  int m_mapping_index;

  // The texture mapping name is for UI and user comfort. 
  // Duplicates are permitted.
  ON_wString m_mapping_name;

  //////////////////////////////////////////////////////////
  //
  // Mapping types:
  //
  //   You can either calculate texture coordinates based on
  //   the parameterization of the surface used to create a mesh,
  //   or project the natural parameterization from a mapping
  //   primitive, like a plane, sphere, box, or cylinder.
  //
	// Do not change TYPE enum values - they are saved in 3dm files.
  //
  enum TYPE
  {
    no_mapping       = 0,

    srfp_mapping     = 1, // u,v = linear transform of surface params,w = 0
    plane_mapping    = 2, // u,v,w = 3d coordinates wrt frame
    cylinder_mapping = 3, // u,v,w = logitude, height, radius
    sphere_mapping   = 4, // (u,v,w) = longitude,latitude,radius
    box_mapping      = 5,
    mesh_mapping_primitive = 6, // m_mapping_primitive is an ON_Mesh 
    srf_mapping_primitive  = 7, // m_mapping_primitive is an ON_Surface
    brep_mapping_primitive = 8, // m_mapping_primitive is an ON_Brep

    force_32bit_mapping_type = 0xFFFFFFFF
  };

	TYPE m_type;

  //////////////////////////////////////////////////////////
  //
  // Projection:
  //
  //   When a mapping primitive, like a plane, sphere, box,
  //   or cylinder, is used, there are two projection options.
  //
  //  clspt_projection: world xyz maps to the point on the 
  //                    mapping primitive that is closest to xyz.
  //                    In this case, ON_TextureMapping::Evaluate
  //                    ignores the vector argument.
  //
  //  ray_projection:   world xyz + world vector defines a world line.
  //                    The world line is intersected with the mapping 
  //                    primitive and the intersection point that is
  //                    closest to the world xyz point is used to
  //                    calculate the mapping parameters.
  //
  //  The value of m_projection can be changed as needed.
  //
  //  If m_type = srfp_mapping, then m_projection is ignored.
  //
  enum PROJECTION
  {
    no_projection    = 0,
    clspt_projection = 1,
    ray_projection   = 2,
    force_32bit_mapping_projection = 0xFFFFFFFF
  };

  PROJECTION m_projection;

  //////////////////////////////////////////////////////////
  //
  // Texture space
  //
  //   When a mapping primitive is a box or a capped cylinder,
  //   there are two options for the mapping.  Either the sides
  //   all map to (0,1)x(0,1) (so the either texture map appears 
  //   on each side, or the sides map to distinct regions of the
  //   texture space.  
  //   
  enum TEXTURE_SPACE
  {
    single  = 0, // sides and caps map to same texture space
    divided = 1, // sides and caps map to distinct vertical
                 // regions of texture space.
                 // (0, 1/4, 2/4, 3/4, 1) for uncapped boxes.
                 // (0, 1/6, 2/6, 3/6, 4/6, 5/6, 1) for capped boxes.
                 // (0, 4/6, 5/6, 1) for capped cylinders.
    force_32bit_texture_space = 0xFFFFFFFF
  };
  
  TEXTURE_SPACE m_texture_space;

  // The m_bCapped applies to planar, cylinder and box mappings.
  // If m_bCapped is false, the cylinder or box is "infinite", if m_bCapped is true, they are finite.
  // In planar mappings, m_bCapped=false means "the Z texture coordinate will always be 0.0"
  // this is now the default behaviour in Rhino 5.0 - it's what users expect apparently.
  bool m_bCapped;

  //////////////////////////////////////////////////////////
  //
  // For primitive based mappings, these transformations are
  // used to map the world coordinate (x,y,z) point P and 
  // surface normal N before it is projected to the normalized 
  // mapping primitive. The surface normal transformation,
  // m_Nxyz, is always calculated from m_Pxyz.  It is a 
  // runtime setting that is not saved in 3dm files. 
  // If m_type is srfp_mapping, then m_Pxyz and m_Nxyz are
  // ignored.
  ON_Xform m_Pxyz;
  ON_Xform m_Nxyz;

  // Transform applied to mapping coordinate (u,v,w) to 
  // convert it into a texture coordinate.
  ON_Xform m_uvw;

  // Custom mapping primitive.
  ON_Object* m_mapping_primitive;

  static TYPE TypeFromInt( int i );
  static PROJECTION ProjectionFromInt( int i );
  static TEXTURE_SPACE TextureSpaceFromInt( int i);

  ON__UINT32 MappingCRC() const;
};

#if defined(ON_DLL_TEMPLATE)
// This stuff is here because of a limitation in the way Microsoft
// handles templates and DLLs.  See Microsoft's knowledge base 
// article ID Q168958 for details.
#pragma warning( push )
#pragma warning( disable : 4231 )
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ON_TextureMapping>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ObjectArray<ON_TextureMapping>;
#pragma warning( pop )
#endif


#endif

/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

////////////////////////////////////////////////////////////////
//
//   defines ON_Color and ON_Material
//
////////////////////////////////////////////////////////////////

#if !defined(OPENNURBS_TEXTURE_INC_)
#define OPENNURBS_TEXTURE_INC_

///////////////////////////////////////////////////////////////////////////////
//
// Class ON_Texture
// 

class ON_CLASS ON_Texture : public ON_Object
{
public:
  ON_OBJECT_DECLARE(ON_Texture);

  ON_Texture();
  ~ON_Texture();

  // default copy constructor and operator= work fine


  // overrides virtual ON_Object::IsValid
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  // overrides virtual ON_Object::Dump
  void Dump( ON_TextLog& ) const;

  // overrides virtual ON_Object::SizeOf
  unsigned int SizeOf() const;

  // overrides virtual ON_Object::Write
  ON_BOOL32 Write(
         ON_BinaryArchive& binary_archive
       ) const;

  // overrides virtual ON_Object::Read
  ON_BOOL32 Read(
         ON_BinaryArchive& binary_archive
       );

  void Default();

  int Compare( const ON_Texture& other ) const; 

  /*
  Description:
    Reverses the texture in the specified direction.
  Parameters:
    dir - [in] 0 = reverse "u", 1 = reverse "v", 2 = reverse "w".
  Remarks:
    Modifes m_uvw so that the spedified direction transforms
    the texture coordinate t to 1-t.
  Returns:
    True if input is valid.
  */
  bool ReverseTextureCoordinate( int dir );

  /*
  Description:
    Swaps the specified texture coordinates.
  Parameters:
    i - [in]
    j - [in]  (0 <= i, j <= 3 and i != j)
  Remarks:
    Modifes m_uvw so that the specified texture coordinates are swapped.
  Returns:
    True if input is valid.
  */
  bool SwapTextureCoordinate( int i, int j );

  /*
  Description:
    Tiles the specified texture coordinates.
  Parameters:
    dir - [in] 0 = reverse "u", 1 = reverse "v", 2 = reverse "w".
    count - [in] number of tiles (can be negative)
    offset - [in] offset of the tile (can be any number)
  Remarks:
    Modifes m_uvw so that the specified texture coordinate is
    tiled.
  Returns:
    True if input is valid.
  */
  bool TileTextureCoordinate( int dir, double count, double offset );

  /*
  Description:
    Examines the m_uvw matrix and harvests tiling constants.
  Parameters:
    dir - [in] 0 = reverse "u", 1 = reverse "v", 2 = reverse "w".
    count - [out] number of tiles
    offset - [out] offset of the tile
  Returns:
    True if if the m_uvw matrix had entries that were compatible
    with tiling.
  */
  bool IsTiled( int dir, double* count, double* offset ) const;


  ON_UUID m_texture_id;

  // list of pre-defined channel ids
  enum MAPPING_CHANNEL
  {
    tc_channel      = 0,     // Use the texture coordinate values
                             // currently on the geometric object.
    default_channel = 1,	   // Use either default mapping, or the "Custom"
							               // mapping applied to the object
    srfp_channel = 0xFFFFFFFE, // Use surface parameterization.
    emap_channel = 0xFFFFFFFF  // Environment map the geometric object.
  };

  // If the m_mapping_channel_id value is one of the built-in 
  // mappings listed in the MAPPING_CHANNEL enum, then that 
  // mapping is used.  Otherwise, if an object has rendering
  // attributes with an ON_MappingChannel entry that has a 
  // matching m_mapping_channel_id value, then the mapping 
  // identified by ON_MappingChannel::m_mapping_id is used.
  // A value of zero means no mapping is supplied
  // and the texture coordinates on the mesh are
  // used.
  int m_mapping_channel_id;

  // Bitmap filename  
  //   During runtime, m_filename is the absolute path to the
  //   file in use.  If m_filename_bRelativePath is true, then
  //   the value saved in the 3dm archive will be a relative path.
  //   When m_filename_bRelativePath is true, user interface
  //   should display a relative path.
  ON_wString m_filename;
  bool m_filename_bRelativePath;

  // If false, texture is off and should be ignored.
  // The intended use is to allow people to turn textures
  // on and off without have to create/destroy or change 
  // other texture settings.
  bool m_bOn;

  // do not change TYPE enum values - they are saved in 3dm files.
  // The "TYPE" setting controls how the pixels in the bitmap
  // are interpreted.
  enum TYPE
  {
    no_texture_type = 0,

    bitmap_texture       = 1, // "standard" image texture.
    bump_texture         = 2, // bump map - see m_bump_scale comment
    transparency_texture = 3, // value = alpha (see m_tranparancy_id)

    // OBSOLETE - set m_mapping_channel_id = ON_MappingChannel::emap_mapping
    emap_texture = 86, // spherical environment mapping.

    force_32bit_texture_type = 0xFFFFFFFF
  };

  TYPE m_type;

  // m_mode determines how the texture is
  // do not change MODE enum values - they are saved in 3dm files.
  enum MODE
  {
    no_texture_mode  = 0,
    modulate_texture = 1,  // modulate with material diffuse color
    decal_texture    = 2,  // decal
    blend_texture    = 3,  // blend texture with others in the material
                           // To "add" a texture, set m_blend_amount = +1
                           // To "subtract" a texture, set m_blend_amount = -1

    force_32bit_texture_mode = 0xFFFFFFFF
  };

  MODE m_mode;

  enum FILTER
  {
    nearest_filter = 0, // nearest texture pixel is used
    linear_filter  = 1, // weighted average of corresponding texture pixels

    force_32bit_texture_filter = 0xFFFFFFFF
  };
  
  // The value of m_minfilter determines how the color
  // of the image pixel is calculated when the image pixel
  // corresponds to multiple texture bitmap pixels.
  FILTER m_minfilter;  

  // The magfilter setting controls how the color
  // of the image pixel is calculated when the image pixel
  // corresponds to a fraction of a texture bitmap pixel.
  FILTER m_magfilter;

  enum WRAP
  {
    repeat_wrap      = 0,
    clamp_wrap       = 1,

    force_32bit_texture_wrap = 0xFFFFFFFF
  };

  WRAP m_wrapu;
  WRAP m_wrapv;
  WRAP m_wrapw;

  // Texture coordinate transformation.
  bool m_bApply_uvw; // true if m_uvw is active.
  ON_Xform m_uvw;

  // If ON_UNSET_COLOR != m_border_color, then this color
  // is used when the texture coordinates are <=0 or >=1
  // and the m_wrap* value is clamp_wrap.
  ON_Color m_border_color;

  // This field is used for textures with type
  // bitmap_texture that reference bitmap files that do
  // not have an alpha channel and is used to set
  // runtime alpha values.  It needs to be parsed when the
  // texture is loaded and can be ignored at runtime.
  // 
  // If ON_UNSET_COLOR != m_transparent_color, then 
  // a pixel in the bitmap file with a matching RGB
  // value is assigned the alpha value (ON_Color::Alpha)
  // in m_transparent_color. The intended use is 
  // for non-rectangular decals defined by RGB bitmaps in
  // files that don't save an alpha channel.
  //
  // For example if the decal is a red number 7 with a 
  // white background, then you would set m_transparent_color's
  // RGB to white and its A to zero.
  ON_Color m_transparent_color;

  // This field is used for textures with type
  // bitmap_texture that reference bitmap files that do
  // not have an alpha channel and is used to set
  // runtime alpha values.  It needs to be parsed when the
  // texture is loaded and can be ignored at runtime.
  // 
  // If m_transparency_id is not nil, it is the id of another
  // texture in the ON_Material.m_textures[] array that has
  // type m_transparency_texture.  The runtime bitmap_texture's
  // alpha is set to (255-max(R,G,B)) (the "value" in the hue,
  // saturation,value sense) of the correspondeing 
  // transparency_texture pixel. 
  //
  // For example, if you had a bitmap texuture that was green 
  // with purple dots saved in a RGB .bmp file and you wanted
  // the purple dots to be semi-transparent, you could create
  // another bitmap that was black, where the original was green,
  // and gray, where the original was purple, have an 
  // transparency_texture reference the white/gray bitmap,
  // and have the bitmap_texture's m_transparency_id 
  // reference the transparency map.
  ON_UUID m_transparency_texture_id;

  // If the m_type is bump_texture, the height of the
  // bump is m_bump_scale.ParameterAt(value), where
  // value is in the HSV sense and normalized 
  // (black=0, white=1).  The interval can be 
  // decreasing.
  ON_Interval m_bump_scale;

  // If the m_mode is blend_texture, then m_blend_A[]
  // and m_blend_RGB[] determine the blending function.
  //  new alpha  = m_blend_constant_A 
  //             + m_blend_A[0]*(current alpha)
  //             + m_blend_A[1]*(texture alpha)
  //             + m_blend_A[2]*min(current alpha,texture alpha)
  //             + m_blend_A[3]*max(current alpha,texture alpha)
  //  new rgb    = m_blend_constant_RGB 
  //             + m_blend_RGB[0]*(current RGB)
  //             + m_blend_RGB[1]*(texture RGB)
  //             + m_blend_RGB[2]*min(current RGB,texture RGB)
  //             + m_blend_RGB[3]*max(current RGB,texture RGB)
  // Results are clamped to handle underflow or overflow.
  double m_blend_constant_A;
  double m_blend_A[4];
  ON_Color m_blend_constant_RGB;
  double m_blend_RGB[4];

  // If an ON_Material m_textures[] array has more than
  // one texture, the textures are blended, and the textures
  // have different m_blend_order values, the the texture 
  // with the smaller m_blend_order is first. 
  int m_blend_order;

  // Applications use the m_runtime_ptr_id and m_runtime_ptr fields
  // to cached runtime bitmaps. If either the id or the pointer
  // are non-zero, then you cannot use them.  If you hang something
  // on the pointer, then set the id to something unique to
  // prevent others from messing with it.
  ON_UUID m_runtime_ptr_id;
  const void* m_runtime_ptr;

  static TYPE   TypeFromInt( int i );
  static MODE   ModeFromInt( int i );
  static FILTER FilterFromInt( int i );
  static WRAP   WrapFromInt( int i );
};

#if defined(ON_DLL_TEMPLATE)
// This stuff is here because of a limitation in the way Microsoft
// handles templates and DLLs.  See Microsoft's knowledge base 
// article ID Q168958 for details.
#pragma warning( push )
#pragma warning( disable : 4231 )
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ON_Texture>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ObjectArray<ON_Texture>;
#pragma warning( pop )
#endif

#endif

/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_MATERIAL_INC_)
#define OPENNURBS_MATERIAL_INC_


///////////////////////////////////////////////////////////////////////////////
//
// Class ON_Material
// 
class ON_CLASS ON_Material : public ON_Object
{
  ON_OBJECT_DECLARE(ON_Material);

public:
  static double MaxShine();			// maximum value of shine exponent

  ON_Material();					// Default grey color
  ~ON_Material();					// destructor
  // C++ default copy construction and operator= work fine.

  bool operator==(const ON_Material&) const; // ignores m_material_index
  bool operator!=(const ON_Material&) const; // ignores m_material_index

  void Default();

  /////////////////////////////////////////////////////////////////
  // ON_Object overrides

  /*
  Description:
    Tests an object to see if its data members are correctly
    initialized.
  Parameters:
    text_log - [in] if the object is not valid and text_log
        is not NULL, then a brief englis description of the
        reason the object is not valid is appened to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     object is valid
    false    object is invalid, uninitialized, etc.
  Remarks:
    Overrides virtual ON_Object::IsValid
  */
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  void Dump( ON_TextLog& ) const; // for debugging

  ON_BOOL32 Write(
         ON_BinaryArchive&  // open binary file
       ) const;

  ON_BOOL32 Read(
         ON_BinaryArchive&  // open binary file
       );

  ON::object_type ObjectType() const;

  // virtual
  ON_UUID ModelObjectId() const;


  /////////////////////////////////////////////////////////////////
  // Interface

  // ignores m_material_index
  int Compare( const ON_Material& other ) const; 

  // OBSOLETE - use m_ambient
  ON_Color Ambient() const;
  // OBSOLETE - use m_diffuse
  ON_Color Diffuse() const;
  // OBSOLETE - use m_emission
  ON_Color Emission() const;
  // OBSOLETE - use m_specular
  ON_Color Specular() const;

  // OBSOLETE - use m_ambient
  void SetAmbient(  ON_Color );
  // OBSOLETE - use m_diffuse
  void SetDiffuse(  ON_Color );
  // OBSOLETE - use m_emission
  void SetEmission( ON_Color );
  // OBSOLETE - use m_specular
  void SetSpecular( ON_Color );

  // Shine values are in range 0.0 to ON_Material::MaxShine()
  double Shine() const;
  void SetShine( double );         // 0 to ON_Material::MaxShine()

  // Transparency values are in range 0.0 = opaque to 1.0 = transparent
  double Transparency() const;
  void SetTransparency( double );  // 0.0 = opaque, 1.0 = transparent

  // OBSOLETE - use m_material_index
  int MaterialIndex() const;
  // OBSOLETE - use m_material_index
  void SetMaterialIndex( int );

  // OBSOLETE - just use m_plugin_id
  ON_UUID MaterialPlugInUuid() const;

  // OBSOLETE - just use m_plugin_id
  void SetMaterialPlugInUuid( ON_UUID );

  // OBSOLETE - just use m_material_name
  const wchar_t* MaterialName() const;

  // OBSOLETE - just use m_material_name
  void SetMaterialName( const wchar_t* );

  // The only reliable and persistent way to reference 
  // materials is by the material_id.
  ON_UUID m_material_id;

  // Runtime material table index. This value is constant
  // for each runtim instance of Rhino, but can change
  // each time a model is loaded or saved.  Once a material
  // is in the CRhinoDoc material table, its id and index
  // never change in that instance of Rhino.
  int m_material_index;

  // 
  ON_wString m_material_name;  // For user comfort - duplicates permitted
  
  ON_wString m_flamingo_library; // Legacy information from V3.
                                 // Will vanish in V5.

  ON_Color   m_ambient;
  ON_Color   m_diffuse;
  ON_Color   m_emission;
  ON_Color   m_specular;
  ON_Color   m_reflection;
  ON_Color   m_transparent;
  double     m_index_of_refraction; // generally >= 1.0 (speed of light in vacum)/(speed of light in material)
  double     m_reflectivity; // 0.0 = none, 1.0 = 100%
  double     m_shine;        // 0.0 = none to GetMaxShine()=maximum
  double     m_transparency; // 0.0 = opaque to 1.0 = transparent (1.0-alpha)

  bool m_bShared; // default = false.
  // True means this material can be shared.  When an
  // object that uses this material is copied,
  // the new object will share the material.
  // False means this material is not shared.
  // When an object that uses this material is
  // duplicated.

  bool m_bDisableLighting; // default = false.
  // True means render this object without
  // applying any modulation based on lights.
  // Basically, the diffuse, ambient, specular and
  // emissive channels get combined additively, clamped,
  // and then get treated as an emissive channel.
  // Another way to think about it is when
  // m_bDisableLighting is true, render the same way
  // OpenGL does when ::glDisable( GL_LIGHTING ) is called.

private:
  unsigned char m_reserved1[2];
#if defined(ON_64BIT_POINTER)
  unsigned char m_reserved2[4];
#endif
public:

  /*
  Description:
    Searches for a texure with matching texture_id.
    If more than one texture matches, the first match
    is returned.
  Parameters:
    texture_id - [in]
  Returns:
    >=0 m_textures[] index of matching texture
    -1 if no match is found.
  */
  int FindTexture(
    ON_UUID texture_id
    ) const;

  /*
  Description:
    Searches for a texure with matching filename and type.
    If more than one texture matches, the first match
    is returned.
  Parameters:
    filename - [in]  If NULL, then any filename matches.
    type - [in] If ON_Texture::no_texture_type, then
                any texture type matches.
    i0 - [in] If i0 is < 0, the search begins at 
              m_textures[0], if i0 >= m_textures.Count(),
              -1 is returnd, otherwise, the search begins
              at m_textures[i0+1].
  Example:
    Iterate through all the the bitmap textures on 
    a material.

          ON_Material& mat = ...;
          int ti = -1;
          int bitmap_texture_count = 0;
          for(;;)
          {
            ti = mat.FindTexture( 
                        NULL, 
                        ON_Texture::bitmap_texture, 
                        ti );

            if ( ti < 0 )
            {
              // no more bitmap textures
              break;
            }

            // we have a bitmap texture
            bitmap_texture_count++;
            const ON_Texture& bitmap_texture = mat.m_textures[ti];
            ...
          }

  Returns:
    >=0 m_textures[] index of matching texture
    -1 if no match is found.
  */
  int FindTexture(
    const wchar_t* filename,
    ON_Texture::TYPE type,
    int i0 = -1
    ) const;

  /*
  Description:
    If there is already a texture with the same file name and
    type, then that texture is modified, otherwise a new texture
    is added.  If tx has user data, the user data is copied
    to the m_textures[] element.
  Parameters:
    tx - [in]
  Returns:
    Index of the added texture in the m_textures[] array.
  Remarks:
    This is intended to be a quick and simple way to add
    textures to the material.  If you need to do something
    different, then just work on the m_textures[] array.
  */
  int AddTexture( 
    const ON_Texture& tx
    );

  /*
  Description:
    If there is a texture with a matching type, that texture's
    filename is modified, otherwise a new texture is added.    
  Parameters:
    filename - [in] new filename
    type - [in]
  Returns:
    Index of the added texture in the m_textures[] array.
  Remarks:
    This is intended to be a quick and simple way to add
    textures to the material.  If you need to do something
    different, then just work on the m_textures[] array.
  */
  int AddTexture(
    const wchar_t* filename,
    ON_Texture::TYPE type 
    );

  /*
  Description:
    Deletes all texures with matching filenames and types.
  Parameters:
    filename - [in]  If NULL, then any filename matches.
    type - [in] If ON_Texture::no_texture_type, then
                any texture type matches.
  Returns:
    Number of textures deleted.
  */
  int DeleteTexture(
    const wchar_t* filename,
    ON_Texture::TYPE type 
    );

  ON_ObjectArray<ON_Texture> m_textures;

  /*
  Description:
    Used to provide per face material support. 
    The parent object reference a basic material. 
    When a brep face or mesh facet wants to use
    a material besides the base material, it specifies
    a channelSupports material channel.  The default
    material channel is 0 and that indicates the base
    material.  A channel of n > 0 means that face
    used the material with id m_material_channel[n-1].
    If (n-1) >= m_material_channel.Count(), then the base
    material is used.  The value of 
    m_material_channel[n].m_id is persistent.  The
    value of m_material_channel[n].m_i is a runtime
    index in the CRhinoDoc::m_material_table[].  If 
    CRhinoDoc::m_material_table[m_i].m_uuid != m_id,
    then m_id is assumed to be correct.
  */
  ON_SimpleArray<ON_UuidIndex> m_material_channel;

  ON_UUID m_plugin_id; // ID of the last plug-in to modify this material

private:
  static double m_max_shine;
  bool ReadV3Helper( ON_BinaryArchive& file, int minor_version );
  bool WriteV3Helper( ON_BinaryArchive& file ) const;
};

#if defined(ON_DLL_TEMPLATE)
// This stuff is here because of a limitation in the way Microsoft
// handles templates and DLLs.  See Microsoft's knowledge base 
// article ID Q168958 for details.
#pragma warning( push )
#pragma warning( disable : 4231 )
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ON_Material>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ObjectArray<ON_Material>;
#pragma warning( pop )
#endif

#endif

/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_LAYER_INC_)
#define OPENNURBS_LAYER_INC_

class ON_CLASS ON_Layer : public ON_Object
{
  ON_OBJECT_DECLARE(ON_Layer);

public:

  ON_Layer();
  ~ON_Layer();
  // C++ default copy construction and operator= work fine.
  // Do not add custom versions.

  //////////////////////////////////////////////////////////////////////
  //
  // ON_Object overrides

  /*
  Description:
    Tests an object to see if its data members are correctly
    initialized.
  Parameters:
    text_log - [in] if the object is not valid and text_log
        is not NULL, then a brief englis description of the
        reason the object is not valid is appened to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     object is valid
    false    object is invalid, uninitialized, etc.
  Remarks:
    Overrides virtual ON_Object::IsValid
  */
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  void Dump( ON_TextLog& ) const; // for debugging

  ON_BOOL32 Write(
         ON_BinaryArchive&  // serialize definition to binary archive
       ) const;

  ON_BOOL32 Read(
         ON_BinaryArchive&  // restore definition from binary archive
       );

  ON::object_type ObjectType() const;

  ON_UUID ModelObjectId() const;

  //////////////////////////////////////////////////////////////////////
  //
  // Interface

  void Default();

  bool SetLayerName( const char* );
  bool SetLayerName( const wchar_t* );
	const ON_wString& LayerName() const;

  /*
  Description:
    The string returned by ON_Layer::LayerNameReferenceDelimiter()
    is used to separate the name of a reference file from the name of 
    the layer in the file.
  Example:
    If a layer named "electrical" is in a file named "house plan.3dm"
    and "house plan.3dm" is a reference file in a Rhino worksession,
    then Rhino's user interface will use the string 
    "house plan : electrical" to identify the layer.
  Returns:
    " : " (null terminated string space,colon,space)
  Remarks:
    Rhino does not save the names of reference files in 3dm archives.
    Reference file names are used as runtime decorations.
  */
  static const wchar_t* LayerNameReferenceDelimiter();

  /*
  Description:
    The string "::" (colon,colon) returned by LayerNamePathDelimiter()
    is used to separate parent and child layer names.
  Example:
    If a model of a building has "level 1" and "level 2" as top level
    layers, an architect might choose to have a "fixtures" sublayer
    on each level.  The complete layer names would be
    "level 1::fixtures" and "level 2::fixtures".
  Returns:
    "::" (null terminated string colon,colon)
  */
  static const wchar_t* LayerNamePathDelimiter();

  /*
  Description:
    Get a layer name's "leaf" level name.
  Example:
    If a layer name is "refernce file : alpha::beta::gamma", 
    then ON_Layer::GetLeafName() returns "gamma"
  Returns:    
    True if the layer has a valid non-empty leaf name.
  */
  static bool GetLeafName( const wchar_t* layer_name, ON_wString& leaf_name);

  /*
  Description:
    Get the layer's "parent" path name.
  Example:
    If a layer name is "refenence file : alpha::beta::gamma", then
    ON_Layer::GetParentPathName() returns "alpha::beta"
  Returns:    
    True if the layer has a valid non-empty parent path name.
  */
  static bool GetParentName( const wchar_t* layer_name, ON_wString& parent_path_name );

  /*
  Description:
    Remove any "reference : " prefix from a layer's name.
  Parameters:
    layer_name - [in]
    layer_path_name - [out]
      layer_name with any reference prefix removed.
  Example:
    If a layer name is "refenence file : alpha::beta::gamma", then
    ON_Layer::RemoveReferenceName() returns "alpha::beta::gamma"
  Returns:    
    True if layer_path_name is non-empty. If no reference prefix was present,
    then the returned layer_path_name is identical to the input layer_name.
  */
  static bool RemoveReferenceName( const wchar_t* layer_name, ON_wString& layer_path_name );

  /*
  Description:
    Get the layer's reference name.
  Example:
    If a layer name is "refenence file : alpha::beta::gamma", then
    ON_Layer::GetReferenceFileName() returns "refenence file"
  Returns:    
    True if the layer has a valid non-empty reference file name.
  */
  static bool GetReferenceName( const wchar_t* layer_name, ON_wString& reference_name );

  // The PER_VIEWPORT_SETTINGS enum defines
  // the bits used to set masks in functions used
  // to specify and query per viewport layer settings.
  enum PER_VIEWPORT_SETTINGS
  {
    per_viewport_none              =  0,

    per_viewport_id               =  1,
    per_viewport_color            =  2,
    per_viewport_plot_color       =  4,
    per_viewport_plot_weight      =  8,
    per_viewport_visible          = 16,
    per_viewport_persistent_visibility = 32,

    per_viewport_all_settings     = 0xFFFFFFFF
    // (Developers: these values are used in file IO and must not be changed.)
  };

 /*
  Parameters:
    viewport_id - [in]
      If viewport_id is not nil, then checks for per viewport
      settings for that specific viewport.
      If viewport_id is nil, then checks for per viewport settings
      in any viewport.
    settings_mask - [in]
      settings_mask is a bitfield that specifies which settings
      to check for.  The bits are defined in the
      ON_Layer::PER_VIEWPORT_PROPERTIES enum.  If you want to 
      determine if the layer has any per viewport settings,
      then pass 0xFFFFFFFF.
  Returns:
    True if the layer has per viewport override for the specified
    settings.
  */
  bool HasPerViewportSettings(
    ON_UUID viewport_id,
    unsigned int settings_mask
    ) const;

  /*
  Parameters:
    viewport_id - [in]
      If viewport_id is not nil, then checks for setting for
      that specific viewport.
      If viewport_id is nil, then checks for any viewport settings.
  Returns:
    True if the layer has per viewport settings.
  */
  bool HasPerViewportSettings(
    const ON_UUID& viewport_id
    ) const;


  /*
  Description:
    Copies all per viewport settings for the source_viewport_id
  Parameters:
    source_viewport_id - [in]
      viewport id to copy all per viewport settings from
    destination_viewport_id - [in]
      viewport od to copy all per viewport settings to
  Returns:
    True if the settings could be copied, False if no per-viewport
    settings exist for the source viewport id
  */
  bool CopyPerViewportSettings( 
    ON_UUID source_viewport_id,
    ON_UUID destination_viewport_id
    );


  /*
  Description:
    Copies specified per viewport settings from a source layer to this
    layer.
  Parameters:
    source_layer - [in]
      layer to copy settings from
    viewport_id - [in]
      viewport id to copy all per viewport settings from.
      If viewport_id is nil, then the per viewport settings
      for all viewports will be copied.
    settings_mask - [in]
      bits indicate which settings to copy
      Use the ON_Layer PER_VIEWPORT_SETTINGS enum to
      set the bits.
  Returns:
    True if the settings were copied, False if no per-viewport
    settings exist for the specified viewport_id.
  */
  bool CopyPerViewportSettings( 
    const ON_Layer& source_layer,
    ON_UUID viewport_id,
    unsigned int settings_mask
    );

  /*
  Description:
    Delete per viewport layer settings.
  Parameters:
    viewport_id - [in]
      If viewport_id is not nil, then the settings for that
      viewport are deleted.  If viewport_id is nil, then all
      per viewport settings are deleted.
  */
  void DeletePerViewportSettings( 
    const ON_UUID& viewport_id 
    ) const;

  /*
  Description:
    Cull unused per viewport layer settings.
  Parameters:
    viewport_id_count - [in]
    viewport_id_list - [in]
      Settings for any viewports NOT in the viewport_id_list[]
      are culled.
  */
  void CullPerViewportSettings( 
    int viewport_id_count, 
    const ON_UUID* viewport_id_list
    );

  /*
  Description:
    The PerViewportSettingsCRC() can be used to determine
    when layers have different per viewport settings.
  */
  ON__UINT32 PerViewportSettingsCRC() const;

  /*
  Description:
    Set the color used by objects on this layer that do
    not have a per object color set
  Parameters:
    layer_color - [in]
      Passing ON_UNSET_COLOR will clear the settings.
    viewport_id - [in]
      If viewport_id is not nil, then the setting applies only
      to the viewport with the specified id.
  */
	void SetColor( ON_Color layer_color ); // layer display color

  /*
  Description:
    Set the color used by objects on this layer that do
    not have a per object color set
  Parameters:
    viewport_id - [in]
      If viewport_id is not nil, then the setting applies only
      to the viewport with the specified id.
    layer_color - [in]
      Passing ON_UNSET_COLOR will clear the settings.
  */
  void SetPerViewportColor( ON_UUID viewport_id, ON_Color layer_color );

  /* use ON_Layer::SetPerViewportColor */
  ON_DEPRECATED void SetColor( ON_Color, const ON_UUID& );

  /*
  Parameters:
    viewport_id - [in]
      If viewport_id is not nil, then the setting to use
      for a specific viewport is returned.
  Returns:
    The color used by objects on this layer that do
    not have a per object color set.
  */
	ON_Color Color() const;

  /*
  Parameters:
    viewport_id - [in]
      If viewport_id is not nil, then the setting to use
      for a specific viewport is returned.
  Returns:
    The color used by objects in the specified viewport and
    on this layer that do not have a per object color set.
  */
  ON_Color PerViewportColor( ON_UUID viewport_id ) const;

  /* use ON_Layer::PerViewportColor */
	ON_DEPRECATED ON_Color Color( const ON_UUID& ) const;

  /*
  Description:
    Remove any per viewport layer color setting so the
    layer's overall setting will be used for all viewports.
  Parameters:
    viewport_id - [in]
      If viewport_id is not nil, then the setting for this
      viewport will be deleted.  If viewport_id is nil,
      the all per viewport layer color settings will be removed.
  */
  void DeletePerViewportColor( const ON_UUID& viewport_id );

  /*
  Description:
    Set the plotting color used by objects on this layer that do
    not have a per object plotting color set
  Parameters:
    plot_color - [in]
      Passing ON_UNSET_COLOR will clear the settings.
    viewport_id - [in]
      If viewport_id is not nil, then the setting applies only
      to the viewport with the specified id.
  */
	void SetPlotColor( ON_Color plot_color ); // plotting color

  void SetPerViewportPlotColor( ON_UUID viewport_id, ON_Color plot_color );

  /* use ON_Layer::SetPerViewportPlotColor */
  ON_DEPRECATED	void SetPlotColor( ON_Color, const ON_UUID& ); 

  /*
  Returns:
    The plotting color used by objects on this layer that do
    not have a per object color set.
  */
	ON_Color PlotColor() const;

  /*
  Parameters:
    viewport_id - [in]
      If viewport_id is not nil, then the setting to use
      for a specific viewport is returned.
  Returns:
    The plotting color used by objects on this layer that do
    not have a per object color set.
  */
	ON_Color PerViewportPlotColor( ON_UUID viewport_id ) const;
  
  /* use ON_Layer::PerViewportPlotColor */
  ON_DEPRECATED	ON_Color PlotColor( const ON_UUID& ) const;

  /*
  Description:
    Remove any per viewport plot color setting so the
    layer's overall setting will be used for all viewports.
  Parameters:
    viewport_id - [in]
      If viewport_id is not nil, then the setting for this
      viewport will be deleted.  If viewport_id is nil,
      the all per viewport plot color settings will be removed.
  */
  void DeletePerViewportPlotColor( const ON_UUID& viewport_id );

  /*
  Description:
    Set the index of the linetype used by objects on this layer that do
    not have a per object lintypes
  Parameters:
    linetype_index - [in]
      Passing -1 will clear the setting.
  */
	bool SetLinetypeIndex( int linetype_index );

  /*
  Returns:
    The index of the linetype used by objects on this layer that do
    not have a per object linetype set.
  */
	int LinetypeIndex() const;

  /*
  Returns:
    Returns true if objects on layer are visible.
  Remarks:
    Does not inspect per viewport settings.
  See Also:
    ON_Layer::SetVisible
  */
  bool IsVisible() const;

  /*
  Description:
    Controls layer visibility
  Parameters:
    bVisible - [in] true to make layer visible, 
                    false to make layer invisible
    viewport_id - [in]
      If viewport_id is not nil, then the setting applies only
      to the viewport with the specified id.
  See Also:
    ON_Layer::IsVisible
  */
  void SetVisible( bool bVisible );

  /*
  Description:
    The persistent visbility setting is used for layers whose
    visibilty can be changed by a "parent" object. A common case
    is when a layer is a child layer (ON_Layer.m_parent_id is
    not nil). In this case, when a parent layer is turned off,
    then child layers are also turned off. The persistent
    visibility setting determines what happens when the parent
    is turned on again.
  Returns:
    true: 
      If this layer's visibility is controlled by a parent object
      and the parent is turned on (after being off), then this
      layer will also be turned on.
    false:
      If this layer's visibility is controlled by a parent object
      and the parent layer is turned on (after being off), then
      this layer will continue to be off.
  Remarks:
    When the persistent visbility is not explicitly set, this
    function returns the current value of IsVisible().
  See Also:
    ON_Layer::SetPersistentVisibility
    ON_Layer::UnsetPersistentVisibility
  */
  bool PersistentVisibility() const;

  /*
  Description:
    Set the persistent visibility setting for this layer.
  Parameters:
    bPersistentVisibility - [in]
      persistent visibility setting for this layer.
  Remarks:
    See ON_Layer::PersistentVisibility for a detailed description
    of persistent visibility.
  See Also:
    ON_Layer::PersistentVisibility
    ON_Layer::UnsetPersistentVisibility
  */
  void SetPersistentVisibility( bool bPersistentVisibility );

  /*
  Description:
    Remove any explicit persistent visibility setting from this
    layer. When persistent visibility is not explictly set,
    the value of ON_Layer::IsVisible() is used.
  Remarks:
    See ON_Layer::PersistentVisibility for a detailed description
    of persistent visibility.
  See Also:
    ON_Layer::PersistentVisibility
    ON_Layer::SetPersistentVisibility
  */
  void UnsetPersistentVisibility();
    
  /*
  Parameters:
    viewport_id - [in]
      If viewport_id is not nil, then the visibility setting
      for that viewport is returned.  If viewport_id
      is nil, then true is returned if the layer is visible
      in some viewport.
  Returns:
    Returns true if objects on layer are visible.
  */
	bool PerViewportIsVisible( ON_UUID viewport_id ) const;	

  /* use ON_Layer::PerViewportIsVisible */ 
  ON_DEPRECATED bool IsVisible( const ON_UUID& ) const; 

  /*
  Description:
    Controls layer visibility in specific viewports.
  Parameters:
    viewport_id - [in]
      If viewport_id is not nil, then the setting applies only
      to the viewport with the specified id.  If viewport_id
      is nil, then the setting applies to all viewports with
      per viewport layer settings.
    bVisible - [in] true to make layer visible, 
                    false to make layer invisible
  See Also:
    ON_Layer::IsVisibleInViewport()
  */
  void SetPerViewportVisible( ON_UUID viewport_id, bool bVisible );
  
  /* use ON_Layer::SetPerViewportVisible */ 
  ON_DEPRECATED void SetVisible( bool, const ON_UUID& );

  /*
  Parameters:
    viewport_id - [in]
      id of a viewport.  If viewport_id is nil, then 
      ON_Layer::PersistentVisibility() is returned.
  Returns:
    true: 
      If this layer's visibility in the specified viewport is 
      controlled by a parent object and the parent is turned on
      (after being off), then this layer will also be turned on
      in the specified viewport.
    false:
      If this layer's visibility in the specified viewport is
      controlled by a parent object and the parent layer is 
      turned on (after being off), then this layer will continue
      to be off in the specified viewport.
  Remarks:
    See ON_Layer::SetPersistentVisibility
    for a description of persistent visibility.
  See Also:
    ON_Layer::SetPerViewportPersistentVisibility
  */
  bool PerViewportPersistentVisibility( ON_UUID viewport_id ) const;

  /*
  Description:
    This function allows per viewport setting the
    child visibility property.
  Parameters
    viewport_id - [in]
    bPersistentVisibility - [in]
  Remarks:
    See ON_Layer::SetPersistentVisibility
    for a description of the child visibility property.
  See Also:
    ON_Layer::SetPersistentVisibility
  */
  void SetPerViewportPersistentVisibility( ON_UUID viewport_id, bool bPersistentVisibility );

  void UnsetPerViewportPersistentVisibility( ON_UUID viewport_id );    

  /*
  Description:
    Remove any per viewport visibility setting so the
    layer's overall setting will be used for all viewports.
  Parameters:
    viewport_id - [in]
      If viewport_id is not nil, then the setting for this
      viewport will be deleted.  If viewport_id is nil,
      the all per viewport visibility settings will be removed.
  */
  void DeletePerViewportVisible( const ON_UUID& viewport_id );

  /*
  Description:
    Get a list of the viewport ids of viewports that 
    that have per viewport visibility settings that
    override the default layer visibility setting 
    ON_Layer::m_bVisible.
  Parameters:
    viewport_id_list - [out]
      List of viewport id's that have a per viewport visibility
      setting.  If the returned list is empty, then there
      are no per viewport visibility settings.
  Returns:
    Number of ids added to the list.
  */
  void GetPerViewportVisibilityViewportIds(
    ON_SimpleArray<ON_UUID>& viewport_id_list
    ) const;

  /*
  Returns:
    Returns true if objects on layer are locked.
  See Also:
    ON_Layer::SetLocked
  */
  bool IsLocked() const;

  /*
  Description:
    Controls layer locked
  Parameters:
    bLocked - [in] True to lock layer
                   False to unlock layer
  See Also:
    ON_Layer::IsLocked
  */
  void SetLocked( bool bLocked );

  /*
  Description:
    The persistent locking setting is used for layers that can
    be locked by a "parent" object. A common case is when a layer
    is a child layer (ON_Layer.m_parent_id is not nil). In this 
    case, when a parent layer is locked, then child layers are 
    also locked. The persistent locking setting determines what
    happens when the parent is unlocked again.
  Returns:
    true: 
      If this layer's locking is controlled by a parent object
      and the parent is unlocked (after being locked), then this
      layer will also be unlocked.
    false:
      If this layer's locking is controlled by a parent object
      and the parent layer is unlocked (after being locked), then
      this layer will continue to be locked.
  Remarks:
    When the persistent locking is not explicitly set, this
    function returns the current value of IsLocked().
  See Also:
    ON_Layer::SetPersistentLocking
    ON_Layer::UnsetPersistentLocking
  */
  bool PersistentLocking() const;

  /*
  Description:
    Set the persistent locking setting for this layer.
  Parameters:
    bPersistentLocking - [in]
      persistent locking for this layer.
  Remarks:
    See ON_Layer::PersistentLocking for a detailed description of
    persistent locking.
  See Also:
    ON_Layer::PersistentLocking
    ON_Layer::UnsetPersistentLocking
  */
  void SetPersistentLocking(bool bPersistentLocking);

  /*
  Description:
    Remove any explicity persistent locking settings from this
    layer.
  Remarks:
    See ON_Layer::PersistentLocking for a detailed description of
    persistent locking.
  See Also:
    ON_Layer::PersistentLocking
    ON_Layer::SetPersistentLocking
  */
  void UnsetPersistentLocking();

  /*
  Returns:
    Value of (IsVisible() && !IsLocked()).
  */
  bool IsVisibleAndNotLocked() const;

  /*
  Returns:
    Value of (IsVisible() && IsLocked()).
  */
  bool IsVisibleAndLocked() const;

  //////////
  // Index of render material for objects on this layer that have
  // MaterialSource() == ON::material_from_layer.
  // A material index of -1 indicates no material has been assigned
  // and the material created by the default ON_Material constructor
  // should be used.
  bool SetRenderMaterialIndex( int ); // index of layer's rendering material
  int RenderMaterialIndex() const;

  bool SetLayerIndex( int ); // index of this layer;
  int LayerIndex() const;

  bool SetIgesLevel( int ); // IGES level for this layer
  int IgesLevel() const;

  /*
  Description:
    Get the weight (thickness) of the plotting pen.
  Returns:
    Thickness of the plotting pen in millimeters.
    A thickness of  0.0 indicates the "default" pen weight should be used.
    A thickness of -1.0 indicates the layer should not be printed.
  */
  double PlotWeight() const;
  
  double PerViewportPlotWeight( ON_UUID viewport_id ) const;

  /* use ON_Layer::PerViewportPlotWeight */ 
  ON_DEPRECATED double PlotWeight( const ON_UUID& ) const;

  /*
  Description:
    Set the weight of the plotting pen.
  Parameters:
    plot_weight_mm - [in] Set the thickness of the plotting pen in millimeters.
       0.0 means use the default pen width which is a Rhino app setting.
      -1.0 means layer does not print (still displays on the screen)
  */
  void SetPlotWeight(double plot_weight_mm);

  /*
  Description:
    Set the weight of the plotting pen.
  Parameters:
    plot_weight_mm - [in] Set the thickness of the plotting pen in millimeters.
       0.0 means use the default pen width which is a Rhino app setting.
      -1.0 means layer does not print (still displays on the screen)
  */
  void SetPerViewportPlotWeight(ON_UUID viewport_id, double plot_weight_mm);

  /* use ON_Layer::SetPerViewportPlotWeight */ 
  ON_DEPRECATED void SetPlotWeight(double, const ON_UUID& );

  /*
  Description:
    Remove any per viewport plot weight setting so the
    layer's overall setting will be used for all viewports.
  Parameters:
    viewport_id - [in]
      If viewport_id is not nil, then the setting for this
      viewport will be deleted.  If viewport_id is nil,
      the all per viewport plot weight settings will be removed.
  */
  void DeletePerViewportPlotWeight( const ON_UUID& viewport_id );

  /*
  Description:
    Use UpdateViewportIds() to change viewport ids in situations
    like merging when a viewport id conflict requires the viewport
    ids in a file to be changed.
  Returns:
    Number of viewport ids that were updated.
  */
  int UpdateViewportIds( 
    const ON_UuidPairList& viewport_id_map 
    );

public:

  int m_layer_index;       // index of this layer
  ON_UUID m_layer_id;
  ON_UUID m_parent_layer_id; // Layers are origanized in a hierarchical 
                             // structure (like file folders).
                             // If a layer is in a parent layer, 
                             // then m_parent_layer_id is the id of 
                             // the parent layer.

  int m_iges_level;        // IGES level number if this layer was made during IGES import



  // Rendering material:
  //   If you want something simple and fast, set 
  //   m_material_index to the index of your rendering material 
  //   and ignore m_rendering_attributes.
  //   If you are developing a fancy plug-in renderer, and a user is
  //   assigning one of your fabulous rendering materials to this
  //   layer, then add rendering material information to the 
  //   m_rendering_attributes.m_materials[] array. 
  //
  // Developers:
  //   As soon as m_rendering_attributes.m_materials[] is not empty,
  //   rendering material queries slow down.  Do not populate
  //   m_rendering_attributes.m_materials[] when setting 
  //   m_material_index will take care of your needs.
  int m_material_index; 
  ON_RenderingAttributes m_rendering_attributes;
  
  int m_linetype_index;    // index of linetype
  
  // Layer display attributes.
  //   If m_display_material_id is nil, then m_color is the layer color
  //   and defaults are used for all other display attributes.
  //   If m_display_material_id is not nil, then some complicated
  //   scheme is used to decide what objects on this layer look like.
  //   In all cases, m_color is a good choice if you don't want to
  //   deal with m_display_material_id.  In Rhino, m_display_material_id
  //   is used to identify a registry entry that contains user specific
  //   display preferences.
  ON_Color m_color;
  ON_UUID m_display_material_id;

  // Layer printing (plotting) attributes.
  ON_Color m_plot_color;   // printing color
                           // ON_UNSET_COLOR means use layer color
  double m_plot_weight_mm; // printing pen thickness in mm
                           //  0.0 means use the default width (a Rhino app setting)
                           // -1.0 means layer does not print (still visible on screen)
  ON_wString m_name;

  bool m_bVisible;  // If true, objects on this layer are visible.
  bool m_bLocked;   // If true, objects on this layer cannot be modified.
  bool m_bExpanded; // If true, when the layer table is displayed in
                    // a tree control then the list of child layers is
                    // shown in the control.


  //////////////////////////////////////////////////////////////
  //
  // Tools for saving layer settings.
  //
  enum LAYER_SETTINGS
  {
    no_layer_settings = 0,
    userdata_settings = 1,
    color_settings = 2,
    plot_color_settings = 4,
    plot_weight_settings = 8,
    visible_settings = 16,
    locked_settings = 32,
    all_layer_settings = 0xFFFFFFFF
  };

  /*
  Returns:
    Bits in the returned value indicate if there are differences
    between layer0 and layer1.  For example, if the layers have 
    difference color, then the returned value would have the
    "color" bit set.
  */
  static unsigned int Differences( const ON_Layer& layer0, const ON_Layer& layer1 );

  /*
  Description:
    Use settings_values and settings to set the specified values 
    on this layer.
  Parameters:
    settings_values - [in]
    settings - [in]
      LAYER_SETTINGS bits specify which values of this
      should be set from settings_values.
  */
  void Set( unsigned int settings, const ON_Layer& settings_values  );

  /*
  Description:
    Saves current values of the specified settings so
    they can be retrieved by GetSettings().
  Parameters:
    settings - [in]
      LAYER_SETTINGS bits specify which values to save.
      if 0 == settings, then all saved settings are deleted.
    bUpdate - [in]
      If true, then previously saved settings for properties
      not identified by the settings paramter are left intact.
      If false, all previously saved settings are removed.
  */
  void SaveSettings( unsigned int settings, bool bUpdate );

  /*
  Returns:
    0 if the layer does not have saved settings.
    Nonzero value with LAYER_SETTINGS bits specifying which settings
    are saved.  The saved that can be retrieved by calling 
    GetSavedSettings().    
  */
  unsigned int SavedSettings() const;

  /*
  Description:
    Gets values of the saved settings.
  Parameters:
    layer - [in/out]
      values of saved settings are set and all other values are
      left unchanged.
    settings - [out]
      LAYER_SETTINGS bits specify which layer values were set
      by this call.
  Returns:
    True if there were saved settings.
  */
  bool GetSavedSettings( ON_Layer& layer, unsigned int& settings ) const;
  
private:
  // The following information may not be accurate and is subject
  // to change at any time.
  //
  // m_extension_bits & 0x01: 
  //   The value of ( m_extension_bits & 0x01) is used to speed
  //   common per viewport visiblity and color queries.
  //     0x00 = there may be per viewport settings on this layer.
  //     0x01 = there are no per viewport settings on this layer.
  //
  // m_extension_bits & 0x06:
  //   The value of ( m_extension_bits & 0x06) is the persistent
  //   visibility setting for this layer.
  //     0x00 = no persistent visibility setting
  //     0x02 = persistent visibility = true
  //     0x04 = persistent visibility = false
  //     0x06 = invalid value - treated as 0x00
  //
  // m_extension_bits & 0x18:
  //   The value of ( m_extension_bits & 0x18) is the persistent
  //   locking setting for this layer.
  //     0x00 = no persistent locking setting
  //     0x08 = persistent locking = true
  //     0x10 = persistent locking = false
  //     0x18 = invalid value - treated as 0x00
  unsigned char m_extension_bits;
};


#endif

/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_LINETYPE_INC_)
#define OPENNURBS_LINETYPE_INC_


// Description:
//   Determine if a line width is deemed to be a "hairline width" in Rhino
//   Any width that is >0 and < 0.001 mm is a hairline width for printing
// Parameters:
//   width_mm: [in] the width to examine in millimeters
// Returns:
//   true if this is a hairline width
ON_DECL bool ON_IsHairlinePrintWidth( double width_mm );

// Description:
//   Return a width in millimeters that is a valid hairline width in rhino
ON_DECL double ON_HairlinePrintWidth();




//////////////////////////////////////////////////////////////////////
// class ON_Linetype

class ON_CLASS ON_Linetype : public ON_Object
{
  ON_OBJECT_DECLARE(ON_Linetype);

public:

  /*
  Description:
    Sets index = -1.
  */
  ON_Linetype();

  ~ON_Linetype();


  /*
  Description:
    Sets index = -1 and emptys name and segment list.
  */
  void Default();

  /*
    Description:
      Tests that name is set and there is at least one non-zero length segment
  */
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  void Dump( ON_TextLog& ) const; // for debugging

  /*
    Description:
      Write to file
  */
  ON_BOOL32 Write(
         ON_BinaryArchive&  // serialize definition to binary archive
       ) const;

  /*
    Description:
      Read from file
  */
  ON_BOOL32 Read(
         ON_BinaryArchive&  // restore definition from binary archive
       );

  // virtual
  ON_UUID ModelObjectId() const;


  //////////////////////////////////////////////////////////////////////
  //
  // Interface

  /*
    Unique name for each linetype
  */
  bool SetLinetypeName( const char*);
  bool SetLinetypeName( const wchar_t*);
	const wchar_t* LinetypeName() const;

  /*
    Index of each linetype
    This index is used by geometry objects to 
    reference a specific linetype
  */
  bool SetLinetypeIndex( int);
  int LinetypeIndex() const;

  /*
    Description:
      Returns the total length of one repeat of the pattern
  */
  double PatternLength() const;


  /*
    Description:
      Returns the number of segments in the pattern
  */
  int SegmentCount() const;

  /*
  Description:
    Adds a segment to the pattern
  Returns:
    Index of the added segment.
  */
  int AppendSegment( const ON_LinetypeSegment& segment);

  /*
  Description:
    Removes a segment in the linetype.
  Parameters:
    index - [in]
      Zero based index of the segment to remove.
  Returns:
    True if the segment index was removed.
  */
  bool RemoveSegment( int index );

  /*
    Description:
      Sets the segment at index to match segment
  */
  bool SetSegment( int index, const ON_LinetypeSegment& segment);

  /*
    Description:
      Sets the length and type of the segment at index
  */
  bool SetSegment( int index, double length, ON_LinetypeSegment::eSegType type);

  /*
    Description:
      Returns a copy of the segment at index
  */
  ON_LinetypeSegment Segment( int index) const;

  /*
    Description:
      Expert user function to get access to the segment array
      for rapid calculations.
  */
  ON_SimpleArray<ON_LinetypeSegment>& Segments();
  const ON_SimpleArray<ON_LinetypeSegment>& Segments() const;

public:
  int m_linetype_index;
  ON_UUID m_linetype_id;    // Set by Rhino - unique id of this linetype
  ON_wString m_linetype_name;

private:
  ON_SimpleArray<ON_LinetypeSegment> m_segments;
};

#endif

/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_GROUP_INC_)
#define OPENNURBS_GROUP_INC_

class ON_CLASS ON_Group : public ON_Object
{
  ON_OBJECT_DECLARE(ON_Group);
public:
  ON_Group();
  ~ON_Group();
  // C++ default copy construction and operator= work fine.
  // Do not add custom versions.

  //////////////////////////////////////////////////////////////////////
  //
  // ON_Object overrides

  /*
  Description:
    Tests an object to see if its data members are correctly
    initialized.
  Parameters:
    text_log - [in] if the object is not valid and text_log
        is not NULL, then a brief englis description of the
        reason the object is not valid is appened to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     object is valid
    false    object is invalid, uninitialized, etc.
  Remarks:
    Overrides virtual ON_Object::IsValid
  */
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  void Dump( ON_TextLog& ) const; // for debugging

  ON_BOOL32 Write(
         ON_BinaryArchive&  // serialize definition to binary archive
       ) const;

  ON_BOOL32 Read(
         ON_BinaryArchive&  // restore definition from binary archive
       );

  //////////////////////////////////////////////////////////////////////
  //
  // Obsolete interface - just work on the public members
  void SetGroupName( const wchar_t* );
  void SetGroupName( const char* );
  
  void GetGroupName( ON_wString& ) const;
  const wchar_t* GroupName() const;

  void SetGroupIndex(int);
  int GroupIndex() const;

public:
  ON_wString m_group_name;
  int m_group_index;
  ON_UUID m_group_id;
};

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_FONT_INC_)
#define OPENNURBS_FONT_INC_

class ON_CLASS ON_Font : public ON_Object
{
  ON_OBJECT_DECLARE(ON_Font);
public:
  ON_Font();
  ~ON_Font();
  // C++ default copy construction and operator= work fine.

  /*
  Description:
    Create a font with a specified facename and properties.
  Parameters:
    face_name - [in]
      If face_name is null or empty, then "Arial" is used.
    bBold - [in]
      True for a bold version of the font.
    bItalic - [in]
      True for an italic version of the font.
  Returns:
    True if the font was created.  The name of this font is
    the face name with " Bold", " Italic" or " Bold Italic"
    appended as
 */
  bool CreateFontFromFaceName( 
    const wchar_t* face_name,
    bool bBold,
    bool bItalic 
    );

#if defined(ON_OS_WINDOWS_GDI)
  ON_Font( const LOGFONT& logfont );
  ON_Font& operator=( const LOGFONT& logfont );
#endif

  //////////////////////////////////////////////////////////////////////
  //
  // ON_Object overrides

  /*
  Description:
    Tests an object to see if its data members are correctly
    initialized.
  Parameters:
    text_log - [in] if the object is not valid and text_log
        is not NULL, then a brief englis description of the
        reason the object is not valid is appened to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     object is valid
    false    object is invalid, uninitialized, etc.
  Remarks:
    Overrides virtual ON_Object::IsValid
  */
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  // virtual
  void Dump( ON_TextLog& ) const; // for debugging

  // virtual
  ON_BOOL32 Write(
         ON_BinaryArchive&  // serialize definition to binary archive
       ) const;

  // virtual
  ON_BOOL32 Read(
         ON_BinaryArchive&  // restore definition from binary archive
       );

  // virtual
  ON_UUID ModelObjectId() const;

  //////////////////////////////////////////////////////////////////////
  //
  // Interface

  enum 
  { 

#if defined(ON_OS_WINDOWS_GDI)

    // Windows GDI facename length

    // 13 November 2008 - Dale Lear
    // Because:
    //   * Prior to this date the above "ON_OS_WINDOWS_GDI" 
    //     was misspelled and this code did not get compiled.
    //   * The Windows headers defines LF_FACESIZE = 32
    //   * ON_Font has a member wchar_t m_facename[face_name_size] array
    //   * We cannot break the SDK by changing the size of ON_Font
    //
    //  we cannot define face_name_size = LF_FACESIZE+1.  So, I'm
    //  using the same "65" we use below.  It is critical that
    //  face_name_size >= LF_FACESIZE+1
    //
    //face_name_size = LF_FACESIZE+1, // <- prior to 13 Nov but never used
    face_name_size = 65,

    // Windows GDI font weights
    bold_weight   = FW_BOLD,
    medium_weight = FW_MEDIUM,
    normal_weight = FW_NORMAL,
    light_weight  = FW_LIGHT,

    // Windows GDI character sets
    default_charset = DEFAULT_CHARSET,
    symbol_charset  = SYMBOL_CHARSET,

#else

    face_name_size = 65, // must be >= 33

    bold_weight   = 700,
    medium_weight = 500,
    normal_weight = 400,
    light_weight  = 300,

    default_charset = 1,
    symbol_charset  = 2,

#endif

    normal_font_height = 256
  }; 

  // Ratio of linefeed to character height (1.6)
  static 
  const double m_default_linefeed_ratio;

  static
  const int m_metrics_char; // ASCII code of character to used
                            // to get runtime "default" glyph
                            // metrics. (Currently an "I").

  /*
  Returns:
    True if the font's character set should be SYMBOL_CHARSET;
  */
  static
  bool IsSymbolFontFaceName( 
          const wchar_t* facename
          );

  void SetFontName( const wchar_t* );
  void SetFontName( const char* );
  
  void GetFontName( ON_wString& ) const;
  const wchar_t* FontName() const;

  void SetFontIndex(int);
  int FontIndex() const;

  /*
  Returns:
    The ratio (height of linefeed)/(height of I).
  */
  double LinefeedRatio() const;

  void SetLinefeedRatio( double linefeed_ratio );

  bool SetFontFaceName( const wchar_t* );
  bool SetFontFaceName( const char* );
  
  void GetFontFaceName( ON_wString& ) const;
  const wchar_t* FontFaceName() const;

  int FontWeight() const;
  void SetFontWeight( int);

  bool IsItalic() const;
  void SetIsItalic( bool );
  void SetItalic( bool );

  bool IsBold() const;
  void SetBold( bool );

  // Added 7/12/07 LW
  bool IsUnderlined() const;
  void SetUnderlined( bool );

  void Defaults();

  /*
  Returns:
    Height of the 'I' character when the font is drawn 
    with m_logfont.lfHeight = ON_Font::normal_font_height.
  */
  int HeightOfI() const;

  /*
  Returns:
    Height of a linefeed when the font is drawn 
    with m_logfont.lfHeight = ON_Font::normal_font_height.
  */
  int HeightOfLinefeed() const;

  /*
    Description:
      Returns the ratio of the height of a typical upper case letter 
      to the height of a whole character cell.

  Parameters:
    none

  Returns:
    double - ratio of Windows Font Height / m_HeightOfH
  */
  double AscentRatio() const;

#if defined(ON_OS_WINDOWS_GDI)
  bool SetLogFont( const LOGFONT& logfont );
  const LOGFONT& LogFont() const;
#endif

public:
  ON_wString m_font_name;      // Name of this font in the Rhino UI
  int        m_font_weight;    // Same as m_logfont.lfWeight
  bool       m_font_italic;    // Same as m_logfont.lfItalic
  bool       m_font_underlined;// Same as m_logfont.lfUnderlined (Added 7/12/07 LW)
  double     m_linefeed_ratio; // defaults to static s_linefeed_ratio.
  int        m_font_index;     // font index in Rhino font table
  ON_UUID    m_font_id;
  wchar_t    m_facename[face_name_size]; // same as m_logfont.lfFaceName ( 

public:

  /*  
  Description:
    Insures the settings in the OS specific information, like 
    the Windows m_logfont field, match the persistent m_font_* values 
    above that are used for all OSs and used in UI code.
  */
  void UpdateImplementationSettings();
#if defined(ON_OS_WINDOWS_GDI)
  // Windows specific settins
  LOGFONT m_logfont;
#endif

private:
  // volitile - can be changed by ON_Font::HeightOfI() const.
  int m_I_height; // height of the 'I' character when the font is drawn 
                  // with m_logfont.lfHeight = 256.
};

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_LIGHT_INC_)
#define OPENNURBS_LIGHT_INC_

class ON_CLASS ON_Light : public ON_Geometry
{
  ON_OBJECT_DECLARE(ON_Light);

public:
  ON_Light();
  ~ON_Light();
  // C++ defaults work fine
  //ON_Light& operator=(const ON_Light&);
  //ON_Light(const ON_Light&);

  /////////////////////////////////////////////////////////////////
  //
  // ON_Object virtual functions 
  //

  /*
  Description:
    Tests an object to see if its data members are correctly
    initialized.
  Parameters:
    text_log - [in] if the object is not valid and text_log
        is not NULL, then a brief englis description of the
        reason the object is not valid is appened to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     object is valid
    false    object is invalid, uninitialized, etc.
  Remarks:
    Overrides virtual ON_Object::IsValid
  */
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  void Dump( ON_TextLog& ) const; // for debugging

  // Use ON_BinaryArchive::WriteObject() and ON_BinaryArchive::ReadObject()
  // for top level serialization.  These Read()/Write() members should just
  // write/read specific definitions.  In particular, they should not write/
  // read any chunk typecode or length information.  The default 
  // implementations return false and do nothing.
  ON_BOOL32 Write(
         ON_BinaryArchive&  // serialize definition to binary archive
       ) const;

  ON_BOOL32 Read(
         ON_BinaryArchive&  // restore definition from binary archive
       );

  ON::object_type ObjectType() const;

  // virtual
  ON_UUID ModelObjectId() const;


  /////////////////////////////////////////////////////////////////
  //
  // ON_Geometry virtual functions 
  //
  int Dimension() const;

  ON_BOOL32 GetBBox( // returns true if successful
         double*,    // boxmin[dim]
         double*,    // boxmax[dim]
         ON_BOOL32 = false  // true means grow box
         ) const;

  ON_BOOL32 Transform( 
         const ON_Xform&
         );
 
  /////////////////////////////////////////////////////////
  //
  // Interface
  //

  void Default(); // make default light

  /////////////////////////////////////////////////////////
  //
  // turn light on/off
  //
  ON_BOOL32 Enable( ON_BOOL32 = true ); // returns previous state
  ON_BOOL32 IsEnabled() const;
  
  /////////////////////////////////////////////////////////
  //
  // style, location, and direction
  //   direction is ignored for "point" and "ambient" lights
  //   location is ignored for "directional" and "ambient" lights
  void SetStyle(ON::light_style);
  ON::light_style Style() const;

  ON_BOOL32 IsPointLight() const;
  ON_BOOL32 IsDirectionalLight() const;
  ON_BOOL32 IsSpotLight() const;
  ON_BOOL32 IsLinearLight() const;
  ON_BOOL32 IsRectangularLight() const;

  ON::coordinate_system CoordinateSystem() const; // determined by style

  /*
  Description:
    A light's location and direction can be defined with respect
    to world, camera, or view coordinates.  GetLightXform gets
    the transformation from the light's intrinsic coordinate
    system to the destination coordinate system specified
    by dest_cs.
  Parameters:
    vp - [in] viewport where light is being used
    dest_cs - [in] destination coordinate system
    xform - [out] transformation from the light's intrinsic
                  coordinate system to cs.
  Returns:
    true if successful.
  */
  ON_BOOL32 GetLightXform( 
           const ON_Viewport& vp,
           ON::coordinate_system dest_cs, 
           ON_Xform& xform 
           ) const;

  void SetLocation( const ON_3dPoint& );
  void SetDirection( const ON_3dVector& );

  ON_3dPoint Location() const;
  ON_3dVector Direction() const;
  ON_3dVector PerpindicularDirection() const;

  double Intensity() const; // 0.0 = 0%  1.0 = 100%
  void SetIntensity(double);

  double PowerWatts() const;
  double PowerLumens() const;
  double PowerCandela() const;
  
  void SetPowerWatts( double );
  void SetPowerLumens( double );
  void SetPowerCandela( double );

  /////////////////////////////////////////////////////////
  //
  // colors
  //
  void SetAmbient(  ON_Color );
  void SetDiffuse(  ON_Color );
  void SetSpecular( ON_Color );
  ON_Color Ambient() const;
  ON_Color Diffuse() const;
  ON_Color Specular() const;

  /////////////////////////////////////////////////////////
  //
  // attenuation settings (ignored for "directional" and "ambient" lights)
  // attenuation = 1/(a[0] + d*a[1] + d^2*a[2]) where d = distance to light
  //
  void SetAttenuation(double,double,double);
  void SetAttenuation(const ON_3dVector&);
  ON_3dVector Attenuation() const;
  double Attenuation(double) const; // computes 1/(a[0] + d*a[1] + d^2*a[2]) where d = argument
                                    // returns 0 if a[0] + d*a[1] + d^2*a[2] <= 0

  /////////////////////////////////////////////////////////
  //
  // spot light parameters (ignored for non-spot lights)
  //
  // angle = 0 to 90 degrees
  // exponent = 0 to 128 (0=uniform, 128=high focus)
  //
  void SetSpotAngleDegrees( double );
  double SpotAngleDegrees() const;

  void SetSpotAngleRadians( double );
  double SpotAngleRadians() const;

  //////////
  // The spot exponent varies from 0.0 to 128.0 and provides
  // an exponential interface for controling the focus or 
  // concentration of a spotlight (like the 
  // OpenGL GL_SPOT_EXPONENT parameter).  The spot exponent
  // and hot spot parameters are linked; changing one will
  // change the other.
  // A hot spot setting of 0.0 corresponds to a spot exponent of 128.
  // A hot spot setting of 1.0 corresponds to a spot exponent of 0.0.
  void SetSpotExponent( double );
  double SpotExponent() const;

  //////////
  // The hot spot setting runs from 0.0 to 1.0 and is used to
  // provides a linear interface for controling the focus or 
  // concentration of a spotlight.
  // A hot spot setting of 0.0 corresponds to a spot exponent of 128.
  // A hot spot setting of 1.0 corresponds to a spot exponent of 0.0.
  void SetHotSpot( double );
  double HotSpot() const;

  // The spotlight radii are useful for display UI.
  bool GetSpotLightRadii( double* inner_radius, double* outer_radius ) const;


  /////////////////////////////////////////////////////////
  //
  // linear and rectangular light parameters
  // (ignored for non-linear/rectangular lights)
  //
  void SetLength( const ON_3dVector& );
  ON_3dVector Length() const;

  void SetWidth( const ON_3dVector& );
  ON_3dVector Width() const;

  /////////////////////////////////////////////////////////
  //
  // shadow parameters (ignored for non-spot lights)
  //
  // shadow intensity 0.0 = does not cast any shadows
  //                  1.0 = casts black shadows
  //
  void SetShadowIntensity(double);
  double ShadowIntensity() const;
                                 

  /////////////////////////////////////////////////////////
  //
  // light index
  //
  void SetLightIndex( int );
  int LightIndex() const;

  /////////////////////////////////////////////////////////
  //
  // light name
  //
  void SetLightName( const char* );
  void SetLightName( const wchar_t* );
  const ON_wString& LightName() const;

public:
  int           m_light_index;
  ON_UUID       m_light_id;
  ON_wString    m_light_name;

  ON_BOOL32                 m_bOn;   // true if light is on
  ON::light_style      m_style; // style of light

  ON_Color m_ambient;
  ON_Color m_diffuse;
  ON_Color m_specular;
  
  ON_3dVector m_direction; // ignored for "point" and "ambient" lights
  ON_3dPoint  m_location;  // ignored for "directional" and "ambient" lights
  ON_3dVector m_length;    // only for linear and rectangular lights
                           // ends of linear lights are m_location and m_location+m_length
  ON_3dVector m_width;     // only for rectangular lights
                           // corners of rectangular lights are m_location, m_location+m_length,
                           // m_location+m_width, m_location+m_width+m_length

  double      m_intensity; // Linear dimming/brightening factor: 0.0 = off, 1.0 = 100%.
                           // Values < 0.0 and values > 1.0 are permitted but are
                           // not consistently interpreted by various renderers.
                           // Renderers should clamp the range to [0.0, 1.0] if their
                           // lighting model does not support more exotic interpretations
                           // of m_intensity.
  double      m_watts;     // Used by lighting models that reference lighting fixtures.
                           // Values < 0.0 are invalid.  If m_watts is 0.0, the
                           // value is ignored.

  // spot settings - ignored for non-spot lights
  double       m_spot_angle;    // 0.0 to 90.0
  double       m_spot_exponent; // 0.0 to 128.0
                                // 0.0 = uniform
                                // 128.0 = high focus
  double       m_hotspot;       // 0.0 to 1.0 (See SetHotSpot() for details)

  // attenuation settings - ignored for "directional" and "ambient" lights
  ON_3dVector m_attenuation;    // each entry >= 0.0
                                // att = 1/(a[0] + d*a[1] + d^2*a[2])
                                // where d = distance to light

  // shawdow casting
  double       m_shadow_intensity; // 0.0 = no shadow casting, 1.0 = full shadow casting
};



#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_POINT_GEOMETRY_INC_)
#define OPENNURBS_POINT_GEOMETRY_INC_

// NOTE:  ON_3dPoint is much more efficient than ON_Point.
//        Use ON_Point when you need a polymorphic 3d point
//        that is derived from ON_Geometry or ON_Object.

class ON_CLASS ON_Point : public ON_Geometry
{
public:
  ON_3dPoint point;

  ON_Point();
  ON_Point(const ON_Point&);
  ON_Point(const ON_3dPoint&);
  ON_Point(double,double,double);
  ~ON_Point();
  ON_Point& operator=(const ON_Point&);
  ON_Point& operator=(const ON_3dPoint&);
  
  operator double*();
  operator const double*() const;
  operator ON_3dPoint*();
  operator const ON_3dPoint*() const;
  operator ON_3dPoint&();
  operator const ON_3dPoint&() const;

  /////////////////////////////////////////////////////////////////
  //
  // ON_Object overrides
  //

  /*
  Description:
    Tests an object to see if its data members are correctly
    initialized.
  Parameters:
    text_log - [in] if the object is not valid and text_log
        is not NULL, then a brief englis description of the
        reason the object is not valid is appened to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     object is valid
    false    object is invalid, uninitialized, etc.
  Remarks:
    Overrides virtual ON_Object::IsValid
  */
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  void Dump( ON_TextLog& ) const; // for debugging

  ON_BOOL32 Write(
         ON_BinaryArchive&  // serialize definition to binary archive
       ) const;

  ON_BOOL32 Read(
         ON_BinaryArchive&  // restore definition from binary archive
       );

  ON::object_type ObjectType() const;

  /////////////////////////////////////////////////////////////////
  //
  // ON_Geometry overrides
  //

  int Dimension() const;

  ON_BOOL32 GetBBox( // returns true if successful
         double*,    // boxmin[dim]
         double*,    // boxmax[dim]
         ON_BOOL32 = false  // true means grow box
         ) const;

  ON_BOOL32 Transform( 
         const ON_Xform&
         );

  // virtual ON_Geometry::IsDeformable() override
  bool IsDeformable() const;

  // virtual ON_Geometry::MakeDeformable() override
  bool MakeDeformable();

  ON_BOOL32 SwapCoordinates(
        int, int        // indices of coords to swap
        );

private:
  ON_OBJECT_DECLARE(ON_Point);
};

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_POINTCLOUD_INC_)
#define OPENNURBS_POINTCLOUD_INC_

///////////////////////////////////////////////////////////////////////////////
//
// Class  ON_PointCloud  - unordered set of points
//          ON_PointField  - point height field
//

class ON_CLASS ON_PointCloud : public ON_Geometry
{
  ON_OBJECT_DECLARE(ON_PointCloud);

public:
  ON_PointCloud();
  ON_PointCloud(
    int  // initial point array capacity
    );
  ON_PointCloud( const ON_PointCloud& );
  ~ON_PointCloud();
  ON_PointCloud& operator=( const ON_PointCloud& );

  ON_3dPoint& operator[](int);
  const ON_3dPoint& operator[](int) const;

  /*
  Description:
    Get a point cloud point from an ON_COMPONENT_INDEX.
  Parameters:
    ci - [in] a component index with m_typ set to ON_COMPONENT_INDEX::pointcloud_point
              and 0 <= m_index and m_index < m_P.Count().
  Returns:
    Point at [ci.m_index] or ON_UNSET_POINT if ci is not valid.
  */
  ON_3dPoint Point( ON_COMPONENT_INDEX ci ) const;

  void Destroy();

  /*
  Description:
    Call when the memory pool used the point cloud's arrays is
    no longer in existence.
  */
  void EmergencyDestroy();

  // virtual ON_Object override
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  // virtual ON_Object override
  void Dump( ON_TextLog& ) const; // for debugging

  // virtual ON_Object override
  ON_BOOL32 Write( ON_BinaryArchive& ) const;

  // virtual ON_Object override
  ON_BOOL32 Read( ON_BinaryArchive& );

  // virtual ON_Object override
  ON::object_type ObjectType() const;

  // virtual ON_Geometry override
  int Dimension() const;

  // virtual ON_Geometry override
  ON_BOOL32 GetBBox( // returns true if successful
         double*,    // minimum
         double*,    // maximum
         ON_BOOL32 = false  // true means grow box
         ) const;

  // virtual ON_Geometry override
	bool GetTightBoundingBox( 
			ON_BoundingBox& tight_bbox, 
      int bGrowBox = false,
			const ON_Xform* xform = 0
      ) const;

  // virtual ON_Geometry override
  ON_BOOL32 Transform( 
         const ON_Xform&
         );

  // virtual ON_Geometry override
  bool IsDeformable() const;

  // virtual ON_Geometry override
  bool MakeDeformable();

  // virtual ON_Geometry override
  ON_BOOL32 SwapCoordinates(
        int, int        // indices of coords to swap
        );

  /*
  Description:
    Get the index of the point in the point cloud that is closest
    to P.
  Parameters:
    P - [in]
    closest_point_index - [out]
    maximum_distance - [in] optional distance constraint.
        If maximum_distance > 0, then only points Q with
        |P-Q| <= maximum_distance are tested.
  Returns:
    True if a point is found; in which case *closest_point_index
    is the index of the point.  False if no point is found
    or the input is not valid.
  See Also:
    ON_GetClosestPointInPointList
  */
  bool GetClosestPoint( 
          ON_3dPoint P,
          int* closest_point_index,
          double maximum_distance = 0.0
          ) const;


  /////////////////////////////////////////////////////////////////
  // Interface
  // 
  int PointCount() const;
  void AppendPoint( const ON_3dPoint& );
  void InvalidateBoundingBox(); // call if you change values of points

  // for ordered streams
  void SetOrdered(bool bOrdered); // true if set is ordered stream
  bool IsOrdered() const; // true if set is ordered stream

  // for height fields
  bool HasPlane() const; // true if set is height field above a plane
  void SetPlane( const ON_Plane& );
  const ON_Plane& Plane();
  double Height(int);

  /*
  Returns:
    True if m_N.Count() == m_P.Count().
  */
  bool HasPointNormals() const;

  /*
  Returns:
    True if m_C.Count() == m_P.Count().
  */
  bool HasPointColors() const;


  /*
  Returns:
    Number of points that are hidden.
  */
  int HiddenPointCount() const;

  /*
  Description:
    Destroys the m_H[] array and sets m_hidden_count=0.
  */
  void DestroyHiddenPointArray();

  /*
  Returns:
    If the point cloud has some hidden points, then an array
    of length PointCount() is returned and the i-th
    element is true if the i-th vertex is hidden.
    If no ponts are hidden, NULL is returned.
  */
  const bool* HiddenPointArray() const;

  /*
  Description:
    Set the runtime hidden point flag.
  Parameters:
    point_index - [in] point vertex index
    bHidden - [in] true to hide vertex
  */
  void SetHiddenPointFlag( int point_index, bool bHidden );

  /*
  Description:
    Returns true if the point is hidden.  This is a runtime
    setting that is not saved in 3dm files.
  Parameters:
    point_index - [in]
  Returns:
    True if the point is hidden.
  */
  bool PointIsHidden( int point_index ) const;

  /////////////////////////////////////////////////////////////////
  // Implementation
  ON_3dPointArray m_P;

  /////////////////////////////////////////////////////////////////
  // Implementation - OPTIONAL point normal
  //    Either m_N[] has zero count or it has the same
  //    count as m_P[], in which case m_N[j] reports
  //    the color assigned to m_P[j].
  ON_SimpleArray<ON_3dVector> m_N;

  /////////////////////////////////////////////////////////////////
  // Implementation - OPTIONAL point color
  //    Either m_C[] has zero count or it has the same
  //    count as m_P[], in which case m_P[j] reports
  //    the color assigned to m_P[j].
  ON_SimpleArray<ON_Color> m_C;

  /////////////////////////////////////////////////////////////////
  // Implementation - RUNTIME point visibility - not saved in 3dm files.
  //    If m_H.Count() = m_P.Count(), then
  //    m_H[j] is true if the point m_P[j] 
  //    is hidden.  Otherwise, all points are visible.
  //    m_hidden_count = number of true values in the m_H[] array.
  ON_SimpleArray<bool> m_H;
  int m_hidden_count;

  ON_Plane m_plane;
  ON_BoundingBox m_bbox;
  unsigned int m_flags; // bit 1 is set if ordered
                        // bit 2 is set if plane is set

};

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

////////////////////////////////////////////////////////////////
//
//   Definition of curve proxy object
//
////////////////////////////////////////////////////////////////

#if !defined(OPENNURBS_CURVEPROXY_INC_)
#define OPENNURBS_CURVEPROXY_INC_

/*
Description:
  An ON_CurveProxy is a reference to an ON_Curve.
  One may specify a subdomain of the referenced curve
	and apply a affine reparameterization, possibly  reversing
	the orientation.  The underlying curve cannot be modified through
	the curve proxy.
Details:
	The reference to the "real_curve" is const, so most functions
	which modify an ON_Curve will fail when passed an ON_CurveProxy.
*/
class ON_CurveProxy;
class ON_CLASS ON_CurveProxy : public ON_Curve
{
  ON_OBJECT_DECLARE(ON_CurveProxy);

public:
  // virtual ON_Object::DestroyRuntimeCache override
  void DestroyRuntimeCache( bool bDelete = true );

public:
  ON_CurveProxy();
  ON_CurveProxy( const ON_CurveProxy& );
  ON_CurveProxy( const ON_Curve* );
  ON_CurveProxy( const ON_Curve*, ON_Interval );

  ON_CurveProxy& operator=(const ON_CurveProxy&);

  virtual ~ON_CurveProxy();

  // virtual ON_Object::SizeOf override
  unsigned int SizeOf() const;

  // virtual ON_Object::DataCRC override
  ON__UINT32 DataCRC(ON__UINT32 current_remainder) const;

  /*
  Description:
    Sets the curve geometry that "this" is a proxy for.  
    Sets proxy domain to proxy_curve->Domain().
  Parameters:
    real_curve - [in]
  */
  void SetProxyCurve( const ON_Curve* real_curve );

  /*
  Description:
    Sets the curve geometry that "this" is a proxy for.  
    Sets proxy domain to proxy_curve->Domain().
  Parameters:
    real_curve - [in]
    real_curve_subdomain - [in] increasing sub interval of
            real_curve->Domain().  This interval defines the
            portion the "real" curve geometry that "this" proxy
            uses.
    bReversed - [in] true if the parameterization of "this" proxy
            as a curve is reversed from the underlying "real" curve
            geometry.
  */
  void SetProxyCurve( const ON_Curve* real_curve, 
                      ON_Interval real_curve_subdomain
                      );

  /*
  Returns:
    "Real" curve geometry that "this" is a proxy for.
  */
  const ON_Curve* ProxyCurve() const;

  /*
  Description:
    Sets portion of the "real" curve that this proxy represents.
    Does NOT change the domain of "this" curve.
  Parameters:
    proxy_curve_subdomain - [in] increasing sub interval of
            ProxyCurve()->Domain().  This interval defines the
            portion the curve geometry that "this" proxy uses.
  Remarks:
    This function is poorly named.  It does NOT set the proxy
    curve's domain.  It does set the interval of the "real"
    curve for which "this" is a proxy.
  */
  bool SetProxyCurveDomain( ON_Interval proxy_curve_subdomain );


  /*
  Returns:
    Sub interval of the "real" curve's domain that "this" uses.
    This interval is not necessarily the same as "this" curve's
    domain.
  Remarks:
    This function is poorly named.  It does NOT get the proxy
    curve's domain.  It does get the evaluation interval
    of the "real" curve for which "this" is a proxy.
  */
  ON_Interval ProxyCurveDomain() const;

  /*
  Returns:
    True if "this" as a curve is reversed from the "real" curve
    geometry.
  */
  bool ProxyCurveIsReversed() const;

  /*
  Parameters:
    t - [in] parameter for "this" curve
  Returns:
    Corresponding parameter in m_real_curve's domain.
  */
  double RealCurveParameter( double t ) const;

  /*
  Parameters:
    real_curve_parameter - [in] m_real_curve parameter
  Returns:
    Corresponding parameter for "this" curve
  */
  double ThisCurveParameter( double real_curve_parameter ) const;

private:
  // "real" curve geometry that "this" is a proxy for.
  const ON_Curve* m_real_curve;

  // If true, the parameterization of "this" proxy is
  // the reverse of the m_curve parameterization.
  bool m_bReversed;

  // The m_domain interval is always increasing and included in 
  // m_curve->Domain().  The m_domain interval defines the portion
  // of m_curve that "this" proxy uses and it can be a proper
  // sub-interval of m_curve->Domain().
  ON_Interval m_real_curve_domain;

  // The evaluation domain of this curve.  If "t" is a parameter for
  // "this" and "r" is a parameter for m_curve, then when m_bReversed==false
	// we have 
  // t = m_this_domain.ParameterAt(m_real_curve_domain.NormalizedParameterAt(r))
  // r = m_real_curve_domain.ParameterAt(m_this_domain.NormalizedParameterAt(t))
	// and when m_bReversed==true we have 
  // t = m_this_domain.ParameterAt(1 - m_real_curve_domain.NormalizedParameterAt(r))
  // r = m_real_curve_domain.ParameterAt(1 - m_this_domain.NormalizedParameterAt(t))
  ON_Interval m_this_domain;

  ON_Interval RealCurveInterval( const ON_Interval* sub_domain ) const;


public:
  /*
  Description:
    Get a duplicate of the curve.
  Returns:
    A duplicate of the curve.  
  Remarks:
    The caller must delete the returned curve.
    For non-ON_CurveProxy objects, this simply duplicates the curve using
    ON_Object::Duplicate.
    For ON_CurveProxy objects, this duplicates the actual proxy curve 
    geometry and, if necessary, trims and reverse the result to that
    the returned curve's parameterization and locus match the proxy curve's.
  */
  ON_Curve* DuplicateCurve() const;
  
  /////////////////////////////////////////////////////////////////
  // ON_Object overrides

  /*
  Description:
    Tests an object to see if its data members are correctly
    initialized.
  Parameters:
    text_log - [in] if the object is not valid and text_log
        is not NULL, then a brief englis description of the
        reason the object is not valid is appened to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     object is valid
    false    object is invalid, uninitialized, etc.
  Remarks:
    Overrides virtual ON_Object::IsValid
  */
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  void Dump( ON_TextLog& ) const; // for debugging

  ON_BOOL32 Write( // returns false - nothing serialized
         ON_BinaryArchive&  // open binary file 
       ) const;

  ON_BOOL32 Read( // returns false - nothing serialized
         ON_BinaryArchive&  // open binary file
       );

  /////////////////////////////////////////////////////////////////
  // ON_Geometry overrides

  int Dimension() const;

  ON_BOOL32 GetBBox( // returns true if successful
         double*,    // minimum
         double*,    // maximum
         ON_BOOL32 = false  // true means grow box
         ) const;

  ON_BOOL32 Transform( 
         const ON_Xform&
         );

  /////////////////////////////////////////////////////////////////
  // ON_Curve overrides

  // Returns:
  //   domain of the curve.
  // Remarks:
  //   If m_bReverse is true, this returns the reverse
  //   of m_domain.
  ON_Interval Domain() const;

  /* virtual ON_Curve::SetDomain() override */
  ON_BOOL32 SetDomain( 
        double t0, 
        double t1 
        );

  bool SetDomain( ON_Interval domain );

  int SpanCount() const; // number of smooth spans in curve

  ON_BOOL32 GetSpanVector(
    double*
    ) const; 

  int Degree( // returns maximum algebraic degree of any span 
                  // ( or a good estimate if curve spans are not algebraic )
    ) const; 

  // (optional - override if curve is piecewise smooth)
  ON_BOOL32 GetParameterTolerance( // returns tminus < tplus: parameters tminus <= s <= tplus
         double,  // t = parameter in domain
         double*, // tminus
         double*  // tplus
         ) const;

  ON_BOOL32 IsLinear( // true if curve locus is a line segment between
                 // between specified points
        double = ON_ZERO_TOLERANCE // tolerance to use when checking linearity
        ) const;

  // virtual override of ON_Curve::IsPolyline
  int IsPolyline(
        ON_SimpleArray<ON_3dPoint>* pline_points = NULL,
        ON_SimpleArray<double>* pline_t = NULL
        ) const;

  ON_BOOL32 IsArc( // ON_Arc.m_angle > 0 if curve locus is an arc between
              // specified points
        const ON_Plane* = NULL, // if not NULL, test is performed in this plane
        ON_Arc* = NULL, // if not NULL and true is returned, then arc parameters
                         // are filled in
        double = ON_ZERO_TOLERANCE    // tolerance to use when checking
        ) const;

  ON_BOOL32 IsPlanar(
        ON_Plane* = NULL, // if not NULL and true is returned, then plane parameters
                           // are filled in
        double = ON_ZERO_TOLERANCE    // tolerance to use when checking
        ) const;

  ON_BOOL32 IsInPlane(
        const ON_Plane&, // plane to test
        double = ON_ZERO_TOLERANCE    // tolerance to use when checking
        ) const;

  ON_BOOL32 IsClosed(  // true if curve is closed (either curve has
        void      // clamped end knots and euclidean location of start
        ) const;  // CV = euclidean location of end CV, or curve is
                  // periodic.)

  ON_BOOL32 IsPeriodic(  // true if curve is a single periodic segment
        void 
        ) const;
  
  /*
  Description:
    Search for a derivatitive, tangent, or curvature discontinuity.
  Parameters:
    c - [in] type of continity to test for.  If ON::C1_continuous
    t0 - [in] search begins at t0
    t1 - [in] (t0 < t1) search ends at t1
    t - [out] if a discontinuity is found, the *t reports the
          parameter at the discontinuity.
    hint - [in/out] if GetNextDiscontinuity will be called repeatedly,
       passing a "hint" with initial value *hint=0 will increase the speed
       of the search.       
    dtype - [out] if not NULL, *dtype reports the kind of discontinuity
        found at *t.  A value of 1 means the first derivative or unit tangent
        was discontinuous.  A value of 2 means the second derivative or
        curvature was discontinuous.
    cos_angle_tolerance - [in] default = cos(1 degree) Used only when
        c is ON::G1_continuous or ON::G2_continuous.  If the cosine
        of the angle between two tangent vectors 
        is <= cos_angle_tolerance, then a G1 discontinuity is reported.
    curvature_tolerance - [in] (default = ON_SQRT_EPSILON) Used only when
        c is ON::G2_continuous or ON::Gsmooth_continuous.  
        ON::G2_continuous:
          If K0 and K1 are curvatures evaluated
          from above and below and |K0 - K1| > curvature_tolerance,
          then a curvature discontinuity is reported.
        ON::Gsmooth_continuous:
          If K0 and K1 are curvatures evaluated from above and below
          and the angle between K0 and K1 is at least twice angle tolerance
          or ||K0| - |K1|| > (max(|K0|,|K1|) > curvature_tolerance,
          then a curvature discontinuity is reported.
  Returns:
    true if a discontinuity was found on the interior of the interval (t0,t1).
  Remarks:
    Overrides ON_Curve::GetNextDiscontinuity.
  */
  bool GetNextDiscontinuity( 
                  ON::continuity c,
                  double t0,
                  double t1,
                  double* t,
                  int* hint=NULL,
                  int* dtype=NULL,
                  double cos_angle_tolerance=ON_DEFAULT_ANGLE_TOLERANCE_COSINE,
                  double curvature_tolerance=ON_SQRT_EPSILON
                  ) const;

  /*
  Description:
    Test continuity at a curve parameter value.
  Parameters:
    c - [in] continuity to test for
    t - [in] parameter to test
    hint - [in] evaluation hint
    point_tolerance - [in] if the distance between two points is
        greater than point_tolerance, then the curve is not C0.
    d1_tolerance - [in] if the difference between two first derivatives is
        greater than d1_tolerance, then the curve is not C1.
    d2_tolerance - [in] if the difference between two second derivatives is
        greater than d2_tolerance, then the curve is not C2.
    cos_angle_tolerance - [in] default = cos(1 degree) Used only when
        c is ON::G1_continuous or ON::G2_continuous.  If the cosine
        of the angle between two tangent vectors 
        is <= cos_angle_tolerance, then a G1 discontinuity is reported.
    curvature_tolerance - [in] (default = ON_SQRT_EPSILON) Used only when
        c is ON::G2_continuous or ON::Gsmooth_continuous.  
        ON::G2_continuous:
          If K0 and K1 are curvatures evaluated
          from above and below and |K0 - K1| > curvature_tolerance,
          then a curvature discontinuity is reported.
        ON::Gsmooth_continuous:
          If K0 and K1 are curvatures evaluated from above and below
          and the angle between K0 and K1 is at least twice angle tolerance
          or ||K0| - |K1|| > (max(|K0|,|K1|) > curvature_tolerance,
          then a curvature discontinuity is reported.
  Returns:
    true if the curve has at least the c type continuity at the parameter t.
  Remarks:
    Overrides ON_Curve::IsContinuous.
  */
  bool IsContinuous(
    ON::continuity c,
    double t, 
    int* hint = NULL,
    double point_tolerance=ON_ZERO_TOLERANCE,
    double d1_tolerance=ON_ZERO_TOLERANCE,
    double d2_tolerance=ON_ZERO_TOLERANCE,
    double cos_angle_tolerance=ON_DEFAULT_ANGLE_TOLERANCE_COSINE,
    double curvature_tolerance=ON_SQRT_EPSILON
    ) const;

  ON_BOOL32 Reverse();       // reverse parameterizatrion
                        // Domain changes from [a,b] to [-b,-a]

  ON_BOOL32 Evaluate( // returns false if unable to evaluate
         double,         // evaluation parameter
         int,            // number of derivatives (>=0)
         int,            // array stride (>=Dimension())
         double*,        // array of length stride*(ndir+1)
         int = 0,        // optional - determines which side to evaluate from
                         //         0 = default
                         //      <  0 to evaluate from below, 
                         //      >  0 to evaluate from above
         int* = 0        // optional - evaluation hint (int) used to speed
                         //            repeated evaluations
         ) const;

  // override of virtual ON_Curve::Trim
  ON_BOOL32 Trim(
    const ON_Interval& domain
    );

  // override of virtual ON_Curve::Split
  ON_BOOL32 Split(
      double t,
      ON_Curve*& left_side,
      ON_Curve*& right_side
    ) const;

  int GetNurbForm( // returns 0: unable to create NURBS representation
                   //            with desired accuracy.
                   //         1: success - returned NURBS parameterization
                   //            matches the curve's to wthe desired accuracy
                   //         2: success - returned NURBS point locus matches
                   //            the curve's to the desired accuracy but, on
                   //            the interior of the curve's domain, the 
                   //            curve's parameterization and the NURBS
                   //            parameterization may not match to the 
                   //            desired accuracy.
        ON_NurbsCurve&,
        double = 0.0,
        const ON_Interval* = NULL // OPTIONAL subdomain of ON_CurveProxy::Domain()
        ) const;

  int HasNurbForm( // returns 0: unable to create NURBS representation
                   //            with desired accuracy.
                   //         1: success - returned NURBS parameterization
                   //            matches the curve's to wthe desired accuracy
                   //         2: success - returned NURBS point locus matches
                   //            the curve's to the desired accuracy but, on
                   //            the interior of the curve's domain, the 
                   //            curve's parameterization and the NURBS
                   //            parameterization may not match to the 
                   //            desired accuracy.
        ) const;

  // virtual ON_Curve::GetCurveParameterFromNurbFormParameter override
  ON_BOOL32 GetCurveParameterFromNurbFormParameter(
        double, // nurbs_t
        double* // curve_t
        ) const;

  // virtual ON_Curve::GetNurbFormParameterFromCurveParameter override
  ON_BOOL32 GetNurbFormParameterFromCurveParameter(
        double, // curve_t
        double* // nurbs_t
        ) const;
};


#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

////////////////////////////////////////////////////////////////
//
//   Definition of surface proxy object
//
////////////////////////////////////////////////////////////////

#if !defined(OPENNURBS_SURFACEPROXY_INC_)
#define OPENNURBS_SURFACEPROXY_INC_

class ON_Curve;
class ON_NurbsSurface;
class ON_CLASS ON_SurfaceProxy : public ON_Surface
{
public:
  // virtual ON_Object::DestroyRuntimeCache override
  void DestroyRuntimeCache( bool bDelete = true );

public:
  ON_SurfaceProxy();
  ON_SurfaceProxy(const ON_Surface*);
  ON_SurfaceProxy(const ON_SurfaceProxy&);
  ON_SurfaceProxy& operator=(const ON_SurfaceProxy&);

  virtual ~ON_SurfaceProxy();

  void SetProxySurface( const ON_Surface* proxy_surface );
  const ON_Surface* ProxySurface() const;
  bool ProxySurfaceIsTransposed() const;

private:
  const ON_Surface* m_surface;
  bool m_bTransposed; // proxy surface parameterization is transpose of m_surface

public:
  /*
  Description:
    Get a duplicate of the surface.
  Returns:
    A duplicate of the surface.  
  Remarks:
    The caller must delete the returned surface.
    For non-ON_SurfaceProxy objects, this simply duplicates the surface using
    ON_Object::Duplicate.
    For ON_SurfaceProxy objects, this duplicates the actual proxy surface 
    geometry and, if necessary, transposes the result to that
    the returned surfaces's parameterization and locus match the proxy surface's.
  */
  virtual
  ON_Surface* DuplicateSurface() const;

  /////////////////////////////////////////////////////////////////
  // ON_Object overrides

  // virtual ON_Object::SizeOf override
  unsigned int SizeOf() const;

  // virtual ON_Object::DataCRC override
  ON__UINT32 DataCRC(ON__UINT32 current_remainder) const;

  /*
  Description:
    Tests an object to see if its data members are correctly
    initialized.
  Parameters:
    text_log - [in] if the object is not valid and text_log
        is not NULL, then a brief englis description of the
        reason the object is not valid is appened to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     object is valid
    false    object is invalid, uninitialized, etc.
  Remarks:
    Overrides virtual ON_Object::IsValid
  */
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  void Dump( ON_TextLog& ) const; // for debugging

  ON_BOOL32 Write(
         ON_BinaryArchive&  // open binary file
       ) const;

  ON_BOOL32 Read(
         ON_BinaryArchive&  // open binary file
       );

  /////////////////////////////////////////////////////////////////
  // ON_Geometry overrides

  int Dimension() const;

  ON_BOOL32 GetBBox( // returns true if successful
         double*,    // minimum
         double*,    // maximum
         ON_BOOL32 = false  // true means grow box
         ) const;

  ON_BOOL32 Transform( 
         const ON_Xform&
         );

  /////////////////////////////////////////////////////////////////
  // ON_Surface overrides

  ON_Interval Domain(
    int // 0 gets first parameter's domain, 1 gets second parameter's domain
    ) const;


  /*
  Description:
    Get an estimate of the size of the rectangle that would
    be created if the 3d surface where flattened into a rectangle.
  Parameters:
    width - [out]  (corresponds to the first surface parameter)
    height - [out] (corresponds to the first surface parameter)
  Remarks:
    overrides virtual ON_Surface::GetSurfaceSize
  Returns:
    true if successful.
  */
  ON_BOOL32 GetSurfaceSize( 
      double* width, 
      double* height 
      ) const;

  int SpanCount(
    int // 0 gets first parameter's domain, 1 gets second parameter's domain
    ) const; // number of smooth spans in curve

  ON_BOOL32 GetSpanVector( // span "knots" 
    int, // 0 gets first parameter's domain, 1 gets second parameter's domain
    double* // array of length SpanCount() + 1 
    ) const; // 

  int Degree( // returns maximum algebraic degree of any span 
                  // ( or a good estimate if curve spans are not algebraic )
    int // 0 gets first parameter's domain, 1 gets second parameter's domain
    ) const; 


  ON_BOOL32 GetParameterTolerance( // returns tminus < tplus: parameters tminus <= s <= tplus
         int,     // 0 gets first parameter, 1 gets second parameter
         double,  // t = parameter in domain
         double*, // tminus
         double*  // tplus
         ) const;

  // override virtual ON_Surface::IsIsoparametric
  ISO IsIsoparametric(
        const ON_Curve& curve,
        const ON_Interval* curve_domain = NULL
        ) const;

  // override virtual ON_Surface::IsIsoparametric
  ISO IsIsoparametric(
        const ON_BoundingBox& bbox
        ) const;

  /*
  Description:
    Test a surface to see if it is planar.
  Parameters:
    plane - [out] if not NULL and true is returned,
                  the plane parameters are filled in.
    tolerance - [in] tolerance to use when checking
  Returns:
    true if there is a plane such that the maximum distance from
    the surface to the plane is <= tolerance.
  Remarks:
    Overrides virtual ON_Surface::IsPlanar.
  */
  ON_BOOL32 IsPlanar(
        ON_Plane* plane = NULL,
        double tolerance = ON_ZERO_TOLERANCE
        ) const;

  ON_BOOL32 IsClosed(   // true if surface is closed in direction
        int        // dir  0 = "s", 1 = "t"
        ) const;

  ON_BOOL32 IsPeriodic( // true if surface is periodic in direction
        int        // dir  0 = "s", 1 = "t"
        ) const;

  ON_BOOL32 IsSingular( // true if surface side is collapsed to a point
        int        // side of parameter space to test
                   // 0 = south, 1 = east, 2 = north, 3 = west
        ) const;
  
  /*
  Description:
    Search for a derivatitive, tangent, or curvature 
    discontinuity.
  Parameters:
    dir - [in] If 0, then "u" parameter is checked.  If 1, then
               the "v" parameter is checked.
    c - [in] type of continity to test for.
    t0 - [in] Search begins at t0. If there is a discontinuity
              at t0, it will be ignored.  This makes it 
              possible to repeatedly call GetNextDiscontinuity
              and step through the discontinuities.
    t1 - [in] (t0 != t1)  If there is a discontinuity at t1 is 
              will be ingored unless c is a locus discontinuity
              type and t1 is at the start or end of the curve.
    t - [out] if a discontinuity is found, then *t reports the
          parameter at the discontinuity.
    hint - [in/out] if GetNextDiscontinuity will be called 
       repeatedly, passing a "hint" with initial value *hint=0
       will increase the speed of the search.       
    dtype - [out] if not NULL, *dtype reports the kind of 
        discontinuity found at *t.  A value of 1 means the first 
        derivative or unit tangent was discontinuous.  A value 
        of 2 means the second derivative or curvature was 
        discontinuous.  A value of 0 means teh curve is not
        closed, a locus discontinuity test was applied, and
        t1 is at the start of end of the curve.
    cos_angle_tolerance - [in] default = cos(1 degree) Used only
        when c is ON::G1_continuous or ON::G2_continuous.  If the
        cosine of the angle between two tangent vectors is 
        <= cos_angle_tolerance, then a G1 discontinuity is reported.
    curvature_tolerance - [in] (default = ON_SQRT_EPSILON) Used 
        only when c is ON::G2_continuous.  If K0 and K1 are 
        curvatures evaluated from above and below and 
        |K0 - K1| > curvature_tolerance, then a curvature 
        discontinuity is reported.
  Returns:
    Parametric continuity tests c = (C0_continuous, ..., G2_continuous):

      true if a parametric discontinuity was found strictly 
      between t0 and t1. Note well that all curves are 
      parametrically continuous at the ends of their domains.

    Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):

      true if a locus discontinuity was found strictly between
      t0 and t1 or at t1 is the at the end of a curve.
      Note well that all open curves (IsClosed()=false) are locus
      discontinuous at the ends of their domains.  All closed 
      curves (IsClosed()=true) are at least C0_locus_continuous at 
      the ends of their domains.
  */
  bool GetNextDiscontinuity( 
                  int dir,
                  ON::continuity c,
                  double t0,
                  double t1,
                  double* t,
                  int* hint=NULL,
                  int* dtype=NULL,
                  double cos_angle_tolerance=ON_DEFAULT_ANGLE_TOLERANCE_COSINE,
                  double curvature_tolerance=ON_SQRT_EPSILON
                  ) const;

  /*
  Description:
    Test continuity at a surface parameter value.
  Parameters:
    c - [in] continuity to test for
    s - [in] surface parameter to test
    t - [in] surface parameter to test
    hint - [in] evaluation hint
    point_tolerance - [in] if the distance between two points is
        greater than point_tolerance, then the surface is not C0.
    d1_tolerance - [in] if the difference between two first derivatives is
        greater than d1_tolerance, then the surface is not C1.
    d2_tolerance - [in] if the difference between two second derivatives is
        greater than d2_tolerance, then the surface is not C2.
    cos_angle_tolerance - [in] default = cos(1 degree) Used only when
        c is ON::G1_continuous or ON::G2_continuous.  If the cosine
        of the angle between two normal vectors 
        is <= cos_angle_tolerance, then a G1 discontinuity is reported.
    curvature_tolerance - [in] (default = ON_SQRT_EPSILON) Used only when
        c is ON::G2_continuous.  If K0 and K1 are curvatures evaluated
        from above and below and |K0 - K1| > curvature_tolerance,
        then a curvature discontinuity is reported.
  Returns:
    true if the surface has at least the c type continuity at the parameter t.
  Remarks:
    Overrides virtual ON_Surface::IsContinuous
  */
  bool IsContinuous(
    ON::continuity c,
    double s, 
    double t, 
    int* hint = NULL,
    double point_tolerance=ON_ZERO_TOLERANCE,
    double d1_tolerance=ON_ZERO_TOLERANCE,
    double d2_tolerance=ON_ZERO_TOLERANCE,
    double cos_angle_tolerance=ON_DEFAULT_ANGLE_TOLERANCE_COSINE,
    double curvature_tolerance=ON_SQRT_EPSILON
    ) const;

  ON_BOOL32 Reverse(  // reverse parameterizatrion, Domain changes from [a,b] to [-b,-a]
    int // dir  0 = "s", 1 = "t"
    );

  ON_BOOL32 Transpose(); // transpose surface parameterization (swap "s" and "t")

  // work horse evaluator
  ON_BOOL32 Evaluate( // returns false if unable to evaluate
         double, double, // evaluation parameters
         int,            // number of derivatives (>=0)
         int,            // array stride (>=Dimension())
         double*,        // array of length stride*(ndir+1)*(ndir+2)/2
         int = 0,        // optional - determines which quadrant to evaluate from
                         //         0 = default
                         //         1 from NE quadrant
                         //         2 from NW quadrant
                         //         3 from SW quadrant
                         //         4 from SE quadrant
         int* = 0        // optional - evaluation hint (int[2]) used to speed
                         //            repeated evaluations
         ) const;


  ON_Curve* IsoCurve(
         int dir,
         double c
         ) const;

  int GetNurbForm( // returns 0: unable to create NURBS representation
                   //            with desired accuracy.
                   //         1: success - returned NURBS parameterization
                   //            matches the surface's to wthe desired accuracy
                   //         2: success - returned NURBS point locus matches
                   //            the surfaces's to the desired accuracy but, on
                   //            the interior of the surface's domain, the 
                   //            surface's parameterization and the NURBS
                   //            parameterization may not match to the 
                   //            desired accuracy.
        ON_NurbsSurface&,
        double = 0.0
        ) const;

  int HasNurbForm( // returns 0: unable to create NURBS representation
                   //            with desired accuracy.
                   //         1: success - returned NURBS parameterization
                   //            matches the surface's to wthe desired accuracy
                   //         2: success - returned NURBS point locus matches
                   //            the surfaces's to the desired accuracy but, on
                   //            the interior of the surface's domain, the 
                   //            surface's parameterization and the NURBS
                   //            parameterization may not match to the 
                   //            desired accuracy.
        ) const;

  bool GetSurfaceParameterFromNurbFormParameter(
        double nurbs_s, double nurbs_t,
        double* surface_s, double* surface_t
        ) const;

  bool GetNurbFormParameterFromSurfaceParameter(
        double surface_s, double surface_t,
        double* nurbs_s,  double* nurbs_t
        ) const;

private:

  ON_OBJECT_DECLARE(ON_SurfaceProxy);
};

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_MESH_INC_)
#define OPENNURBS_MESH_INC_

///////////////////////////////////////////////////////////////////////////////
//
// Class  ON_Mesh
//
class ON_CLASS ON_MeshParameters
{
  // surface meshing perameters
public:

  enum MESH_STYLE
  {
    // All of these enum values must be in the range 0-255 because
    // unsigned chars are use for storage in some locations.
    unset_mesh_style      =   0,
    render_mesh_fast      =   1, // Use ON_MeshParameters::FastRenderMesh
    render_mesh_quality   =   2, // Use ON_MeshParameters::QualityRenderMesh
    // 3 - 8 reserved for future predefined render mesh styles
    render_mesh_custom    =   9,// Use ON_3dmSettings::m_CustomRenderMeshSettings
    render_mesh_per_object = 10 // Use ON_Object::GetMeshParameters().
  };

  /*
  Description:
    Parameters that create render meshes where meshing
    speed is prefered over mesh quality.
  */
  static 
  const ON_MeshParameters FastRenderMesh;

  /*
  Description:
    Parameters that create render meshes where mesh quality
    is prefered over meshing speed.
  */
  static 
  const ON_MeshParameters QualityRenderMesh;

  /*
  Description:
    Get a value to use for tolerance based on the relative_tolerance
    and actual size.
  Parameters:
    relative_tolerance - [in] 
      See m_relative_tolerance field
    actual_size - [in]
      Diagonal ov object bounding box or some similar measure of
      an object's 3d size.
  Returns:
    A value that can be used for m_tolerance if no
    user specified value is available.
  */
  static
  double Tolerance( double relative_tolerance, double actual_size );

  /*
  Description:
    Get a value to use for minimum edge length base on max_edge_length
    and tolerance settings.
  Parameters:
    max_edge_length - [in] 
      3d maximum edge length used to create mesh.
    tolerance - [in]
      3d distance tolerance used to create mesh.
  Returns:
    A value that can be used for m_min_edge_length if no
    user specified value is available.
  */
  static
  double MinEdgeLength( double max_edge_length, double tolerance );

  ON_MeshParameters();
  ~ON_MeshParameters();
  // C++ default works fine // ON_MeshParameters(const ON_MeshParameters& );
  // C++ default works fine // ON_MeshParameters& operator=(const ON_MeshParameters&);
 
  bool operator!=(const ON_MeshParameters&) const;
  bool operator==(const ON_MeshParameters&) const;

  // compares with mesh's mesh parameters
  bool operator==(const ON_Mesh&) const;
  bool operator!=(const ON_Mesh&) const;
  
  void Dump( ON_TextLog& test_log ) const;

  void Default(); 

  /*
  Description:
    Tool for provding a simple slider interface.
  Parameters:
    density - [in] 0.0 <= density <= 1.0
      0 quickly creates coarse meshes.
      1 creates accurate meshes but takes lots of time.
  */
  void Set(
    double density,
    double min_edge_length = 0.0001
    );

  /*
  Description:
    Sets the meshing parameters to ON_MeshParameters::FastRenderMesh.
  */
  ON_DEPRECATED
  void JaggedAndFasterMeshParameters();

  /*
  Description:
    Sets the meshing parameters to ON_MeshParameters::QualityRenderMesh.
  */
  ON_DEPRECATED
  void SmoothAndSlowerMeshParameters();

  /*
  Description:
    Sets the meshing parameters to create the default
    analysis mesh.
  */
  void DefaultAnalysisMeshParameters();

  // Compare() ignores weld and curvature settings
  // Ignores m_min_tolerance setting.
  int Compare( const ON_MeshParameters& ) const;

  /*
  Description:
    Compares all meshing parameters that control mesh geometry.
    Does not compare m_bCustomSettings, m_bComputeCurvature, 
    m_bDoublePrecision, m_min_tolerance, and m_texture_range.
  */
  int CompareGeometrySettings( const ON_MeshParameters& ) const;


  bool Write( ON_BinaryArchive& ) const;
  bool Read( ON_BinaryArchive& );
  ON__UINT32 DataCRC(ON__UINT32) const;


  // Meshing happens in two stages.  The first stage creates a
  // rectangular grid.  The second stage refines the grid until
  // the mesh meets all meshing requirements.  The third stage
  // combines coincident vertices if the resulting mesh is a composite.
  
  bool m_bCustomSettings;    // false - if these settings were used to create
                             //         a mesh and the app settings don't match,
                             //         then remesh the object using the app
                             //         settings.
                             // true  - these settings are customized for a
                             //         particular object - ignore app mesh
                             //         settings.

  bool m_bComputeCurvature;  // false - (default) - ON_Mesh::m_K[] not computed
                             // true  - ON_Mesh::m_K[] computed

  bool m_bSimplePlanes;      // false - (default) planar surfaces are meshed
                             //          using the controls below.
                             // true   - planar surfaces are meshed using
                             //          minimal number of triangles and
                             //          aspect/edge controls are ignored.

  bool m_bRefine;            // false - skip stage 2
                             // true  - (default) do stage 2

  bool m_bJaggedSeams;       // false - (default) edges of meshes of joined 
                             //          b-rep faces match with no gaps or
                             //          "T" joints.
                             // true   - faces in b-reps are meshed independently.
                             //          This is faster but results in gaps and
                             //          "T" joints along seams between faces.

  bool m_bDoublePrecision;   // false - (default) the mesh vertices will be 
                             //         float precision values in the m_V[] array.
                             // true -  The mesh vertices will be double precision
                             //         values in the DoublePrecisionVertices()
                             //         array.  Float precision values will also
                             //         be returned in the m_V[] array.
  bool m_bCustomSettingsEnabled; // false - if these settings should be ignored
                             //         when used as per object custom render mesh 
                             //         settings.
                             //  true - ignore these settings.
  unsigned char m_mesher;    // 0 = slow mesher, 1 = fast mesher
    
  int m_texture_range;       // 1: normalized
                             //
                             //          each face has a normalized texture range 
                             //          [0,1]x[0,1].
                             //
                             // 2: packed normalized (default)
                             //
                             //          each face in a polysurface is assigned
                             //          a texture range that is a subrectangle 
                             //          of [0,1]x[0,1].  The subrectangles are 
                             //          mutually disjoint and packed into
                             //          into [0,1]x[0,1] in a way that minimizes
                             //          distortion and maximizes the coverage
                             //          of [0,1]x[0,1].  (This texture style 
                             //          is suitable for creating texture maps 
                             //          with popular 3D painting programs.)

private:
  unsigned int m_reserved2;
public:
                           
  // These controls are used in both stages

  double m_tolerance; // maximum distance from center of edge to surface

        
  double m_relative_tolerance; // If 0 < m_relative_tolerance < 1, 
  double m_min_tolerance;      // then the maximum distance from the
                               // center of an edge to the surface will
                               // be <= T, where T is the larger of
                               // (m_min_tolerance,d*m_relative_tolerance), 
                               // where d is an esimate of the size of the
                               // object being meshed.


  double m_min_edge_length; // edges shorter than m_min_edge_length will
                            // not be split even if the do not meet other
                            // meshing requirements

  double m_max_edge_length; // edges longer than m_max_edge_length will
                            // be split even when they meet all other
                            // meshing requirements

  // These controls are used during stage 1 to generate the grid
  double m_grid_aspect_ratio;  // desired aspect ratio of quads in grid
                               // 0.0 = any aspect ratio is acceptable
                               // values >0 and < sqrt(2) are treated as sqrt(2)
  int    m_grid_min_count;     // minimum number of quads in initial grid
  int    m_grid_max_count;     // desired masimum number of quads in initial grid
  double m_grid_angle;         // (in radians) maximum angle between surface
                               // normal evaluated at adjacent vertices.
                               // 0.0 is treated as pi.
  double m_grid_amplification; // The parameters above generate a grid.
                               // If you want fewer quads, set m_grid_amplification
                               // to a value < 1.  If you want more quads,
                               // set m_grid_amplification to a value > 1.
                               // default = 1 and values <= 0 are treated as 1.

  // These controls are used during stage 2 to refine the grid
  double m_refine_angle;       // (in radians) maximum angle in radians between
                               // surface normal evaluated at adjacent vertices.

  // These controls are used during stage 3
  int     m_face_type;         // 0 = mixed triangle and quads
                               // 1 = all triangles
                               // 2 = all quads
private:
  unsigned int m_reserved3;
};

class ON_CLASS ON_MeshCurvatureStats
{
public:
  ON_MeshCurvatureStats();
  ~ON_MeshCurvatureStats();
  ON_MeshCurvatureStats(const ON_MeshCurvatureStats& );
  ON_MeshCurvatureStats& operator=(const ON_MeshCurvatureStats&);

  void Destroy();
  void EmergencyDestroy();
  
  bool Set( ON::curvature_style,
            int,           // Kcount,
            const ON_SurfaceCurvature*, // K[]
            const ON_3fVector*, // N[] surface normals needed for normal sectional curvatures
            double = 0.0   // if > 0, value is used for "infinity"
            );

  bool Write( ON_BinaryArchive& ) const;
  bool Read( ON_BinaryArchive& );

  ON::curvature_style m_style;
  
  double m_infinity; // curvature values >= this are considered infinite
                     // and not used to compute the m_average or m_adev
  int    m_count_infinite; // number of "infinte" values
  int    m_count;    // count of "finite" values
  double m_mode;     // mode of "finite" values
  double m_average;  // average of "finite" values
  double m_adev;     // average deviation of "finite" values

  ON_Interval m_range;
};

///////////////////////////////////////////////////////////////////////////////
//
// Class  ON_MeshTopology
//

struct ON_MeshTopologyVertex
{
  // m_tope_count = number of topological edges that begin or 
  // end at this topological vertex.
  int m_tope_count;

  // m_topei[] is an array of length m_tope_count with the indices 
  // of the topological edges that begin or end at this topological
  // vertex.  Generally, these edges are listed in no particular
  // order.  If you want the edges listed "radially", then call
  // ON_MeshTopology::SortVertexEdges.
  const int* m_topei;

  // m_v_count = number of ON_Mesh vertices that correspond to 
  // this topological vertex.
  int m_v_count;

  // m_vi[] is an array of length m_v_count with the indices of the
  // ON_Mesh vertices that correspond to this topological vertex.
  const int* m_vi;
};

struct ON_MeshTopologyEdge
{
  // m_topvi[] = indices of the topological verteices where the 
  // edge begins and ends.
  int m_topvi[2];

  // m_topf_count = number of topological faces tat share this topological edge
  int m_topf_count;

  // m_topfi[] is an array of length m_topf_count with the indices of the
  // topological faces that share this topological edge.
  const int* m_topfi;
};

struct ON_CLASS ON_MeshTopologyFace
{
  /*
    m_topei[] = indices of the topological edges that bound the face.
    If m_topei[2] = m_topei[3], then the face is a triangle, otherwise
    the face is a quad.
 
    NOTE WELL:
      The topological edge with index m_topei[k] ENDS at the
      vertex corresponding to ON_MeshFace.vi[k]. So, ...

      If the face is a quad, (ON_MeshFace.vi[2]!=ON_MeshFace.vi[3]),
      the topological edge with index m_topei[0] STARTS at
      ON_MeshFace.vi[3] and ENDS at ON_MeshFace.vi[0],
      the topological edge with index m_topei[1] STARTS at
      ON_MeshFace.vi[0] and ENDS at ON_MeshFace.vi[1],
      the topological edge with index m_topei[2] STARTS at
      ON_MeshFace.vi[1] and ENDS at ON_MeshFace.vi[2], and
      the topological edge with index m_topei[3] STARTS at
      ON_MeshFace.vi[0] and ENDS at ON_MeshFace.vi[1],
      
      If the face is a triangle, (ON_MeshFace.vi[2]==ON_MeshFace.vi[3]),
      the topological edge with index m_topei[0] STARTS at
      ON_MeshFace.vi[2] and ENDS at ON_MeshFace.vi[0],
      the topological edge with index m_topei[1] STARTS at
      ON_MeshFace.vi[0] and ENDS at ON_MeshFace.vi[1],
      the topological edge with index m_topei[2] STARTS at
      ON_MeshFace.vi[1] and ENDS at ON_MeshFace.vi[2].
  */
  int m_topei[4];

  /*
    If m_reve[i] is 0, then the orientation of the edge matches the
    orientation of the face.  If m_reve[i] is 1, then the orientation
    of the edge is opposite that of the face.
  */
  char m_reve[4];

  /*
  Description:
    A topological mesh face is a valid triangle if m_topei[0], 
    m_topei[1], m_topei[2] are distinct edges and 
    m_topei[3]=m_topei[2].
  Returns:
    True if face is a triangle.
  */
  bool IsTriangle() const;

  /*
  Description:
    A topological mesh face is a valid quad if m_topei[0], 
    m_topei[1], m_topei[2], and m_topei[3] are distinct edges.
  Returns:
    True if face is a quad.
  */
  bool IsQuad() const;

  /*
  Description:
    A topological mesh face is valid if m_topei[0], m_topei[1], 
    and m_topei[2] are mutually distinct, and m_topei[3] is 
    either equal to m_topei[2] or mutually distinct from the
    first three indices.
  Returns:
    True if face is valid.
  */
  bool IsValid( ) const;
};

class ON_CLASS ON_MeshFace
{
public:
  int vi[4]; // vertex index - vi[2]==vi[3] for tirangles

  /*
  Returns:
    True if vi[2] == vi[3];
  Remarks:
    Assumes the face is valid.
  */
  bool IsTriangle() const;

  /*
  Returns:
    True if vi[2] != vi[3];
  Remarks:
    Assumes the face is valid.
  */
  bool IsQuad() const;

  /*
  Description:
    Determine if a face is valid by checking that the vertices
    are distinct.
  Parameters:
    mesh_vertex_count - [in]
      number of vertices in the mesh
    V - [in]
      optional array of mesh_vertex_count vertex locations.
  Returns:
    true
      The face is valid.
    false
      The face is not valid. It may be possible to repair the
      face by calling ON_MeshFace::Repair().
  */
  bool IsValid( 
        int mesh_vertex_count
        ) const;
  bool IsValid(
        int mesh_vertex_count,
        const ON_3fPoint* V
        ) const;
  bool IsValid(
        int mesh_vertex_count,
        const ON_3dPoint* V
        ) const;

  /*
  Description:
    Reverses the order of the vertices in v[].
    vi[0] is not changed.
  */
  void Flip();

  /*
  Description:
    If IsValid() returns false, then you can use Repair()
    to attempt to create a valid triangle. 
  Parameters:
    mesh_vertex_count - [in]
      number of vertices in the mesh
    V - [in]
      optional array of mesh_vertex_count vertex locations.
  Returns:
    true
     repair was successful and v[0], v[1], vi[2] have distinct valid
     values and v[2] == v[3].
    false
     this face's vi[] values cannot be repaired    
  */
  bool Repair(
        int mesh_vertex_count
        );
  bool Repair(
        int mesh_vertex_count,
        const ON_3fPoint* V
        );
  bool Repair(
        int mesh_vertex_count,
        const ON_3dPoint* V
        );

  /*
  Description:
    Compute the face normal
  Parameters:
    dV - [in] double precision vertex array for the mesh
    fV - [in] float precision vertex array for the mesh
    FN - [out] face normal
  Returns:
    true if FN is valid.
  */
  bool ComputeFaceNormal( const ON_3dPoint* dV, ON_3dVector& FN ) const;
  bool ComputeFaceNormal( const ON_3fPoint* fV, ON_3dVector& FN ) const;
};

struct ON_MeshFaceSide
{
  int vi[2]; // vertex indices
  int fi;    // mesh m_F[] array face index
  unsigned char  side;  // edge connects mesh m_V[m_F[fi].vi[side]] and m_V[m_F[fi].vi[(side+1)%4]]
  unsigned char  dir;   // 0 = counterclockwise, 1 = clockwise (reversed)
  unsigned short value; // Set to zero by ON_Mesh::GetFaceSideList(). Can be used as needed.
};


/*
Description:
  Sort the sides[] array of ON_MeshFaceSide structs in dictionary
  order by "vi[0]", "vi[1]", "fi", and "side" values.
Paramters:
  sides_count - [in]
    number of elements in the sides[] array.
  sides - [in/out]
Remarks:
  The function is thread safe.
*/
ON_DECL
void ON_SortMeshFaceSidesByVertexIndex( 
        int sides_count, 
        struct ON_MeshFaceSide* sides 
        );

struct ON_MeshPart
{
  // ON_Mesh faces with indices fi[0] <= i < fi[1] reference
  // vertices with indices vi[0] <= j < vi[1].
  int vi[2]; // subinterval of mesh m_V[] array
  int fi[2]; // subinterval of mesh m_F[] array
  int vertex_count;   // = vi[1] - vi[0];
  int triangle_count; // tris + 2*quads >= fi[1] - fi[0]
};

#if defined(ON_DLL_TEMPLATE)
// This stuff is here because of a limitation in the way Microsoft
// handles templates and DLLs.  See Microsoft's knowledge base 
// article ID Q168958 for details.
#pragma warning( push )
#pragma warning( disable : 4231 )
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_MeshFace>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_MeshTopologyVertex>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_MeshTopologyEdge>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_MeshTopologyFace>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<struct ON_MeshPart>;
#pragma warning( pop )
#endif

class ON_CLASS ON_MeshTopology
{
  // A mesh topology class is always associated with an ON_Mesh
  // and can be retrieved by calling ON_Mesh::Topology()
public:
  ON_MeshTopology();
  ~ON_MeshTopology();

  bool IsValid() const;

  void Dump( ON_TextLog& ) const;

  //////////
  // The parent ON_Mesh geometry used to compute this mesh topology.
  const ON_Mesh* m_mesh;

  //////////
  // number of topoligical vertices (<= m_mesh.VertexCount())
  int TopVertexCount() const;

  //////////
  // number of topoligical edges
  int TopEdgeCount() const;
  
  //////////
  // number of topoligical faces (same as m_mesh.FaceCount())
  int TopFaceCount() const;

  /*
  Description:
    Get a vertex reference to a mesh vertex index.
  Parameters:
    ci - [in] component index with type mesh_vertex or meshtop_vertex.
  Returns:
    a reference to the vertex
  */
  class ON_MeshVertexRef VertexRef(ON_COMPONENT_INDEX ci) const;

  class ON_MeshVertexRef VertexRef(int topv_index) const;

  /*
  Description:
    Get an edge reference.
  Parameters:
    ci - [in] component index with type meshtop_edge.
  Returns:
    a reference to the edge
  */
  class ON_MeshEdgeRef EdgeRef(ON_COMPONENT_INDEX ci) const;

  class ON_MeshEdgeRef EdgeRef(int tope_index) const;

  /*
  Description:
    Get a face reference from a mesh face index.
  Parameters:
    ci - [in] component index with type mesh_face.
  Returns:
    a reference to the face.
  Remarks:
    The OM_Mesh.m_F[] and ON_MeshTopology.m_topf[] arrays
    are parallel arrays; corresponding faces have identical
    indices.
  */
  class ON_MeshFaceRef FaceRef(ON_COMPONENT_INDEX ci) const;

  class ON_MeshFaceRef FaceRef(int topf_index) const;


  /*
  Description:
    Get the 3d point location of a vertex.
  Parameters:
    topv_index - [in];
  Returns:
    Location of vertex.
  */
  ON_3fPoint TopVertexPoint(
    int topv_index
    ) const;

  /*
  Description:
    Get the 3d line along an edge.
  Parameters:
    tope_index - [in];
  Returns:
    Line along edge.  If input is not valid,
    the line.from and to are ON_UNSET_POINT
  */
  ON_Line TopEdgeLine(
    int tope_index
    ) const;

  ////////
  // returns index of edge that connects topological vertices
  // returns -1 if no edge is found.
  int TopEdge(
    int vtopi0,
    int vtopi1 // ON_MeshTopology vertex topology indices
    ) const;

  ////////
  // returns ON_MeshTopology vertex topology index of a face
  // corner.  The face is triangle iv TopFaceVertex(2) = TopFaceVertex(3)
  bool GetTopFaceVertices(
    int topfi,    // ON_MeshTopology face topology index (= ON_Mesh face index)
    int topvi[4]  // ON_MeshTopology vertex indices returned here
    ) const;

  /*
  Description:
    Sort the m_topei[] list of a mesh topology vertex so that
    the edges are in radial order.  The "const" is a white
    lie to make this function easier to call.
  Parameter:
    topvi - [in] index of vertex in m_topv[] array.
  Remarks:
    A nonmanifold edge is treated as a boundary edge with respect
    to sorting.  If any boundary or nonmanifold edges end at the
    vertex, then the first edge will be a boundary or nonmanifold
    edge.
  */
  bool SortVertexEdges( int topvi ) const;

  /*
  Description:
    Sort the m_topei[] list of every mesh topology vertex so 
    that the edges are in radial order.  The "const" is a white
    lie to make this function easier to call.
  Remarks:
    Same as
    for ( int topvi = 0; topvi < m_topv.Count(); topvi++ )
      SortVertexEdges(topvi);
  */
  bool SortVertexEdges() const;

  /*
  Description:
    Returns true if the topological vertex is hidden. 
  Parameters:
    topvi - [in] mesh topology vertex index.
  Returns:
    True if mesh topology vertex is hidden.
  Remarks:
    The mesh topology vertex is hidden if and only if
    all the ON_Mesh vertices it represents is hidden.
  */
  bool TopVertexIsHidden( int topvi ) const;

  /*
  Description:
    Returns true if the topological edge is hidden. 
  Parameters:
    topei - [in] mesh topology edge index.
  Returns:
    True if mesh topology edge is hidden.
  Remarks:
    The mesh topology edge is hidden if and only if
    either of its mesh topology vertices is hidden.
  */
  bool TopEdgeIsHidden( int topei ) const;

  /*
  Description:
    Returns true if the topological face is hidden. 
  Parameters:
    topfi - [in] mesh topology face index.
  Returns:
    True if mesh topology face is hidden.
  Remarks:
    The mesh topology face is hidden if and only if
    any of its mesh topology edges are hidden.
  */
  bool TopFaceIsHidden( int topfi ) const;

  //////////
  // m_topv_map[] has length m_mesh.VertexCount() and 
  // m_topv[m_topv_map[vi]] is the topological mesh vertex that is assocated
  // the with the mesh vertex m_mesh.m_V[vi].
  ON_SimpleArray<int> m_topv_map;

  ////////////
  // Array of topological mesh vertices.  See the comments in the definition
  // of ON_MeshTopologyVertex for details.
  ON_SimpleArray<ON_MeshTopologyVertex> m_topv;

  ////////////
  // Array of topological mesh edges.  See the comments in the definition
  // of ON_MeshTopologyEdge for details.
  ON_SimpleArray<ON_MeshTopologyEdge> m_tope;

  ////////////
  // Array of topological mesh faces.  The topological face
  // m_topf[fi] corresponds to the mesh face ON_Mesh.m_F[fi].
  // See the comments in the definition of ON_MeshTopologyFace
  // for details. To get the indices of the mesh topology 
  // vertices at the face corners use 
  // topvi = m_topv_map[m_mesh.m_F[fi].vi[n]]
  ON_SimpleArray<ON_MeshTopologyFace> m_topf;

  /*
  Description:
    Expert user function for efficiently getting the
    integer arrays used by the ON_MeshTopologyVertex
    and ON_MeshTopologyEdge classes.
  Parameters:
    count - [in] number of integers in array
  Returns:
    pointer to integer array.  The array memory
    will be freed by ~ON_MeshTopology()
  */
  int* GetIntArray(int count);

private:
  friend class ON_Mesh;

  bool Create();
  void Destroy();
  void EmergencyDestroy();

  // efficient workspaces for
  struct memchunk
  {
    struct memchunk* next;
  } *m_memchunk;

  // NOTE: this field is a bool with valid values of 0 and 1.
  volatile int m_b32IsValid; // sizeof(m_bIsValid) must be 4 - it is used in sleep locks.
                    //    0: Not Valid
                    //    1: Valid
                    //   -1: Sleep locked - ON_Mesh::Topology() calculation is in progress
  int WaitUntilReady(int sleep_value) const; // waits until m_b32IsValid >= 0

private:
  // no implementation
  ON_MeshTopology(const ON_MeshTopology&);
  ON_MeshTopology& operator=(const ON_MeshTopology&);
};

struct ON_MeshNgon
{
  // Number of N-gon corners (N >= 3)
  int N;

  // N-gon vertex indices
  // An array of N indices into the mesh's m_V[] vertex array.
  // If the ON_MeshNgon is returned by the ON_MeshNgonList::AddNgon()
  // function, then the memory for vi is managed by the ON_MeshNgonList
  // class.  
  int* vi;

  // N-gon face indices
  // An array of N indices into the mesh's m_F[] face array.
  // Often, only N-2 indices are used. Unused indices are set to -1.
  // If the ON_MeshNgon is returned by the ON_MeshNgonList::AddNgon()
  // function, then the memory for fi is managed by the ON_MeshNgonList
  // class.  
  int* fi;
};

class ON_CLASS ON_MeshNgonList
{
public:
  ON_MeshNgonList();
  ~ON_MeshNgonList();
  ON_MeshNgonList(const ON_MeshNgonList&);
  ON_MeshNgonList& operator=(const ON_MeshNgonList&);


  /*
  Description:
    Add an N-gon to the list
  Parameters:
    N - [in] number of vertices ( >= 5)
    vi - [in] array of N vertex indices into the mesh's m_V[] array.
    fi - [in] array of N face indices into the mesh's m_F[] array.
              Unused indices are set to -1.  In many cases
              there are N-2 valid indices and these are triangles.
  Remarks:
    Adding an N-gon may invalidate any pointers previously
    returned by Ngon.
  */
  bool AddNgon(int N, const int* vi, const int* fi);
  struct ON_MeshNgon* AddNgon(int N);

  /*
  Returns:
    Number of Ngons
  */
  int NgonCount() const;

  /*
  Parameters:
    Ngon_index - [in] zero based index
  Returns:
    NULL or a pointer to the Ngon
  */
  ON_MeshNgon* Ngon(int Ngon_index) const;

  /*
  Description:
    If you know about how many ngons you will need,
    then use the function to reserve space for them.
  */
  bool ReserveNgonCapacity(int capacity);

  /*
  Description:
    Destroy N-gon list
  */
  void Destroy();

  /*
  Returns:
    Approximate number of bytes used by this class.
  */
  unsigned int SizeOf() const;

private:
  int m_ngons_count;
  int m_ngons_capacity;
  ON_MeshNgon* m_ngons;
  struct ON_NGON_MEMBLK* m_memblk_list;
};

class ON_CLASS ON_MeshPartition
{
public:
  ON_MeshPartition();
  ~ON_MeshPartition();

  // maximum number of vertices in a partition
  int m_partition_max_vertex_count;
  // maximum number of triangles in a partition (quads count as 2 triangles)
  int m_partition_max_triangle_count;

  // Partition i uses 
  // vertices m_V[j] where 
  //
  //   m_part[i].vi[0] <= j < m_part[i].vi[1] 
  //
  // and uses faces m_F[k] where
  //
  //    m_part[i].fi[0] <= k < m_part[i].fi[1]
  ON_SimpleArray<struct ON_MeshPart> m_part;
};



class ON_CLASS ON_MappingTag
{
public:
  ON_MappingTag();
  void Default();
  bool Write(ON_BinaryArchive&) const;
  bool Read(ON_BinaryArchive&);
  void Dump( ON_TextLog& ) const;
  void Transform( const ON_Xform& xform );
  void Set(const ON_TextureMapping& mapping);

  /*
  Description:
    Sets the tag to the value the meshes have that
    come out of ON_Brep::CreateMesh().
  */
  void SetDefaultSurfaceParameterMappingTag();

  int Compare( const ON_MappingTag& other,
               bool bCompareId = true,
               bool bCompareCRC = true,
               bool bCompareXform = true
               ) const;

  /*
  Returns:
    True if the mapping tag is set.
  */
  bool IsSet() const;

  /*
  Returns:
    True if the mapping tag is for a mapping with
    type ON_TextureMapping::srfp_mapping with
    m_uvw = identity.
  */
  bool IsDefaultSurfaceParameterMapping() const;

  // Identifies the mapping used to create the texture 
  // coordinates and records transformations applied 
  // to the mesh after the texture coordinates were
  // calculated.  If the texture mapping does not
  // change when the mesh is transformed, then set 
  // m_mesh_xform to zero so that compares will work right.
  //
  // 
  ON_UUID                 m_mapping_id;   // ON_TextureMapping::m_mapping_id
  ON_TextureMapping::TYPE m_mapping_type; // ON_TextureMapping::m_type
  ON__UINT32              m_mapping_crc;  // ON_TextureMapping::MappingCRC()
  ON_Xform                m_mesh_xform;
};

class ON_CLASS ON_TextureCoordinates
{
public:
  ON_TextureCoordinates();

  ON_MappingTag   m_tag;
  int                        m_dim; // 1, 2, or 3
  ON_SimpleArray<ON_3fPoint> m_T;   // texture coordinates
};


#if defined(ON_DLL_TEMPLATE)
// This stuff is here because of a limitation in the way Microsoft
// handles templates and DLLs.  See Microsoft's knowledge base 
// article ID Q168958 for details.
#pragma warning( push )
#pragma warning( disable : 4231 )
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_MappingTag>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ON_TextureCoordinates>;
#pragma warning( pop )
#endif

class ON_CLASS ON_Mesh : public ON_Geometry
{
  ON_OBJECT_DECLARE(ON_Mesh);
public:
  ON_Mesh();
  ON_Mesh(
    int   initial_face_array_capacity,   // initial face array capacity
    int   initial_vertex_array_capacity, // initial vertex array capacity
    bool  has_vertex_normals,            // true if mesh has vertex normals
    bool  has_texture_coordinates        // true if mesh has texture coordinates
    );
  ON_Mesh( const ON_Mesh& );
  ON_Mesh& operator=( const ON_Mesh& );
  ~ON_Mesh();

  // Override of virtual ON_Object::MemoryRelocate
  void MemoryRelocate();

  // virtual ON_Object::DestroyRuntimeCache override
  void DestroyRuntimeCache( bool bDelete = true );

  void Destroy();
  void EmergencyDestroy(); // Call only when memory used by this class's
                           // members will soon become invalid for reasons 
                           // beyond your control. EmergencyDestroy() zeros
                           // anything that could possibly cause
                           // ~ON_Mesh() to crash.  Calling
                           // EmergencyDestroy() under normal conditions 
                           // will result in ~ON_Mesh() leaking
                           // memory.

  void DestroyTree( bool bDeleteTree = true );

  /////////////////////////////////////////////////////////////////
  // ON_Object overrides

  // virtual ON_Object::SizeOf override
  unsigned int SizeOf() const;

  // virtual ON_Object::DataCRC override
  ON__UINT32 DataCRC(ON__UINT32 current_remainder) const;

  /*
  Description:
    Tests an object to see if its data members are correctly
    initialized.
  Parameters:
    text_log - [in] if the object is not valid and text_log
        is not NULL, then a brief englis description of the
        reason the object is not valid is appened to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     object is valid
    false    object is invalid, uninitialized, etc.
  Remarks:
    Overrides virtual ON_Object::IsValid
  */
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  void Dump( ON_TextLog& ) const; // for debugging

  ON_BOOL32 Write( ON_BinaryArchive& ) const;

  ON_BOOL32 Read( ON_BinaryArchive& );

  ON::object_type ObjectType() const;

  /////////////////////////////////////////////////////////////////
  // ON_Geometry overrides

  int Dimension() const;

  ON_BOOL32 GetBBox( // returns true if successful
         double*,    // minimum
         double*,    // maximum
         ON_BOOL32 = false  // true means grow box
         ) const;

  /*
	Description:
    Get tight bounding box of the mesh.
	Parameters:
		tight_bbox - [in/out] tight bounding box
		bGrowBox -[in]	(default=false)			
      If true and the input tight_bbox is valid, then returned
      tight_bbox is the union of the input tight_bbox and the 
      mesh's tight bounding box.
		xform -[in] (default=NULL)
      If not NULL, the tight bounding box of the transformed
      mesh is calculated.  The mesh is not modified.
	Returns:
    True if the returned tight_bbox is set to a valid 
    bounding box.
  */
	bool GetTightBoundingBox( 
			ON_BoundingBox& tight_bbox, 
      int bGrowBox = false,
			const ON_Xform* xform = 0
      ) const;

  ON_BOOL32 Transform( 
         const ON_Xform&
         );

  // virtual ON_Geometry::IsDeformable() override
  bool IsDeformable() const;

  // virtual ON_Geometry::MakeDeformable() override
  bool MakeDeformable();

  ON_BOOL32 SwapCoordinates(
        int, int        // indices of coords to swap
        );

  // virtual ON_Geometry override
  bool EvaluatePoint( const class ON_ObjRef& objref, ON_3dPoint& P ) const;


  /////////////////////////////////////////////////////////////////
  // Interface
  // 

  // creation
  bool SetVertex(
         int,              // vertex index
         const ON_3dPoint& // vertex location
         );
  bool SetVertex(
         int,              // vertex index
         const ON_3fPoint& // vertex location
         );
  bool SetVertexNormal(
         int,               // vertex index
         const ON_3dVector& // unit normal
         );
  bool SetVertexNormal(
         int,               // vertex index
         const ON_3fVector& // unit normal
         );
  bool SetTextureCoord(
         int,               // vertex index
         double, double     // texture coordinates
         );
  bool SetTriangle(
         int, // face index
         int,int,int // vertex indices
         );
  bool SetQuad(
         int, // face index
         int,int,int,int // vertex indices
         );

  /*
  Description:
    Get a vertex reference to a mesh vertex index.
  Parameters:
    ci - [in] component index with type mesh_vertex or meshtop_vertex.
  Returns:
    a reference to the vertex
  */
  ON_MeshVertexRef VertexRef(ON_COMPONENT_INDEX ci) const;

  ON_MeshVertexRef VertexRef(int mesh_V_index) const;

  /*
  Description:
    Get an edge reference from a mesh topology edge index.
  Parameters:
    ci - [in] component index with type meshtop_edge
  Returns:
    a reference to the edge
  */
  ON_MeshEdgeRef EdgeRef(ON_COMPONENT_INDEX ci) const;

  ON_MeshEdgeRef EdgeRef(int tope_index) const;

  /*
  Description:
    Get a face reference from a mesh face index.
  Parameters:
    ci - [in] component index with type mesh_face.
  Returns:
    a reference to the face
  */
  ON_MeshFaceRef FaceRef(ON_COMPONENT_INDEX ci) const;

  ON_MeshFaceRef FaceRef(int mesh_F_index) const;

  /*
  Parameters:
   ci - [in] a component index with type mesh_vertex, meshtop_vertex,
             meshtop_edge, or mesh_face.
  Returns:
    A pointer to an ON_MeshVertexRef, ON_MeshEdgeRef, or ON_MeshFaceRef.
    The caller must delete the returned object when it is no longer
    needed.
  See Also:
    ON_Mesh::VertexRef
    ON_Mesh::EdgeRef
    ON_Mesh::FaceRef
  */
  ON_Geometry* MeshComponent( 
      ON_COMPONENT_INDEX ci
      ) const;

  // query
  int VertexCount() const;
  int FaceCount() const;
  int QuadCount() const; // number of faces that are quads
  int TriangleCount() const; // number of faces that are triangles
  int InvalidFaceCount() const; // number of face that have invalid m_vi[] values.
  bool HasVertexNormals() const; // normals at vertices
  bool HasFaceNormals() const;
  bool HasTextureCoordinates() const;
  bool HasSurfaceParameters() const;
  bool HasPrincipalCurvatures() const;
  bool HasVertexColors() const;

  /*
  Returns:
    Number of vertices that are hidden.
  */
  int HiddenVertexCount() const;

  bool GetCurvatureStats( 
         ON::curvature_style, 
         ON_MeshCurvatureStats& 
         ) const;

  void InvalidateVertexBoundingBox(); // Call if defining geometry is changed by 
                             // directly manipulating the m_V[] array.
  void InvalidateVertexNormalBoundingBox(); // Call if defining geometry is changed by 
                             // directly manipulating the m_N[] array.
  void InvalidateTextureCoordinateBoundingBox(); // Call if defining geometry is changed by 
                             // directly manipulating the m_T[] array.
  void InvalidateCurvatureStats(); // Call if defining geometry is changed by 
                             // directly manipulating the m_T[] array.
  void InvalidateBoundingBoxes(); // Invalidates all cached bounding box information.


  void Flip(); // reverses face orientations and flips vertex and face normals

  void FlipVertexNormals(); // reverses vertex normals
  void FlipFaceNormals(); // reverses face normals
  void FlipFaceOrientation(); // reverses face orientation (does nothing to normals)

  void SetMeshParameters( const ON_MeshParameters& );
  const ON_MeshParameters* MeshParameters() const;
  void DeleteMeshParameters();

  
  bool UnitizeVertexNormals();
  bool UnitizeFaceNormals();
  bool CountQuads();

  /*
  Description:
    Splits all quads along the short diagonal.
  */
  bool ConvertQuadsToTriangles();

  /*
  Description:
    Joins adjacent triangles into quads if the resulting quad
    is nice.
  Parameters:
    angle_tol_radians - [in] Used to compare adjacent
      triangles' face normals.  For two triangles to be considered,
      the angle between their face normals has to be <= angle_tol_radians.
      When in doubt use ON_PI/90.0 (2 degrees).
    min_diagonal_length_ratio - [in] ( <= 1.0) For two triangles to be
       considered the ratio of the resulting quad's diagonals
       (length of the shortest diagonal)/(length of longest diagonal).
       has to be >= min_diagonal_length_ratio.
       When in doubt us .875.
  */
  bool ConvertTrianglesToQuads(
    double angle_tol_radians,
    double min_diagonal_length_ratio
    );

  bool ComputeFaceNormals();   // compute face normals for all faces
  bool ComputeFaceNormal(int); // computes face normal of indexed face

  int CullDegenerateFaces(); // returns number of degenerate faces

  int CullUnusedVertices(); // returns number of culled vertices

  // Description:
  //   Removes any unreferenced objects from arrays, reindexes as needed,
  //   and shrinks arrays to minimum required size.
  bool Compact();

  bool ComputeVertexNormals();    // uses face normals to cook up a vertex normal
  
  //////////
  // Scales textures so the texture domains are [0,1] and
  // eliminates any texture rotations.
  bool NormalizeTextureCoordinates();

	/////////
	// Description:
	//		Transposes the texture coordinates
	//  Returns
	//			true  -  success
	bool TransposeTextureCoordinates();
	bool TransposeSurfaceParameters();
 
	/////////
	// Description:
	//		Reverse one coordinate direction of the texture coordinates, within texture domain m_tex_domain
	//	Parameters:
	//		dir  -[in]	-   dir=0  first texture coordinate is reversed
	//									  dir=1 second texture coordinate is reversed
	//  Returns
	//			true  -  success
	bool ReverseTextureCoordinates( int dir );
	bool ReverseSurfaceParameters( int dir );
 


  /*
  Description:
    Use a texture mapping function to set the m_T[] values.
  Parameters:
    mapping - [in]
    mesh_xform - [in]
      If not NULL, the mapping calculation is performed as
      if the mesh were transformed by mesh_xform; the
      location of the mesh is not changed.
    bLazy - [in]
      If true and the m_T[] values were set using the same
      mapping parameters, then no calculation is performed.
  Returns:
    True if successful.
  See Also:
    ON_TextureMapping::GetTextureCoordinates
  */
  bool SetTextureCoordinates( 
          const class ON_TextureMapping& mapping,
					const class ON_Xform* mesh_xform = 0,
          bool bLazy = true
          );

  bool HasCachedTextureCoordinates() const;

  const ON_TextureCoordinates* CachedTextureCoordinates( 
          const ON_UUID& mapping_id 
          ) const;

  const ON_TextureCoordinates* SetCachedTextureCoordinates( 
          const class ON_TextureMapping& mapping,
					const class ON_Xform* mesh_xform = 0,
          bool bLazy = true
          );

  bool EvaluateMeshGeometry( const ON_Surface& ); // evaluate surface at tcoords
                                                  // to set mesh geometry

  // finds all coincident vertices and merges them if break angle is small enough
  bool CombineCoincidentVertices( 
          ON_3fVector, // coordinate tols for considering vertices
                       // to be coincident
          double  // cosine normal angle tolerance in radians
                  // if vertices are coincident, then they are combined
                  // if NormalA o NormalB >= this value
          );

  /*
  Description:
    Combines identical vertices.
  Parameters:
    bIgnoreVertexNormals - [in] If true, then vertex normals
      are ignored when comparing vertices.
    bIgnoreTextureCoordinates - [in] If true, then vertex
      texture coordinates, colors, and principal curvatures
      are ignored when comparing vertices.
  Returns:
    True if the mesh is changed, in which case the returned
    mesh will have fewer vertices than the input mesh.
  */
  bool CombineIdenticalVertices(
          bool bIgnoreVertexNormals = false,
          bool bIgnoreTextureCoordinates = false
          );

  void Append( const ON_Mesh& ); // appends a copy of mesh to this and updates
                                 // indices of appended mesh parts

  /*
  Description:
    Append a list of meshes. This function is much more efficient
    than making repeated calls to ON_Mesh::Append(const ON_Mesh&)
    when lots of meshes are being joined into a single large mesh.
  Parameters:
    count - [in]
      length of meshes[] array.
    meshes - [in]
      array of meshes to append.
  */
  void Append( int count, const ON_Mesh* const* meshes );
  
  /*
  Description:
    Expert user function to set m_is_closed member.  
    Setting this value correctly after a mesh is constructed 
    can save time when IsClosed() is called.
    This function sets the private member variable m_is_closed.
  Paramters:
    closed - [in]
      0: The mesh is not closed.  There is at least one face with an 
         edge that is geometrically distinct (as an unoriented line segment)
         from all other edges.
      1: The mesh is closed.  Every geometrically distict edge is used
         by two or more faces.
  */
  void SetClosed(int closed);

  /*
  Returns:
    True if every mesh "edge" has two or more faces.
  */
  bool IsClosed() const;

  /*
  Returns:
    True if every mesh "edge" has at most two faces.
  */
  bool IsManifold() const;

  /*
  Returns:
    True if the mesh is manifold and every pair of faces
    that share an "edge" have compatible orientations.
  */
  bool IsOriented() const;

  /*
  Description:
    Determine if the mesh is a manifold.
  Parameters:
    bTopologicalTest - [in]
      If true, the query treats coincident vertices as
      the same.
    pbIsOriented - [out]
      If the input pointer is not NULL, then the returned
      value of *pbIsOriented will be true if the mesh
      is a manifold and adjacent faces have compatible
      face normals.
    pbHasBoundary - [out]
      If the input pointer is not NULL, then the returned
      value of *pbHasBoundary will be true if the mesh
      is a manifold and there is at least one "edge"
      with no adjacent faces have compatible
      face normals.
  Returns:
    True if every mesh "edge" has at most two adjacent faces.
  */
  bool IsManifold(
    bool bTopologicalTest,
    bool* pbIsOriented = NULL,
    bool* pbHasBoundary = NULL
    ) const;

  /*
  Description:
    Expert user function to set m_is_solid member.  
    Setting this value correctly after a mesh is constructed 
    can save time when IsSolid() is called.
    This function sets the private member variable m_is_solid.
    If solid is nonzero, it will set m_is_closed to 1.
  Paramters:
    solid - [in]
      0: The mesh is not an oriented manifold solid mesh. Either
         the mesh is not closed, not manifold, or the faces are
         not oriented compatibly.
      1: The mesh is an oriented manifold solid whose face normals
         point outwards.
     -1: The mesh is an oriented manifold solid whose face normals
         point inwards.
  */
  void SetSolidOrientation(int solid_orientation);

  /*
  Description:
    Determine orientation of a mesh.
  Returns:
    +1     mesh is a solid with outward facing normals
    -1     mesh is a solid with inward facing normals
     0     mesh is not a solid
  See Also:
    ON_Mesh::IsSolid
  */
  int SolidOrientation() const;

  /*
  Description:
    Test mesh to see if it is a solid.  (A "solid" is
    a closed oriented manifold.)
  Returns:
    true       mesh is a solid
    fals       mesh is not a solid
  See Also:
    ON_Mesh::SolidOrientation
    ON_Mesh::IsManifold
  */
  bool IsSolid() const;

  /*
  Description:
    Appends a list of mesh edges that begin or end at the specified
    vertices to the edges[] array.
  Parameters:
    vcount - [in]
      number of vertices
    vertex_index - [in]
      array of vertex indices
    bNoDuplicates - [in]
      If true, then only one edges[] is added for each edge,
      the first vertex index will alwasy be less than the
      second, and the returned elements are sorted in dictionary
      order.
      If false and an edge is shared by multiple faces, then
      there will be an edges[] element added for each face and the
      order of the vertex indicies will indicate the orientation
      of the edge with respect to the face.  No sorting is performed
      in this case.
    edges - [out]
      Edges that begin or end at one of the specified vertices are
      appended to this array.  Each ON_2dex records the start and
      end vertex index.
  Returns:
    Number of ON_2dex values appended to the edges[] array.
  */
  int GetVertexEdges( 
    int vcount,
    const int* vertex_index, 
    bool bNoDuplicates,
    ON_SimpleArray<ON_2dex>& edges
    ) const;


  /*
  Description:
    Appends a list of mesh edges to the edges[] array.
  Parameters:
    edges - [out]
      Each edges[] element is a pair of vertex indices.  There
      is at least one face in the mesh with an edge running between
      the indicies.
  Returns:
    Number of ON_2dex values appended to the edges[] array.
  */
  int GetMeshEdges( 
    ON_SimpleArray<ON_2dex>& edges
    ) const;

  /*
  Description:
    Assign a unique id to each vertex location.  Coincident vertices
    get the same id.
  Parameters:
    first_vid - [in]
      Initial vertex id.  Typically 1 or 0.
    Vid - [out]
      If not null, then Vid[] sould be an array of length VertexCount().
      and the vertex ids will be stored in this array.  If null,
      the array will be allocated by calling onmalloc().  The returned
      array Vid[i] is the id of the vertex m_V[i].  If m_V[i] and
      m_V[j] are the same 3d point, then Vid[i] and Vid[j] will have
      the same value.
    Vindex - [out] (can be null)
      If Vindex is not null, then it must have length at least m_V.Count()
      and the returned array will be a permutation of (0,1,...,m_V.Count()-1)
      such (Vid[Vindex[0]], Vid[Vindex[1]], ..., Vid[Vindex[m_V.Count()-1]])
      is an increasing list of value.
  Returns:
    null if the mesh has no vertices.
    An array of length VertexCount(). If vertices m_V[i] and m_V[j]
    are coincident, then Vid[i] = Vid[j].  The id values begin at first_vid.
    The maximum vertex id is Vid[Vindex[m_V.Count()-1]].  The number of
    unique vertex locations is (Vid[Vindex[m_V.Count()-1]] - first_vid + 1).
  */
  int* GetVertexLocationIds( 
    int first_vid, 
    int* Vid, 
    int* Vindex
    ) const;

  /*
  Description:
    Get a list of the sides of every face.
  Parameters:
    Vid - [in] (can be null)
      If Vid is null, then the mesh m_V[] index values are used to set
      the ON_MeshFaceSide::vi[] values.
      If Vid is not null, then it must be an array of length VertexCount().
      The value Vid[mesh m_V[] index] will be used to set the
      ON_MeshFaceSide::vi[] values.
    sides - [out]
      If the input value of sides is not null, then sides[] must be long 
      enough to hold the returned side list.  The maximum posssible length
      is 4*FaceCount() for a mesh contining FaceCount() nondegenerate quads.
      If the input value of sides is null, memory will be allocated using
      onmalloc() and the caller is responsible for calling onfree() at an
      appropriate time.  This function fills in the sides[] array
      with face side information.  The returned list is sorted by sides[].fi
      and the sides[].side and each element has vi[0] <= vi[1].  
      The function ON_SortMeshFaceSidesByVertexIndex() can be used to sort the 
      list by the sides[].vi[] values.
  Returns:
    Number of elements added to sides[].
  Remarks:
    Faces with out of range ON_MeshFace.vi[] values are skipped. 
    Degenerate faces are processed, but degenerate sides (equal vertex indices)
    are not added to the list.
  */
  int GetMeshFaceSideList( 
      const int* Vid,
      struct ON_MeshFaceSide*& sides
      ) const;

  /*
  Description:
    Get a list of the geometrically uniqued edges in a mesh.
  Parameters:
    edge_list - [out]
      The edge list for this mesh is appended to edge_list[].  
      The ON_2dex i and j values are mesh->m_V[] array indices.
      There is exactly one element in edge_list[] for each
      unoriented 3d line segment in the mesh. The edges are 
      oriented the same way the corresponding ON_MeshTopology
      edge is oriented.
    ci_meshtop_edge_map - [out]
      If you call the verson of GetMeshEdgeList() with the ci_meshtop_edge_map[],
      parameter, then the edge in edge_list[i] cooresponds to the edge
      in ON_MeshTopology.m_tope[ci_meshtop_edge_map[i]]. The value
      ci_meshtop_edge_map[i] is useful if you need to convert an edge_list[]
      index into an ON_COMPONENT_INDEX with type meshtop_edge.
    ci_meshtop_vertex_map - [out]
      If you call the verson of GetMeshEdgeList() with the ci_meshtop_vertex_map[],
      parameter, then the vertex m_V[i] cooresponds to the vertex
      in ON_MeshTopology.m_topv[ci_meshtop_vertex_map[i]]. The value
      ci_meshtop_vertex_map[i] is useful if you need to convert an m_V[]
      index into an ON_COMPONENT_INDEX with type meshtop_vertex.
    edge_list_partition - [out] (can be null)
      The edge_list[] is always ordered so that edge_types
      are partitioned into contiguous regions. The edge_list_partition[5]
      values report the edge type regions.
      * If edge_type_partition[0] <= ei < edge_type_partition[1], then
        edge_list[ei] is an edge of exactly two faces and the vertices
        used by the faces are identical.  These are also called
        "manifold edges".
      * If edge_type_partition[1] <= ei < edge_type_partition[2], then
        edge_list[ei] is an edge of exactly two faces, but at least
        one of the vertices is duplicated.  These are also called
        "crease edges".
      * If edge_type_partition[2] <= ei < edge_type_partition[3], then
        edge_list[ei] is an edge of 3 or more faces. These are also called
        "nonmanifold edges".
      * If edge_type_partition[3] <= ei < edge_type_partition[4], 
        then edge_list[ei] is a boundary edge of exactly one mesh face.
        These are also called "naked edges".
  Returns:
    Number of edges added to edge_list[].
  Remarks:
    This calculation also sets m_closed.  If you modify the mesh's
    m_V or m_F information after calling this function, be sure to
    clear m_is_closed.
  */
  int GetMeshEdgeList( 
      ON_SimpleArray<ON_2dex>& edge_list, 
      int edge_type_partition[5] 
      ) const;

  int GetMeshEdgeList( 
      ON_SimpleArray<ON_2dex>& edge_list, 
      ON_SimpleArray<int>& ci_meshtop_edge_map,
      int edge_type_partition[5] 
      ) const;

  int GetMeshEdgeList( 
      ON_SimpleArray<ON_2dex>& edge_list, 
      ON_SimpleArray<int>& ci_meshtop_edge_map,
      ON_SimpleArray<int>& ci_meshtop_vertex_map,
      int edge_type_partition[5] 
      ) const;

  ///////////////////////////////////////////////////////////////////////
  //
  // mesh editing
  //

  /*
  Description:
    Replace a mesh edge with a vertex at its center and update
    adjacent faces as needed.
  Parameters:
    topei - [in] index of edge in MeshTopology().m_tope[] array
  Returns:
    true if successful.
  */
  bool CollapseEdge( int topei );

  /*
  Description:
    Tests a mesh edge to see if it is valid as input to
    ON_Mesh::SwapMeshEdge.
  Parameters:
    topei - [in] index of edge in MeshTopology().m_tope[] array
  Returns:
    true if edge can be swapped by ON_Mesh::SwapMeshEdge.
  See Also:
    ON_Mesh::SwapEdge
  */
  bool IsSwappableEdge( int topei );


  /*
  Description:
    If the edge is shared by two triangular face, then
    the edge is "swapped".
  Parameters:
    topei - [in] index of edge in MeshTopology().m_tope[] array
  Returns:
    true if successful
  See Also:
    ON_Mesh::IsSwappableEdge
  */
  bool SwapEdge( int topei );

  /*
  Description:
    Removes a face from a mesh and does not alter the
    geometry of the remaining mesh.
  Parameters:
    meshfi - [in] index of face in ON_Mesh.m_F[] array
  Remarks:
    This function calls DestroyTopology() and DestroyPartition().
    The caller is responsible for calling Compact() if that step
    is required.
  Returns:
    true if successful
  */
  bool DeleteFace( int meshfi );

  /*
  Description:
    Destroys the m_H[] array and sets m_hidden_count=0.
  */
  void DestroyHiddenVertexArray();

  /*
  Returns:
    If the mesh has some hidden vertices, then an array
    of length VertexCount() is returned and the i-th
    element is true if the i-th vertex is hidden.
    If no vertices are hidden, NULL is returned.
  */
  const bool* HiddenVertexArray() const;

  /*
  Description:
    Set the runtime vertex hidden flag.
  Parameters:
    meshvi - [in] mesh vertex index
    bHidden - [in] true to hide vertex
  */
  void SetVertexHiddenFlag( int meshvi, bool bHidden );

  /*
  Description:
    Returns true if the mesh vertex is hidden.  This is a runtime
    setting that is not saved in 3dm files.
  Parameters:
    meshvi - [in] mesh vertex index.
  Returns:
    True if mesh vertex is hidden.
  */
  bool VertexIsHidden( int meshvi ) const;

  /*
  Description:
    Returns true if the mesh face is hidden.  This is a runtime
    setting that is not saved in 3dm files.
  Parameters:
    meshfi - [in] mesh face index.
  Returns:
    True if mesh face is hidden.
  Remarks:
    A face is hidden if, and only if, at least one of its
    vertices is hidden.
  */
  bool FaceIsHidden( int meshvi ) const;


  ///////////////////////////////////////////////////////////////////////
  //
  // mesh topology
  //
  // In order to keep the mesh facet definition simple and make the mesh
  // definition easily used in common rendering application, if two facets
  // share a vertex location but have different normals, curvatures, 
  // textures, etc., at that common vertex location, then the vertex is
  // duplicated.  When the topology of the mesh needs to be known,
  // use Topology() to get a class that provides complete topological
  // information about the mesh.
  const ON_MeshTopology& Topology() const;

  ///////////////////////////////////////////////////////////////////////
  // If you modify the mesh in any way that may change its topology,
  // then call DestroyTopology().  Specifically if you add or remove
  // vertices or face, change vertex locations, or change the face m_vi[]
  // values, then you must call DestroyTopology().
  void DestroyTopology();

  /*
  Returns:
    This is an expert user function that returns true if the topology
    information is already calculated and cached.  It can be used to
    to avoid calling the Topology() function when the expensive creation
    step will be performed.
  */
  bool TopologyExists() const;


  ///////////////////////////////////////////////////////////////////////
  //
  // mesh partitions
  //
  // In ancient times, some rendering engines were only able to process
  // small batches of triangles and th CreatePartition() function was
  // provided to partition the mesh into subsets of vertices and faces
  // that those renering engines could handle.
  //
  const ON_MeshPartition* CreatePartition( 
                int, // maximum number of vertices in a partition
                int  // maximum number of triangles in a partition
                );
  const ON_MeshPartition* Partition() const;
  void DestroyPartition();

  /*
  Description:
    Extract the portion of this mesh defined by mesh_part.
  Parameters:
    mesh_part - [in]
      defines portion of the mesh to extract.
    mesh - [in] (can be null, cannot be = "this).
      If mesh is no null, the extracted mesh will be put into
      this mesh.  If mesh is null, the extracted mesh will
      be created in a mesh allocated on the heap using the
      new operator.
  Returns:
    A pointer to the submesh.  If the input mesh parameter is null,
    then the caller must delete this mesh when it is no longer needed.
    If the input is invalid, then null is returned.
  */
  ON_Mesh* MeshPart( 
    const ON_MeshPart& mesh_part,
    ON_Mesh* mesh 
    ) const;

  /*
  Description:
    Create a mesh that is a single face of this mesh.
  Parameters:
  Returns:
    A pointer to the submesh.  If the input mesh parameter is null,
    then the caller must delete this mesh when it is no longer needed.
    If the input is invalid, then null is returned.
  */
  ON_Mesh* DuplicateFace( 
    int face_index,
    ON_Mesh* mesh 
    ) const;

  ///////////////////////////////////////////////////////////////////////
  //
  // mesh N-gon lists.  
  //   ON_Mesh objects support faces that are triangle or quads.
  //   When a mesh is created from a format that supports N-gons
  //   for N larger than 4, an optional N-gon list can be added 
  //   that specifies the vertices and faces that make up the N-gon.
  //

  /*
  Description:
    If the mesh has an N-gon list, return a pointer to it.
  Returns:
    A pointer to the current N-gon list or NULL.
  */
  const class ON_MeshNgonList* NgonList() const;

  /*
  Description:
    If an N-gon list exists, it is returned and can be modified.
    If no N-gon list exists, a new empty list is returned and
    it can be modified.
  Returns:
    A pointer to the N-gon list that can be modified.
  */
  class ON_MeshNgonList* ModifyNgonList();

  /*
  Description:
    Destroy any existing N-gon list.
  */
  void DestroyNgonList();

  ///////////////////////////////////////////////////////////////////////
  //
  // mesh components
  //   ON_Mesh objects can consist of sets of faces that are isolated
  //   from any other sets of faces.  The following 2 functions will
  //   dissect a mesh into these sets, called components.  Not to be 
  //   confused with ON_COMPONENT_INDEX.

  /*
    Description:
      Calculates the components of a mesh and sets a label for each face in
      the facet_component_labels array.
    Parameters:
      bUseVertexConnections- [in]
        If this parameter is true, then facets that share a common vertex
        are considered connected.
        If this parameter is false, then facets must share an edge to
        be considered connected.
      bUseTopologicalConnections - [in]
        If this parameter is true, then geometric location is used
        to determine if facets are connected. 
        If this parameter is false, then facets must share the same vertex 
        or vertices to be considered connected.
      facet_component_labels- [out]
        facet_component_labels[] will be an array with the same size
        as ON_Mesh.m_F.Count() and facet_component_labels[i]
        is the component id m_F[i] belongs to.  The component id
        will be 1 to the number of compoents.
    Returns:
      Number of components on success, 0 on failure 
  */

  int GetConnectedComponents( bool bUseVertexConnections, 
                              bool bTopologicalConnections, 
                              ON_SimpleArray<int>& facet_component_labels
                            ) const;

  /*
    Description:
      Calculates the components of a mesh and sets a label for each face in
      the facet_component_labels array.
    Parameters:
      bUseVertexConnections- [in]
        If this parameter is true, then facets that share a common vertex
        are considered connected.
        If this parameter is false, then facets must share an edge to
        be considered connected.
      bUseTopologicalConnections - [in]
        If this parameter is true, then geometric location is used
        to determine if facets are connected. 
        If this parameter is false, then facets must share the same vertex 
        or vertices to be considered connected.
      components   - [out]
        New components are appended to this array
        if this parameter is null, then the components are just counted.
    Returns:
      Number of components on success, 0 on failure 
  */

  int GetConnectedComponents( bool bUseVertexConnections, 
                              bool bTopologicalConnections, 
                              ON_SimpleArray<ON_Mesh*>* components
                            ) const;


  /////////////////////////////////////////////////////////////////
  // 
  // Double precision vertex support
  // 

  /*
  Returns:
    True if the mesh has single and double precision
    vertices, and the values of the two sets are synchronized.
  */
  bool HasSynchronizedDoubleAndSinglePrecisionVertices() const;

  /*
  Returns:
    True if the mesh has double precision vertices.
  Remarks:
    This function returns true if a mesh has double
    precision vertex information, even if it is not
    updated. 
    
    Use ON_Mesh::DoublePrecisionVerticesAreValid()
    and ON_Mesh::SinglePrecisionVerticesAreValid() to 
    check the validity.  
    
    Use ON_Mesh::UpdateDoublePrecisionVertices()
    or ON_Mesh::UpdateSinglePrecisionVertices() to synchronize
    values of single and double precision vertices.
  */
  bool HasDoublePrecisionVertices() const;

  /*
  Parameters:
    bEnableDoublePrecisionVertices - [in]
      True to enable use of double precision vertices.
      False to destroy any existing precision vertices.
  */
  void EnableDoublePrecisionVertices(bool bEnableDoublePrecisionVertices);

  /*
  Description:
    If you modify the values of double precision vertices,
    then you must call UpdateSinglePrecisonVertices().
  Remarks:
    If double precision vertices are not present, this function
    does nothing.
  */
  void UpdateSinglePrecisionVertices();

  /*
  Description:
    If you modify the values of the single precision vertices
    in m_V[], then you must call UpdateDoublePrecisionVertices().
  Remarks:
    If double precision vertices are not present, this function
    does nothing.
  */
  void UpdateDoublePrecisionVertices();

  /*
  Description:
    If you have modified the single precision vertices
    and are certain they are valid, then call this 
    function to update crc information.
  Remarks:
    If double precision vertices are not present, this function
    does nothing.
  */
  void SetSinglePrecisionVerticesAsValid();

  /*
  Description:
    If you have modified the double precision vertices
    and are certain they are valid, then call this 
    function to update crc information.
  Remarks:
    If double precision vertices are not present, this function
    does nothing.
  */
  void SetDoublePrecisionVerticesAsValid();

  /*
  Description:
    The functions UpdateSinglePrecisionVertices(), 
    UpdateDoublePrecisionVertices(), and 
    SetSinglePrecisionVerticesAsValid() save
    the count and crc of the single precision vertex
    array. True is returned if there are no
    double precision vertices or the current
    count and crc of the single precision
    vertex array match the saved values.
  Remarks:
    If double precision vertices are not present, this function
    does nothing and returns true.
  */
  bool SinglePrecisionVerticesAreValid() const;

  /*
  Description:
    The functions UpdateSinglePrecisionVertices(), 
    UpdateDoublePrecisionVertices(), and 
    SetDoublePrecisionVerticesAsValid() save
    the count and crc of the double precision vertex
    array. True is returned if the current
    count and crc of the double precision
    vertex array match the saved values.
  Remarks:
    If double precision vertices are not present, this function
    does nothing and returns true.
  */
  bool DoublePrecisionVerticesAreValid() const;

  /*
  Description:
    The function removes all double precision vertex information.
  */
  void DestroyDoublePrecisionVertices();


  /////////////////////////////////////////////////////////////////
  // Implementation - mesh geometry

  // Vertex locations
  //   In a case where adjacent facets share a vertex
  //   location but have distinct normals or texture
  //   coordinates at that location, the vertex must
  //   be duplicated.

  /*
  Description:
    Get double precision vertices.  If they do not exist,
    they will be created and match the existing single
    precision vertices.
  Returns:
    Array of double precision vertices.  If you modify the
    values in this array, you must make the same modifications
    to the single precision vertices, or call 
    UpdateSinglePrecisonVertices().
  Example:

          // add a bunch of double precision information
          ON_3dPointArray& dv = mesh.DoublePrecisionVertices();
          for ( i = 0; i < lots; i++ )
          {
            dv[i] = ...
          }
          // This call updates the single precison values
          // in m_V[] and sets all the counts and CRCs that
          // are used in validity checking.
          mesh.UpdateSinglePrecisonVertices();
    
  Remarks:
    Avoid mulitple calls to DoublePrecisionVertices().
    It is most efficient to make one call, save a local 
    reference, and use the local reference as needed.
  */
  ON_3dPointArray& DoublePrecisionVertices();
  const ON_3dPointArray& DoublePrecisionVertices() const;

  /*
  Description:
    Get single precision vertices.
  Returns:
    Array of float precision vertices.  If you modify the
    values in this array, you must make the same modifications
    to the double precision vertices, or call 
    UpdateSinglePrecisonVertices().
  */
  ON_3fPointArray& SinglePrecisionVertices();
  const ON_3fPointArray& SinglePrecisionVertices() const;

  /*
  Description:
    In general,use one of
    ON_Mesh::SinglePrecisionVertices()
    or
    ON_Mesh::DoublePrecisionVertices()
    to get the array of vertex locations.  If you modify
    m_V[] directly and HasDoublePrecisionVertices() is true,
    then you must make the same modifications to the array
    returned by DoublePrecisionVertices().
  */
  ON_3fPointArray m_V;

  /*
  Returns:
    Location of the vertex.  If double precision vertices
    are present, the double precision vertex location is
    returned.  If vertex_index is out of range,
    ON_UNSET_VALUE is returned.
  */
  ON_3dPoint Vertex(int vertex_index) const;

  // m_F[] facets (triangles or quads)
  ON_SimpleArray<ON_MeshFace> m_F;

  // m_N[] OPTIONAL vertex unit normals
  // If m_N[] is empty or m_N.Count() != m_V.Count(), 
  // Either m_N[] has zero count or it m_N[j] is the
  // the unit vertex normal at m_V[j].
  ON_3fVectorArray m_N;

  // m_FN[] OPTIONAL face unit normals
  // If m_FN[] is empty or m_FN.Count() != m_F.Count(), 
  // then m_FN is ignored.  Otherwise m_FN[j] is the
  // unit normal for the facet m_F[j].
  ON_3fVectorArray m_FN;

  /////////////////////////////////////////////////////////////////
  // Implementation - texture coordinates
  //
  // OPTIONAL texture coordinates for each vertex

  // It would be nice if this were an ON_TextureCoordinates,
  // but that breaks lots of checked out code that assumes
  // m_T is an array of ON_2fPoints.
  ON_MappingTag m_Ttag; // OPTIONAL tag for values in m_T[]
  ON_2fPointArray m_T;  // OPTIONAL texture coordinates for each vertex

  // RUNTIME ONLY
  //   This array is used to cache texture coordinates used by
  //   rendering applications that require 1d texture coordinates,
  //   3d texture coordinates, or multiple sets of texture 
  //   coordinates (e.g. blended textures with different mappings).
  //   Users are responsible for verifying 
  //   m_TC[i].m_T.Count() = m_V.Count()
  ON_ClassArray<ON_TextureCoordinates> m_TC;  

  // If m_T.Count() == m_V.Count(), then the mesh has texture coordinates
  // and m_T[j] is the texture coordinate for vertex m_V[j].
  //
  // When opennurbs or Rhino meshes an ON_Surface or ON_Brep, the texture
  // coordinates have a "canonical" linear relationship with the surface 
  // parameters that is described in the next section.  However, various 
  // mappings, spherical, planar, cylindrical, etc., can be applied that 
  // change the values of the texture coordinates.
  //
  // If a texture mapping function was used to set the m_T[] values, 
  // then the id and serial number of the mapping function is saved
  // in m_mapping_id and m_mapping_sn. The intended use of these fields
  // is to make it easy to avoid unnecessary recalculation.  
  // If a mesh is modified, then m_mapping_id should be set to nil 
  // and m_mapping_crc should be set to 0.
  //
  /////////////////////////////////////////////////////////////////


  /////////////////////////////////////////////////////////////////
  // Implementation - surface parameters and packed texture 
  // information
  //
  // If m_S.Count() == m_V.Count(), then the mesh is a tesselation
  // of a parameteric surface and m_S[j] is the surface parameter at
  // m_V[j].  Storing values in m_S[] is OPTIONAL.
  //
  // If m_srf_scale[] has positive values, then they report
  // the world coordinate size of a rectangle that would 
  // minimize texture distortion if it were mapped to the
  // mesh using normalized surface evaluation parameters.
  // This information is used to calculate high quality 
  // packed texture coordinates.  
  ON_2dPointArray m_S;
  ON_Interval m_srf_domain[2]; // surface evaluation domain.
  double m_srf_scale[2];


  // Packed texture information.
  //
  // If either of the m_packed_tex_domain[] intervals is a 
  // proper subinterval of (0,1), then a texture packing 
  // calculation assigned this subrectangle to this mesh.

  ON_Interval m_packed_tex_domain[2];

  // The m_packed_tex_rotate setting is valid only when
  // m_S, m_srf_domain, m_packed_scale[] and 
  // m_packed_tex_domain[] are all valid and the texture
  // coordinates are based on surface evaluation parameters.
  // In this special situation, this boolean records the 
  // correspondence between the the surface parameters, (u,v),
  // and the packed texture coordinates, (s,t),
  //
  //   m_packed_tex_rotate = false:
  //     a = m_srf_domain[0].NormalizedParameterAt(u);
  //     b = m_srf_domain[1].NormalizedParameterAt(v);
  //     s = m_packed_tex_domain[0].ParameterAt(a);
  //     t = m_packed_tex_domain[1].ParameterAt(b);
  //
  //     x = m_packed_tex_domain[0].NormalizedParameterAt(s);
  //     y = m_packed_tex_domain[1].NormalizedParameterAt(t);
  //     u = m_srf_domain[0].ParameterAt(x);
  //     v = m_srf_domain[1].ParameterAt(y);
  //
  //   m_packed_tex_rotate = true:
  //     a = m_srf_domain[0].NormalizedParameterAt(u);
  //     b = m_srf_domain[1].NormalizedParameterAt(v);
  //     s = m_packed_tex_domain[0].ParameterAt(a);
  //     t = m_packed_tex_domain[1].ParameterAt(1.0-b);
  //
  //     x = m_packed_tex_domain[0].NormalizedParameterAt(s);
  //     y = m_packed_tex_domain[1].NormalizedParameterAt(t);
  //     u = m_srf_domain[0].ParameterAt(y);
  //     v = m_srf_domain[1].ParameterAt(1.0 - x);
  bool m_packed_tex_rotate;

  /*
  Returns:
    True if the m_srf_scale[] values are positive and
    the m_packed_tex_domain[] intervals are set to values
    that describe a proper subrectangle of (0,1)x(0,1).
    True does not necessarily mean the current values in
    m_T[] are packed texture coordinates.
  */
  bool HasPackedTextureRegion() const;

  /////////////////////////////////////////////////////////////////
  // Implementation - curvature

  ON_SimpleArray<ON_SurfaceCurvature> m_K;  // OPTIONAL surface curvatures
                                            // Either m_K[] has zero count or it has the same
                                            // count as m_V[], in which case m_K[j] reports
                                            // the surface curvatures at m_V[j].

  /////////////////////////////////////////////////////////////////
  // Implementation - false color
  ON_MappingTag m_Ctag; // OPTIONAL tag for values in m_C[]
  ON_SimpleArray<ON_Color> m_C;  // OPTIONAL vertex color
                                 // Either m_C[] has zero count or it has the same
                                 // count as m_V[], in which case m_C[j] reports
                                 // the color assigned to m_V[j].

  /////////////////////////////////////////////////////////////////
  // Implementation - runtime vertex visibility - not saved in 3dm files.
  ON_SimpleArray<bool> m_H; // OPTIONAL vertex visibility.
                            // If m_H.Count() = m_V.Count(), then
                            // m_H[vi] is true if the vertex m_V[vi] 
                            // is hidden.  Otherwise, all vertices are visible.
  int m_hidden_count;       // number of vertices that are hidden
                            // = number of true values in m_H[] array.

  /////////////////////////////////////////////////////////////////
  // Implementation - runtime UI information
  const ON_Object* m_parent; // runtime parent geometry (use ...::Cast() to get it)

protected:
  friend class ON_MeshVertexRef;
  friend class ON_MeshEdgeRef;
  friend class ON_MeshFaceRef;


  /////////////////////////////////////////////////////////////////
  // Implementation - mesh topology
  ON_MeshTopology m_top;

  ON_MeshParameters* m_mesh_parameters; // If mesh was created from a parametric surface,
                                        // these parameters were used to create the mesh.
  int                         m_invalid_count;
  int                         m_quad_count;
  int                         m_triangle_count;

private:
  char m_mesh_is_closed;   // 0 = unset, 1 = all edges have 2 or more faces, 2 = at least one boundary edge 
  char m_mesh_is_manifold; // 0 = unset, 1 = all edges have 1 or 2 faces, 2 = not manifold
  char m_mesh_is_oriented; // 0 = unset, 1 = faces normals agree across all edges that have 2 faces, 2 = not oriented
  char m_mesh_is_solid;    // 0 = unset, 1 = solid with outward face normals, 2 = solid with inward face normals, 3 = not solid

protected:
  // The bounding boxes are valid if m_?box[0][0] <= m_?box[0][1];
  float m_vbox[2][3]; // 3d bounding box of all referenced vertices
  float m_nbox[2][3]; // 3d bounding box of all referenced unit normals 
                      // (for estimation of Gauss map bounds)
  float m_tbox[2][2]; // 2d bounding box of all referenced texture coordinates
  ON_MeshCurvatureStats* m_kstat[4]; // gaussian,mean,min,max,sectionx,sectiony,sectionz

  // sub-mesh information rendering large meshes
  ON_MeshPartition* m_partition;

private:
  bool Write_1( ON_BinaryArchive& ) const; // uncompressed 1.x format
  bool Write_2( int, ON_BinaryArchive& ) const; // compressed 2.x format
  bool Read_1( ON_BinaryArchive& );
  bool Read_2( int, ON_BinaryArchive& );
  bool WriteFaceArray( int, int, ON_BinaryArchive& ) const;
  bool ReadFaceArray( int, int, ON_BinaryArchive& );
  bool SwapEdge_Helper( int, bool );
};

class ON_CLASS ON_MeshVertexRef : public ON_Geometry
{
  ON_OBJECT_DECLARE(ON_MeshVertexRef);
public:
  ON_MeshVertexRef();
  ~ON_MeshVertexRef();
  ON_MeshVertexRef& operator=(const ON_MeshVertexRef&);


  // parent mesh
  const ON_Mesh* m_mesh;
  
  // m_mesh->m_V[] index
  // (can be -1 when m_top_vi references a shared vertex location)
  int m_mesh_vi; 
  
  // m_mesh->m_top.m_tope[] index
  int m_top_vi; 


  /*
  Description:
    Override of the virtual ON_Geometry::ComponentIndex().
  Returns:
    A component index for the vertex.  The type of the returned
    component index can be 
    ON_COMPONENT_INDEX::mesh_vertex, 
    ON_COMPONENT_INDEX::meshtop_vertex, or
    ON_COMPONENT_INDEX::invalid_type.
  */
  ON_COMPONENT_INDEX ComponentIndex() const;

  /*
  Returns:
    The mesh topology associated with this 
    mesh vertex reference or NULL if it doesn't
    exist.
  */
  const ON_MeshTopology* MeshTopology() const;

  /*
  Returns:
    The 3d location of the mesh vertex.  Returns
    ON_UNSET_POINT is this ON_MeshVertexRef is not 
    valid.
  */
  ON_3dPoint Point() const;

  /*
  Returns:
    The mesh topology vertex associated with this 
    mesh vertex reference.
  */
  const ON_MeshTopologyVertex* MeshTopologyVertex() const;

  // overrides of virtual ON_Object functions
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;
  void Dump( ON_TextLog& ) const;
  unsigned int SizeOf() const;
  ON::object_type ObjectType() const;

  // overrides of virtual ON_Geometry functions
  int Dimension() const;
  ON_BOOL32 GetBBox(
         double* boxmin,
         double* boxmax,
         int bGrowBox = false
         ) const;
  ON_BOOL32 Transform( 
         const ON_Xform& xform
         );
};

class ON_CLASS ON_MeshEdgeRef : public ON_Geometry
{
  ON_OBJECT_DECLARE(ON_MeshEdgeRef);
public:
  ON_MeshEdgeRef();
  ~ON_MeshEdgeRef();
  ON_MeshEdgeRef& operator=(const ON_MeshEdgeRef&);

  // parent mesh
  const ON_Mesh* m_mesh;
  
  // m_mesh->m_top.m_tope[] index
  int m_top_ei; 

  /*
  Description:
    Override of the virtual ON_Geometry::ComponentIndex().
  Returns:
    A mesh component index for the edge.  The type is
    ON_COMPONENT_INDEX::meshtop_edge and the index is the
    index into the ON_MeshTopology.m_tope[] array.
  */
  ON_COMPONENT_INDEX ComponentIndex() const;

  /*
  Returns:
    The mesh topology associated with this 
    mesh edge reference or NULL if it doesn't
    exist.
  */

  const ON_MeshTopology* MeshTopology() const;
  /*
  Returns:
    The 3d location of the mesh edge.  Returns
    ON_UNSET_POINT,ON_UNSET_POINT, is this ON_MeshEdgeRef
    is not valid.
  */
  ON_Line Line() const;

  /*
  Returns:
    The mesh topology edge associated with this 
    mesh edge reference.
  */
  const ON_MeshTopologyEdge* MeshTopologyEdge() const;

  // overrides of virtual ON_Object functions
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;
  void Dump( ON_TextLog& ) const;
  unsigned int SizeOf() const;
  ON::object_type ObjectType() const;

  // overrides of virtual ON_Geometry functions
  int Dimension() const;
  ON_BOOL32 GetBBox(
         double* boxmin,
         double* boxmax,
         int bGrowBox = false
         ) const;
  ON_BOOL32 Transform( 
         const ON_Xform& xform
         );
};

class ON_CLASS ON_MeshFaceRef : public ON_Geometry
{
  ON_OBJECT_DECLARE(ON_MeshFaceRef);
public:
  ON_MeshFaceRef();
  ~ON_MeshFaceRef();
  ON_MeshFaceRef& operator=(const ON_MeshFaceRef&);

  // parent mesh
  const ON_Mesh* m_mesh;

  // m_mesh->m_F[] and m_mesh->m_top.m_tope[] index.
  int m_mesh_fi; 

  /*
  Description:
    Override of the virtual ON_Geometry::ComponentIndex().
  Returns:
    A mesh component index for the face.  The type is
    ON_COMPONENT_INDEX::mesh_face and the index is the
    index into the ON_Mesh.m_F[] array.
  */
  ON_COMPONENT_INDEX ComponentIndex() const;

  /*
  Returns:
    The mesh topology associated with this 
    mesh face reference or NULL if it doesn't
    exist.
  */
  const ON_MeshTopology* MeshTopology() const;

  /*
  Returns:
    The mesh face associated with this mesh face reference.
  */
  const ON_MeshFace* MeshFace() const;

  /*
  Returns:
    The mesh topology face associated with this 
    mesh face reference.
  */
  const ON_MeshTopologyFace* MeshTopologyFace() const;

  // overrides of virtual ON_Object functions
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;
  void Dump( ON_TextLog& ) const;
  unsigned int SizeOf() const;
  ON::object_type ObjectType() const;

  // overrides of virtual ON_Geometry functions
  int Dimension() const;
  ON_BOOL32 GetBBox(
         double* boxmin,
         double* boxmax,
         int bGrowBox = false
         ) const;
  ON_BOOL32 Transform( 
         const ON_Xform& xform
         );
};

/*
Description:
  Calculate a mesh representation of the NURBS surface's control polygon.
Parameters:
  nurbs_surface - [in]
  bCleanMesh - [in] If true, then degenerate quads are cleaned
                    up to be triangles. Surfaces with singular
                    sides are a common source of degenerate qauds.
  input_mesh - [in] If NULL, then the returned mesh is created
       by a class to new ON_Mesh().  If not null, then this 
       mesh will be used to store the conrol polygon.
Returns:
  If successful, a pointer to a mesh.
*/
ON_DECL
ON_Mesh* ON_ControlPolygonMesh( 
          const ON_NurbsSurface& nurbs_surface, 
          bool bCleanMesh,
          ON_Mesh* input_mesh = NULL
          );

/*
Description:
  Finds the unit normal to the triangle
Parameters:
  A - [in] triangle corner
  B - [in] triangle corner
  C - [in] triangle corner
Returns:
  Unit normal
*/
ON_DECL
ON_3dVector ON_TriangleNormal(
        const ON_3dPoint& A,
        const ON_3dPoint& B,
        const ON_3dPoint& C
        );


/*
Description:
  Finds the unit normal to the triangle
Parameters:
  A - [in] triangle corner
  B - [in] triangle corner
  C - [in] triangle corner
  a - [out] must not be null
  b - [out] must not be null
  c - [out] must not be null
  d - [out] must not be null
    The equation of the plane is a*x + b*y + c*z + d = 0
  ev_tol - [out]
    If ev_tol is not null, then it is the maximum absolute
    value of the plane equation evaluated at A,B,C.  Mathematically,
    ev_tol is zero.  Since these computations are performed with
    finite precision doubles, ev_tol is generally not zero.
Returns:
  Unit normal
*/
ON_DECL
bool ON_GetTrianglePlaneEquation(
        const ON_3dPoint& A,
        const ON_3dPoint& B,
        const ON_3dPoint& C,
        double* a,
        double* b,
        double* c,
        double* d,
        double* evaluation_tol
        );

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_POINT_GRID_INC_)
#define OPENNURBS_POINT_GRID_INC_

class ON_CLASS ON_PointGrid : public ON_Geometry
{
public:
  ON_PointGrid();
  ON_PointGrid(const ON_PointGrid&);
  ON_PointGrid(
          int,  // point count0 (>=1)
          int   // point count1 (>=1)
          );

  void Initialize(void);  // zeros all fields

  ON_BOOL32 Create( 
          int,  // point count0 (>=1)
          int   // point count1 (>=1)
          );

  void Destroy();

  virtual ~ON_PointGrid();
  void EmergencyDestroy(); // call if memory used by point grid becomes invalid

	ON_PointGrid& operator=(const ON_PointGrid&);

  // point_grid[i][j] returns GetPoint(i,j)
  ON_3dPoint* operator[](int);             // 0 <= index < PointCount(0)
  const ON_3dPoint* operator[](int) const; // 0 <= index < PointCount(0)
  
  /////////////////////////////////////////////////////////////////
  // ON_Object overrides

  /*
  Description:
    Tests an object to see if its data members are correctly
    initialized.
  Parameters:
    text_log - [in] if the object is not valid and text_log
        is not NULL, then a brief englis description of the
        reason the object is not valid is appened to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     object is valid
    false    object is invalid, uninitialized, etc.
  Remarks:
    Overrides virtual ON_Object::IsValid
  */
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  void Dump( ON_TextLog& ) const; // for debugging

  ON_BOOL32 Write(
         ON_BinaryArchive&  // open binary file
       ) const;

  ON_BOOL32 Read(
         ON_BinaryArchive&  // open binary file
       );

  ON::object_type ObjectType() const;

  /////////////////////////////////////////////////////////////////
  // ON_Geometry overrides

  int Dimension() const;

  ON_BOOL32 GetBBox( // returns true if successful
         double*,    // minimum
         double*,    // maximum
         ON_BOOL32 = false  // true means grow box
         ) const;

  /*
	Description:
    Get tight bounding box of the point grid.
	Parameters:
		tight_bbox - [in/out] tight bounding box
		bGrowBox -[in]	(default=false)			
      If true and the input tight_bbox is valid, then returned
      tight_bbox is the union of the input tight_bbox and the 
      tight bounding box of the point grid.
		xform -[in] (default=NULL)
      If not NULL, the tight bounding box of the transformed
      point grid is calculated.  The point grid is not modified.
	Returns:
    True if the returned tight_bbox is set to a valid 
    bounding box.
  */
	bool GetTightBoundingBox( 
			ON_BoundingBox& tight_bbox, 
      int bGrowBox = false,
			const ON_Xform* xform = 0
      ) const;

  ON_BOOL32 Transform( 
         const ON_Xform&
         );

  // virtual ON_Geometry::IsDeformable() override
  bool IsDeformable() const;

  // virtual ON_Geometry::MakeDeformable() override
  bool MakeDeformable();

  ON_BOOL32 SwapCoordinates(
        int, int        // indices of coords to swap
        );

  /////////////////////////////////////////////////////////////////
  // Interface

  ON_BOOL32 IsClosed( 
        int // dir
        ) const;

  int PointCount(   // number of points in grid direction
        int         // dir 0 = "s", 1 = "t"
        ) const;

  int PointCount(   // total number of points in grid
        void
        ) const;

  ON_3dPoint& Point(
        int, int // point index ( 0 <= i <= PointCount(0), 0 <= j <= PointCount(1)
        );

  ON_3dPoint Point(
        int, int // point index ( 0 <= i <= PointCount(0), 0 <= j <= PointCount(1)
        ) const;

  double* PointArray();

  const double* PointArray() const;

  int PointArrayStride(  // point stride in grid direction
        int         // dir 0 = "s", 1 = "t"
        ) const;

  ON_BOOL32 SetPoint(      // set a single point
        int, int, // point index ( 0 <= i <= PointCount(0), 0 <= j <= PointCount(1)
        const ON_3dPoint& // value of point
        );

  ON_BOOL32 GetPoint(              // get a single control vertex
        int, int,   // CV index ( 0 <= i <= CVCount(0), 0 <= j <= CVCount(1)
        ON_3dPoint&      // gets euclidean cv when NURBS is rational
        ) const;

  ON_BOOL32 Reverse(  // reverse grid order
    int // dir  0 = "s", 1 = "t"
    );

  ON_BOOL32 Transpose(); // transpose grid points

  /////////////////////////////////////////////////////////////////
  // Implementation
protected:

  int m_point_count[2];   // number of points (>=1)
  int m_point_stride0;    // >= m_point_count[1]
  ON_3dPointArray m_point;
  // point[i][j] = m_point[i*m_point_stride0+j]

private:
  static ON_3dPoint m_no_point; // prevent crashes when sizes are 0

  ON_OBJECT_DECLARE(ON_PointGrid);
};


#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(ON_GEOMETRY_CURVE_LINE_INC_)
#define ON_GEOMETRY_CURVE_LINE_INC_

class ON_LineCurve;
class ON_CLASS ON_LineCurve : public ON_Curve
{
  ON_OBJECT_DECLARE(ON_LineCurve);

public:
  ON_LineCurve();
  ON_LineCurve(const ON_2dPoint&,const ON_2dPoint&); // creates a 2d line curve
  ON_LineCurve(const ON_3dPoint&,const ON_3dPoint&); // creates a 3d line curve
  ON_LineCurve(const ON_Line&);
  ON_LineCurve(const ON_Line&,
                double,double    // domain
                );
  ON_LineCurve(const ON_LineCurve&);

  virtual ~ON_LineCurve();

	ON_LineCurve& operator=(const ON_LineCurve&);
	ON_LineCurve& operator=(const ON_Line&);
  
  /////////////////////////////////////////////////////////////////
  // ON_Object overrides

  // virtual ON_Object::SizeOf override
  unsigned int SizeOf() const;

  // virtual ON_Object::DataCRC override
  ON__UINT32 DataCRC(ON__UINT32 current_remainder) const;

  /*
  Description:
    Tests an object to see if its data members are correctly
    initialized.
  Parameters:
    text_log - [in] if the object is not valid and text_log
        is not NULL, then a brief englis description of the
        reason the object is not valid is appened to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     object is valid
    false    object is invalid, uninitialized, etc.
  Remarks:
    Overrides virtual ON_Object::IsValid
  */
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  void Dump( ON_TextLog& ) const; // for debugging

  ON_BOOL32 Write(
         ON_BinaryArchive&  // open binary file
       ) const;

  ON_BOOL32 Read(
         ON_BinaryArchive&  // open binary file
       );

  /////////////////////////////////////////////////////////////////
  // ON_Geometry overrides

  int Dimension() const;

  ON_BOOL32 GetBBox( // returns true if successful
         double*,    // minimum
         double*,    // maximum
         ON_BOOL32 = false  // true means grow box
         ) const;

  /*
	Description:
    Get tight bounding box of the line.
	Parameters:
		tight_bbox - [in/out] tight bounding box
		bGrowBox -[in]	(default=false)			
      If true and the input tight_bbox is valid, then returned
      tight_bbox is the union of the input tight_bbox and the 
      line's tight bounding box.
		xform -[in] (default=NULL)
      If not NULL, the tight bounding box of the transformed
      line is calculated.  The line is not modified.
	Returns:
    True if the returned tight_bbox is set to a valid 
    bounding box.
  */
	bool GetTightBoundingBox( 
			ON_BoundingBox& tight_bbox, 
      int bGrowBox = false,
			const ON_Xform* xform = 0
      ) const;

  ON_BOOL32 Transform( 
         const ON_Xform&
         );

  // virtual ON_Geometry::IsDeformable() override
  bool IsDeformable() const;

  // virtual ON_Geometry::MakeDeformable() override
  bool MakeDeformable();

  ON_BOOL32 SwapCoordinates(
        int, int        // indices of coords to swap
        );

  /////////////////////////////////////////////////////////////////
  // ON_Curve overrides

  ON_Interval Domain() const;

  // Description:
  //   Set the domain of the curve
  // Parameters:
  //   t0 - [in]
  //   t1 - [in] new domain will be [t0,t1]
  // Returns:
  //   true if successful.
  ON_BOOL32 SetDomain( 
        double t0, 
        double t1 
        );

  bool ChangeDimension(
          int desired_dimension
          );

  int SpanCount() const; // number of smooth spans in curve

  ON_BOOL32 GetSpanVector( // span "knots" 
         double* // array of length SpanCount() + 1 
         ) const; // 

  int Degree( // returns maximum algebraic degree of any span 
                  // ( or a good estimate if curve spans are not algebraic )
    ) const; 

  ON_BOOL32 IsLinear( // true if curve locus is a line segment between
                 // between specified points
        double = ON_ZERO_TOLERANCE // tolerance to use when checking linearity
        ) const;

  /*
  Description:
    Several types of ON_Curve can have the form of a polyline including
    a degree 1 ON_NurbsCurve, an ON_PolylineCurve, and an ON_PolyCurve
    all of whose segments are some form of polyline.  IsPolyline tests
    a curve to see if it can be represented as a polyline.
  Parameters:
    pline_points - [out] if not NULL and true is returned, then the
        points of the polyline form are returned here.
    t - [out] if not NULL and true is returned, then the parameters of
        the polyline points are returned here.
  Returns:
    @untitled table
    0        curve is not some form of a polyline
    >=2      number of points in polyline form
  */
  virtual
  int IsPolyline(
        ON_SimpleArray<ON_3dPoint>* pline_points = NULL,
        ON_SimpleArray<double>* pline_t = NULL
        ) const;

  ON_BOOL32 IsArc( // ON_Arc.m_angle > 0 if curve locus is an arc between
              // specified points
        const ON_Plane* = NULL, // if not NULL, test is performed in this plane
        ON_Arc* = NULL, // if not NULL and true is returned, then arc parameters
                         // are filled in
        double = ON_ZERO_TOLERANCE    // tolerance to use when checking
        ) const;

  ON_BOOL32 IsPlanar(
        ON_Plane* = NULL, // if not NULL and true is returned, then plane parameters
                           // are filled in
        double = ON_ZERO_TOLERANCE    // tolerance to use when checking
        ) const;

  ON_BOOL32 IsInPlane(
        const ON_Plane&, // plane to test
        double = ON_ZERO_TOLERANCE    // tolerance to use when checking
        ) const;

  ON_BOOL32 IsClosed(  // true if curve is closed (either curve has
        void      // clamped end knots and euclidean location of start
        ) const;  // CV = euclidean location of end CV, or curve is
                  // periodic.)

  ON_BOOL32 IsPeriodic(  // true if curve is a single periodic segment
        void 
        ) const;
  
  /*
  Description:
    Force the curve to start at a specified point.
  Parameters:
    start_point - [in]
  Returns:
    true if successful.
  Remarks:
    Some end points cannot be moved.  Be sure to check return
    code.
  See Also:
    ON_Curve::SetEndPoint
    ON_Curve::PointAtStart
    ON_Curve::PointAtEnd
  */
  ON_BOOL32 SetStartPoint(
          ON_3dPoint start_point
          );

  /*
  Description:
    Force the curve to end at a specified point.
  Parameters:
    end_point - [in]
  Returns:
    true if successful.
  Remarks:
    Some end points cannot be moved.  Be sure to check return
    code.
  See Also:
    ON_Curve::SetStartPoint
    ON_Curve::PointAtStart
    ON_Curve::PointAtEnd
  */
  ON_BOOL32 SetEndPoint(
          ON_3dPoint end_point
          );

  ON_BOOL32 Reverse();       // reverse parameterizatrion
                        // Domain changes from [a,b] to [-b,-a]

  ON_BOOL32 Evaluate( // returns false if unable to evaluate
         double,         // evaluation parameter
         int,            // number of derivatives (>=0)
         int,            // array stride (>=Dimension())
         double*,        // array of length stride*(ndir+1)
         int = 0,        // optional - determines which side to evaluate from
                         //         0 = default
                         //      <  0 to evaluate from below, 
                         //      >  0 to evaluate from above
         int* = 0        // optional - evaluation hint (int) used to speed
                         //            repeated evaluations
         ) const;


  // virtual ON_Curve override
  int IntersectSelf(
          ON_SimpleArray<ON_X_EVENT>& x,
          double intersection_tolerance = 0.0,
          const ON_Interval* curve_domain = 0
          ) const;


  // Description:
  //   virtual ON_Curve::Trim override.
  //   Removes portions of the curve outside the specified interval.
  // Parameters:
  //   domain - [in] interval of the curve to keep.  Portions of the
  //      curve before curve(domain[0]) and after curve(domain[1]) are
  //      removed.
  // Returns:
  //   true if successful.
  ON_BOOL32 Trim(
    const ON_Interval& domain
    );

  // Description:
  //   Where possible, analytically extends curve to include domain.
  // Parameters:
  //   domain - [in] if domain is not included in curve domain, 
  //   curve will be extended so that its domain includes domain.  
  //   Original curve is identical
  //   to the restriction of the resulting curve to the original curve domain, 
  // Returns:
  //   true if successful.
  bool Extend(
    const ON_Interval& domain
    );

  // Description:
  //   virtual ON_Curve::Split override.
  //   Divide the curve at the specified parameter.  The parameter
  //   must be in the interior of the curve's domain.  The pointers
  //   passed to Split must either be NULL or point to an ON_Curve
  //   object of the same of the same type.  If the pointer is NULL,
  //   then a curve will be created in Split().  You may pass "this"
  //   as one of the pointers to Split().
  // Parameters:
  //   t - [in] parameter in interval Domain().
  //   left_side - [out] left portion of curve
  //   right_side - [out] right portion of curve
  // Example:
  //   For example, if crv were an ON_NurbsCurve, then
  //
  //     ON_NurbsCurve right_side;
  //     crv.Split( crv.Domain().Mid() &crv, &right_side );
  //
  //   would split crv at the parametric midpoint, put the left side
  //   in crv, and return the right side in right_side.
  ON_BOOL32 Split(
      double t,    // t = curve parameter to split curve at
      ON_Curve*& left_side, // left portion returned here
      ON_Curve*& right_side // right portion returned here
    ) const;

  // Description:
  //   virtual ON_Curve::GetNurbForm override.
  //   Get a NURBS curve representation of this curve.
  // Parameters:
  //   nurbs_curve - [out] NURBS representation returned here
  //   tolerance - [in] tolerance to use when creating NURBS
  //       representation.
  //   subdomain - [in] if not NULL, then the NURBS representation
  //       for this portion of the curve is returned.
  // Returns:
  //   0   unable to create NURBS representation
  //       with desired accuracy.
  //   1   success - returned NURBS parameterization
  //       matches the curve's to wthe desired accuracy
  //   2   success - returned NURBS point locus matches
  //       the curve's to the desired accuracy but, on
  //       the interior of the curve's domain, the 
  //       curve's parameterization and the NURBS
  //       parameterization may not match to the 
  //       desired accuracy.
  int GetNurbForm(
        ON_NurbsCurve&,
        double = 0.0,
        const ON_Interval* = NULL
        ) const;

  // Description:
  //   virtual ON_Curve::HasNurbForm override.
  //   Does a NURBS curve representation of this curve exist.
  // Parameters:
  // Returns:
  //   0   unable to create NURBS representation
  //       with desired accuracy.
  //   1   success - returned NURBS parameterization
  //       matches the curve's to wthe desired accuracy
  //   2   success - returned NURBS point locus matches
  //       the curve's to the desired accuracy but, on
  //       the interior of the curve's domain, the 
  //       curve's parameterization and the NURBS
  //       parameterization may not match to the 
  //       desired accuracy.
  int HasNurbForm(
        ) const;

  // Description:
  //   virtual ON_Curve::GetCurveParameterFromNurbFormParameter override.
  //   Convert a NURBS curve parameter to a curve parameter
  //
  // Parameters:
  //   nurbs_t - [in] nurbs form parameter
  //   curve_t - [out] curve parameter
  //
  // Remarks:
  //   If GetNurbForm returns 2, this function converts the curve
  //   parameter to the NURBS curve parameter.
  //
  // See Also:
  //   ON_Curve::GetNurbForm, ON_Curve::GetNurbFormParameterFromCurveParameter
  virtual
  ON_BOOL32 GetCurveParameterFromNurbFormParameter(
        double nurbs_t,
        double* curve_t
        ) const;

  // Description:
  //   virtual ON_Curve::GetNurbFormParameterFromCurveParameter override.
  //   Convert a curve parameter to a NURBS curve parameter.
  //
  // Parameters:
  //   curve_t - [in] curve parameter
  //   nurbs_t - [out] nurbs form parameter
  //
  // Remarks:
  //   If GetNurbForm returns 2, this function converts the curve
  //   parameter to the NURBS curve parameter.
  //
  // See Also:
  //   ON_Curve::GetNurbForm, ON_Curve::GetCurveParameterFromNurbFormParameter
  virtual
  ON_BOOL32 GetNurbFormParameterFromCurveParameter(
        double curve_t,
        double* nurbs_t
        ) const;

  /////////////////////////////////////////////////////////////////
  // Interface

  ON_Line m_line;
  ON_Interval m_t;  // domain
  int      m_dim;   // 2 or 3 (2 so ON_LineCurve can be uses as a trimming curve)
};


#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(ON_GEOMETRY_CURVE_ARC_INC_)
#define ON_GEOMETRY_CURVE_ARC_INC_


/*
Description:
  ON_ArcCurve is used to represent arcs and circles.
  ON_ArcCurve.IsCircle() returns true if the curve
  is a complete circle.
Details:
	an ON_ArcCurve is a subcurve of a circle, with a
	constant speed parameterization. The parameterization is
	an affine linear reparameterzation of the underlying arc
	m_arc onto the domain m_t.

	A valid ON_ArcCurve has Radius()>0 and  0<AngleRadians()<=2*PI
	and a strictly increasing Domain().
*/
class ON_CLASS ON_ArcCurve : public ON_Curve
{
  ON_OBJECT_DECLARE(ON_ArcCurve);

public:
  ON_ArcCurve();
  ON_ArcCurve(const ON_ArcCurve&);
  virtual ~ON_ArcCurve();

  // virtual ON_Object::SizeOf override
  unsigned int SizeOf() const;

  // virtual ON_Object::DataCRC override
  ON__UINT32 DataCRC(ON__UINT32 current_remainder) const;

  /*
  Description:
    Create an arc curve with domain (0,arc.Length()).
  */
  ON_ArcCurve(
      const ON_Arc& arc
      );

  /*
  Description:
    Create an arc curve with domain (t0,t1)
  */
  ON_ArcCurve(
      const ON_Arc& arc,
      double t0,
      double t1
      );

  /*
  Description:
    Creates a curve that is a complete circle with
    domain (0,circle.Length()).
  */
  ON_ArcCurve(
      const ON_Circle& circle
      );

  /*
  Description:
    Creates a curve that is a complete circle with domain (t0,t1).
  */
  ON_ArcCurve(
      const ON_Circle& circle,
      double t0,
      double t1
      );


	ON_ArcCurve& operator=(const ON_ArcCurve&);

  /*
  Description:
    Create an arc curve with domain (0,arc.Length()).
  */
	ON_ArcCurve& operator=(const ON_Arc& arc);

  /*
  Description:
    Creates a curve that is a complete circle with
    domain (0,circle.Length()).
  */
	ON_ArcCurve& operator=(const ON_Circle& circle);

  /////////////////////////////////////////////////////////////////
  // ON_Object overrides

  /*
  Description:
		A valid ON_ArcCurve has Radius()>0 and  0<AngleRadians()<=2*PI
		and a strictly increasing Domain().
  Parameters:
    text_log - [in] if the object is not valid and text_log
        is not NULL, then a brief English description of the
        reason the object is not valid is appended to the log.
        The information appended to text_log is suitable for
        low-level debugging purposes by programmers and is
        not intended to be useful as a high level user
        interface tool.
  Returns:
    @untitled table
    true     object is valid
    false    object is invalid, uninitialized, etc.
  Remarks:
    Overrides virtual ON_Object::IsValid
  */
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  void Dump( ON_TextLog& ) const;

  ON_BOOL32 Write(
         ON_BinaryArchive&  // open binary file
       ) const;

  ON_BOOL32 Read(
         ON_BinaryArchive&  // open binary file
       );

  /////////////////////////////////////////////////////////////////
  // ON_Geometry overrides

  int Dimension() const;

  ON_BOOL32 GetBBox( // returns true if successful
         double*,    // minimum
         double*,    // maximum
         ON_BOOL32 = false  // true means grow box
         ) const;

  /*
	Description:
    Get tight bounding box of the arc.
	Parameters:
		tight_bbox - [in/out] tight bounding box
		bGrowBox -[in]	(default=false)
      If true and the input tight_bbox is valid, then returned
      tight_bbox is the union of the input tight_bbox and the
      arc's tight bounding box.
		xform -[in] (default=NULL)
      If not NULL, the tight bounding box of the transformed
      arc is calculated.  The arc is not modified.
	Returns:
    True if the returned tight_bbox is set to a valid
    bounding box.
  */
	bool GetTightBoundingBox(
			ON_BoundingBox& tight_bbox,
      int bGrowBox = false,
			const ON_Xform* xform = 0
      ) const;


  ON_BOOL32 Transform(
         const ON_Xform&
         );

  /////////////////////////////////////////////////////////////////
  // ON_Curve overrides

  // Description:
  //   virtual ON_Curve::SetDomain override.
  //   Set the domain of the curve
  // Parameters:
  //   t0 - [in]
  //   t1 - [in] new domain will be [t0,t1]
  // Returns:
  //   true if successful.
  ON_BOOL32 SetDomain(
        double t0,
        double t1
        );

  ON_Interval Domain() const;

  bool ChangeDimension(
          int desired_dimension
          );

  ON_BOOL32 ChangeClosedCurveSeam(
            double t
            );

  int SpanCount() const; // number of smooth spans in curve

  ON_BOOL32 GetSpanVector( // span "knots"
         double* // array of length SpanCount() + 1
         ) const; //

  int Degree( // returns maximum algebraic degree of any span
                  // ( or a good estimate if curve spans are not algebraic )
    ) const;

  ON_BOOL32 IsLinear( // true if curve locus is a line segment between
                 // between specified points
        double = ON_ZERO_TOLERANCE // tolerance to use when checking linearity
        ) const;

  ON_BOOL32 IsArc( // ON_Arc.m_angle > 0 if curve locus is an arc between
              // specified points
        const ON_Plane* = NULL, // if not NULL, test is performed in this plane
        ON_Arc* = NULL, // if not NULL and true is returned, then arc parameters
                         // are filled in
        double = 0.0    // tolerance to use when checking
        ) const;

  ON_BOOL32 IsPlanar(
        ON_Plane* = NULL, // if not NULL and true is returned, then plane parameters
                           // are filled in
        double = 0.0    // tolerance to use when checking
        ) const;

  ON_BOOL32 IsInPlane(
        const ON_Plane&, // plane to test
        double = 0.0    // tolerance to use when checking
        ) const;

  ON_BOOL32 IsClosed(  // true if curve is closed (either curve has
        void      // clamped end knots and euclidean location of start
        ) const;  // CV = euclidean location of end CV, or curve is
                  // periodic.)

  ON_BOOL32 IsPeriodic(  // true if curve is a single periodic segment
        void
        ) const;

  bool IsContinuous(
    ON::continuity c,
    double t,
    int* hint = NULL,
    double point_tolerance=ON_ZERO_TOLERANCE,
    double d1_tolerance=ON_ZERO_TOLERANCE,
    double d2_tolerance=ON_ZERO_TOLERANCE,
    double cos_angle_tolerance=ON_DEFAULT_ANGLE_TOLERANCE_COSINE,
    double curvature_tolerance=ON_SQRT_EPSILON
    ) const;

  ON_BOOL32 Reverse();       // reverse parameterization
                        // Domain changes from [a,b] to [-b,-a]

  /*
  Description:
    Force the curve to start at a specified point.
  Parameters:
    start_point - [in]
  Returns:
    true if successful.
  Remarks:
    Some end points cannot be moved.  Be sure to check return
    code.
  See Also:
    ON_Curve::SetEndPoint
    ON_Curve::PointAtStart
    ON_Curve::PointAtEnd
  */
  ON_BOOL32 SetStartPoint(
          ON_3dPoint start_point
          );

  /*
  Description:
    Force the curve to end at a specified point.
  Parameters:
    end_point - [in]
  Returns:
    true if successful.
  Remarks:
    Some end points cannot be moved.  Be sure to check return
    code.
  See Also:
    ON_Curve::SetStartPoint
    ON_Curve::PointAtStart
    ON_Curve::PointAtEnd
  */
  ON_BOOL32 SetEndPoint(
          ON_3dPoint end_point
          );

  ON_BOOL32 Evaluate( // returns false if unable to evaluate
         double,         // evaluation parameter
         int,            // number of derivatives (>=0)
         int,            // array stride (>=Dimension())
         double*,        // array of length stride*(ndir+1)
         int = 0,        // optional - determines which side to evaluate from
                         //         0 = default
                         //      <  0 to evaluate from below,
                         //      >  0 to evaluate from above
         int* = 0        // optional - evaluation hint (int) used to speed
                         //            repeated evaluations
         ) const;

  ON_BOOL32 Trim( const ON_Interval& );

  // Description:
  //   Where possible, analytically extends curve to include domain.
  // Parameters:
  //   domain - [in] if domain is not included in curve domain,
  //   curve will be extended so that its domain includes domain.
  //   Will not work if curve is closed. Original curve is identical
  //   to the restriction of the resulting curve to the original curve domain,
  // Returns:
  //   true if successful.
  bool Extend(
    const ON_Interval& domain
    );

  /*
  Description:
    Splits (divides) the arc at the specified parameter.
    The parameter must be in the interior of the arc's domain.
    The ON_Curve pointers passed to ON_ArcCurve::Split must
    either be NULL or point to ON_ArcCurve objects.
    If a pointer is NULL, then an ON_ArcCurve will be created
    in Split().  You may pass "this" as left_side or right_side.
  Parameters:
    t - [in] parameter to split the curve at in the
             interval returned by Domain().
    left_side - [out] left portion of curve returned here.
       If not NULL, left_side must point to an ON_ArcCuve.
    right_side - [out] right portion of curve returned here
       If not NULL, right_side must point to an ON_ArcCuve.
  Remarks:
    Overrides virtual ON_Curve::Split.
  */
  virtual
  ON_BOOL32 Split(
      double t,
      ON_Curve*& left_side,
      ON_Curve*& right_side
    ) const;


  // virtual ON_Curve override
  int IntersectSelf(
          ON_SimpleArray<ON_X_EVENT>& x,
          double intersection_tolerance = 0.0,
          const ON_Interval* curve_domain = 0
          ) const;

  // virtual ON_Curve::GetNurbForm override
  int GetNurbForm( // returns 0: unable to create NURBS representation
                   //            with desired accuracy.
                   //         1: success - returned NURBS parameterization
                   //            matches the curve's to wthe desired accuracy
                   //         2: success - returned NURBS point locus matches
                   //            the curve's to the desired accuracy but, on
                   //            the interior of the curve's domain, the
                   //            curve's parameterization and the NURBS
                   //            parameterization may not match to the
                   //            desired accuracy.
        ON_NurbsCurve&,
        double = 0.0,
        const ON_Interval* = NULL     // OPTIONAL subdomain of arc curve
        ) const;

  // virtual ON_Curve::HasNurbForm override
  int HasNurbForm( // returns 0: unable to create NURBS representation
                   //            with desired accuracy.
                   //         1: success - NURBS parameterization
                   //            matches the curve's
                   //         2: success - returned NURBS point locus matches
                   //            the curve'sbut, on
                   //            the interior of the curve's domain, the
                   //            curve's parameterization and the NURBS
                   //            parameterization may not match to the
                   //            desired accuracy.
        ) const;

  // virtual ON_Curve::GetCurveParameterFromNurbFormParameter override
  ON_BOOL32 GetCurveParameterFromNurbFormParameter(
        double, // nurbs_t
        double* // curve_t
        ) const;

  // virtual ON_Curve::GetNurbFormParameterFromCurveParameter override
  ON_BOOL32 GetNurbFormParameterFromCurveParameter(
        double, // curve_t
        double* // nurbs_t
        ) const;


  /*
  Description:
    Returns true if this arc curve is a complete circle.
  */
  bool IsCircle() const;

  // Returns:
  //   The arc's radius.
	double Radius() const;

  // Returns:
  //   The arc's subtended angle in radians.
  double AngleRadians() const;

  // Returns:
  //   The arc's subtended angle in degrees.
  double AngleDegrees() const;


  /////////////////////////////////////////////////////////////////

  ON_Arc   m_arc;

  // evaluation domain (always increasing)
  // ( m_t[i] corresponds to m_arc.m_angle[i] )
  ON_Interval m_t;

  // The dimension of a arc curve can be 2 or 3.
  // (2 so ON_ArcCurve can be used as a trimming curve)
  int m_dim;

};


#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_CURVE_POLYLINE_INC_)
#define OPENNURBS_CURVE_POLYLINE_INC_

class ON_PolylineCurve;
class ON_CLASS ON_PolylineCurve : public ON_Curve
{
  ON_OBJECT_DECLARE(ON_PolylineCurve);

public:
  ON_PolylineCurve();
  ON_PolylineCurve(const ON_3dPointArray&);
  ON_PolylineCurve(const ON_PolylineCurve&);
	ON_PolylineCurve& operator=(const ON_PolylineCurve&);
	ON_PolylineCurve& operator=(const ON_3dPointArray&);

  virtual ~ON_PolylineCurve();

  // Description:
  //   Call if memory used by ON_PolylineCurve becomes invalid.
  void EmergencyDestroy(); 

  
  /////////////////////////////////////////////////////////////////
  // ON_Object overrides

  // virtual ON_Object::SizeOf override
  unsigned int SizeOf() const;

  // virtual ON_Object::DataCRC override
  ON__UINT32 DataCRC(ON__UINT32 current_remainder) const;

  /*
  Description:
    Tests an object to see if its data members are correctly
    initialized.
  Parameters:
    text_log - [in] if the object is not valid and text_log
        is not NULL, then a brief englis description of the
        reason the object is not valid is appened to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     object is valid
    false    object is invalid, uninitialized, etc.
  Remarks:
    Overrides virtual ON_Object::IsValid
  */
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  // Description:
  //   virtual ON_Object::Dump override
  void Dump( 
    ON_TextLog& dump
    ) const;

  // Description:
  //   virtual ON_Object::Write override
  ON_BOOL32 Write(
         ON_BinaryArchive& binary_archive
       ) const;

  // Description:
  //   virtual ON_Object::Read override
  ON_BOOL32 Read(
         ON_BinaryArchive& binary_archive
       );

  /////////////////////////////////////////////////////////////////
  // ON_Geometry overrides

  // Description:
  //   virtual ON_Geometry::Dimension override
  // Returns:
  //   value of m_dim
  int Dimension() const;

  // Description:
  //   virtual ON_Geometry::GetBBox override
  //   Calculates axis aligned bounding box.
  // Parameters:
  //   boxmin - [in/out] array of Dimension() doubles
  //   boxmax - [in/out] array of Dimension() doubles
  //   bGrowBox - [in] (default=false) 
  //     If true, then the union of the input bbox and the 
  //     object's bounding box is returned in bbox.  
  //     If false, the object's bounding box is returned in bbox.
  // Returns:
  //   true if object has bounding box and calculation was successful
  ON_BOOL32 GetBBox( // returns true if successful
         double* boxmin,
         double* boxmax,
         int bGrowBox = false
         ) const;

  /*
	Description:
    Get tight bounding box.
	Parameters:
		tight_bbox - [in/out] tight bounding box
		bGrowBox -[in]	(default=false)			
      If true and the input tight_bbox is valid, then returned
      tight_bbox is the union of the input tight_bbox and the 
      polyline's tight bounding box.
		xform -[in] (default=NULL)
      If not NULL, the tight bounding box of the transformed
      polyline is calculated.  The polyline is not modified.
	Returns:
    True if a valid tight_bbox is returned.
  */
	bool GetTightBoundingBox( 
			ON_BoundingBox& tight_bbox, 
      int bGrowBox = false,
			const ON_Xform* xform = 0
      ) const;

  // Description:
  //   virtual ON_Geometry::Transform override.
  //   Transforms the NURBS curve.
  //
  // Parameters:
  //   xform - [in] transformation to apply to object.
  //
  // Remarks:
  //   When overriding this function, be sure to include a call
  //   to ON_Object::TransformUserData() which takes care of 
  //   transforming any ON_UserData that may be attached to 
  //   the object.
  ON_BOOL32 Transform( 
         const ON_Xform& xform
         );

  // virtual ON_Geometry::IsDeformable() override
  bool IsDeformable() const;

  // virtual ON_Geometry::MakeDeformable() override
  bool MakeDeformable();

  // Description:
  //   virtual ON_Geometry::SwapCoordinates override.
  //   Swaps control point coordinate values with indices i and j.
  // Parameters:
  //   i - [in] coordinate index
  //   j - [in] coordinate index
  ON_BOOL32 SwapCoordinates(
        int i, 
        int j
        );

  /////////////////////////////////////////////////////////////////
  // ON_Curve overrides

  // Description:
  //   virtual ON_Curve::Domain override.
  // Returns:
  //   domain of the polyline curve.
  ON_Interval Domain() const;

  // Description:
  //   virtual ON_Curve::SetDomain override.
  //   Set the domain of the curve
  // Parameters:
  //   t0 - [in]
  //   t1 - [in] new domain will be [t0,t1]
  // Returns:
  //   true if successful.
  ON_BOOL32 SetDomain(
        double t0, 
        double t1 
        );

  bool ChangeDimension(
          int desired_dimension
          );

  /*
  Description:
    If this curve is closed, then modify it so that
    the start/end point is at curve parameter t.
  Parameters:
    t - [in] curve parameter of new start/end point.  The
             returned curves domain will start at t.
  Returns:
    true if successful.
  Remarks:
    Overrides virtual ON_Curve::ChangeClosedCurveSeam
  */
  ON_BOOL32 ChangeClosedCurveSeam( 
            double t 
            );

  // Description:
  //   virtual ON_Curve::SpanCount override.
  //   Get number of segments in polyline.
  // Returns:
  //   Number of segments in polyline.
  int SpanCount() const;

  // Description:
  //   virtual ON_Curve::GetSpanVector override.
  //   Get list of parameters at polyline points.
  // Parameters:
  //   knot_values - [out] an array of length SpanCount()+1 is 
  //       filled in with the parameter values.  knot_values[i]
  //       is the parameter for the point m_pline[i].
  // Returns:
  //   true if successful
  ON_BOOL32 GetSpanVector(
         double* knot_values
         ) const;

  // Description:
  //   virtual ON_Curve::Degree override.
  // Returns:
  //   1
  int Degree() const; 

  // Description:
  //   virtual ON_Curve::IsLinear override.
  // Returns:
  //   true if all the polyline points are within tolerance
  //   of the line segment connecting the ends of the polyline.
  ON_BOOL32 IsLinear(
        double tolerance = ON_ZERO_TOLERANCE
        ) const;

  /*
  Description:
    Several types of ON_Curve can have the form of a polyline including
    a degree 1 ON_NurbsCurve, an ON_PolylineCurve, and an ON_PolyCurve
    all of whose segments are some form of polyline.  IsPolyline tests
    a curve to see if it can be represented as a polyline.
  Parameters:
    pline_points - [out] if not NULL and true is returned, then the
        points of the polyline form are returned here.
    t - [out] if not NULL and true is returned, then the parameters of
        the polyline points are returned here.
  Returns:
    @untitled table
    0        curve is not some form of a polyline
    >=2      number of points in polyline form
  */
  int IsPolyline(
        ON_SimpleArray<ON_3dPoint>* pline_points = NULL,
        ON_SimpleArray<double>* pline_t = NULL
        ) const;

  // Description:
  //   virtual ON_Curve::IsArc override.
  // Returns:
  //   false for all polylines.
  ON_BOOL32 IsArc(
        const ON_Plane* plane = NULL,
        ON_Arc* arc = NULL,
        double tolerance = ON_ZERO_TOLERANCE
        ) const;

  // Description:
  //   virtual ON_Curve::IsPlanar override.
  // Returns:
  //   true if the polyline is planar.
  ON_BOOL32 IsPlanar(
        ON_Plane* plane = NULL,
        double tolerance = ON_ZERO_TOLERANCE
        ) const;

  // Description:
  //   virtual ON_Curve::IsInPlane override.
  // Returns:
  //   true if every point in the polyline is within 
  //   tolerance of the test_plane.
  ON_BOOL32 IsInPlane(
        const ON_Plane& test_plane,
        double tolerance = ON_ZERO_TOLERANCE
        ) const;

  // Description:
  //   virtual ON_Curve::IsClosed override.
  // Returns:
  //   true if the polyline has 4 or more point, the
  //   first point and the last point are equal, and
  //   some other point is distinct from the first and
  //   last point.
  ON_BOOL32 IsClosed() const;

  // Description:
  //   virtual ON_Curve::IsPeriodic override.
  // Returns:
  //   false for all polylines.
  ON_BOOL32 IsPeriodic(  // true if curve is a single periodic segment
        void 
        ) const;
  
  /*
  Description:
    Search for a derivatitive, tangent, or curvature discontinuity.
  Parameters:
    c - [in] type of continity to test for.  If ON::C1_continuous
    t0 - [in] search begins at t0
    t1 - [in] (t0 < t1) search ends at t1
    t - [out] if a discontinuity is found, the *t reports the
          parameter at the discontinuity.
    hint - [in/out] if GetNextDiscontinuity will be called repeatedly,
       passing a "hint" with initial value *hint=0 will increase the speed
       of the search.       
    dtype - [out] if not NULL, *dtype reports the kind of discontinuity
        found at *t.  A value of 1 means the first derivative or unit tangent
        was discontinuous.  A value of 2 means the second derivative or
        curvature was discontinuous.
    cos_angle_tolerance - [in] default = cos(1 degree) Used only when
        c is ON::G1_continuous or ON::G2_continuous.  If the cosine
        of the angle between two tangent vectors 
        is <= cos_angle_tolerance, then a G1 discontinuity is reported.
    curvature_tolerance - [in] (default = ON_SQRT_EPSILON) Used only when
        c is ON::G2_continuous or ON::Gsmooth_continuous.  
        ON::G2_continuous:
          If K0 and K1 are curvatures evaluated
          from above and below and |K0 - K1| > curvature_tolerance,
          then a curvature discontinuity is reported.
        ON::Gsmooth_continuous:
          If K0 and K1 are curvatures evaluated from above and below
          and the angle between K0 and K1 is at least twice angle tolerance
          or ||K0| - |K1|| > (max(|K0|,|K1|) > curvature_tolerance,
          then a curvature discontinuity is reported.
  Returns:
    true if a discontinuity was found on the interior of the interval (t0,t1).
  Remarks:
    Overrides ON_Curve::GetNextDiscontinuity.
  */
  bool GetNextDiscontinuity( 
                  ON::continuity c,
                  double t0,
                  double t1,
                  double* t,
                  int* hint=NULL,
                  int* dtype=NULL,
                  double cos_angle_tolerance=ON_DEFAULT_ANGLE_TOLERANCE_COSINE,
                  double curvature_tolerance=ON_SQRT_EPSILON
                  ) const;

  /*
  Description:
    Test continuity at a curve parameter value.
  Parameters:
    c - [in] continuity to test for
    t - [in] parameter to test
    hint - [in] evaluation hint
    point_tolerance - [in] if the distance between two points is
        greater than point_tolerance, then the curve is not C0.
    d1_tolerance - [in] if the difference between two first derivatives is
        greater than d1_tolerance, then the curve is not C1.
    d2_tolerance - [in] if the difference between two second derivatives is
        greater than d2_tolerance, then the curve is not C2.
    cos_angle_tolerance - [in] default = cos(1 degree) Used only when
        c is ON::G1_continuous or ON::G2_continuous.  If the cosine
        of the angle between two tangent vectors 
        is <= cos_angle_tolerance, then a G1 discontinuity is reported.
    curvature_tolerance - [in] (default = ON_SQRT_EPSILON) Used only when
        c is ON::G2_continuous or ON::Gsmooth_continuous.  
        ON::G2_continuous:
          If K0 and K1 are curvatures evaluated
          from above and below and |K0 - K1| > curvature_tolerance,
          then a curvature discontinuity is reported.
        ON::Gsmooth_continuous:
          If K0 and K1 are curvatures evaluated from above and below
          and the angle between K0 and K1 is at least twice angle tolerance
          or ||K0| - |K1|| > (max(|K0|,|K1|) > curvature_tolerance,
          then a curvature discontinuity is reported.
  Returns:
    true if the curve has at least the c type continuity at the parameter t.
  Remarks:
    Overrides ON_Curve::IsContinuous.
  */
  bool IsContinuous(
    ON::continuity c,
    double t, 
    int* hint = NULL,
    double point_tolerance=ON_ZERO_TOLERANCE,
    double d1_tolerance=ON_ZERO_TOLERANCE,
    double d2_tolerance=ON_ZERO_TOLERANCE,
    double cos_angle_tolerance=ON_DEFAULT_ANGLE_TOLERANCE_COSINE,
    double curvature_tolerance=ON_SQRT_EPSILON
    ) const;

  // Description:
  //   virtual ON_Curve::Reverse override.
  //   Reverse parameterizatrion by negating all m_t values
  //   and reversing the order of the m_pline points.
  // Remarks:
  //   Domain changes from [a,b] to [-b,-a]
  ON_BOOL32 Reverse();

  /*
  Description:
    Force the curve to start at a specified point.
  Parameters:
    start_point - [in]
  Returns:
    true if successful.
  Remarks:
    Some start points cannot be moved.  Be sure to check return
    code.
  See Also:
    ON_Curve::SetEndPoint
    ON_Curve::PointAtStart
    ON_Curve::PointAtEnd
  */
  // virtual
  ON_BOOL32 SetStartPoint(
          ON_3dPoint start_point
          );

  /*
  Description:
    Force the curve to end at a specified point.
  Parameters:
    end_point - [in]
  Returns:
    true if successful.
  Remarks:
    Some end points cannot be moved.  Be sure to check return
    code.
  See Also:
    ON_Curve::SetStartPoint
    ON_Curve::PointAtStart
    ON_Curve::PointAtEnd
  */
  //virtual
  ON_BOOL32 SetEndPoint(
          ON_3dPoint end_point
          );

  ON_BOOL32 Evaluate( // returns false if unable to evaluate
         double,         // evaluation parameter
         int,            // number of derivatives (>=0)
         int,            // array stride (>=Dimension())
         double*,        // array of length stride*(ndir+1)
         int = 0,        // optional - determines which side to evaluate from
                         //         0 = default
                         //      <  0 to evaluate from below, 
                         //      >  0 to evaluate from above
         int* = 0        // optional - evaluation hint (int) used to speed
                         //            repeated evaluations
         ) const;

  // Description:
  //   virtual ON_Curve::Trim override.
  ON_BOOL32 Trim( const ON_Interval& );

  // Description:
  //   Where possible, analytically extends curve to include domain.
  // Parameters:
  //   domain - [in] if domain is not included in curve domain, 
  //   curve will be extended so that its domain includes domain.  
  //   Will not work if curve is closed. Original curve is identical
  //   to the restriction of the resulting curve to the original curve domain, 
  // Returns:
  //   true if successful.
  bool Extend(
    const ON_Interval& domain
    );

  // Description:
  //   virtual ON_Curve::Split override.
  //
  // Split() divides the polyline at the specified parameter.  The parameter
  // must be in the interior of the curve's domain.  The pointers passed
  // to ON_NurbsCurve::Split must either be NULL or point to an ON_NurbsCurve.
  // If the pointer is NULL, then a curve will be created
  // in Split().  You may pass "this" as one of the pointers to Split().
  // For example, 
  //
  //   ON_NurbsCurve right_side;
  //   crv.Split( crv.Domain().Mid() &crv, &right_side );
  //
  // would split crv at the parametric midpoint, put the left side in crv,
  // and return the right side in right_side.
  ON_BOOL32 Split(
      double,    // t = curve parameter to split curve at
      ON_Curve*&, // left portion returned here (must be an ON_NurbsCurve)
      ON_Curve*&  // right portion returned here (must be an ON_NurbsCurve)
    ) const;

  int GetNurbForm( // returns 0: unable to create NURBS representation
                   //            with desired accuracy.
                   //         1: success - returned NURBS parameterization
                   //            matches the curve's to wthe desired accuracy
                   //         2: success - returned NURBS point locus matches
                   //            the curve's to the desired accuracy but, on
                   //            the interior of the curve's domain, the 
                   //            curve's parameterization and the NURBS
                   //            parameterization may not match to the 
                   //            desired accuracy.
        ON_NurbsCurve&,
        double = 0.0,
        const ON_Interval* = NULL     // OPTIONAL subdomain of polyline
        ) const;

  int HasNurbForm( // returns 0: unable to create NURBS representation
                   //            with desired accuracy.
                   //         1: success - returned NURBS parameterization
                   //            matches the curve's to wthe desired accuracy
                   //         2: success - returned NURBS point locus matches
                   //            the curve's to the desired accuracy but, on
                   //            the interior of the curve's domain, the 
                   //            curve's parameterization and the NURBS
                   //            parameterization may not match to the 
                   //            desired accuracy.
        ) const;

  // virtual ON_Curve::GetCurveParameterFromNurbFormParameter override
  ON_BOOL32 GetCurveParameterFromNurbFormParameter(
        double, // nurbs_t
        double* // curve_t
        ) const;

  // virtual ON_Curve::GetNurbFormParameterFromCurveParameter override
  ON_BOOL32 GetNurbFormParameterFromCurveParameter(
        double, // curve_t
        double* // nurbs_t
        ) const;
/*
	Description:
		Lookup a parameter in the m_t array, optionally using a built in snap tolerance to 
		snap a parameter value to an element of m_t.
	Parameters:
		t - [in]	  	parameter
		index -[out]	index into m_t such that
					  			if function returns false then value of index is
								   
									 @table  
									 value of index              condition
						  			  -1									  t<m_t[0] or m_t is empty				
										  0<=i<=m_t.Count()-2		m_t[i] < t < m_t[i+1]			
										  m_t.Count()-1					t>m_t[ m_t.Count()-1]			 

									if the function returns true then t is equal to, or is closest to and 
									within  tolerance of m_t[index]. 
									
		bEnableSnap-[in] enable snapping 	
	Returns:		
		true if the t is exactly equal to, or within tolerance of
		(only if bEnableSnap==true) m_t[index]. 
*/ 
	bool ParameterSearch(double t, int& index, bool bEnableSnap) const;

  bool Append( const ON_PolylineCurve& );

  /////////////////////////////////////////////////////////////////
  // Interface
	public:
  int PointCount() const; // number of points in polyline

  ON_Polyline            m_pline;
  ON_SimpleArray<double> m_t;    // parameters
  int                    m_dim;  // 2 or 3 (2 so ON_PolylineCurve can be uses as a trimming curve)
};


#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

////////////////////////////////////////////////////////////////
//
//   Definition of NURBS curve
//
////////////////////////////////////////////////////////////////

#if !defined(OPENNURBS_NURBSCURVE_INC_)
#define OPENNURBS_NURBSCURVE_INC_

class ON_NurbsCurve;
class ON_CLASS ON_NurbsCurve : public ON_Curve
{
  ON_OBJECT_DECLARE(ON_NurbsCurve);

public:
  /*
  Description:
    Use ON_NurbsCurve::New(...) instead of new ON_NurbsCurve(...)
  Returns:
    Pointer to an ON_NurbsCurve.  Destroy by calling delete.
  Remarks:
    See static ON_Brep* ON_Brep::New() for details.
  */
  static ON_NurbsCurve* New();
  static ON_NurbsCurve* New(
            const ON_NurbsCurve& nurbs_curve 
            );
  static ON_NurbsCurve* New(
            const ON_BezierCurve& bezier_curve 
            );
  static ON_NurbsCurve* New(
            int dimension,
            ON_BOOL32 bIsRational,
            int order,
            int cv_count
            );

  ON_NurbsCurve();
  ON_NurbsCurve(const ON_NurbsCurve&);

  // Description:
  //   Create a NURBS curve equal to bezier with domain [0,1].
  // Parameters:
  //   bezier_curve - [in]
  ON_NurbsCurve(
        const ON_BezierCurve& bezier_curve
        );

  // Description:
  //   Create a NURBS curve with knot a cv memory allocated.
  // Parameters:
  //   dimension - [in] (>= 1)
  //   bIsRational - [in] true to make a rational NURBS
  //   order - [in] (>= 2) The order=degree+1
  //   cv_count - [in] (>= order) number of control vertices
  ON_NurbsCurve(
          int dimension,
          ON_BOOL32 bIsRational,
          int order,
          int cv_count
          );

  // virtual ON_Object::SizeOf override
  unsigned int SizeOf() const;

  // virtual ON_Object::DataCRC override
  ON__UINT32 DataCRC(ON__UINT32 current_remainder) const;

  /*
  Description:
    See if this and other are same NURBS geometry.
  Parameters:
    other - [in] other NURBS curve
    bIgnoreParameterization - [in] if true, parameterization
             and orientaion are ignored.
    tolerance - [in] tolerance to use when comparing
                     control points.
  Returns:
    true if curves are tne same.
  */
  bool IsDuplicate( 
          const ON_NurbsCurve& other, 
          bool bIgnoreParameterization,
          double tolerance = ON_ZERO_TOLERANCE 
          ) const;

  // Description:
  //   Zeros all fields.
  void Initialize(void);

  // Description:
  //   Create a NURBS curve with knot a cv memory allocated.
  // Parameters:
  //   dimension - [in] (>= 1)
  //   bIsRational - [in] true to make a rational NURBS
  //   order - [in] (>= 2) The order=degree+1
  //   cv_count - [in] (>= order) number of control vertices
  bool Create( 
          int dimension,
          ON_BOOL32 bIsRational,
          int order,
          int cv_count
          );

  // Description:
  //   Create a clamped uniform NURBS curve from a list
  //   of control points
  // Parameters:
  //   dimension - [in] 1, 2 or 3
  //   order - [in] (>=2) order=degree+1
  //   point_count - [in] (>=order) number of control vertices
  //   point - [in] array of control vertex locations.
  //   knot_delta - [in] (>0.0) knot spacing
  // Returns:
  //   true if successful
  bool CreateClampedUniformNurbs( 
          int dimension,
          int order,
          int point_count,
          const ON_3dPoint* point,
          double knot_delta = 1.0
          );

  // Description:
  //   Create a periodic uniform NURBS curve from a list
  //   of control points
  // Parameters:
  //   dimension - [in] 1, 2 or 3
  //   order - [in] (>=2) order=degree+1
  //   point_count - [in] (>=max(3,order-1)) number of distinct control vertices
  //   point - [in] array of distinct control vertex locations.
  //   knot_delta - [in] (>0.0) knot spacing
  // Returns:
  //   true if successful
  bool CreatePeriodicUniformNurbs( 
          int dimension,
          int order,
          int point_count,
          const ON_3dPoint* point,
          double knot_delta = 1.0
          );

  // Description:
  //   Deallocate knot and cv memory.  Zeros all fields.
  void Destroy();

  virtual ~ON_NurbsCurve();

  // Description:
  //   Call if memory used by ON_NurbsCurve becomes invalid.
  void EmergencyDestroy(); 

	ON_NurbsCurve& operator=(const ON_NurbsCurve& src);

  // Description:
  //   Set NURBS curve equal to bezier with domain [0,1].
  // Parameters:
  //   bezier_curve - [in]
	ON_NurbsCurve& operator=(
    const ON_BezierCurve& bezier_curve
    );

  /////////////////////////////////////////////////////////////////
  // ON_Object overrides

  /*
  Description:
    Tests an object to see if its data members are correctly
    initialized.
  Parameters:
    text_log - [in] if the object is not valid and text_log
        is not NULL, then a brief englis description of the
        reason the object is not valid is appened to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     object is valid
    false    object is invalid, uninitialized, etc.
  Remarks:
    Overrides virtual ON_Object::IsValid
  */
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  // Description:
  //   virtual ON_Object::Dump override
  void Dump( 
    ON_TextLog& dump
    ) const;

  // Description:
  //   virtual ON_Object::Write override
  ON_BOOL32 Write(
         ON_BinaryArchive& binary_archive
       ) const;

  // Description:
  //   virtual ON_Object::Read override
  ON_BOOL32 Read(
         ON_BinaryArchive& binary_archive
       );

  /////////////////////////////////////////////////////////////////
  // ON_Geometry overrides

  // Description:
  //   virtual ON_Geometry::Dimension override
  // Returns:
  //   value of m_dim
  int Dimension() const;

  // Description:
  //   virtual ON_Geometry::GetBBox override
  //   Calculates axis aligned bounding box.
  // Parameters:
  //   boxmin - [in/out] array of Dimension() doubles
  //   boxmax - [in/out] array of Dimension() doubles
  //   bGrowBox - [in] (default=false) 
  //     If true, then the union of the input bbox and the 
  //     object's bounding box is returned in bbox.  
  //     If false, the object's bounding box is returned in bbox.
  // Returns:
  //   true if object has bounding box and calculation was successful
  ON_BOOL32 GetBBox( // returns true if successful
         double* boxmin,
         double* boxmax,
         int bGrowBox = false
         ) const;

  // Description:
  //   virtual ON_Geometry::Transform override.
  //   Transforms the NURBS curve.
  //
  // Parameters:
  //   xform - [in] transformation to apply to object.
  //
  // Remarks:
  //   When overriding this function, be sure to include a call
  //   to ON_Object::TransformUserData() which takes care of 
  //   transforming any ON_UserData that may be attached to 
  //   the object.
  ON_BOOL32 Transform( 
         const ON_Xform& xform
         );

  // virtual ON_Geometry::IsDeformable() override
  bool IsDeformable() const;

  // virtual ON_Geometry::MakeDeformable() override
  bool MakeDeformable();

  // Description:
  //   virtual ON_Geometry::SwapCoordinates override.
  //   Swaps control vertex coordinate values with indices i and j.
  // Parameters:
  //   i - [in] coordinate index
  //   j - [in] coordinate index
  ON_BOOL32 SwapCoordinates(
        int i, 
        int j
        );

  /////////////////////////////////////////////////////////////////
  // ON_Curve overrides

  // Description:
  //   virtual ON_Curve::Domain override.
  // Returns:
  //   domain of the NURBS curve.
  ON_Interval Domain() const;

  // Description:
  //   virtual ON_Curve::SetDomain override.
  //   Set the domain of the curve
  // Parameters:
  //   t0 - [in]
  //   t1 - [in] new domain will be [t0,t1]
  // Returns:
  //   true if successful.
  ON_BOOL32 SetDomain(
        double t0, 
        double t1 
        );

  /*
  Description:
    If this curve is closed, then modify it so that
    the start/end point is at curve parameter t.
  Parameters:
    t - [in] curve parameter of new start/end point.  The
             returned curves domain will start at t.
  Returns:
    true if successful.
  Remarks:
    Overrides virtual ON_Curve::ChangeClosedCurveSeam
  */
  ON_BOOL32 ChangeClosedCurveSeam( 
            double t 
            );

  // Description:
  //   virtual ON_Curve::SpanCount override.
  //   Get number of nonempty smooth (c-infinity) spans in curve
  // Returns:
  //   Number of nonempty smooth (c-infinity) spans.
  // Remarks:
  //   A nonempty span is bracked by knots m_knot[i] < m_knot[i+1]
  //   with m_order-2 <= i < m_cv_count-1.
  int SpanCount() const;

  // Description:
  //   virtual ON_Curve::GetSpanVector override.
  //   Get number of parameters of distinct knots in NURBS curve's domain.
  // Parameters:
  //   knot_values - [out] an array of length SpanCount()+1 is 
  //       filled in with the distinct knot values in the list
  ///      (m_knot[m_order-2],...,m_knot[m_cv_count-1)
  // Returns:
  //   true if successful
  ON_BOOL32 GetSpanVector(
         double* knot_values
         ) const; // 

  // Description:
  //   virtual ON_Curve::Degree override.
  // Returns:
  //   m_order-1
  int Degree() const; 

  // Description:
  //   virtual ON_Curve::GetParameterTolerance override.
  ON_BOOL32 GetParameterTolerance( // returns tminus < tplus: parameters tminus <= s <= tplus
         double t,
         double* tminus,
         double* tplus
         ) const;

  // Description:
  //   virtual ON_Curve::IsLinear override.
  ON_BOOL32 IsLinear(
        double tolerance = ON_ZERO_TOLERANCE
        ) const;

  /*
  Description:
    Several types of ON_Curve can have the form of a polyline including
    a degree 1 ON_NurbsCurve, an ON_PolylineCurve, and an ON_PolyCurve
    all of whose segments are some form of polyline.  IsPolyline tests
    a curve to see if it can be represented as a polyline.
  Parameters:
    pline_points - [out] if not NULL and true is returned, then the
        points of the polyline form are returned here.
    t - [out] if not NULL and true is returned, then the parameters of
        the polyline points are returned here.
  Returns:
    @untitled table
    0        curve is not some form of a polyline
    >=2      number of points in polyline form
  */
  int IsPolyline(
        ON_SimpleArray<ON_3dPoint>* pline_points = NULL,
        ON_SimpleArray<double>* pline_t = NULL
        ) const;

  // Description:
  //   virtual ON_Curve::IsArc override.
  ON_BOOL32 IsArc(
        const ON_Plane* plane = NULL,
        ON_Arc* arc = NULL,
        double tolerance = ON_ZERO_TOLERANCE
        ) const;

  // Description:
  //   virtual ON_Curve::IsPlanar override.
  ON_BOOL32 IsPlanar(
        ON_Plane* plane = NULL,
        double tolerance = ON_ZERO_TOLERANCE
        ) const;

  // Description:
  //   virtual ON_Curve::IsInPlane override.
  ON_BOOL32 IsInPlane(
        const ON_Plane& test_plane,
        double tolerance = ON_ZERO_TOLERANCE
        ) const;

  // Description:
  //   virtual ON_Curve::IsClosed override.
  // Returns:
  //   true if NURBS curve is closed. (Either curve has
  //   clamped end knots and euclidean location of start
  //   CV = euclidean location of end CV, or curve is
  //   periodic.)
  ON_BOOL32 IsClosed() const;

  // Description:
  //   virtual ON_Curve::IsPeriodic override.
  // Returns:
  //   true if NURBS curve is periodic (degree > 1,
  //   periodic knot vector, last degree many CVs 
  //   are duplicates of first degree many CVs).
  ON_BOOL32 IsPeriodic() const;
  
  /*
  Description:
    Search for a derivatitive, tangent, or curvature discontinuity.
  Parameters:
    c - [in] type of continity to test for.  If ON::C1_continuous
    t0 - [in] search begins at t0
    t1 - [in] (t0 < t1) search ends at t1
    t - [out] if a discontinuity is found, the *t reports the
          parameter at the discontinuity.
    hint - [in/out] if GetNextDiscontinuity will be called repeatedly,
       passing a "hint" with initial value *hint=0 will increase the speed
       of the search.       
    dtype - [out] if not NULL, *dtype reports the kind of discontinuity
        found at *t.  A value of 1 means the first derivative or unit tangent
        was discontinuous.  A value of 2 means the second derivative or
        curvature was discontinuous.
    cos_angle_tolerance - [in] default = cos(1 degree) Used only when
        c is ON::G1_continuous or ON::G2_continuous.  If the cosine
        of the angle between two tangent vectors 
        is <= cos_angle_tolerance, then a G1 discontinuity is reported.
    curvature_tolerance - [in] (default = ON_SQRT_EPSILON) Used only when
        c is ON::G2_continuous or ON::Gsmooth_continuous.  
        ON::G2_continuous:
          If K0 and K1 are curvatures evaluated
          from above and below and |K0 - K1| > curvature_tolerance,
          then a curvature discontinuity is reported.
        ON::Gsmooth_continuous:
          If K0 and K1 are curvatures evaluated from above and below
          and the angle between K0 and K1 is at least twice angle tolerance
          or ||K0| - |K1|| > (max(|K0|,|K1|) > curvature_tolerance,
          then a curvature discontinuity is reported.
  Returns:
    true if a discontinuity was found on the interior of the interval (t0,t1).
  Remarks:
    Overrides ON_Curve::GetNextDiscontinuity.
  */
  bool GetNextDiscontinuity( 
                  ON::continuity c,
                  double t0,
                  double t1,
                  double* t,
                  int* hint=NULL,
                  int* dtype=NULL,
                  double cos_angle_tolerance=ON_DEFAULT_ANGLE_TOLERANCE_COSINE,
                  double curvature_tolerance=ON_SQRT_EPSILON
                  ) const;

  /*
  Description:
    Test continuity at a curve parameter value.
  Parameters:
    c - [in] continuity to test for
    t - [in] parameter to test
    hint - [in] evaluation hint
    point_tolerance - [in] if the distance between two points is
        greater than point_tolerance, then the curve is not C0.
    d1_tolerance - [in] if the difference between two first derivatives is
        greater than d1_tolerance, then the curve is not C1.
    d2_tolerance - [in] if the difference between two second derivatives is
        greater than d2_tolerance, then the curve is not C2.
    cos_angle_tolerance - [in] default = cos(1 degree) Used only when
        c is ON::G1_continuous or ON::G2_continuous.  If the cosine
        of the angle between two tangent vectors 
        is <= cos_angle_tolerance, then a G1 discontinuity is reported.
    curvature_tolerance - [in] (default = ON_SQRT_EPSILON) Used only when
        c is ON::G2_continuous or ON::Gsmooth_continuous.  
        ON::G2_continuous:
          If K0 and K1 are curvatures evaluated
          from above and below and |K0 - K1| > curvature_tolerance,
          then a curvature discontinuity is reported.
        ON::Gsmooth_continuous:
          If K0 and K1 are curvatures evaluated from above and below
          and the angle between K0 and K1 is at least twice angle tolerance
          or ||K0| - |K1|| > (max(|K0|,|K1|) > curvature_tolerance,
          then a curvature discontinuity is reported.
  Returns:
    true if the curve has at least the c type continuity at the parameter t.
  Remarks:
    Overrides ON_Curve::IsContinuous.
  */
  bool IsContinuous(
    ON::continuity c,
    double t, 
    int* hint = NULL,
    double point_tolerance=ON_ZERO_TOLERANCE,
    double d1_tolerance=ON_ZERO_TOLERANCE,
    double d2_tolerance=ON_ZERO_TOLERANCE,
    double cos_angle_tolerance=ON_DEFAULT_ANGLE_TOLERANCE_COSINE,
    double curvature_tolerance=ON_SQRT_EPSILON
    ) const;

  /*
  Description:
    Force the curve to start at a specified point.
  Parameters:
    start_point - [in]
  Returns:
    true if successful.
  Remarks:
    Some end points cannot be moved.  Be sure to check return
    code.
  See Also:
    ON_Curve::SetEndPoint
    ON_Curve::PointAtStart
    ON_Curve::PointAtEnd
  */
  //virtual
  ON_BOOL32 SetStartPoint(
          ON_3dPoint start_point
          );

  /*
  Description:
    Force the curve to end at a specified point.
  Parameters:
    end_point - [in]
  Returns:
    true if successful.
  Remarks:
    Some end points cannot be moved.  Be sure to check return
    code.
  See Also:
    ON_Curve::SetStartPoint
    ON_Curve::PointAtStart
    ON_Curve::PointAtEnd
  */
  //virtual
  ON_BOOL32 SetEndPoint(
          ON_3dPoint end_point
          );

  // Description:
  //   virtual ON_Curve::Reverse override.
  //   Reverse parameterizatrion by negating all knots
  //   and reversing the order of the control vertices.
  // Remarks:
  //   Domain changes from [a,b] to [-b,-a]
  ON_BOOL32 Reverse();       

  // Description:
  //   virtual ON_Curve::Evaluate override.
  ON_BOOL32 Evaluate( // returns false if unable to evaluate
         double,         // evaluation parameter
         int,            // number of derivatives (>=0)
         int,            // array stride (>=Dimension())
         double*,        // array of length stride*(ndir+1)
         int = 0,        // optional - determines which side to evaluate from
                         //         0 = default
                         //      <  0 to evaluate from below, 
                         //      >  0 to evaluate from above
         int* = 0        // optional - evaluation hint (int) used to speed
                         //            repeated evaluations
         ) const;

  /*
  Parameters:
    span_index - [in]
      (0 <= span_index <= m_cv_count-m_order)
    min_length -[in]
      minimum length of a linear span
    tolerance -[in]
      distance tolerance to use when checking control points
      between the span ends
  Returns 
    true if the span is a non-degenrate line.  This means:
    - dimension = 2 or 3
    - There are full multiplicity knots at each end of the span.
    - The length of the the line segment from the span's initial 
      control point to the span's final control point is 
      >= min_length.
    - The distance from the line segment to the interior control points
      is <= tolerance and the projections of these points onto
      the line increases monotonically.
  */
  bool SpanIsLinear( 
    int span_index, 
    double min_length,
    double tolerance
    ) const;

  bool SpanIsLinear( 
    int span_index, 
    double min_length,
    double tolerance,
    ON_Line* line
    ) const;

  /*
  Description:
    Looks for problems caused by knots that are close together
    or have mulitplicity >= order. If bRepair is true, the problems
    are fixed.  Does not change the domain.
  Parameters:
    knot_tolerance - [in] >= 0  When in doubt, use zero.
    bRepair - [in] If true, then problems are repaired.
      Otherwise this function looks for problemsn that
      can be repaired, but does not modify the curve.
  Returns:
    True if bad knots were found and can be repaired.
  See Also:
    ON_NurbsCurve::RemoveShortSegments
  */
  bool RepairBadKnots(
    double knot_tolerance=0.0,
    bool bRepair = true
    );

  // Description:
  //   virtual ON_Curve::Trim override.
  ON_BOOL32 Trim( const ON_Interval& );

  // Description:
  //   Where possible, analytically extends curve to include domain.
  // Parameters:
  //   domain - [in] if domain is not included in curve domain, 
  //   curve will be extended so that its domain includes domain.  
  //   Will not work if curve is closed. Original curve is identical
  //   to the restriction of the resulting curve to the original curve domain, 
  // Returns:
  //   true if successful.
  bool Extend(
    const ON_Interval& domain
    );

  // Description:
  //   virtual ON_Curve::Split override.
  //
  // Split() divides the curve at the specified parameter.  The parameter
  // must be in the interior of the curve's domain.  The pointers passed
  // to ON_NurbsCurve::Split must either be NULL or point to an ON_NurbsCurve.
  // If the pointer is NULL, then a curve will be created
  // in Split().  You may pass "this" as one of the pointers to Split().
  // For example, 
  //
  //   ON_NurbsCurve right_side;
  //   crv.Split( crv.Domain().Mid() &crv, &right_side );
  //
  // would split crv at the parametric midpoint, put the left side in crv,
  // and return the right side in right_side.
  ON_BOOL32 Split(
      double split_param,    // t = curve parameter to split curve at
      ON_Curve*& left_result, // left portion returned here (must be an ON_NurbsCurve)
      ON_Curve*& right_result // right portion returned here (must be an ON_NurbsCurve)
    ) const;

  // Description:
  //   virtual ON_Curve::GetNurbForm override.
  int GetNurbForm( // returns 0: unable to create NURBS representation
                   //            with desired accuracy.
                   //         1: success - returned NURBS parameterization
                   //            matches the curve's to wthe desired accuracy
                   //         2: success - returned NURBS point locus matches
                   //            the curve's to the desired accuracy but, on
                   //            the interior of the curve's domain, the 
                   //            curve's parameterization and the NURBS
                   //            parameterization may not match to the 
                   //            desired accuracy.
        ON_NurbsCurve& nurbsform,
        double tolerance = 0.0,
        const ON_Interval* subdomain = NULL     // OPTIONAL subdomain of curve
        ) const;

  // Description:
  //   virtual ON_Curve::HasNurbForm override.
  int HasNurbForm( // returns 0: unable to create NURBS representation
                   //            with desired accuracy.
                   //         1: success - returned NURBS parameterization
                   //            matches the curve's to wthe desired accuracy
                   //         2: success - returned NURBS point locus matches
                   //            the curve's to the desired accuracy but, on
                   //            the interior of the curve's domain, the 
                   //            curve's parameterization and the NURBS
                   //            parameterization may not match to the 
                   //            desired accuracy.
        ) const;

  // Description:
  //   virtual ON_Curve::GetCurveParameterFromNurbFormParameter override
  ON_BOOL32 GetCurveParameterFromNurbFormParameter(
        double  nurbs_t,
        double* curve_t
        ) const;

  // Description:
  //   virtual ON_Curve::GetNurbFormParameterFromCurveParameter override
  ON_BOOL32 GetNurbFormParameterFromCurveParameter(
        double  curve_t,
        double* nurbs_t
        ) const;

public:

  /////////////////////////////////////////////////////////////////
  // Interface

  bool IsRational(  // true if NURBS curve is rational
        void
        ) const;
  
  int CVSize(       // number of doubles per control vertex 
        void        // = IsRational() ? Dim()+1 : Dim()
        ) const;
  
  int Order(        // order = degree + 1
        void
        ) const;
	
  int CVCount(      // number of control vertices
        void 
        ) const;

  int KnotCount(    // total number of knots in knot vector
        void
        ) const;
  
  /*
  Description:
    Expert user function to get a pointer to control vertex
    memory.  If you are not an expert user, please use
    ON_NurbsCurve::GetCV( ON_3dPoint& ) or 
    ON_NurbsCurve::GetCV( ON_4dPoint& ).
  Parameters:
    cv_index - [in]
  Returns:
    Pointer to control vertex.
  Remarks:
    If the NURBS curve is rational, the format of the 
    returned array is a homogeneos rational point with
    length m_dim+1.  If the NURBS curve is not rational, 
    the format of the returned array is a nonrational 
    euclidean point with length m_dim.
  See Also
    ON_NurbsCurve::CVStyle
    ON_NurbsCurve::GetCV
    ON_NurbsCurve::Weight
  */
  double* CV(
        int cv_index
        ) const;

  /*
  Description:
    Returns the style of control vertices in the m_cv array.
  Returns:
    @untitled table
    ON::not_rational                m_is_rat is false
    ON::homogeneous_rational        m_is_rat is true
  */
  ON::point_style CVStyle() const;


  double Weight(        // get value of control vertex weight
        int             // CV index ( >= 0 and < CVCount() )
        ) const;

  ON_BOOL32 SetWeight(      // get value of control vertex weight
        int,            // CV index ( >= 0 and < CVCount() )
        double
        );

  ON_BOOL32 SetCV(              // set a single control vertex
        int,              // CV index ( >= 0 and < CVCount() )
        ON::point_style, // style of input point
        const double*     // value of control vertex
        );

  ON_BOOL32 SetCV(               // set a single control vertex
        int,               // CV index ( >= 0 and < CVCount() )
        const ON_3dPoint& // value of control vertex
                           // If NURBS is rational, weight
                           // will be set to 1.
        );

  ON_BOOL32 SetCV(              // set a single control vertex
        int,              // CV index ( >= 0 and < CVCount() )
        const ON_4dPoint& // value of control vertex
                          // If NURBS is not rational, euclidean
                          // location of homogeneous point will
                          // be used.
        );

  ON_BOOL32 GetCV(              // get a single control vertex
        int,              // CV index ( >= 0 and < CVCount() )
        ON::point_style, // style to use for output point
        double*           // array of length >= CVSize()
        ) const;

  ON_BOOL32 GetCV(              // get a single control vertex
        int,              // CV index ( >= 0 and < CVCount() )
        ON_3dPoint&      // gets euclidean cv when NURBS is rational
        ) const;

  ON_BOOL32 GetCV(              // get a single control vertex
        int,              // CV index ( >= 0 and < CVCount() )
        ON_4dPoint&      // gets homogeneous cv
        ) const;

  // Description:
  //   Set knot value.
  // Parameters:
  //   knot_index - [in] 0 <= knot_index <= KnotCount()-1
  //   knot_value - [in]
  // Remarks:
  //   m_knot[] must exist.  Use ReserveKnotCapacity to
  //   allocate m_knot[].
  // Returns:
  //   true if successful
  // See Also:
  //   ON_NurbsCurve::ReserveKnotCapacity
  bool SetKnot(
        int knot_index,
        double knot_value
        );

  // Description:
  //   Get knot value.
  // Parameters:
  //   knot_index - [in] 0 <= knot_index <= KnotCount()-1
  // Returns:
  //   knot value = m_knot[knot_index]
  // See Also:
  //   ON_NurbsCurve::SetKnot, ON_NurbsCurve::KnotMultiplicity
  double Knot(
        int knot_index
        ) const;

  // Description:
  //   Get knot multiplicity.
  // Parameters:
  //   knot_index - [in] 0 <= knot_index <= KnotCount()-1
  // Returns:
  //   knot multiplicity = m_knot[knot_index]
  // See Also:
  //   ON_NurbsCurve::SetKnot, ON_NurbsCurve::Knot, 
  //   ON_NurbsCurve::InsertKnot
  int KnotMultiplicity(
        int knot_index
        ) const;

  // Description:
  //   Get pointer to knot vector array.
  // Returns:
  //   pointer to knot vector array (m_knot).
  // See Also:
  //   ON_NurbsCurve::SetKnot, ON_NurbsCurve::Knot, 
  //   ON_NurbsCurve::InsertKnot
  const double* Knot() const;

  // Description:
  //   Make knot vector a clamped uniform knot vector
  //   based on the current values of m_order and m_cv_count.
  //   Does not change values of control vertices.
  // Parameters:
  //   delta - [in] (>0.0) knot spacing.
  // Returns:
  //   true if successful.
  // Remarks:
  //   Allocates m_knot[] if it is not big enough.
  // See Also:
  //   ON_MakeClampedUniformKnotVector
  bool MakeClampedUniformKnotVector( 
    double delta = 1.0 
    );

  // Description:
  //   Make knot vector a periodic uniform knot vector
  //   based on the current values of m_order and m_cv_count.
  //   Does not change values of control vertices.
  // Parameters:
  //   delta - [in] (>0.0) knot spacing.
  // Returns:
  //   true if successful.
  // Remarks:
  //   Allocates m_knot[] if it is not big enough.
  // See Also:
  //   ON_MakePeriodicUniformKnotVector
  bool MakePeriodicUniformKnotVector( 
    double delta = 1.0 
    );

  bool IsClamped( // determine if knot vector is clamped
        int = 2 // end to check: 0 = start, 1 = end, 2 = start and end
        ) const;
  
  double SuperfluousKnot(
           int // 0 = start, 1 = end
           ) const;

  double GrevilleAbcissa(
           int   // index (0 <= index < CVCount(dir)
           ) const;

  bool GetGrevilleAbcissae( // see ON_GetGrevilleAbcissae() for details
           double*   // g[cv_count]
           ) const;

  bool ZeroCVs(); // zeros control vertices and, if rational, sets weights to 1

  // Description:
  //   Clamp end knots.  Does not modify control points.
  // Parameters:
  //   end - [in] 0 = clamp start, 1 = clamp end, 2 = clamp start and end
  // Returns:
  //   true if successful
  bool ClampEnd(
            int end
            );

  // Description:
  //   Insert a knot and update cv locations.
  // Parameters:
  //   knot_value - [in] m_knot[order-2] < knot_value < m_knot[m_cv_count-1]
  //   knot_multiplicity - [in] 1 to degree - includes multiplicity of existing knots.
  // Remarks:
  //   Does not change parameterization or locus of curve.
  // Returns:
  //   true if successful
  bool InsertKnot( 
            double knot_value,
            int knot_multiplicity
            );

  bool MakeRational();

  bool MakeNonRational();

  bool IncreaseDegree(
          int desired_degree
          );

  bool ChangeDimension(
          int desired_dimension
          );

  bool Append( const ON_NurbsCurve& );

  /////////////////////////////////////////////////////////////////
  // Tools for managing CV and knot memory
  bool ReserveCVCapacity(
    int // number of doubles to reserve
    );
  bool ReserveKnotCapacity(
    int // number of doubles to reserve
    );

  //////////
  // returns the length of the control polygon
  double ControlPolygonLength() const;

  ////////
  // Converts a span of the NURBS curve into a bezier.  If
  // the span is empty 
  // (m_knot[span_index+m_order-2] == m_knot[span_index+m_order-1]),
  // then false is returned.
  bool ConvertSpanToBezier(
      int,            // span_index (0 <= span_index <= m_cv_count-m_order)
      ON_BezierCurve& // bezier returned here
      ) const;

  /*
  Paramaters:
    span_index - [in]
      The index of a non-empty span to test.
        span_index >= 0
        span_index <= m_cv_count-m_order
        m_knot[span_index+m_order-2] < m_knot[span_index+m_order-1]
  Returns:
    true if the span_index parameter is valid and the span is singular
    (collapsed to a point).
    false if the span is not singular or span_index does not identify
    a non-empty span.
  */
  bool SpanIsSingular( 
    int span_index 
    ) const;

  /*
  Paramaters:
    span_index - [in]
      The index of a non-empty span to remove.
        span_index >= 0
        span_index <= m_cv_count-m_order
        m_knot[span_index+m_order-2] < m_knot[span_index+m_order-1]
  Returns:
    True if the span was successfully removed.
  Remarks:
    The NURBS curve must have 2 or more spans (m_cv_count > m_order).
    Set m0 = mulitiplicity of the knot at m_knot[span_index+m_order-2]
    and m1 = mulitiplicity of the knot at m_knot[span_index+m_order-1].
    If (m0 + m1) < degree, then the degree-(m0+m1) cvs will be added
    to the NURBS curve. If (m0+m1) > degree, then (m0+m1)-degree cvs will
    be removed from the curve.
  See Also:
    ON_NurbsCurve::RepairBadKnots()
    ON_NurbsCurve::RemoveShortSegments()
  */
  bool RemoveSpan(
    int span_index 
    );

  /*
  Returns:
    Number of spans removed.
  */
  int RemoveSingularSpans();

  ////////
  // Returns true if the NURBS curve has bezier spans 
  // (all distinct knots have multiplitity = degree)
  bool HasBezierSpans() const;

  /*
  Description:
    Clamps ends and adds knots so the NURBS curve has bezier spans 
   (all distinct knots have multiplitity = degree).
  Paremeters:
    bSetEndWeightsToOne - [in] If true and the first or last weight is
       not one, then the first and last spans are reparameterized so 
       that the end weights are one.
  Returns:
    true if successful.
  */      
  bool MakePiecewiseBezier( 
        bool bSetEndWeightsToOne = false
        );

  /*
  Description:
    Use a combination of scaling and reparameterization to change
    the end weights to the specified values.
  Parameters:
    w0 - [in] weight for first cv
    w1 - [in] weight for last cv
  Returns:
    true if successful.
  See Also:
    ON_ChangeRationalNurbsCurveEndWeights
  Remarks:
    The domain, eucleanean locations of the control points,
    and locus of the curve do not change, but the weights,
    homogeneous cv values and internal knot values may change.
    If w0 and w1 are 1 and the curve is not rational, the 
    curve is not changed.
  */
  bool ChangeEndWeights( double w0, double w1 );

  /*
  Description:
    Use a linear fractional transformation to reparameterize 
    the NURBS curve.  This does not change the curve's domain.
  Parameters:
    c - [in]
      reparameterization constant (generally speaking, c should be > 0).
      The control points and knots are adjusted so that 
      output_nurbs(t) = input_nurbs(lambda(t)), where
      lambda(t) = c*t/( (c-1)*t + 1 ).
      Note that lambda(0) = 0, lambda(1) = 1, lambda'(t) > 0, 
      lambda'(0) = c and lambda'(1) = 1/c.
  Returns:
    true if successful.  
  Remarks:
    The cv and knot values are values are changed so that
    output_nurbs(t) = input_nurbs(lambda(t)).
  See Also:
    ON_ReparameterizeRationalNurbsCurve
  */
  bool Reparameterize( double c );



  /////////////////////////////////////////////////////////////////
  // Implementation
public:
  // NOTE: These members are left "public" so that expert users may efficiently
  //       create NURBS curves using the default constructor and borrow the
  //       knot and CV arrays from their native NURBS representation.
  //       No technical support will be provided for users who access these
  //       members directly.  If you can't get your stuff to work, then use
  //       the constructor with the arguments and the SetKnot() and SetCV()
  //       functions to fill in the arrays.

  int     m_dim;            // (>=1)

  int     m_is_rat;         // 1 for rational B-splines. (Rational control
                            // vertices use homogeneous form.)
                            // 0 for non-rational B-splines. (Control
                            // verticies do not have a weight coordinate.)

  int     m_order;          // order = degree+1 (>=2)

  int     m_cv_count;       // number of control vertices ( >= order )

  // knot vector memory

  int     m_knot_capacity;  // If m_knot_capacity > 0, then m_knot[]
                            // is an array of at least m_knot_capacity
                            // doubles whose memory is managed by the
                            // ON_NurbsCurve class using rhmalloc(),
                            // onrealloc(), and rhfree().
                            // If m_knot_capacity is 0 and m_knot is
                            // not NULL, then  m_knot[] is assumed to
                            // be big enough for any requested operation
                            // and m_knot[] is not deleted by the
                            // destructor.

  double* m_knot;           // Knot vector. ( The knot vector has length
                            // m_order+m_cv_count-2. )
  
  // control vertex net memory

  int     m_cv_stride;      // The pointer to start of "CV[i]" is
                            //   m_cv + i*m_cv_stride.

  int     m_cv_capacity;    // If m_cv_capacity > 0, then m_cv[] is an array
                            // of at least m_cv_capacity doubles whose
                            // memory is managed by the ON_NurbsCurve
                            // class using rhmalloc(), onrealloc(), and rhfree().
                            // If m_cv_capacity is 0 and m_cv is not
                            // NULL, then m_cv[] is assumed to be big enough
                            // for any requested operation and m_cv[] is not
                            // deleted by the destructor.

  double* m_cv;             // Control points.
                            // If m_is_rat is false, then control point is
                            //
                            //          ( CV(i)[0], ..., CV(i)[m_dim-1] ).
                            //
                            // If m_is_rat is true, then the control point
                            // is stored in HOMOGENEOUS form and is
                            //
                            //           [ CV(i)[0], ..., CV(i)[m_dim] ].
                            //
};

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

////////////////////////////////////////////////////////////////
//
//   Definition of poly curve (composite curve)
//
////////////////////////////////////////////////////////////////

#if !defined(OPENNURBS_POLYCURVE_INC_)
#define OPENNURBS_POLYCURVE_INC_

/*
 Description: 
		An ON_PolyCurve is an ON_Curve represented by a sequence of 
	contiguous ON_Curve segments.    A valid polycurve is represented 
	by an array m_segment of Count()>=1 curve objects	and a strictly
	increasing array m_t of Count()+1 parameter values.  The i-th 
	curve segment,  when considered as part of the polycurve, is affinely 
	reparamaterized from m_t[i] to m_t[i+1], i.e., m_segment[i].Domain()[0] 
	is mapped to 	m_t[i] and m_segment[i].Domain()[1] is mapped to m_t[i+1]. 
*/
class ON_PolyCurve;
class ON_CLASS ON_PolyCurve : public ON_Curve
{
  ON_OBJECT_DECLARE(ON_PolyCurve);

public:
  // virtual ON_Object::DestroyRuntimeCache override
  void DestroyRuntimeCache( bool bDelete = true );

public:
  ON_PolyCurve();
  ON_PolyCurve( int ); // int = initial capacity - use when a good estimate
                        // of the number of segments is known.
  ON_PolyCurve(const ON_PolyCurve&);

  void Destroy();

  virtual ~ON_PolyCurve();

  void EmergencyDestroy(); // call if memory used by ON_PolyCurve becomes invalid

	ON_PolyCurve& operator=(const ON_PolyCurve&);
  
  /////////////////////////////////////////////////////////////////
  // ON_Object overrides

  // virtual ON_Object::SizeOf override
  unsigned int SizeOf() const;

  // virtual ON_Object::DataCRC override
  ON__UINT32 DataCRC(ON__UINT32 current_remainder) const;

  /*
  Description:
    Tests an object to see if its data members are correctly
    initialized.
  Parameters:
    text_log - [in] if the object is not valid and text_log
        is not NULL, then a brief englis description of the
        reason the object is not valid is appened to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     object is valid
    false    object is invalid, uninitialized, etc.
  Remarks:
    Overrides virtual ON_Object::IsValid
  */
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  /*
  Description:
    Tests an object to see if its data members are correctly
    initialized.
  Parameters:
    bAllowGaps - [in]
      If true, gaps are allowed between polycurve segments.
      If false, gaps are not allowed between polycurve segments.
    text_log - [in] if the object is not valid and text_log
        is not NULL, then a brief englis description of the
        reason the object is not valid is appened to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     object is valid
    false    object is invalid, uninitialized, etc.
  Remarks:
    Overrides virtual ON_Object::IsValid
  */
  bool IsValid( bool bAllowGaps, ON_TextLog* text_log ) const;


  void Dump( ON_TextLog& ) const; // for debugging

  ON_BOOL32 Write(
         ON_BinaryArchive&  // open binary file
       ) const;

  ON_BOOL32 Read(
         ON_BinaryArchive&  // open binary file
       );

  /////////////////////////////////////////////////////////////////
  // ON_Geometry overrides

  int Dimension() const;

  ON_BOOL32 GetBBox( // returns true if successful
         double*,    // minimum
         double*,    // maximum
         ON_BOOL32 = false  // true means grow box
         ) const;

  /*
	Description:
    Get tight bounding box.
	Parameters:
		tight_bbox - [in/out] tight bounding box
		bGrowBox -[in]	(default=false)			
      If true and the input tight_bbox is valid, then returned
      tight_bbox is the union of the input tight_bbox and the 
      curve's tight bounding box.
		xform -[in] (default=NULL)
      If not NULL, the tight bounding box of the transformed
      curve is calculated.  The curve is not modified.
	Returns:
    True if a valid tight_bbox is returned.
  */
	bool GetTightBoundingBox( 
			ON_BoundingBox& tight_bbox, 
      int bGrowBox = false,
			const ON_Xform* xform = 0
      ) const;

  ON_BOOL32 Transform( 
         const ON_Xform&
         );

  // virtual ON_Geometry::IsDeformable() override
  bool IsDeformable() const;

  // virtual ON_Geometry::MakeDeformable() override
  bool MakeDeformable();

  ON_BOOL32 SwapCoordinates(
        int, int        // indices of coords to swap
        );

  // virtual ON_Geometry override
  bool EvaluatePoint( const class ON_ObjRef& objref, ON_3dPoint& P ) const;

  /////////////////////////////////////////////////////////////////
  // ON_Curve overrides

  ON_Curve* DuplicateCurve() const;

  ON_Interval Domain() const;

  // Description:
  //   virtual ON_Curve::SetDomain override.
  //   Set the domain of the curve
  // Parameters:
  //   t0 - [in]
  //   t1 - [in] new domain will be [t0,t1]
  // Returns:
  //   true if successful.
  ON_BOOL32 SetDomain(
        double t0, 
        double t1 
        );

  bool ChangeDimension(
          int desired_dimension
          );

  /*
  Description:
    If this curve is closed, then modify it so that
    the start/end point is at curve parameter t.
  Parameters:
    t - [in] curve parameter of new start/end point.  The
             returned curves domain will start at t.
  Returns:
    true if successful.
  Remarks:
    Overrides virtual ON_Curve::ChangeClosedCurveSeam
  */
  ON_BOOL32 ChangeClosedCurveSeam( 
            double t 
            );

  int SpanCount() const; // number of smooth spans in curve

  ON_BOOL32 GetSpanVector( // span "knots" 
         double* // array of length SpanCount() + 1 
         ) const; // 

  int Degree( // returns maximum algebraic degree of any span 
                  // ( or a good estimate if curve spans are not algebraic )
    ) const; 

  ON_BOOL32 IsLinear( // true if curve locus is a line segment between
                 // between specified points
        double = ON_ZERO_TOLERANCE // tolerance to use when checking linearity
        ) const;

  /*
  Description:
    Several types of ON_Curve can have the form of a polyline including
    a degree 1 ON_NurbsCurve, an ON_PolylineCurve, and an ON_PolyCurve
    all of whose segments are some form of polyline.  IsPolyline tests
    a curve to see if it can be represented as a polyline.
  Parameters:
    pline_points - [out] if not NULL and true is returned, then the
        points of the polyline form are returned here.
    t - [out] if not NULL and true is returned, then the parameters of
        the polyline points are returned here.
  Returns:
    @untitled table
    0        curve is not some form of a polyline
    >=2      number of points in polyline form
  */
  int IsPolyline(
        ON_SimpleArray<ON_3dPoint>* pline_points = NULL,
        ON_SimpleArray<double>* pline_t = NULL
        ) const;

  ON_BOOL32 IsArc( // ON_Arc.m_angle > 0 if curve locus is an arc between
              // specified points
        const ON_Plane* = NULL, // if not NULL, test is performed in this plane
        ON_Arc* = NULL, // if not NULL and true is returned, then arc parameters
                         // are filled in
        double = ON_ZERO_TOLERANCE    // tolerance to use when checking
        ) const;

  ON_BOOL32 IsPlanar(
        ON_Plane* = NULL, // if not NULL and true is returned, then plane parameters
                           // are filled in
        double = ON_ZERO_TOLERANCE    // tolerance to use when checking
        ) const;

  ON_BOOL32 IsInPlane(
        const ON_Plane&, // plane to test
        double = ON_ZERO_TOLERANCE    // tolerance to use when checking
        ) const;

  ON_BOOL32 IsClosed(  // true if curve is closed (either curve has
        void      // clamped end knots and euclidean location of start
        ) const;  // CV = euclidean location of end CV, or curve is
                  // periodic.)

  ON_BOOL32 IsPeriodic(  // true if curve is a single periodic segment
        void 
        ) const;
  
  /*
  Description:
    Search for a derivatitive, tangent, or curvature discontinuity.
  Parameters:
    c - [in] type of continity to test for.  If ON::C1_continuous
    t0 - [in] search begins at t0
    t1 - [in] (t0 < t1) search ends at t1
    t - [out] if a discontinuity is found, the *t reports the
          parameter at the discontinuity.
    hint - [in/out] if GetNextDiscontinuity will be called repeatedly,
       passing a "hint" with initial value *hint=0 will increase the speed
       of the search.       
    dtype - [out] if not NULL, *dtype reports the kind of discontinuity
        found at *t.  A value of 1 means the first derivative or unit tangent
        was discontinuous.  A value of 2 means the second derivative or
        curvature was discontinuous.
    cos_angle_tolerance - [in] default = cos(1 degree) Used only when
        c is ON::G1_continuous or ON::G2_continuous.  If the cosine
        of the angle between two tangent vectors 
        is <= cos_angle_tolerance, then a G1 discontinuity is reported.
    curvature_tolerance - [in] (default = ON_SQRT_EPSILON) Used only when
        c is ON::G2_continuous or ON::Gsmooth_continuous.  
        ON::G2_continuous:
          If K0 and K1 are curvatures evaluated
          from above and below and |K0 - K1| > curvature_tolerance,
          then a curvature discontinuity is reported.
        ON::Gsmooth_continuous:
          If K0 and K1 are curvatures evaluated from above and below
          and the angle between K0 and K1 is at least twice angle tolerance
          or ||K0| - |K1|| > (max(|K0|,|K1|) > curvature_tolerance,
          then a curvature discontinuity is reported.
  Returns:
    true if a discontinuity was found on the interior of the interval (t0,t1).
  Remarks:
    Overrides ON_Curve::GetNextDiscontinuity.
  */
  bool GetNextDiscontinuity( 
                  ON::continuity c,
                  double t0,
                  double t1,
                  double* t,
                  int* hint=NULL,
                  int* dtype=NULL,
                  double cos_angle_tolerance=ON_DEFAULT_ANGLE_TOLERANCE_COSINE,
                  double curvature_tolerance=ON_SQRT_EPSILON
                  ) const;

  /*
  Description:
    Test continuity at a curve parameter value.
  Parameters:
    c - [in] continuity to test for
    t - [in] parameter to test
    hint - [in] evaluation hint
    point_tolerance - [in] if the distance between two points is
        greater than point_tolerance, then the curve is not C0.
    d1_tolerance - [in] if the difference between two first derivatives is
        greater than d1_tolerance, then the curve is not C1.
    d2_tolerance - [in] if the difference between two second derivatives is
        greater than d2_tolerance, then the curve is not C2.
    cos_angle_tolerance - [in] default = cos(1 degree) Used only when
        c is ON::G1_continuous or ON::G2_continuous.  If the cosine
        of the angle between two tangent vectors 
        is <= cos_angle_tolerance, then a G1 discontinuity is reported.
    curvature_tolerance - [in] (default = ON_SQRT_EPSILON) Used only when
        c is ON::G2_continuous or ON::Gsmooth_continuous.  
        ON::G2_continuous:
          If K0 and K1 are curvatures evaluated
          from above and below and |K0 - K1| > curvature_tolerance,
          then a curvature discontinuity is reported.
        ON::Gsmooth_continuous:
          If K0 and K1 are curvatures evaluated from above and below
          and the angle between K0 and K1 is at least twice angle tolerance
          or ||K0| - |K1|| > (max(|K0|,|K1|) > curvature_tolerance,
          then a curvature discontinuity is reported.
  Returns:
    true if the curve has at least the c type continuity at the parameter t.
  Remarks:
    Overrides ON_Curve::IsContinuous.
  */
  bool IsContinuous(
    ON::continuity c,
    double t, 
    int* hint = NULL,
    double point_tolerance=ON_ZERO_TOLERANCE,
    double d1_tolerance=ON_ZERO_TOLERANCE,
    double d2_tolerance=ON_ZERO_TOLERANCE,
    double cos_angle_tolerance=ON_DEFAULT_ANGLE_TOLERANCE_COSINE,
    double curvature_tolerance=ON_SQRT_EPSILON
    ) const;

  ON_BOOL32 Reverse();       // reverse parameterizatrion
                        // Domain changes from [a,b] to [-b,-a]

  /*
  Description:
    Force the curve to start at a specified point.
  Parameters:
    start_point - [in]
  Returns:
    true if successful.
  Remarks:
    Some start points cannot be moved.  Be sure to check return
    code.
  See Also:
    ON_Curve::SetEndPoint
    ON_Curve::PointAtStart
    ON_Curve::PointAtEnd
  */
  // virtual
  ON_BOOL32 SetStartPoint(
          ON_3dPoint start_point
          );

  /*
  Description:
    Force the curve to end at a specified point.
  Parameters:
    end_point - [in]
  Returns:
    true if successful.
  Remarks:
    Some end points cannot be moved.  Be sure to check return
    code.
  See Also:
    ON_Curve::SetStartPoint
    ON_Curve::PointAtStart
    ON_Curve::PointAtEnd
  */
  //virtual
  ON_BOOL32 SetEndPoint(
          ON_3dPoint end_point
          );

  ON_BOOL32 Evaluate( // returns false if unable to evaluate
         double,         // evaluation parameter
         int,            // number of derivatives (>=0)
         int,            // array stride (>=Dimension())
         double*,        // array of length stride*(ndir+1)
         int = 0,        // optional - determines which side to evaluate from
                         //         0 = default
                         //      <  0 to evaluate from below, 
                         //      >  0 to evaluate from above
         int* = 0        // optional - evaluation hint (int) used to speed
                         //            repeated evaluations
         ) const;

  // Description:
  //   virtual ON_Curve::Trim override.
  //   Removes portions of the curve outside the specified interval.
  // Parameters:
  //   domain - [in] interval of the curve to keep.  Portions of the
  //      curve before curve(domain[0]) and after curve(domain[1]) are
  //      removed.
  // Returns:
  //   true if successful.
  ON_BOOL32 Trim(
    const ON_Interval& domain
    );

  // Description:
  //   Where possible, analytically extends curve to include domain.
  // Parameters:
  //   domain - [in] if domain is not included in curve domain, 
  //   curve will be extended so that its domain includes domain.  
  //   Will not work if curve is closed. Original curve is identical
  //   to the restriction of the resulting curve to the original curve domain, 
  // Returns:
  //   true if successful.
  bool Extend(
    const ON_Interval& domain
    );

  // Description:
  //   virtual ON_Curve::Split override.
  //   Divide the curve at the specified parameter.  The parameter
  //   must be in the interior of the curve's domain.  The pointers
  //   passed to Split must either be NULL or point to an ON_Curve
  //   object of the same of the same type.  If the pointer is NULL,
  //   then a curve will be created in Split().  You may pass "this"
  //   as one of the pointers to Split().
  // Parameters:
  //   t - [in] parameter in interval Domain().
  //   left_side - [out] left portion of curve
  //   right_side - [out] right portion of curve
  // Example:
  //   For example, if crv were an ON_NurbsCurve, then
  //
  //     ON_NurbsCurve right_side;
  //     crv.Split( crv.Domain().Mid() &crv, &right_side );
  //
  //   would split crv at the parametric midpoint, put the left side
  //   in crv, and return the right side in right_side.
  ON_BOOL32 Split(
      double t,    // t = curve parameter to split curve at
      ON_Curve*& left_side, // left portion returned here
      ON_Curve*& right_side // right portion returned here
    ) const;

  int GetNurbForm( // returns 0: unable to create NURBS representation
                   //            with desired accuracy.
                   //         1: success - returned NURBS parameterization
                   //            matches the curve's to wthe desired accuracy
                   //         2: success - returned NURBS point locus matches
                   //            the curve's to the desired accuracy but, on
                   //            the interior of the curve's domain, the 
                   //            curve's parameterization and the NURBS
                   //            parameterization may not match to the 
                   //            desired accuracy.
        ON_NurbsCurve&,
        double = 0.0,
        const ON_Interval* = NULL     // OPTIONAL subdomain of polycurve
        ) const;

  int HasNurbForm( // returns 0: unable to create NURBS representation
                   //            with desired accuracy.
                   //         1: success - returned NURBS parameterization
                   //            matches the curve's to wthe desired accuracy
                   //         2: success - returned NURBS point locus matches
                   //            the curve's to the desired accuracy but, on
                   //            the interior of the curve's domain, the 
                   //            curve's parameterization and the NURBS
                   //            parameterization may not match to the 
                   //            desired accuracy.
        ) const;

  // virtual ON_Curve::GetCurveParameterFromNurbFormParameter override
  ON_BOOL32 GetCurveParameterFromNurbFormParameter(
        double, // nurbs_t
        double* // curve_t
        ) const;

  // virtual ON_Curve::GetNurbFormParameterFromCurveParameter override
  ON_BOOL32 GetNurbFormParameterFromCurveParameter(
        double, // curve_t
        double* // nurbs_t
        ) const;

  /////////////////////////////////////////////////////////////////
  // Interface

  int Count() const; // number of segment curves

  // These operator[] functions return NULL if index is out of range
  ON_Curve* operator[](int) const;

  /*
  Description:
    Returns a pointer to a segment curve.
  Parameters:
    segment_index - [in] 0 based index  (0 <= segment_index < Count() )
  Returns:
    A pointer to the segment curve.  Returns NULL if segment_index < 0
    or segment_index >= Count().
  */
  ON_Curve* SegmentCurve(
    int segment_index
    ) const;

  /*
  Description:
    Converts a polycurve parameter to a segment curve parameter.
  Parameters:
    polycurve_parameter - [in] 
  Returns:
    Segment curve evaluation parameter or ON_UNSET_VALUE if the
    segment curve parameter cannot be computed.
  See Also:
    ON_PolyCurve::PolyCurveParameter
  */
  double SegmentCurveParameter(
    double polycurve_parameter
    ) const;

  /*
  Description:
    Converts a segment curve parameter to a polycurve parameter.
  Parameters:
    segment_index - [in]
    segmentcurve_parameter - [in] 
  Returns:
    Polycurve evaluation parameter or ON_UNSET_VALUE if the
    polycurve curve parameter cannot be computed.
  See Also:
    ON_PolyCurve::SegmentCurveParameter
  */
  double PolyCurveParameter(
    int segment_index,
    double segmentcurve_parameter
    ) const;

  /*
  Description:
    Returns the polycurve subdomain assigned to a segment curve.
  Parameters:
    segment_index - [in] 0 based index  (0 <= segment_index < Count() )
  Returns:
    The polycurve subdomain assigned to a segment curve.
    Returns ([ON_UNSET_VALUE,ON_UNSET_VALUE) if segment_index < 0  
    or segment_index >= Count().
  */
  ON_Interval SegmentDomain( 
    int segment_index
    ) const;

  /*
  Description:
    Find the segment used for evaluation at polycurve_parameter.
  Parameters:
    polycurve_parameter - [in]
  Returns:
    index of the segment used for evaluation at polycurve_parameter.
    If polycurve_parameter < Domain.Min(), then 0 is returned.
    If polycurve_parameter > Domain.Max(), then Count()-1 is returned.
  */
  int SegmentIndex(
    double polycurve_parameter
    ) const;

  /*
  Description:
    Find the segments with support on sub_domain.
  Parameters:
    sub_domain - [in] increasing interval
    segment_index0 - [out] 
    segment_index1 - [out] segments with index i where
      *segment_index0 <= i < *segment_index1 are the segments
      with support on the sub_domain
  Returns:
    number of segments with support on sub_domain.
  */
  int SegmentIndex(
    ON_Interval sub_domain,
    int* segment_index0,
    int* segment_index1
    ) const;

  ON_Curve* FirstSegmentCurve() const; // returns NULL if count = 0

  ON_Curve* LastSegmentCurve() const;  // returns NULL if count = 0

  /*
  Description:
    Search the curve for gaps between the sub curve segments. 
  Parameters:
    segment_index0 - [in]
      The search for gaps starts at with the comparing
      the end of segment[segment_index0] and the start of
      segment[segment_index0+1].
  Returns:
    0:     
      No gaps were found.
    i > segment_index0:
      The end of polycuve segment[i-1] is not coincident
      with the start of polycurve segment[i].
  */
  int FindNextGap( int segment_index0 ) const;

  /*
  Description:
    Determine if there is a gap between the end of 
    segment[segment_index] and the start of segment[segment_index+1].
  Parameters:
    segment_index - [in]
      >= 0
  Returns:
    true: 
      segment_index was valid and there is a gap between
      the end of segment[segment_index] and the start of
      segment[segment_index+1].
  */
  bool HasGapAt( int segment_index ) const;
  
  // Replace calls to HasGap() with FindNextGap(0)
  ON_DEPRECATED int HasGap() const;

  /*
  Description:
    Modify the one or both locations at the end of 
    segment[gap_index-1] and the start of segment[gap_index]
    so they are coindicent.  
  Parameters:
    gap_index - [in] 1 <= gap_index < Count()
      If the locations at the end of segment[gap_index-1] and 
      the start of segment[gap_index] are not identical, then
      an attempt is made to modify the segments so these
      locations are closer.
    ends_to_modify - [in]
      0: (suggested)
        The code will decide what segments to modify.
      1: 
        modify the end location of segment[gap_index-1]
      2:
        modify the start location of segment[gap_index]
  Returns:
    True if a modification was performed and HasGap(gap_index-1)
    returns 0 after the modification.
    False if no modification was preformed because there
    was no gap or because one could not be performed.
  Remarks:
    Note that passing the return value from FindNextGap() will 
    close the gap found by FindNextGap().
  */
  bool CloseGap( int gap_index, int segments_to_modify );

  /*
  Description:
    Searches for and closes all gaps that can be found.
  Returns:
    Number of gaps that were closed.
  */
  int CloseGaps();

  void Reserve( int ); // make sure capacity is at least the specified count

  // ON_Curve pointers added with Prepend(), Append(), PrependAndMatch(), AppendANdMatch(),and Insert() are deleted
  // by ~ON_PolyCurve(). Use ON_CurveProxy( ON_Curve*) if you want
  // the original curve segment to survive ~ON_PolyCurve().
  ON_BOOL32 Prepend( ON_Curve* ); // Prepend curve.
  ON_BOOL32 Append( ON_Curve* );  // Append curve.
  ON_BOOL32 Insert( 
           int, // segment_index,
           ON_Curve*
           );

  //PrependAndMatch() and AppendAndMatch() return false if this->IsCLosed() or 
  //this->Count() > 0 and curve is closed
  ON_BOOL32 PrependAndMatch(ON_Curve*); //Prepend and match end of curve to start of polycurve
  ON_BOOL32 AppendAndMatch(ON_Curve*);  //Append and match start of curve to end of polycurve

  ON_BOOL32 Remove(); // delete last segment and reduce count by 1
  ON_BOOL32 Remove( int ); // delete specified segment and reduce count by 1

  //////////
  // Use the HarvestSegment() function when you want to prevent a
  // segment from being destroyed by ~ON_PolyCurve().  HarvestSegment()
  // replaces the polycurve segment with a NULL.  Count() and parameter
  // information remains unchanged.
  ON_Curve* HarvestSegment( int );

	/*
  Returns:
    True if a curve in the m_segment[] array is an ON_PolyCurve.
  */
  bool IsNested() const;

	/*
  Description:
    Same as RemoveNestingEx().
  Remarks:
    RemoveNestingEx was added to avoid breaking the SDK.
  */
	void RemoveNesting();

  /* 
  Description:
    Removes the nested of polycurves. The result will have not
    have an  ON_PolyCurve  as a segment but will have identical
    locus and parameterization.
  Returns:
    True if a nested polycurve was removed.  False
    if no nested polycurves were found.
  */
	bool RemoveNestingEx();

  /* 
  Returns:
    True if the domains of the curves in the m_segment[] array exactly
    match the domains of the segments specified in the m_t[] array.
    Put another way, returns true if SegmentDomain(i) = SegmentCurve(i).Domain()
    for every segment index.
  */
	bool HasSynchronizedSegmentDomains() const;

  /* 
  Description:
    Sets the domain of the curve int the m_segment[] array to exactly
    match the domain defined in the m_t[] array.  This is not required,
    but can simplify some coding situations.
  Returns:
    True if at least one segment was reparameterized. False if no
    changes were made.
  */
	bool SynchronizeSegmentDomains();




	//////////
	// Expert user function  
	//   Sets the m_segment[index] to crv. 
	void SetSegment(int index, ON_Curve* crv);

	//////////
  /*
  Description:
	  Expert user function to set the m_t[] array.
  Parameters:
    t - [in] increasing array of SegmentCount()+1 parameters.
  Returns
    True if successful.
  */
  bool SetParameterization( const double* t );

/*
	Description:
		Lookup a parameter in the m_t array, optionally using a built in snap tolerance to 
		snap a parameter value to an element of m_t.
	Parameters:
		t    - [in]	  	parameter
		index -[out]	index into m_t such that if the function returns true then t is equal 
									to, or is within tolerance of m_t[index]. 
					  			if function returns false then the value of index is

									 @table  
												condition									value of index
						  			t<m_t[0] or m_t is empty				-1
										m_t[i] < t < m_t[i+1]				i for 0<=i<=m_t.Count()-2
										t>m_t[ m_t.Count()-1]				m_t.Count()-1
									
		bEnableSnap -[in]  if true use tolerance when comparing to m_t values 
	Returns		
		true if the t is exactly equal to, or within tolerance of
		(only if bEnableSnap==true) m_t[index]. 
*/ 
	bool ParameterSearch(double t, int& index, bool bEnableSnap) const;

  /*
  Returns:
    Reference to m_segment.
  */
  const ON_CurveArray& SegmentCurves() const;

  /*
  Returns:
    Reference to m_t.
  */
  const ON_SimpleArray<double>& SegmentParameters() const;

  /////////////////////////////////////////////////////////////////
  // Implementation
private:
  // The curves in this array are deleted by ~ON_PolyCurve().
  // Use ON_CurveProxy classes if you don't want ON_PolyCurve()
  // to destroy the curve.

  ON_CurveArray m_segment;  // array of pointers to curves
                             // all have the same dimension
                             // and are contiguous to tolerance

  ON_SimpleArray<double> m_t; // ON_PolyCurve segment parameterizations
};


#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_CURVE_ON_SURFACE_INC_)
#define OPENNURBS_CURVE_ON_SURFACE_INC_

class ON_CurveOnSurface;
class ON_CLASS ON_CurveOnSurface : public ON_Curve
{
  ON_OBJECT_DECLARE(ON_CurveOnSurface);

public:
  ON_CurveOnSurface();

  /*
  Parameters:
    p2dCurve - [in] ~ON_CurveOnSurface() will delete this curve.
       Use an ON_CurveProxy if you don't want the original deleted.
    p3dCurve - [in] ~ON_CurveOnSurface() will delete this curve.
       Use an ON_CurveProxy if you don't want the original deleted.
    pSurface - [in] ~ON_CurveOnSurface() will delete this surface.
       Use an ON_SurfaceProxy if you don't want the original deleted.
  */
  ON_CurveOnSurface( ON_Curve* p2dCurve,  // required 2d curve
                     ON_Curve* p3dCurve,  // optional 3d curve
                     ON_Surface* pSurface // required surface
                     );
  ON_CurveOnSurface(const ON_CurveOnSurface&); // no implementation
  ON_CurveOnSurface& operator=(const ON_CurveOnSurface&); // no implementation

  /*
  Remarks:
    Deletes m_c2, m_c3, and m_s.  Use ON_CurveProxy or ON_SurfaceProxy
    if you need to use curves or a surface that you do not want deleted.
  */
  virtual ~ON_CurveOnSurface();

  // virtual ON_Object::SizeOf override
  unsigned int SizeOf() const;


  /////////////////////////////////////////////////////////////////
  // ON_Object overrides

  /*
  Description:
    Tests an object to see if its data members are correctly
    initialized.
  Parameters:
    text_log - [in] if the object is not valid and text_log
        is not NULL, then a brief englis description of the
        reason the object is not valid is appened to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     object is valid
    false    object is invalid, uninitialized, etc.
  Remarks:
    Overrides virtual ON_Object::IsValid
  */
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  void Dump( ON_TextLog& ) const; // for debugging

  ON_BOOL32 Write(
         ON_BinaryArchive&  // open binary file
       ) const;

  ON_BOOL32 Read(
         ON_BinaryArchive&  // open binary file
       );

  /////////////////////////////////////////////////////////////////
  // ON_Geometry overrides

  int Dimension() const;

  ON_BOOL32 GetBBox( // returns true if successful
         double*,    // minimum
         double*,    // maximum
         ON_BOOL32 = false  // true means grow box
         ) const;

  ON_BOOL32 Transform( 
         const ON_Xform&
         );

  // (optional - default uses Transform for 2d and 3d objects)
  ON_BOOL32 SwapCoordinates(
        int, int        // indices of coords to swap
        );

  /////////////////////////////////////////////////////////////////
  // ON_Curve overrides

  ON_Interval Domain() const;

  int SpanCount() const; // number of smooth spans in curve

  ON_BOOL32 GetSpanVector( // span "knots" 
         double* // array of length SpanCount() + 1 
         ) const; // 

  int Degree( // returns maximum algebraic degree of any span 
                  // ( or a good estimate if curve spans are not algebraic )
    ) const; 


  // (optional - override if curve is piecewise smooth)
  ON_BOOL32 GetParameterTolerance( // returns tminus < tplus: parameters tminus <= s <= tplus
         double,  // t = parameter in domain
         double*, // tminus
         double*  // tplus
         ) const;

  ON_BOOL32 IsLinear( // true if curve locus is a line segment between
                 // between specified points
        double = ON_ZERO_TOLERANCE // tolerance to use when checking linearity
        ) const;

  ON_BOOL32 IsArc( // ON_Arc.m_angle > 0 if curve locus is an arc between
              // specified points
        const ON_Plane* = NULL, // if not NULL, test is performed in this plane
        ON_Arc* = NULL, // if not NULL and true is returned, then arc parameters
                         // are filled in
        double = ON_ZERO_TOLERANCE    // tolerance to use when checking
        ) const;

  ON_BOOL32 IsPlanar(
        ON_Plane* = NULL, // if not NULL and true is returned, then plane parameters
                           // are filled in
        double = ON_ZERO_TOLERANCE    // tolerance to use when checking
        ) const;

  ON_BOOL32 IsInPlane(
        const ON_Plane&, // plane to test
        double = ON_ZERO_TOLERANCE    // tolerance to use when checking
        ) const;

  ON_BOOL32 IsClosed(  // true if curve is closed (either curve has
        void      // clamped end knots and euclidean location of start
        ) const;  // CV = euclidean location of end CV, or curve is
                  // periodic.)

  ON_BOOL32 IsPeriodic(  // true if curve is a single periodic segment
        void 
        ) const;
  
  ON_BOOL32 Reverse();       // reverse parameterizatrion
                        // Domain changes from [a,b] to [-b,-a]

  ON_BOOL32 Evaluate( // returns false if unable to evaluate
         double,         // evaluation parameter
         int,            // number of derivatives (>=0)
         int,            // array stride (>=Dimension())
         double*,        // array of length stride*(ndir+1)
         int = 0,        // optional - determines which side to evaluate from
                         //         0 = default
                         //      <  0 to evaluate from below, 
                         //      >  0 to evaluate from above
         int* = 0        // optional - evaluation hint (int) used to speed
                         //            repeated evaluations
         ) const;

  int GetNurbForm( // returns 0: unable to create NURBS representation
                   //            with desired accuracy.
                   //         1: success - returned NURBS parameterization
                   //            matches the curve's to wthe desired accuracy
                   //         2: success - returned NURBS point locus matches
                   //            the curve's to the desired accuracy but, on
                   //            the interior of the curve's domain, the 
                   //            curve's parameterization and the NURBS
                   //            parameterization may not match to the 
                   //            desired accuracy.
        ON_NurbsCurve&,
        double = 0.0,
        const ON_Interval* = NULL     // OPTIONAL subdomain of 2d curve
        ) const;

  /////////////////////////////////////////////////////////////////
  // Interface

  // ~ON_CurveOnSurface() deletes these classes.  Use a
  // ON_CurveProxy and/or ON_SurfaceProxy wrapper if you don't want
  // the destructor to destroy the curves
  ON_Curve* m_c2;  // REQUIRED parameter space (2d) curve
  ON_Curve* m_c3;  // OPTIONAL 3d curve (approximation) to srf(crv2(t))
  ON_Surface* m_s; 
};


#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

////////////////////////////////////////////////////////////////
//
//   Definition of NURBS surface
//
////////////////////////////////////////////////////////////////

#if !defined(OPENNURBS_NURBSSURFACE_INC_)
#define OPENNURBS_NURBSSURFACE_INC_

class ON_CLASS ON_TensorProduct
{
  // Pure virtual tensor passed to ON_NurbsSurface::TensorProduct()
public:
  ON_TensorProduct();

  virtual
  ~ON_TensorProduct();

  // Evaluate() must define a function T:R^dimA X R^dimB -> R^Dimension()
  // such that
  //
  //          T(a*A0 + (1-a)*A1, B) = a*T(A0,B) + (1-a)*T(A1,B) and
  //          T(A, b*B0 + (1-b)*B1) = b*T(A,B0) + (1-b)*T(A,B1).
  virtual
  int DimensionA() const = 0; // dimension of A space

  virtual
  int DimensionB() const = 0; // dimension of B space

  virtual
  int DimensionC() const = 0; // dimension of range space

  virtual
  bool Evaluate( double,        // a
                 const double*, // A
                 double,        // b
                 const double*, // B
                 double*        // C
                ) = 0;

};

class ON_Brep;
class ON_NurbsSurface;

class ON_CLASS ON_NurbsSurface : public ON_Surface
{
  ON_OBJECT_DECLARE(ON_NurbsSurface);

public:
  /*
  Description:
    Use ON_NurbsSurface::New(...) instead of new ON_NurbsSurface(...)
  Returns:
    Pointer to an ON_NurbsSurface.  Destroy by calling delete.
  Remarks:
    See static ON_Brep* ON_Brep::New() for details.
  */
  static ON_NurbsSurface* New();
  static ON_NurbsSurface* New(
          const ON_NurbsSurface& nurbs_surface
          );
  static ON_NurbsSurface* New(
            const ON_BezierSurface& bezier_surface 
            );
  static ON_NurbsSurface* New(
          int dimension,
          ON_BOOL32 bIsRational,
          int order0,
          int order1,
          int cv_count0,
          int cv_count1
          );

  ON_NurbsSurface();
  ON_NurbsSurface(const ON_NurbsSurface& nurbs_surface);
  ON_NurbsSurface(const ON_BezierSurface& bezier_surface);
  ON_NurbsSurface(
          int dimension,     // dimension (>= 1)
          ON_BOOL32 bIsRational, // true to make a rational NURBS
          int order0,       // order0 (>= 2)
          int order1,       // order1 (>= 2)
          int cv_count0,    // cv count0 (>= order0)
          int cv_count1     // cv count1 (>= order1)
          );

  // virtual ON_Object::SizeOf override
  unsigned int SizeOf() const;

  // virtual ON_Object::DataCRC override
  ON__UINT32 DataCRC(ON__UINT32 current_remainder) const;

  /*
  Description:
    See if this and other are same NURBS geometry.
  Parameters:
    other - [in] other NURBS surface
    bIgnoreParameterization - [in] if true, parameterization
             and orientaion are ignored.
    tolerance - [in] tolerance to use when comparing
                     control points.
  Returns:
    true if curves are tne same.
  */
  bool IsDuplicate( 
          const ON_NurbsSurface& other, 
          bool bIgnoreParameterization,
          double tolerance = ON_ZERO_TOLERANCE 
          ) const;

  void Initialize(void);  // zeros all fields

  ON_BOOL32 Create( 
          int dim,  // dimension (>= 1)
          ON_BOOL32 is_rat, // true to make a rational NURBS
          int order0,  // order0 (>= 2)
          int order1,  // order1 (>= 2)
          int cv_count0,  // cv count0 (>= order0)
          int cv_count1  // cv count1 (>= order1)
          );

  /*
  Description:
    Create a ruled surface from two curves.
  Parameters:
    curveA - [in] (must have same NURBS form knots as curveB)
    curveB - [in] (must have same NURBS form knots as curveA)
    curveA_domain - [in] if not NULL, then this is a subdomain
       of curveA to use for the ruled surface.
    curveB_domain - [in] if not NULL, then this is a subdomain
       of curveA to use for the ruled surface.
  Returns:
    @untitled table
    0      failure
    1      success - parameterization is exact
    2      success - parameterization is not exact
  Remarks:
    The ruling parameter is the second surface parameter and
    it is in the interval [0,1].
    The true ruled surface has parameterization 
    srf(s,t) = (1.0-t)*curveA(s) + t*curveB(s).
    The returned NURBS surface has parameterization
    srf(s,t) = (1.0-t)*nurbs_curveA(s) + t*nurbs_curveB(s),
    where nurbs_curveX is the NURBS form of curveX.  If the
    parameterization of nurbs_curveX does not match the 
    parameterization of curveX, then 2 is returned.
  */
  virtual
  int CreateRuledSurface(
         const ON_Curve& curveA,
         const ON_Curve& curveB,
         const ON_Interval* curveA_domain = NULL,
         const ON_Interval* curveB_domain = NULL
         );

  /*
  Description:
    Create a cone surface from a curve to a point.
  Parameters:
    apex_point - [in]
    curve - [in]
    curve_domain - [in] if not NULL, then this is a subdomain
       of curve to use for the ruled surface.
  Returns:
    @untitled table
    0      failure
    1      success - parameterization is exact
    2      success - parameterization is not exact
  Remarks:
    The ruling parameter is the second surface parameter and
    it is in the interval [0,1].
    The true cone surface has parameterization 
    srf(s,t) = (1.0-t)*curve(s) + t*apex_point.
    The returned NURBS surface has parameterization
    srf(s,t) = (1.0-t)*nurbs_curve(s) + t*apex_point,
    where nurbs_curve is the NURBS form of curve.  If the
    parameterization of nurbs_curve does not match the 
    parameterization of curve, then 2 is returned.
  */
  int CreateConeSurface(
         ON_3dPoint apex_point,
         const ON_Curve& curve,
         const ON_Interval* curve_domain = NULL
         );

  /*
  Description:
    Collapse the side of a NURBS surface to a single point.
  Parameters:
    side - [in] 0 = south west, 
                1 = south east, 
                2 = north east,
                3 = north west
    point - [in] point to collapse to.  If point is ON_unset_point,
                the the current location of the start of the side
                is used.
  Returns:
    True if successful.
  Remarks:
    If the surface is rational, the weights of the side control
    points must be set before calling CollapseSide.
  */
  bool CollapseSide(
    int side,
    ON_3dPoint point = ON_unset_point
    );

  void Destroy();

  virtual ~ON_NurbsSurface();

  void EmergencyDestroy(); // call if memory used by this class becomes invalid

  ON_NurbsSurface& operator=(const ON_NurbsSurface&);
  
  /*
  Description:
    Set NURBS surface equal to bezier surface with domain [0,1]x[0,1].
  Parameters:
    bezier_surface - [in]
  */
	ON_NurbsSurface& operator=(
    const ON_BezierSurface& bezier_surface
    );

  /////////////////////////////////////////////////////////////////
  // ON_Object overrides

  /*
  Description:
    Tests an object to see if its data members are correctly
    initialized.
  Parameters:
    text_log - [in] if the object is not valid and text_log
        is not NULL, then a brief englis description of the
        reason the object is not valid is appened to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     object is valid
    false    object is invalid, uninitialized, etc.
  Remarks:
    Overrides virtual ON_Object::IsValid
  */
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  void Dump( ON_TextLog& ) const; // for debugging

  ON_BOOL32 Write(
         ON_BinaryArchive&  // open binary file
       ) const;

  ON_BOOL32 Read(
         ON_BinaryArchive&  // open binary file
       );

  /////////////////////////////////////////////////////////////////
  // ON_Geometry overrides

  int Dimension() const;

  ON_BOOL32 GetBBox( // returns true if successful
         double*,    // minimum
         double*,    // maximum
         ON_BOOL32 = false  // true means grow box
         ) const;

  ON_BOOL32 Transform( 
         const ON_Xform&
         );

  // virtual ON_Geometry::IsDeformable() override
  bool IsDeformable() const;

  // virtual ON_Geometry::MakeDeformable() override
  bool MakeDeformable();

  ON_BOOL32 SwapCoordinates(
        int, int        // indices of coords to swap
        );

  /////////////////////////////////////////////////////////////////
  // ON_Surface overrides

  ON_BOOL32 SetDomain( 
    int dir, // 0 sets first parameter's domain, 1 gets second parameter's domain
    double t0, 
    double t1
    );

  ON_Interval Domain(
    int // 0 gets first parameter's domain, 1 gets second parameter's domain
    ) const;


  /*
  Description:
    Get an estimate of the size of the rectangle that would
    be created if the 3d surface where flattened into a rectangle.
  Parameters:
    width - [out]  (corresponds to the first surface parameter)
    height - [out] (corresponds to the first surface parameter)
  Remarks:
    overrides virtual ON_Surface::GetSurfaceSize
  Returns:
    true if successful.
  */
  ON_BOOL32 GetSurfaceSize( 
      double* width, 
      double* height 
      ) const;

  int SpanCount(
    int // 0 gets first parameter's domain, 1 gets second parameter's domain
    ) const; // number of smooth spans in curve

  ON_BOOL32 GetSpanVector( // span "knots" 
    int, // 0 gets first parameter's domain, 1 gets second parameter's domain
    double* // array of length SpanCount() + 1 
    ) const; // 

  int Degree( // returns maximum algebraic degree of any span 
                  // ( or a good estimate if curve spans are not algebraic )
    int // 0 gets first parameter's domain, 1 gets second parameter's domain
    ) const; 

  ON_BOOL32 GetParameterTolerance( // returns tminus < tplus: parameters tminus <= s <= tplus
         int,     // 0 gets first parameter, 1 gets second parameter
         double,  // t = parameter in domain
         double*, // tminus
         double*  // tplus
         ) const;

  /*
  Description:
    Test a surface to see if it is planar.
  Parameters:
    plane - [out] if not NULL and true is returned,
                  the plane parameters are filled in.
    tolerance - [in] tolerance to use when checking
  Returns:
    true if there is a plane such that the maximum distance from
    the surface to the plane is <= tolerance.
  Remarks:
    Overrides virtual ON_Surface::IsPlanar.
  */
  ON_BOOL32 IsPlanar(
        ON_Plane* plane = NULL,
        double tolerance = ON_ZERO_TOLERANCE
        ) const;

  ON_BOOL32 IsClosed(   // true if NURBS surface is closed (either surface has
        int // dir // clamped end knots and euclidean location of start
        ) const;   // CV = euclidean location of end CV, or surface is
                   // periodic.)

  ON_BOOL32 IsPeriodic( // true if NURBS surface is periodic (degree > 1,
        int // dir // periodic knot vector, last degree many CVs 
        ) const;   // are duplicates of first degree many CVs.)
  
  ON_BOOL32 IsSingular( // true if surface side is collapsed to a point
        int        // side of parameter space to test
                   // 0 = south, 1 = east, 2 = north, 3 = west
        ) const;

  /*
  Description:
    Search for a derivatitive, tangent, or curvature 
    discontinuity.
  Parameters:
    dir - [in] If 0, then "u" parameter is checked.  If 1, then
               the "v" parameter is checked.
    c - [in] type of continity to test for.
    t0 - [in] Search begins at t0. If there is a discontinuity
              at t0, it will be ignored.  This makes it 
              possible to repeatedly call GetNextDiscontinuity
              and step through the discontinuities.
    t1 - [in] (t0 != t1)  If there is a discontinuity at t1 is 
              will be ingored unless c is a locus discontinuity
              type and t1 is at the start or end of the curve.
    t - [out] if a discontinuity is found, then *t reports the
          parameter at the discontinuity.
    hint - [in/out] if GetNextDiscontinuity will be called 
       repeatedly, passing a "hint" with initial value *hint=0
       will increase the speed of the search.       
    dtype - [out] if not NULL, *dtype reports the kind of 
        discontinuity found at *t.  A value of 1 means the first 
        derivative or unit tangent was discontinuous.  A value 
        of 2 means the second derivative or curvature was 
        discontinuous.  A value of 0 means teh curve is not
        closed, a locus discontinuity test was applied, and
        t1 is at the start of end of the curve.
    cos_angle_tolerance - [in] default = cos(1 degree) Used only
        when c is ON::G1_continuous or ON::G2_continuous.  If the
        cosine of the angle between two tangent vectors is 
        <= cos_angle_tolerance, then a G1 discontinuity is reported.
    curvature_tolerance - [in] (default = ON_SQRT_EPSILON) Used 
        only when c is ON::G2_continuous.  If K0 and K1 are 
        curvatures evaluated from above and below and 
        |K0 - K1| > curvature_tolerance, then a curvature 
        discontinuity is reported.
  Returns:
    Parametric continuity tests c = (C0_continuous, ..., G2_continuous):

      true if a parametric discontinuity was found strictly 
      between t0 and t1. Note well that all curves are 
      parametrically continuous at the ends of their domains.

    Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):

      true if a locus discontinuity was found strictly between
      t0 and t1 or at t1 is the at the end of a curve.
      Note well that all open curves (IsClosed()=false) are locus
      discontinuous at the ends of their domains.  All closed 
      curves (IsClosed()=true) are at least C0_locus_continuous at 
      the ends of their domains.
  */
  bool GetNextDiscontinuity( 
                  int dir,
                  ON::continuity c,
                  double t0,
                  double t1,
                  double* t,
                  int* hint=NULL,
                  int* dtype=NULL,
                  double cos_angle_tolerance=ON_DEFAULT_ANGLE_TOLERANCE_COSINE,
                  double curvature_tolerance=ON_SQRT_EPSILON
                  ) const;

  /*
  Description:
    Test continuity at a surface parameter value.
  Parameters:
    c - [in] continuity to test for
    s - [in] surface parameter to test
    t - [in] surface parameter to test
    hint - [in] evaluation hint
    point_tolerance - [in] if the distance between two points is
        greater than point_tolerance, then the surface is not C0.
    d1_tolerance - [in] if the difference between two first derivatives is
        greater than d1_tolerance, then the surface is not C1.
    d2_tolerance - [in] if the difference between two second derivatives is
        greater than d2_tolerance, then the surface is not C2.
    cos_angle_tolerance - [in] default = cos(1 degree) Used only when
        c is ON::G1_continuous or ON::G2_continuous.  If the cosine
        of the angle between two normal vectors 
        is <= cos_angle_tolerance, then a G1 discontinuity is reported.
    curvature_tolerance - [in] (default = ON_SQRT_EPSILON) Used only when
        c is ON::G2_continuous.  If K0 and K1 are curvatures evaluated
        from above and below and |K0 - K1| > curvature_tolerance,
        then a curvature discontinuity is reported.
  Returns:
    true if the surface has at least the c type continuity at the parameter t.
  Remarks:
    Overrides virtual ON_Surface::IsContinuous
  */
  bool IsContinuous(
    ON::continuity c,
    double s, 
    double t, 
    int* hint = NULL,
    double point_tolerance=ON_ZERO_TOLERANCE,
    double d1_tolerance=ON_ZERO_TOLERANCE,
    double d2_tolerance=ON_ZERO_TOLERANCE,
    double cos_angle_tolerance=ON_DEFAULT_ANGLE_TOLERANCE_COSINE,
    double curvature_tolerance=ON_SQRT_EPSILON
    ) const;

  ON_BOOL32 Reverse(  // reverse parameterizatrion, Domain changes from [a,b] to [-b,-a]
    int // dir  0 = "s", 1 = "t"
    );

  ON_BOOL32 Transpose(); // transpose surface parameterization (swap "s" and "t")

  ON_BOOL32 Evaluate( // returns false if unable to evaluate
         double, double, // evaluation parameter
         int,            // number of derivatives (>=0)
         int,            // array stride (>=Dimension())
         double*,        // array of length stride*(ndir+1)*(ndir+2)/2
         int = 0,        // optional - determines which quadrant to evaluate from
                         //         0 = default
                         //         1 from NE quadrant
                         //         2 from NW quadrant
                         //         3 from SW quadrant
                         //         4 from SE quadrant
         int* = 0        // optional - evaluation hint (int[2]) used to speed
                         //            repeated evaluations
         ) const;

  /*
  Description:
    Get isoparametric curve.
    Overrides virtual ON_Surface::IsoCurve.
  Parameters:
    dir - [in] 0 first parameter varies and second parameter is constant
                 e.g., point on IsoCurve(0,c) at t is srf(t,c)
               1 first parameter is constant and second parameter varies
                 e.g., point on IsoCurve(1,c) at t is srf(c,t)

    c - [in] value of constant parameter 
  Returns:
    Isoparametric curve.
  */
  ON_Curve* IsoCurve(
         int dir,
         double c
         ) const;

  /*
  Description:
    Removes the portions of the surface outside of the specified interval.
    Overrides virtual ON_Surface::Trim.

  Parameters:
    dir - [in] 0  The domain specifies an sub-interval of Domain(0)
                  (the first surface parameter).
               1  The domain specifies an sub-interval of Domain(1)
                  (the second surface parameter).
    domain - [in] interval of the surface to keep. If dir is 0, then
        the portions of the surface with parameters (s,t) satisfying
        s < Domain(0).Min() or s > Domain(0).Max() are trimmed away.
        If dir is 1, then the portions of the surface with parameters
        (s,t) satisfying t < Domain(1).Min() or t > Domain(1).Max() 
        are trimmed away.
  */
  ON_BOOL32 Trim(
         int dir,
         const ON_Interval& domain
         );

  /*
   Description:
     Where possible, analytically extends surface to include domain.
   Parameters:
     dir - [in] 0  new Domain(0) will include domain.
                   (the first surface parameter).
                1  new Domain(1) will include domain.
                   (the second surface parameter).
     domain - [in] if domain is not included in surface domain, 
     surface will be extended so that its domain includes domain.  
     Will not work if surface is closed in direction dir. 
     Original surface is identical to the restriction of the
     resulting surface to the original surface domain, 
   Returns:
     true if successful.
     */
  bool Extend(
    int dir,
    const ON_Interval& domain
    );


  /*
  Description:
    Splits (divides) the surface into two parts at the 
    specified parameter.
    Overrides virtual ON_Surface::Split.

  Parameters:
    dir - [in] 0  The surface is split vertically.  The "west" side
                  is returned in "west_or_south_side" and the "east"
                  side is returned in "east_or_north_side".
               1  The surface is split horizontally.  The "south" side
                  is returned in "west_or_south_side" and the "north"
                  side is returned in "east_or_north_side".
    c - [in] value of constant parameter in interval returned
               by Domain(dir)
    west_or_south_side - [out] west/south portion of surface returned here
    east_or_north_side - [out] east/north portion of surface returned here

  Example:

          ON_NurbsSurface srf = ...;
          int dir = 1;
          ON_NurbsSurface* south_side = 0;
          ON_NurbsSurface* north_side = 0;
          srf.Split( dir, srf.Domain(dir).Mid() south_side, north_side );

  */
  ON_BOOL32 Split(
         int dir,
         double c,
         ON_Surface*& west_or_south_side,
         ON_Surface*& east_or_north_side
         ) const;

  /*
  Description:
    Offset surface.
  Parameters:
    offset_distance - [in] offset distance
    tolerance - [in] Some surfaces do not have an exact offset that
      can be represented using the same class of surface definition.
      In that case, the tolerance specifies the desired accuracy.
    max_deviation - [out] If this parameter is not NULL, the maximum
      deviation from the returned offset to the true offset is returned
      here.  This deviation is zero except for cases where an exact
      offset cannot be computed using the same class of surface definition.
  Returns:
    Offset surface.
  */
  ON_Surface* Offset(
        double offset_distance, 
        double tolerance, 
        double* max_deviation = NULL
        ) const;

  int GetNurbForm( // returns 0: unable to create NURBS representation
                   //            with desired accuracy.
                   //         1: success - returned NURBS parameterization
                   //            matches the surface's to wthe desired accuracy
                   //         2: success - returned NURBS point locus matches
                   //            the surfaces's to the desired accuracy but, on
                   //            the interior of the surface's domain, the 
                   //            surface's parameterization and the NURBS
                   //            parameterization may not match to the 
                   //            desired accuracy.
        ON_NurbsSurface&,
        double = 0.0 // tolerance
        ) const;

  /////////////////////////////////////////////////////////////////
  // Interface

  /*
  Description:
    Get the maximum length of a nurb surface's control polygon
    rows and/or columns
  Parameters:
    dir - [in] 0 to get "u" direction length, 1 to get "v" 
               direction length
    length - [out] maximum length of a polygon "row" in the 
                   specified direction
  Returns:
    true if successful.
  */
  double ControlPolygonLength( int dir ) const;


  bool IsRational(  // true if NURBS surface is rational
        void
        ) const;
  
  int CVSize(       // number of doubles per control vertex 
        void        // = IsRational() ? Dim()+1 : Dim()
        ) const;
  
  int Order(        // order = degree + 1
        int         // dir 0 = "s", 1 = "t"
        ) const;
	
  int CVCount(      // number of control vertices
        int         // dir 0 = "s", 1 = "t"
        ) const;

  int CVCount(      // total number of control vertices
        void
        ) const;

  int KnotCount(    // total number of knots in knot vector
        int dir         // dir 0 = "s", 1 = "t"
        ) const;
  
  /*
  Description:
    Expert user function to get a pointer to control vertex
    memory.  If you are not an expert user, please use
    ON_NurbsSurface::GetCV( ON_3dPoint& ) or 
    ON_NurbsSurface::GetCV( ON_4dPoint& ).
  Parameters:
    i - [in] (0 <= i < m_cv_count[0])
    j - [in] (0 <= j < m_cv_count[1])
  Returns:
    Pointer to control vertex.
  Remarks:
    If the NURBS surface is rational, the format of the 
    returned array is a homogeneos rational point with
    length m_dim+1.  If the NURBS surface is not rational, 
    the format of the returned array is a nonrational 
    euclidean point with length m_dim.
  See Also
    ON_NurbsSurface::CVStyle
    ON_NurbsSurface::GetCV
    ON_NurbsSurface::Weight
  */
  double* CV(
        int i,
        int j
        ) const;

  /*
  Description:
    Returns the style of control vertices in the m_cv array.
  Returns:
    @untitled table
    ON::not_rational                m_is_rat is false
    ON::homogeneous_rational        m_is_rat is true
  */
  ON::point_style CVStyle() const;

  double Weight(        // get value of control vertex weight
        int i, int j   // CV index ( 0 <= i <= CVCount(0), 0 <= j <= CVCount(1)
        ) const;

  ON_BOOL32 SetWeight(      // get value of control vertex weight
        int i, int j,   // CV index ( 0 <= i <= CVCount(0), 0 <= j <= CVCount(1)
        double weight
        );

  ON_BOOL32 SetCV(              // set a single control vertex
        int i, int j,   // CV index ( 0 <= i <= CVCount(0), 0 <= j <= CVCount(1)
        ON::point_style, // style of input point
        const double* cv    // value of control vertex
        );

  ON_BOOL32 SetCV(               // set a single control vertex
        int i, int j,   // CV index ( 0 <= i <= CVCount(0), 0 <= j <= CVCount(1)
        const ON_3dPoint& cv// value of control vertex
                           // If NURBS is rational, weight
                           // will be set to 1.
        );

  ON_BOOL32 SetCV(              // set a single control vertex
        int i, int j,   // CV index ( 0 <= i <= CVCount(0), 0 <= j <= CVCount(1)
        const ON_4dPoint& cv// value of control vertex
        );

  ON_BOOL32 SetCVRow(          // Sets CV( *, row_index ) 
       int row_index,               // row_index >= 0 and < m_cv_count[1]
       const ON_3dPoint& cv // value of control vertex
                          // If NURBS is rational, weight
                          // will be set to 1.
       );

  ON_BOOL32 SetCVRow(          // Sets CV( *, row_index ) 
       int row_index,               // row_index >= 0 and < m_cv_count[1]
       int v_stride,               // v stride
       const double* v     // v[] = values (same dim and is_rat as surface)
       );

  ON_BOOL32 SetCVColumn(       // Sets CV( col_index, * ) 
       int col_index,               // col_index >= 0 and < m_cv_count[0]
       const ON_3dPoint& cv // value of control vertex
                          // If NURBS is rational, weight
                          // will be set to 1.
       );

  ON_BOOL32 SetCVColumn(       // Sets CV( col_index, * ) 
       int col_index,               // col_index >= 0 and < m_cv_count[0]
       int v_stride,               // v stride
       const double* v     // v[] = values (same dim and is_rat as surface)
       );

  ON_BOOL32 GetCV(              // get a single control vertex
        int i, int j,   // CV index ( 0 <= i <= CVCount(0), 0 <= j <= CVCount(1)
        ON::point_style, // style to use for output point
        double* cv          // array of length >= CVSize()
        ) const;

  ON_BOOL32 GetCV(              // get a single control vertex
        int i, int j,   // CV index ( 0 <= i <= CVCount(0), 0 <= j <= CVCount(1)
        ON_3dPoint& cv     // gets euclidean cv when NURBS is rational
        ) const;

  ON_BOOL32 GetCV(              // get a single control vertex
        int i, int j,   // CV index ( 0 <= i <= CVCount(0), 0 <= j <= CVCount(1)
        ON_4dPoint& cv     // gets homogeneous cv
        ) const;

  int SetKnot(
        int dir,    // dir 0 = "s", 1 = "t"
        int knot_index,            // knot index ( 0 to KnotCount - 1 )
        double knot_value         // value for knot
        );

  double Knot(
        int dir,    // dir 0 = "s", 1 = "t"
        int knot_index  // knot index ( >= 0 and < Order + CV_count - 2 )
        ) const;

  int KnotMultiplicity(
        int dir,    // dir 0 = "s", 1 = "t"
        int knot_index            // knot index ( >= 0 and < Order + CV_count - 2 )
        ) const;

  const double* Knot(   // knot[] array
        int dir    // dir 0 = "s", 1 = "t"
        ) const;

  // Description:
  //   Make knot vector a clamped uniform knot vector
  //   based on the current values of m_order and m_cv_count.
  //   Does not change values of control vertices.
  // Parameters:
  //   dir - [in] 0 = u knots, 1 = v knots
  //   delta - [in] (>0.0) knot spacing.
  // Returns:
  //   true if successful.
  // Remarks:
  //   Allocates m_knot[] if it is not big enough.
  // See Also:
  //   ON_MakeClampedUniformKnotVector
  bool MakeClampedUniformKnotVector( 
    int dir,
    double delta = 1.0 
    );

  // Description:
  //   Make knot vector a periodic uniform knot vector
  //   based on the current values of m_order and m_cv_count.
  //   Does not change values of control vertices.
  // Parameters:
  //   dir - [in] 0 = u knots, 1 = v knots
  //   delta - [in] (>0.0) knot spacing.
  // Returns:
  //   true if successful.
  // Remarks:
  //   Allocates m_knot[] if it is not big enough.
  // See Also:
  //   ON_MakePeriodicUniformKnotVector
  bool MakePeriodicUniformKnotVector( 
    int dir,
    double delta = 1.0 
    );


  bool IsClamped( // determine if knot vector is clamped
        int dir,    // dir 0 = "s", 1 = "t"
        int end = 2 // end to check: 0 = start, 1 = end, 2 = start and end
        ) const;
  
  double SuperfluousKnot(
           int dir,    // dir 0 = "s", 1 = "t"
           int end  // 0 = start, 1 = end
           ) const;

  double GrevilleAbcissa(
           int dir,  // dir
           int cv_index  // index (0 <= index < CVCount(dir)
           ) const;

  bool GetGrevilleAbcissae( // see ON_GetGrevilleAbcissa() for details
           int dir,      // dir
           double* g   // g[cv count]
           ) const;

  bool SetClampedGrevilleKnotVector(
           int dir,          // dir
           int g_stride,          // g_stride
           const double* g // g[], CVCount(dir) many Greville abcissa
           );

  bool SetPeriodicGrevilleKnotVector(
           int dir,          // dir
           int g_stride,          // g_stride
           const double* g // g[], Greville abcissa
           );

  bool ZeroCVs(); // zeros all CVs (any weights set to 1);

  bool ClampEnd(
            int dir,         // dir 0 = "s", 1 = "t"
            int end // 0 = clamp start, 1 = clamp end, 2 = clamp start and end
            );

  bool InsertKnot(
           int dir,         // dir 0 = "s", 1 = "t"
           double knot_value, // value of knot
           int knot_multiplicity=1   // multiplicity of knot ( >= 1 and <= degree )
           );

  bool MakeRational();

  bool MakeNonRational();

  bool IncreaseDegree(
           int dir,  // dir 0 = "s", 1 = "t"
           int desired_degree  //  desired_degree
           );

  bool ChangeDimension(
           int desired_dimension  //  desired_dimension
           );

  /*
  Description:
    If the surface is closed in direction dir, then modify it so that
    the seam is at parameter t in the dir direction.
  Parameters:
		dir - [in] must be 0 or 1
    t -		[in] dir parameter of seam, must have Domain(dir).Includes(t).
               The resulting surface domain in the dir direction will start at t.
  Returns:
    true if successful.
  */
  ON_BOOL32 ChangeSurfaceSeam( 
						int dir,
            double t 
            );


  // Creates a tensor product nurbs surface with srf(s,t) = T(A(s),B(t));
  ON_BOOL32 TensorProduct(
        const ON_NurbsCurve&, // A
        const ON_NurbsCurve&, // B
        ON_TensorProduct&     // T
        );

  /////////////////////////////////////////////////////////////////
  // Tools for managing CV and knot memory
  ON_BOOL32 ReserveKnotCapacity( // returns false if allocation fails
                    // does not change m_order or m_cv_count
    int dir, // dir 0 = "s", 1 = "t"
    int knot_array_capacity // minimum capacity of m_knot[] array
    );
  ON_BOOL32 ReserveCVCapacity(  // returns false if allocation fails
                    // does not change m_order or m_cv_count
    int cv_array_capacity // minimum capacity of m_cv[] array
    );

  /*
  Description:
    Convert a NURBS surface bispan into a bezier surface.
  Parameters:
    span_index0 - [in] Specifies the "u" span and must satisfy
         0 <= span_index0 <= m_cv_count[0]-m_order[0]
         m_knot[0][span_index0+m_order[0]-2] < m_knot[0][span_index0+m_order[0]-1]
    span_index1 - [in] Specifies the "v" span and must satisfy
         0 <= span_index1 <= m_cv_count[1]-m_order[1]
         m_knot[1][span_index1+m_order[1]-2] < m_knot[1][span_index1+m_order[1]-1]
    bezier_surface - [out] bezier surface returned here
  Returns:
    true if successful
    false if input is not valid
  */
  ON_BOOL32 ConvertSpanToBezier(
      int span_index0,
      int span_index1, 
      ON_BezierSurface& bezier_surface
      ) const;

  /////////////////////////////////////////////////////////////////
  // Implementation
public:
  // NOTE: These members are left "public" so that expert users may efficiently
  //       create NURBS curves using the default constructor and borrow the
  //       knot and CV arrays from their native NURBS representation.
  //       No technical support will be provided for users who access these
  //       members directly.  If you can't get your stuff to work, then use
  //       the constructor with the arguments and the SetKnot() and SetCV()
  //       functions to fill in the arrays.

  int     m_dim;            // (>=1)

  int     m_is_rat;         // 1 for rational B-splines. (Control vertices
                            // use homogeneous form.)
                            // 0 for non-rational B-splines. (Control
                            // verticies do not have a weight coordinate.)

  int     m_order[2];       // order = degree+1 (>=2)

  int     m_cv_count[2];    // number of control vertices ( >= order )

  // knot vector memory

  int     m_knot_capacity[2]; // If m_knot_capacity > 0, then m_knot[]
                              // is an array of at least m_knot_capacity
                              // doubles whose memory is managed by the
                              // ON_NurbsSurface class using rhmalloc(),
                              // onrealloc(), and rhfree().
                              // If m_knot_capacity is 0 and m_knot is
                              // not NULL, then  m_knot[] is assumed to
                              // be big enough for any requested operation
                              // and m_knot[] is not deleted by the
                              // destructor.

  double* m_knot[2];        // Knot vector. ( The knot vector has length
                            // m_order+m_cv_count-2. )
  
  // control vertex net memory

  int     m_cv_stride[2];   // The pointer to start of "CV[i]" is
                            //   m_cv + i*m_cv_stride.

  int     m_cv_capacity;    // If m_cv_capacity > 0, then m_cv[] is an array
                            // of at least m_cv_capacity doubles whose
                            // memory is managed by the ON_NurbsSurface
                            // class using rhmalloc(), onrealloc(), and rhfree().
                            // If m_cv_capacity is 0 and m_cv is not
                            // NULL, then m_cv[] is assumed to be big enough
                            // for any requested operation and m_cv[] is not
                            // deleted by the destructor.

  double* m_cv;             // Control points.
                            // If m_is_rat is false, then control point is
                            //
                            //          ( CV(i)[0], ..., CV(i)[m_dim-1] ).
                            //
                            // If m_is_rat is true, then the control point
                            // is stored in HOMOGENEOUS form and is
                            //
                            //         [ CV(i)[0], ..., CV(i)[m_dim] ].
                            // 
};


class ON_CLASS ON_NurbsCage : public ON_Geometry
{
  ON_OBJECT_DECLARE(ON_NurbsCage);

public:
  ON_NurbsCage();

  ON_NurbsCage(
    int dim,
    bool is_rat,
    int order0,
    int order1,
    int order2,
    int cv_count0,
    int cv_count1,
    int cv_count2
    );

  ON_NurbsCage( 
    const ON_BoundingBox& bbox,
    int order0,
    int order1,
    int order2,
    int cv_count0,
    int cv_count1,
    int cv_count2
    );

  ON_NurbsCage( 
    const ON_3dPoint* box_corners, // array of 8 3d points
    int order0,
    int order1,
    int order2,
    int cv_count0,
    int cv_count1,
    int cv_count2
    );

  ON_NurbsCage( const ON_BezierCage& src );

  ~ON_NurbsCage();

  ON_NurbsCage(const ON_NurbsCage& src);

  ON_NurbsCage& operator=(const ON_NurbsCage& src);

  ON_NurbsCage& operator=(const ON_BezierCage& src);


  /*
  Description:
    Overrides the pure virtual ON_Object::IsValid function.
  Parameters:
    text_log - [in] If not null and the object is invalid,
                    a brief description of the problem
                    suitable for debugging C++ code
                    is printed in this log.
  Returns:
    True if the orders are at least two, dimension is positive,
    knot vectors are valid, and the other fields are valid
    for the specified orders and dimension.
  */
  ON_BOOL32 IsValid( 
          ON_TextLog* text_log = NULL 
          ) const;

  /*
  Description:
    Overrides the pure virtual ON_Object::Dump function.
  Parameters:
    text_log - [in] A listing of the values of the members.
  */
  void Dump( ON_TextLog& text_log) const;

  /*
  Description:
    Overrides the pure virtual ON_Object::SizeOf function.
  Returns:
    An estimate of the amount of memory used by the class 
    and its members.
  */
  unsigned int SizeOf() const;

  // virtual ON_Object::DataCRC override
  ON__UINT32 DataCRC(ON__UINT32 current_remainder) const;

  /*
  Description:
    Overrides the pure virtual ON_Object::Read function.
    Reads the definition of this class from an
    archive previously saved by ON_BezierVolue::Write.
  Parameters:
    archive - [in] target archive
  Returns:
    True if successful.
  */
  ON_BOOL32 Read(
    ON_BinaryArchive& archive
    );

  /*
  Description:
    Overrides the pure virtual ON_Object::Write function.
    Saves the definition of this class in serial binary
    form that can be read by ON_BezierVolue::Read.
  Parameters:
    archive - [in] target archive
  Returns:
    True if successful.
  */
  ON_BOOL32 Write(
    ON_BinaryArchive& archive
    ) const;

  /*
  Description:
    Overrides the pure virtual ON_Object::ObjectType function.
    Saves the definition of this class in serial binary
    form that can be read by ON_BezierVolue::Read.
  Parameters:
    archive - [in] target archive
  Returns:
    True if successful.
  */
  ON::object_type ObjectType() const;

  /*
  Description:
    Overrides the pure virtual ON_Object::DestroyRuntimeCache function.
    Saves the definition of this class in serial binary
    form that can be read by ON_BezierVolue::Read.
  Parameters:
    bDelete - [in] if true, the cache is deleted.  If false, the
       pointers to the cache are set to zero; this is done when
       the cache memory was allocated from a pool that has
       been destroyed and an attempt to free the memory would
       result in a crash.
  Returns:
    True if successful.
  */
  void DestroyRuntimeCache( 
    bool bDelete = true 
    );


  /*
  Description:
    Overrides virtual ON_Geometry::Dimension function.
    Gets a tight bounding box with respect to the coordinate
    system specified by the frame parameter.
  Parameters:
    bbox - [in/out]
    bGrowBox - [in] If true, the input bbox is grown to include
        this object's bounding box.
    frame - [in] if not null, this specifies the coordinate system
                frame.
  Returns:
    True if successful.
  */
  int Dimension() const;

  /*
  Description:
    Overrides virtual ON_Geometry::GetBBox function.
    Gets the world axis aligned bounding box that contains
    the NURBS volume's control points.  The NURBS volume
    maps the unit cube into this box.
  Parameters:
    boxmin - [in] array of Dimension() doubles
    boxmax - [in] array of Dimension() doubles
    bGrowBox =  [in] if true and the input is a valid box
                          then the input box is grown to
                          include this object's bounding box.
  Returns:
    true if successful.
  */
  ON_BOOL32 GetBBox(
         double* boxmin,
         double* boxmax,
         int bGrowBox = false 
         ) const;

  /*
	Description:
    Get tight bounding box.
	Parameters:
		tight_bbox - [in/out] tight bounding box
		bGrowBox -[in]	(default=false)			
      If true and the input tight_bbox is valid, then returned
      tight_bbox is the union of the input tight_bbox and the 
      surface's tight bounding box.
		xform -[in] (default=NULL)
      If not NULL, the tight bounding box of the transformed
      surface is calculated.  The surface is not modified.
	Returns:
    True if a valid tight_bbox is returned.
  */
	bool GetTightBoundingBox( 
			ON_BoundingBox& tight_bbox, 
      int bGrowBox = false,
			const ON_Xform* xform = 0
      ) const;

  /*
  Description:
    Overrides virtual ON_Geometry::Transform function.
    Transforms NURBS volume.
  Parameters:
    xform - [in]
  Returns:
    true if successful.
  */
  ON_BOOL32 Transform( 
         const ON_Xform& xform
         );

  /*
  Description:
    Overrides virtual ON_Geometry::IsDeformable function.
  Returns:
    True because a NURBS volume can be accuratly modified 
    with "squishy" transformations like projections, 
    shears, an non-uniform scaling.
  */
  bool IsDeformable() const;

  /*
  Description:
    Overrides virtual ON_Geometry::MakeDeformable function.
  Returns:
    True because NURBS volumes are deformable.
  */
  bool MakeDeformable();

  /*
  Returns:
    True if the cage is a parallelogram within the tolerance.
    This means the cage can be used as a starting point
    for cage deformations.
  */
  bool IsParallelogram(double tolerance) const;

  bool Create(
    int dim,
    bool is_rat,
    int order0,
    int order1,
    int order2,
    int cv_count0,
    int cv_count1,
    int cv_count2
    );

  /*
  Description:
    Create a Nurbs volume with corners defined by a bounding box.
  Parameters:
    box_corners - [in] 8 points that define corners of the volume

            7______________6
            |\             |\
            | \            | \
            |  \ _____________\
            |   4          |   5
            |   |          |   |
            |   |          |   |
            3---|----------2   |
            \   |          \   |
             \  |z          \  |
            y \ |            \ |
               \0_____________\1
                       x

  */
  bool Create(
    const ON_BoundingBox& bbox,
    int order0,
    int order1,
    int order2,
    int cv_count0,
    int cv_count1,
    int cv_count2
    );

  /*
  Description:
    Create a nurbs volume from a 3d box
  Parameters:
    box_corners - [in] 8 points that define corners of the volume

            7______________6
            |\             |\
            | \            | \
            |  \ _____________\
            |   4          |   5
            |   |          |   |
            |   |          |   |
            3---|----------2   |
            \   |          \   |
             \  |t          \  |
            s \ |            \ |
               \0_____________\1
                       r

  */
  bool Create(
    const ON_3dPoint* box_corners,
    int order0,
    int order1,
    int order2,
    int cv_count0,
    int cv_count1,
    int cv_count2
    );

  void Destroy();

  void EmergencyDestroy(); // call if memory used by ON_NurbsCage becomes invalid

  ON_Interval Domain(
    int // dir 0 = "r", 1 = "s", 2 = "t"
    ) const;

  /*
  Description:
    Evaluate the NURBS cage
  Parameters:
    r - [in]
    s - [in]
    t - [in] (r,s,t) = evaluation parameters
    der_count - [in]  (>= 0)
    v_stride - [in] (>= m_dim)
    v - [out] An array of length v_stride*(der_count+1)(der_count+2)*(der_count+3)/6.
              The evaluation results are stored in this array.

                P = v[0],...,v[m_dim-1]
                Dr = v[v_stride],...
                Ds = v[2*v_stride],...
                Dt = v[3*v_stride],...

              In general, Dr^i Ds^j Dt^k is returned in v[n],...,v[n+m_dim-1], where

               d = (i+j+k)
               n = v_stride*( d*(d+1)*(d+2)/6 + (j+k)*(j+k+1)/2 + k) 

    side - [in] specifies the span to use for the evaluation
                when r, s, or t is at a knot value.
            0 = default
            1 = from upper NE quadrant
            2 = from upper NW quadrant
            3 = from upper SW quadrant
            4 = from upper SE quadrant
            5 = from lower NE quadrant
            6 = from lower NW quadrant
            7 = from lower SW quadrant
            8 = from lower SE quadrant  
    hint - [in/out] If a bunch of evaluations will be performed that
                    tend to occur in the same region, then
                    hint[3] can be used to speed the search for
                    the evaluation span.  The input value is
                    used as a search hint and the output value
                    records the span used for that evaluation.
  Example:

          int der_count = 2;
          int v_stride = dim;
          double v[v_stride*(der_count+1)*(der_count+2)*(der_count+3)/6];
          int side = 0;
          int hint[3]; hint[0] = 0; hint[1] = 0; hint[2] = 0;
          bool rc = cage.Evaluate(r,s,t,der_count,v_stride,v,side,hint);

          ON_3dPoint P = v;

          // first order partial derivatives
          ON_3dVector Dr = v + v_stride;
          ON_3dVector Ds = v + 2*v_stride;
          ON_3dVector Dt = v + 3*v_stride;

          // second order partial derivatives
          ON_3dVector Drr = v + 4*v_stride;
          ON_3dVector Drs = v + 5*v_stride;
          ON_3dVector Drt = v + 6*v_stride;
          ON_3dVector Dss = v + 7*v_stride;
          ON_3dVector Dst = v + 8*v_stride;
          ON_3dVector Dtt = v + 8*v_stride;

  Returns:
    True if successful
  See Also:
    ON_NurbsCage::PointAt
  */
  bool Evaluate( 
         double r, 
         double s, 
         double t,
         int der_count,
         int v_stride,
         double* v,
         int side=0,
         int* hint=0
         ) const;

  /*
  Description:
    Evaluates bezer volume map.
  Parameters:
    rst - [in]
  Returns:
    Value of the nurbs volume map at (r,s,t).
  */
  ON_3dPoint PointAt(
         double r, 
         double s, 
         double t
         ) const;

  ON_NurbsSurface* IsoSurface(
         int dir,
         double c,
         ON_NurbsSurface* srf = 0
         ) const;


  /*
  Description:
    Evaluates bezer volume map.
  Parameters:
    rst - [in]
  Returns:
    Value of the nurbs volume map at (rst.x,rst.y,rst.z).
  */
  ON_3dPoint PointAt(
         ON_3dPoint rst
         ) const;

  bool IsRational() const;
  
  int CVSize() const;
  
  int Order(
        int dir     // dir 0 = "r", 1 = "s", 2 = "t"
        ) const;
	
  int CVCount(      // number of control vertices
        int         // dir 0 = "r", 1 = "s", 2 = "t"
        ) const;

  int CVCount(      // total number of control vertices
        void
        ) const;

  int KnotCount(    // total number of knots in knot vector
        int dir     // dir 0 = "r", 1 = "s", 2 = "t"
        ) const;

  int Degree(
        int dir
        ) const;
  /*
  Description:
    Expert user function to get a pointer to control vertex
    memory.  If you are not an expert user, please use
    ON_NurbsCage::GetCV( ON_3dPoint& ) or 
    ON_NurbsCage::GetCV( ON_4dPoint& ).
  Parameters:
    cv_index0 - [in] (0 <= cv_index0 < m_order[0])
    cv_index1 - [in] (0 <= cv_index1 < m_order[1])
  Returns:
    Pointer to control vertex.
  Remarks:
    If the Nurbs surface is rational, the format of the 
    returned array is a homogeneos rational point with
    length m_dim+1.  If the Nurbs surface is not rational, 
    the format of the returned array is a nonrational 
    euclidean point with length m_dim.
  See Also
    ON_NurbsCage::CVStyle
    ON_NurbsCage::GetCV
    ON_NurbsCage::Weight
  */
  double* CV(
        int i,
        int j,
        int k
        ) const;

  /*
  Description:
    Returns the style of control vertices in the m_cv array.
  Returns:
    @untitled table
    ON::not_rational                m_is_rat is false
    ON::homogeneous_rational        m_is_rat is true
  */
  ON::point_style CVStyle() const;

  double Weight(        // get value of control vertex weight
        int i,
        int j,
        int k
        ) const;

  bool SetWeight(      // get value of control vertex weight
        int i,
        int j,
        int k,
        double w
        );

  bool SetCV(              // set a single control vertex
        int i,
        int j,
        int k,
        ON::point_style, // style of input point
        const double*     // value of control vertex
        );

  // set a single control vertex
  // If NURBS is rational, weight
  // will be set to 1.
  bool SetCV(
        int i,
        int j,
        int k,
        const ON_3dPoint& point
        );

  // set a single control vertex
  // value of control vertex
  // If NURBS is not rational, euclidean
  // location of homogeneous point will
  // be used.
  bool SetCV(
        int i,
        int j,
        int k,
        const ON_4dPoint& hpoint
        );

  bool GetCV(              // get a single control vertex
        int i,
        int j,
        int k,
        ON::point_style, // style to use for output point
        double*           // array of length >= CVSize()
        ) const;

  bool GetCV(              // get a single control vertex
        int i,
        int j,
        int k,
        ON_3dPoint&      // gets euclidean cv when NURBS is rational
        ) const;

  bool GetCV(              // get a single control vertex
        int i,
        int j,
        int k,
        ON_4dPoint&      // gets homogeneous cv
        ) const;

  /*
  Parameters:
    dir - [in] 0 = "r", 1 = "s", 2 = "t"
    knot_index - [in] 0 <= knot_index < KnotCount(dir)
    knot_value - [in]
  Returns:
    True if dir and knot_index parameters were valid and knot value
    was set.
  */
  bool SetKnot(
        int dir,
        int knot_index,
        double knot_value
        );

  /*
  Parameters:
    dir - [in] 0 = "r", 1 = "s", 2 = "t"
    knot_index - [in] 0 <= knot_index < KnotCount(dir)
  Returns:
    Value of knot or ON_UNSET_VALUE if input parameters are not valid.
  */
  double Knot(
        int dir,
        int knot_index
        ) const;

  bool ZeroCVs(); // zeros control vertices and, if rational, sets weights to 1

  bool MakeRational();

  bool MakeNonRational();

  bool IsClosed(   // true if NURBS cage is closed (either cage has
        int // dir // clamped end knots and euclidean location of start
        ) const;   // CV = euclidean location of end CV, or cage is
                   // periodic.)

  bool IsPeriodic( // true if NURBS cage is periodic (degree > 1,
        int // dir // periodic knot vector, last degree many CVs 
        ) const;   // are duplicates of first degree many CVs.)

  bool IsSingular( // true if cage side is collapsed to a point
        int        // side of parameter space to test
                   // 0 = south, 1 = east, 2 = north, 3 = west
        ) const;

  double GrevilleAbcissa(
          int dir,    // dir
          int gindex  // index (0 <= index < CVCount(dir)
          ) const;

  /////////////////////////////////////////////////////////////////
  // Tools for managing CV and knot memory

  /*
  Description:
    cv_capacity - [in] number of doubles to reserve
  */
  bool ReserveCVCapacity(
    int cv_capacity
    );

  bool ReserveKnotCapacity(
    int dir,
    int cv_capacity
    );

  /////////////////////////////////////////////////////////////////
  // Implementation
public:
  // NOTE: These members are left "public" so that expert users may efficiently
  //       create nurbs curves using the default constructor and borrow the
  //       knot and CV arrays from their native NURBS representation.
  //       No technical support will be provided for users who access these
  //       members directly.  If you can't get your stuff to work, then use
  //       the constructor with the arguments and the SetKnot() and SetCV()
  //       functions to fill in the arrays.


  int     m_dim;
  bool    m_is_rat;
  int     m_order[3];
  int     m_cv_count[3];
  int     m_knot_capacity[3];
  double* m_knot[3];
  int     m_cv_stride[3];
  int     m_cv_capacity;
  double* m_cv;
};

ON_DECL
bool ON_GetCageXform( 
          const ON_NurbsCage& cage, 
          ON_Xform& cage_xform 
          );


class ON_CLASS ON_MorphControl : public ON_Geometry
{
  ON_OBJECT_DECLARE(ON_MorphControl);

public:
  ON_MorphControl();
  ~ON_MorphControl();
  // C++ default copy construction and operator= work fine.


  void Destroy();
  

  /////////////////////////////////////////////////////////
  //
  // ON_Object virtual functions
  //

  void MemoryRelocate();

  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  void Dump( ON_TextLog& ) const;

  unsigned int SizeOf() const;

  ON_BOOL32 Write(
    ON_BinaryArchive& archive
    ) const;

  ON_BOOL32 Read(
    ON_BinaryArchive& archive
    );

  ON::object_type ObjectType() const;

  void DestroyRuntimeCache( bool bDelete = true );

  /////////////////////////////////////////////////////////
  //
  // ON_Geometry virtual functions
  //

  int Dimension() const;

  ON_BOOL32 GetBBox(
         double* boxmin,
         double* boxmax,
         int bGrowBox = false
         ) const;

	bool GetTightBoundingBox( 
			ON_BoundingBox& tight_bbox, 
      int bGrowBox = false,
			const ON_Xform* xform = 0
      ) const;

  void ClearBoundingBox();

  ON_BOOL32 Transform( 
         const ON_Xform& xform
         );

  ON_BOOL32 HasBrepForm() const;

  ON_Brep* BrepForm( ON_Brep* brep = NULL ) const;


  /*
  Returns:
    True if the target NURBS object is rational
  */
  bool IsRational() const;

  /*
  Description:
    Makes the target NURBS object rational.
  */
  bool MakeRational();

  /*
  Description:
    Makes the target NURBS object non-rational.
  */
  bool MakeNonRational();

  /*
  Returns:
    Number of control points in the target NURBS object.
  */
  int CVCount() const;

  int CVCount(int dir) const;
  int Order(int dir) const;
  const double* Knot(int dir) const;
  ON_3dex MaxCVIndex() const;
  const double* CV(ON_3dex) const;
  double Weight(ON_3dex) const;

  /////////////////////////////////////////////////////////
  //
  // Localizers
  //

  /*
  Description:
    Adds localizer with support near the controling NURBS object.
  Parameters:
    support_distance - [in] >= 0
      If the distance a point to the controls NURBS 
      curve/surface/cage is less than or equal to support_distance,
      then MorphPoint() deformation has 100% effect.
      
    falloff_distance - [in] > 0
      If the distance a point to the controls NURBS 
      curve/surface/cage is more than support_distance+falloff_distance,
      then MorphPoint() deformation does not move the point.
      As the distance varies from support_distance to 
      support_distance+falloff_distance the deformation attenuates
      from 100% to 0%.
  */
  bool AddControlLocalizer(
    double support_distance, 
    double falloff_distance
    );

  bool AddSphereLocalizer(
    ON_3dPoint center,
    double support_distance, 
    double falloff_distance
    );

  bool AddCylinderLocalizer(
    ON_Line axis,
    double support_distance, 
    double falloff_distance
    );

  bool AddBoxLocalizer(
    ON_BoundingBox bbox,
    double support_distance, 
    double falloff_distance
    );

  bool AddPlaneLocalizer(
    const ON_Plane& plane,
    double support_distance, 
    double falloff_distance
    );

  bool AddConvexPolygonLocalizer(
    const ON_SimpleArray<ON_Plane>& planes,
    double support_distance, 
    double falloff_distance
    );

  /////////////////////////////////////////////////////////
  //
  //

  // Get a cage_morph that can be passed to Morph functions
  bool GetCageMorph( class ON_CageMorph& cage_morph ) const;

  bool IsIdentity( const ON_BoundingBox& bbox ) const;

  int m_varient; // 1= curve, 2 = surface, 3 = cage

  // The value of m_varient determines which nurbs object
  // controls the cage
  ON_NurbsCurve   m_nurbs_curve0;
  ON_NurbsCurve   m_nurbs_curve;
  ON_Interval     m_nurbs_curve_domain;

  ON_NurbsSurface m_nurbs_surface0;
  ON_NurbsSurface m_nurbs_surface;
  ON_Interval     m_nurbs_surface_domain[2];

  ON_Xform        m_nurbs_cage0;
  ON_NurbsCage    m_nurbs_cage;

  // Rhino captive object ids
  ON_UuidList m_captive_id;

  // Use ON_GetCageXform to set m_cage_xform.

  // Used to localize the deformation
  ON_ClassArray<ON_Localizer> m_localizers;

  // ON_SpaceMorphOptions
  double m_sporh_tolerance;
  bool   m_sporh_bQuickPreview;
  bool   m_sporh_bPreserveStructure;
};


class ON_CLASS ON_CageMorph : public ON_SpaceMorph
{
public:
  ON_CageMorph();
  ~ON_CageMorph();

  bool IsIdentity( const ON_BoundingBox& bbox ) const;

  const ON_MorphControl* m_control;
};


// Description:
//   Get an ON_NurbsSurface definition of a quadrilateral.
// Parameters:
//   P - [in]
//   Q - [in]
//   R - [in]
//   S - [in] corners in counter clockwise layer
//   nurbs_surface - [in] if this pointer is not NULL,
//       then this ON_NurbsSurface is used to return
//       the quadrilateral.
// Returns:
//   An ON_NurbsSurface representation of the quadrilateral.
ON_DECL
ON_NurbsSurface* ON_NurbsSurfaceQuadrilateral( 
             const ON_3dPoint& P, 
             const ON_3dPoint& Q, 
             const ON_3dPoint& R, 
             const ON_3dPoint& S,
             ON_NurbsSurface* nurbs_surface = NULL
             );

#if defined(ON_DLL_TEMPLATE)
// This stuff is here because of a limitation in the way Microsoft
// handles templates and DLLs.  See Microsoft's knowledge base 
// article ID Q168958 for details.
#pragma warning( push )
#pragma warning( disable : 4231 )
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ON_NurbsCurve>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ObjectArray<ON_NurbsCurve>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_NurbsCurve*>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ON_NurbsSurface>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ObjectArray<ON_NurbsSurface>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_NurbsSurface*>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ON_NurbsCage>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ObjectArray<ON_NurbsCage>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_NurbsCage*>;
#pragma warning( pop )
#endif

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(ON_GEOMETRY_SURFACE_PLANE_INC_)
#define ON_GEOMETRY_SURFACE_PLANE_INC_

class ON_PlaneSurface;

class ON_CLASS ON_PlaneSurface : public ON_Surface
{
  ON_OBJECT_DECLARE(ON_PlaneSurface);

public:
  ON_PlaneSurface();
  ON_PlaneSurface(const ON_PlaneSurface&);
  ON_PlaneSurface& operator=(const ON_PlaneSurface&);

  ON_PlaneSurface(const ON_Plane&);
  ON_PlaneSurface& operator=(const ON_Plane&);

  virtual ~ON_PlaneSurface();

  // An ON_PlaneSurface is really a finite rectangle.
  // m_plane defines the plane and m_extents[] stores
  // the x and y intervals of the plane that define the
  // rectangle.  The m_domain[] intervals specify the
  // evaluation domain.  Changing the extents are domain
  // are INDEPENDENT of each other.  Use Domain() and
  // SetDomain() to control the evluation domain.  Use
  // Extents() and SetExtents() to control the rectangle
  // extents.
  ON_Plane m_plane;

  /////////////////////////////////////////////////////////////////
  // ON_Object overrides

  // virtual ON_Object::SizeOf override
  unsigned int SizeOf() const;

  // virtual ON_Object::DataCRC override
  ON__UINT32 DataCRC(ON__UINT32 current_remainder) const;

  /*
  Description:
    Tests an object to see if its data members are correctly
    initialized.
  Parameters:
    text_log - [in] if the object is not valid and text_log
        is not NULL, then a brief englis description of the
        reason the object is not valid is appened to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     object is valid
    false    object is invalid, uninitialized, etc.
  Remarks:
    Overrides virtual ON_Object::IsValid
  */
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  void Dump( ON_TextLog& ) const; // for debugging

  ON_BOOL32 Write(
         ON_BinaryArchive&  // open binary file
       ) const;

  ON_BOOL32 Read(
         ON_BinaryArchive&  // open binary file
       );

  /////////////////////////////////////////////////////////////////
  // ON_Geometry overrides

  int Dimension() const;

  ON_BOOL32 GetBBox( // returns true if successful
         double*,    // minimum
         double*,    // maximum
         ON_BOOL32 = false  // true means grow box
         ) const;

  ON_BOOL32 Transform( 
         const ON_Xform&
         );

  /////////////////////////////////////////////////////////////////
  // ON_Surface overrides

  /*
  Description:
    Sets the evaluation domains.  Does not change the geometry.
  Parameters:
    dir - [in] 0 sets first parameter's domain
               1 sets second parameter's domain
    t0 - [in]
    t1 - [in] (t0 < t1) the interval (t0,t1) will be the new domain
  Returns:
    True if successful.
  See Also:
    ON_PlaneSurface::SetExtents
  */
  ON_BOOL32 SetDomain( 
    int dir, 
    double t0, 
    double t1
    );

  ON_Interval Domain(
    int // 0 gets first parameter's domain, 1 gets second parameter's domain
    ) const;

  /*
  Description:
    Get an estimate of the size of the rectangle that would
    be created if the 3d surface where flattened into a rectangle.
  Parameters:
    width - [out]  (corresponds to the first surface parameter)
    height - [out] (corresponds to the first surface parameter)
  Remarks:
    overrides virtual ON_Surface::GetSurfaceSize
  Returns:
    true if successful.
  */
  ON_BOOL32 GetSurfaceSize( 
      double* width, 
      double* height 
      ) const;

  int SpanCount(
    int // 0 gets first parameter's domain, 1 gets second parameter's domain
    ) const; // number of smooth spans in curve

  ON_BOOL32 GetSpanVector( // span "knots" 
    int, // 0 gets first parameter's domain, 1 gets second parameter's domain
    double* // array of length SpanCount() + 1 
    ) const; // 

  int Degree( // returns maximum algebraic degree of any span 
                  // ( or a good estimate if curve spans are not algebraic )
    int // 0 gets first parameter's domain, 1 gets second parameter's domain
    ) const; 

  ON_BOOL32 GetParameterTolerance( // returns tminus < tplus: parameters tminus <= s <= tplus
         int,     // 0 gets first parameter, 1 gets second parameter
         double,  // t = parameter in domain
         double*, // tminus
         double*  // tplus
         ) const;

  /*
  Description:
    Test a surface to see if it is planar.
  Parameters:
    plane - [out] if not NULL and true is returned,
                  the plane parameters are filled in.
    tolerance - [in] tolerance to use when checking
  Returns:
    true if there is a plane such that the maximum distance from
    the surface to the plane is <= tolerance.
  Remarks:
    Overrides virtual ON_Surface::IsPlanar.
  */
  ON_BOOL32 IsPlanar(
        ON_Plane* plane = NULL,
        double tolerance = ON_ZERO_TOLERANCE
        ) const;

  ON_BOOL32 IsClosed(   // true if surface is closed in direction
        int        // dir  0 = "s", 1 = "t"
        ) const;

  ON_BOOL32 IsPeriodic( // true if surface is periodic in direction
        int        // dir  0 = "s", 1 = "t"
        ) const;

  ON_BOOL32 IsSingular( // true if surface side is collapsed to a point
        int        // side of parameter space to test
                   // 0 = south, 1 = east, 2 = north, 3 = west
        ) const;
  
  /*
  Description:
    Search for a derivatitive, tangent, or curvature 
    discontinuity.
  Parameters:
    dir - [in] If 0, then "u" parameter is checked.  If 1, then
               the "v" parameter is checked.
    c - [in] type of continity to test for.
    t0 - [in] Search begins at t0. If there is a discontinuity
              at t0, it will be ignored.  This makes it 
              possible to repeatedly call GetNextDiscontinuity
              and step through the discontinuities.
    t1 - [in] (t0 != t1)  If there is a discontinuity at t1 is 
              will be ingored unless c is a locus discontinuity
              type and t1 is at the start or end of the curve.
    t - [out] if a discontinuity is found, then *t reports the
          parameter at the discontinuity.
    hint - [in/out] if GetNextDiscontinuity will be called 
       repeatedly, passing a "hint" with initial value *hint=0
       will increase the speed of the search.       
    dtype - [out] if not NULL, *dtype reports the kind of 
        discontinuity found at *t.  A value of 1 means the first 
        derivative or unit tangent was discontinuous.  A value 
        of 2 means the second derivative or curvature was 
        discontinuous.  A value of 0 means teh curve is not
        closed, a locus discontinuity test was applied, and
        t1 is at the start of end of the curve.
    cos_angle_tolerance - [in] default = cos(1 degree) Used only
        when c is ON::G1_continuous or ON::G2_continuous.  If the
        cosine of the angle between two tangent vectors is 
        <= cos_angle_tolerance, then a G1 discontinuity is reported.
    curvature_tolerance - [in] (default = ON_SQRT_EPSILON) Used 
        only when c is ON::G2_continuous.  If K0 and K1 are 
        curvatures evaluated from above and below and 
        |K0 - K1| > curvature_tolerance, then a curvature 
        discontinuity is reported.
  Returns:
    Parametric continuity tests c = (C0_continuous, ..., G2_continuous):

      true if a parametric discontinuity was found strictly 
      between t0 and t1. Note well that all curves are 
      parametrically continuous at the ends of their domains.

    Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):

      true if a locus discontinuity was found strictly between
      t0 and t1 or at t1 is the at the end of a curve.
      Note well that all open curves (IsClosed()=false) are locus
      discontinuous at the ends of their domains.  All closed 
      curves (IsClosed()=true) are at least C0_locus_continuous at 
      the ends of their domains.
  */
  bool GetNextDiscontinuity( 
                  int dir,
                  ON::continuity c,
                  double t0,
                  double t1,
                  double* t,
                  int* hint=NULL,
                  int* dtype=NULL,
                  double cos_angle_tolerance=ON_DEFAULT_ANGLE_TOLERANCE_COSINE,
                  double curvature_tolerance=ON_SQRT_EPSILON
                  ) const;

  /*
  Description:
    Test continuity at a surface parameter value.
  Parameters:
    c - [in] continuity to test for
    s - [in] surface parameter to test
    t - [in] surface parameter to test
    hint - [in] evaluation hint
    point_tolerance - [in] if the distance between two points is
        greater than point_tolerance, then the surface is not C0.
    d1_tolerance - [in] if the difference between two first derivatives is
        greater than d1_tolerance, then the surface is not C1.
    d2_tolerance - [in] if the difference between two second derivatives is
        greater than d2_tolerance, then the surface is not C2.
    cos_angle_tolerance - [in] default = cos(1 degree) Used only when
        c is ON::G1_continuous or ON::G2_continuous.  If the cosine
        of the angle between two normal vectors 
        is <= cos_angle_tolerance, then a G1 discontinuity is reported.
    curvature_tolerance - [in] (default = ON_SQRT_EPSILON) Used only when
        c is ON::G2_continuous.  If K0 and K1 are curvatures evaluated
        from above and below and |K0 - K1| > curvature_tolerance,
        then a curvature discontinuity is reported.
  Returns:
    true if the surface has at least the c type continuity at the parameter t.
  Remarks:
    Overrides virtual ON_Surface::IsContinuous
  */
  bool IsContinuous(
    ON::continuity c,
    double s, 
    double t, 
    int* hint = NULL,
    double point_tolerance=ON_ZERO_TOLERANCE,
    double d1_tolerance=ON_ZERO_TOLERANCE,
    double d2_tolerance=ON_ZERO_TOLERANCE,
    double cos_angle_tolerance=ON_DEFAULT_ANGLE_TOLERANCE_COSINE,
    double curvature_tolerance=ON_SQRT_EPSILON
    ) const;

  ON_BOOL32 Reverse(  // reverse parameterizatrion, Domain changes from [a,b] to [-b,-a]
    int // dir  0 = "s", 1 = "t"
    );

  ON_BOOL32 Transpose(); // transpose surface parameterization (swap "s" and "t")


  ON_BOOL32 Evaluate( // returns false if unable to evaluate
         double, double, // evaluation parameters
         int,            // number of derivatives (>=0)
         int,            // array stride (>=Dimension())
         double*,        // array of length stride*(ndir+1)*(ndir+2)/2
         int = 0,        // optional - determines which quadrant to evaluate from
                         //         0 = default
                         //         1 from NE quadrant
                         //         2 from NW quadrant
                         //         3 from SW quadrant
                         //         4 from SE quadrant
         int* = 0        // optional - evaluation hint (int[2]) used to speed
                         //            repeated evaluations
         ) const;

  /*
  Description:
    Get isoparametric curve.
    Overrides virtual ON_Surface::IsoCurve.
  Parameters:
    dir - [in] 0 first parameter varies and second parameter is constant
                 e.g., point on IsoCurve(0,c) at t is srf(t,c)
               1 first parameter is constant and second parameter varies
                 e.g., point on IsoCurve(1,c) at t is srf(c,t)

    c - [in] value of constant parameter 
  Returns:
    Isoparametric curve.
  */
  ON_Curve* IsoCurve(
         int dir,         
         double c
         ) const;

  /*
  Description:
    Removes the portions of the surface outside of the specified interval.
    Overrides virtual ON_Surface::Trim.

  Parameters:
    dir - [in] 0  The domain specifies an sub-interval of Domain(0)
                  (the first surface parameter).
               1  The domain specifies an sub-interval of Domain(1)
                  (the second surface parameter).
    domain - [in] interval of the surface to keep. If dir is 0, then
        the portions of the surface with parameters (s,t) satisfying
        s < Domain(0).Min() or s > Domain(0).Max() are trimmed away.
        If dir is 1, then the portions of the surface with parameters
        (s,t) satisfying t < Domain(1).Min() or t > Domain(1).Max() 
        are trimmed away.
  */
  ON_BOOL32 Trim(
         int dir,
         const ON_Interval& domain
         );

  /*
   Description:
     Where possible, analytically extends surface to include domain.
   Parameters:
     dir - [in] 0  new Domain(0) will include domain.
                   (the first surface parameter).
                1  new Domain(1) will include domain.
                   (the second surface parameter).
     domain - [in] if domain is not included in surface domain, 
     surface will be extended so that its domain includes domain.  
     Will not work if surface is closed in direction dir. 
     Original surface is identical to the restriction of the
     resulting surface to the original surface domain, 
   Returns:
     true if successful.
     */
  bool Extend(
    int dir,
    const ON_Interval& domain
    );

  /*
  Description:
    Splits (divides) the surface into two parts at the 
    specified parameter.
    Overrides virtual ON_Surface::Split.

  Parameters:
    dir - [in] 0  The surface is split vertically.  The "west" side
                  is returned in "west_or_south_side" and the "east"
                  side is returned in "east_or_north_side".
               1  The surface is split horizontally.  The "south" side
                  is returned in "west_or_south_side" and the "north"
                  side is returned in "east_or_north_side".
    c - [in] value of constant parameter in interval returned
               by Domain(dir)
    west_or_south_side - [out] west/south portion of surface returned here
    east_or_north_side - [out] east/north portion of surface returned here

  Example:

          ON_PlaneSurface srf = ...;
          int dir = 1;
          ON_PlaneSurface* south_side = 0;
          ON_PlaneSurface* north_side = 0;
          srf.Split( dir, srf.Domain(dir).Mid() south_side, north_side );

  */
  ON_BOOL32 Split(
         int dir,
         double c,
         ON_Surface*& west_or_south_side,
         ON_Surface*& east_or_north_side
         ) const;

  /*
  Description:
    Get the parameters of the point on the surface that is closest to P.
  Parameters:
    P - [in] 
            test point
    s - [out]
    t - [out] 
            (*s,*t) = parameters of the surface point that 
            is closest to P.
    maximum_distance = 0.0 - [in] 
            optional upper bound on the distance from P to 
            the surface.  If you are only interested in 
            finding a point Q on the surface when 
            P.DistanceTo(Q) < maximum_distance, then set
            maximum_distance to that value.
    sdomain = 0 - [in] optional domain restriction
    tdomain = 0 - [in] optional domain restriction
  Returns:
    True if successful.  If false, the values of *s and *t
    are undefined.
  See Also:
    ON_Surface::GetLocalClosestPoint.
  */
  bool GetClosestPoint( 
          const ON_3dPoint& P,
          double* s,
          double* t,
          double maximum_distance = 0.0,
          const ON_Interval* sdomain = 0,
          const ON_Interval* tdomain = 0
          ) const;

  //////////
  // Find parameters of the point on a surface that is locally closest to 
  // the test_point.  The search for a local close point starts at 
  // seed parameters. If a sub_domain parameter is not NULL, then
  // the search is restricted to the specified portion of the surface.
  //
  // true if returned if the search is successful.  false is returned if
  // the search fails.
  ON_BOOL32 GetLocalClosestPoint( const ON_3dPoint&, // test_point
          double,double,     // seed_parameters
          double*,double*,   // parameters of local closest point returned here
          const ON_Interval* = NULL, // first parameter sub_domain
          const ON_Interval* = NULL  // second parameter sub_domain
          ) const;


  /*
  Description:
    Offset surface.
  Parameters:
    offset_distance - [in] offset distance
    tolerance - [in] Some surfaces do not have an exact offset that
      can be represented using the same class of surface definition.
      In that case, the tolerance specifies the desired accuracy.
    max_deviation - [out] If this parameter is not NULL, the maximum
      deviation from the returned offset to the true offset is returned
      here.  This deviation is zero except for cases where an exact
      offset cannot be computed using the same class of surface definition.
  Remarks:
    Overrides virtual ON_Surface::Offset.
  Returns:
    Offset surface.
  */
  ON_Surface* Offset(
        double offset_distance, 
        double tolerance, 
        double* max_deviation = NULL
        ) const;


  int GetNurbForm( // returns 0: unable to create NURBS representation
                   //            with desired accuracy.
                   //         1: success - returned NURBS parameterization
                   //            matches the surface's to wthe desired accuracy
                   //         2: success - returned NURBS point locus matches
                   //            the surfaces's to the desired accuracy but, on
                   //            the interior of the surface's domain, the 
                   //            surface's parameterization and the NURBS
                   //            parameterization may not match to the 
                   //            desired accuracy.
        ON_NurbsSurface&,
        double = 0.0
        ) const;

  int HasNurbForm( // returns 0: unable to create NURBS representation
                   //            with desired accuracy.
                   //         1: success - returned NURBS parameterization
                   //            matches the surface's to wthe desired accuracy
                   //         2: success - returned NURBS point locus matches
                   //            the surfaces's to the desired accuracy but, on
                   //            the interior of the surface's domain, the 
                   //            surface's parameterization and the NURBS
                   //            parameterization may not match to the 
                   //            desired accuracy.
        ) const;

  /*
  Description:
    Sets the extents of then rectangle.  Does not change the evaluation
    domain.
  Parameters:
    dir - [in] 0 sets plane's x coordinate extents
               0 sets plane's y coordinate extents
    extents - [in] increasing interval
    bSynchDomain - [in] if true, the corresponding evaluation interval
               domain is set so that it matches the extents interval
  Returns:
    True if successful.
  See Also:
    ON_PlaneSurface::SetDomain
  */
  bool SetExtents( 
         int dir,
         ON_Interval extents,
         bool bSynchDomain = false
         );

  /*
  Description:
    Gets the extents of the rectangle.
  Parameters:
    dir - [in] 0 gets plane's x coordinate extents
               0 gets plane's y coordinate extents
  Returns:
    Increasing interval
  See Also:
    ON_PlaneSurface::Domain
  */
  ON_Interval Extents(
         int dir
         ) const;

  /*
  Description:
    Create a plane that contains the projection of a bounding box.
  Parameters:
    plane_equation - [in]
    bbox - [in]
    padding - [in]
      amount of extra padding to add around the edges of the
      plane.  Default is 0.0625
  Returns:
    true if successful
  */
  bool CreatePseudoInfinitePlane( 
          ON_PlaneEquation plane_equation,
          const ON_BoundingBox& bbox,
          double padding = 0.0625
          );

  /*
  Description:
    Create a plane that contains the projection of a bounding box.
  Parameters:
    plane - [in]
    bbox - [in]
    padding - [in]
      amount of extra padding to add around the edges of the
      plane.  Default is 0.0625
  Returns:
    true if successful
  */
  bool CreatePseudoInfinitePlane( 
          const ON_Plane& plane,
          const ON_BoundingBox& bbox,
          double padding = 0.0625
          );

  /*
  Description:
    Create a plane that contains the projection of a list of points.
  Parameters:
    plane - [in]
    point_count - [in]
    point_list - [in]
    padding - [in]
      amount of extra padding to add around the edges of the
      plane.  Default is 0.0625
  Returns:
    true if successful
  */
  bool CreatePseudoInfinitePlane( 
          const ON_Plane& plane,
          int point_count,
          const ON_3dPoint* point_list,
          double padding = 0.0625
          );

protected:
  // evaluation domain (always increasing)
  ON_Interval m_domain[2]; // always increasing

  // rectangle extents (in m_plane x,y coordinates)
  ON_Interval m_extents[2];
};


class ON_CLASS ON_ClippingPlaneSurface : public ON_PlaneSurface
{
  ON_OBJECT_DECLARE(ON_ClippingPlaneSurface);
public:
  ON_ClippingPlaneSurface();
  ON_ClippingPlaneSurface(const ON_Plane& src);
  ON_ClippingPlaneSurface(const ON_PlaneSurface& src);
  ~ON_ClippingPlaneSurface();

  ON_ClippingPlaneSurface& operator=(const ON_Plane& src);
  ON_ClippingPlaneSurface& operator=(const ON_PlaneSurface& src);

  void Default();

  // override ON_Object::ObjectType() - returns ON::clipplane_object
  ON::object_type ObjectType() const;

  // virtual ON_Object::SizeOf override
  unsigned int SizeOf() const;

  // virtual ON_Object::DataCRC override
  ON__UINT32 DataCRC(ON__UINT32 current_remainder) const;

  // virtual ON_Object::Dump override
  void Dump( ON_TextLog& ) const; // for debugging

  // virtual ON_Object::Write override
  ON_BOOL32 Write(
         ON_BinaryArchive&  // open binary file
       ) const;

  // virtual ON_Object::Read override
  ON_BOOL32 Read(
         ON_BinaryArchive&  // open binary file
       );

  ON_ClippingPlane m_clipping_plane;
};


#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_REVSURFACE_INC_)
#define OPENNURBS_REVSURFACE_INC_

// surface of revolution
class ON_CLASS ON_RevSurface : public ON_Surface
{
  ON_OBJECT_DECLARE(ON_RevSurface);

public:
  // virtual ON_Object::DestroyRuntimeCache override
  void DestroyRuntimeCache( bool bDelete = true );

public:
  // Revolute curve.
  // If m_curve is not NULL, then ~ON_RevSurface() deletes m_curve.
  ON_Curve*   m_curve;

  // Axis of revolution.
  ON_Line     m_axis;

  // Start and end angles of revolution in radians. 
  // The interval m_angle must be increasing and satisfiy 
  // ON_ZERO_TOLERANCE < m_angle.Length() <= 2.0*ON_PI
  ON_Interval m_angle;

  // The interval m_t specifies the parameterization for the
  // angular parameter; m_t must be an increasing interval.
  // The parameter m_t[0] corresonds to angle m_angle[0] and 
  // the parameter m_t[1] corresponds to angle m_angle[1].
  // Changing m_t and leaving m_angle unchanged will change the
  // parameterization but not change the locus of the surface.
  // Changing m_angle and leaving m_t unchanged, will change the
  // locus of the surface but not change the evaluation domain.
  ON_Interval m_t;

  // If false, the "u" parameter is the angle parameter
  // and the "v" parameter is the curve parameter.  
  // If true,  the "u" parameter is the curve parameter
  // and the "v" parameter is the angle parameter.  
  ON_BOOL32 m_bTransposed;

  // Bounding box of the surface of revolution.
  ON_BoundingBox m_bbox;

  /*
  Description:
    Use ON_RevSurface::New(...) instead of new ON_RevSurface(...)
  Returns:
    Pointer to an ON_RevSurface.  Destroy by calling delete.
  Remarks:
    See static ON_Brep* ON_Brep::New() for details.
  */
  static ON_RevSurface* New();
  static ON_RevSurface* New( const ON_RevSurface& rev_surface );


  ON_RevSurface();
  ~ON_RevSurface();
  ON_RevSurface( const ON_RevSurface& );
  ON_RevSurface& operator=( const ON_RevSurface& );

  void Destroy();

  ON_BOOL32 SetAngleRadians(
    double start_angle_radians,
    double end_angle_radians
    );
  
  ON_BOOL32 SetAngleDegrees(
    double start_angle_degrees,
    double end_angle_degrees
    );

  ////////////////////////////////////////////////////////////
  //
  // overrides of virtual ON_Object functions
  //

  // virtual ON_Object::SizeOf override
  unsigned int SizeOf() const;

  // virtual ON_Object::DataCRC override
  ON__UINT32 DataCRC(ON__UINT32 current_remainder) const;

  /*
  Description:
    Tests an object to see if its data members are correctly
    initialized.
  Parameters:
    text_log - [in] if the object is not valid and text_log
        is not NULL, then a brief englis description of the
        reason the object is not valid is appened to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     object is valid
    false    object is invalid, uninitialized, etc.
  Remarks:
    Overrides virtual ON_Object::IsValid
  */
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  void Dump( ON_TextLog& ) const; // for debugging

  // Use ON_BinaryArchive::WriteObject() and ON_BinaryArchive::ReadObject()
  // for top level serialization.  These Read()/Write() members should just
  // write/read specific definitions.  In particular, they should not write/
  // read any chunk typecode or length information.  The default 
  // implementations return false and do nothing.
  ON_BOOL32 Write(
         ON_BinaryArchive&  // serialize definition to binary archive
       ) const;

  ON_BOOL32 Read(
         ON_BinaryArchive&  // restore definition from binary archive
       );

  ////////////////////////////////////////////////////////////
  //
  // overrides of virtual ON_Geometry functions
  //
  int Dimension() const;

  ON_BOOL32 GetBBox( // returns true if successful
         double*,    // boxmin[dim]
         double*,    // boxmax[dim]
         ON_BOOL32 = false  // true means grow box
         ) const;

  void ClearBoundingBox();

  ON_BOOL32 Transform( 
         const ON_Xform&
         );

  ////////////////////////////////////////////////////////////
  //
  // overrides of virtual ON_Surface functions
  //
  
  ON_BOOL32 SetDomain( 
    int dir, // 0 sets first parameter's domain, 1 gets second parameter's domain
    double t0, 
    double t1
    );

  ON_Interval Domain(
    int // 0 gets first parameter's domain, 1 gets second parameter's domain
    ) const;

  /*
  Description:
    Get an estimate of the size of the rectangle that would
    be created if the 3d surface where flattened into a rectangle.
  Parameters:
    width - [out]  (corresponds to the first surface parameter)
    height - [out] (corresponds to the first surface parameter)
  Remarks:
    overrides virtual ON_Surface::GetSurfaceSize
  Returns:
    true if successful.
  */
  ON_BOOL32 GetSurfaceSize( 
      double* width, 
      double* height 
      ) const;

  int SpanCount(
    int // 0 gets first parameter's domain, 1 gets second parameter's domain
    ) const; // number of smooth spans in curve

  ON_BOOL32 GetSpanVector( // span "knots" 
    int, // 0 gets first parameter's domain, 1 gets second parameter's domain
    double* // array of length SpanCount() + 1 
    ) const; // 

  int Degree( // returns maximum algebraic degree of any span 
                  // ( or a good estimate if curve spans are not algebraic )
    int // 0 gets first parameter's domain, 1 gets second parameter's domain
    ) const; 

  ON_BOOL32 GetParameterTolerance( // returns tminus < tplus: parameters tminus <= s <= tplus
         int,     // 0 gets first parameter, 1 gets second parameter
         double,  // t = parameter in domain
         double*, // tminus
         double*  // tplus
         ) const;

  /*
  Description:
    Test a surface of revolution to see if it is a portion
    of a sphere.
  Parameters:
    sphere - [out] if not NULL and true is returned,
                  the sphere parameters are filled in.
    tolerance - [in] tolerance to use when checking
  Returns:
    true if the surface of revolution is a portion of a sphere.
  */
  ON_BOOL32 IsSpherical(
        ON_Sphere* sphere = NULL,
        double tolerance = ON_ZERO_TOLERANCE
        ) const;

  /*
  Description:
    Test a surface of revolution to see if it is a portion
    of a cylinder.
  Parameters:
    cylinder - [out] if not NULL and true is returned,
                  the cylinder parameters are filled in.
    tolerance - [in] tolerance to use when checking
  Returns:
    true if the surface of revolution is a portion of a cylinder.
  */
  ON_BOOL32 IsCylindrical(
        ON_Cylinder* cylinder = NULL,
        double tolerance = ON_ZERO_TOLERANCE
        ) const;

  /*
  Description:
    Test a surface of revolution to see if it is a portion
    of a cone.
  Parameters:
    cone - [out] if not NULL and true is returned,
                  the cone parameters are filled in.
    tolerance - [in] tolerance to use when checking
  Returns:
    true if the surface of revolution is a portion of a cone.
  */
  ON_BOOL32 IsConical(
        ON_Cone* cone = NULL,
        double tolerance = ON_ZERO_TOLERANCE
        ) const;

  /*
  Description:
    Test a surface to see if it is planar.
  Parameters:
    plane - [out] if not NULL and true is returned,
                  the plane parameters are filled in.
    tolerance - [in] tolerance to use when checking
  Returns:
    true if there is a plane such that the maximum distance from
    the surface to the plane is <= tolerance.
  Remarks:
    Overrides virtual ON_Surface::IsPlanar.
  */
  ON_BOOL32 IsPlanar(
        ON_Plane* plane = NULL,
        double tolerance = ON_ZERO_TOLERANCE
        ) const;

  ON_BOOL32 IsClosed(   // true if surface is closed in direction
        int        // dir  0 = "s", 1 = "t"
        ) const;

  ON_BOOL32 IsPeriodic( // true if surface is periodic in direction
        int        // dir  0 = "s", 1 = "t"
        ) const;

  ON_BOOL32 IsSingular( // true if surface side is collapsed to a point
        int        // side of parameter space to test
                   // 0 = south, 1 = east, 2 = north, 3 = west
        ) const;
  
  /*
  Description:
    Search for a derivatitive, tangent, or curvature 
    discontinuity.
  Parameters:
    dir - [in] If 0, then "u" parameter is checked.  If 1, then
               the "v" parameter is checked.
    c - [in] type of continity to test for.
    t0 - [in] Search begins at t0. If there is a discontinuity
              at t0, it will be ignored.  This makes it 
              possible to repeatedly call GetNextDiscontinuity
              and step through the discontinuities.
    t1 - [in] (t0 != t1)  If there is a discontinuity at t1 is 
              will be ingored unless c is a locus discontinuity
              type and t1 is at the start or end of the curve.
    t - [out] if a discontinuity is found, then *t reports the
          parameter at the discontinuity.
    hint - [in/out] if GetNextDiscontinuity will be called 
       repeatedly, passing a "hint" with initial value *hint=0
       will increase the speed of the search.       
    dtype - [out] if not NULL, *dtype reports the kind of 
        discontinuity found at *t.  A value of 1 means the first 
        derivative or unit tangent was discontinuous.  A value 
        of 2 means the second derivative or curvature was 
        discontinuous.  A value of 0 means teh curve is not
        closed, a locus discontinuity test was applied, and
        t1 is at the start of end of the curve.
    cos_angle_tolerance - [in] default = cos(1 degree) Used only
        when c is ON::G1_continuous or ON::G2_continuous.  If the
        cosine of the angle between two tangent vectors is 
        <= cos_angle_tolerance, then a G1 discontinuity is reported.
    curvature_tolerance - [in] (default = ON_SQRT_EPSILON) Used 
        only when c is ON::G2_continuous.  If K0 and K1 are 
        curvatures evaluated from above and below and 
        |K0 - K1| > curvature_tolerance, then a curvature 
        discontinuity is reported.
  Returns:
    Parametric continuity tests c = (C0_continuous, ..., G2_continuous):

      true if a parametric discontinuity was found strictly 
      between t0 and t1. Note well that all curves are 
      parametrically continuous at the ends of their domains.

    Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):

      true if a locus discontinuity was found strictly between
      t0 and t1 or at t1 is the at the end of a curve.
      Note well that all open curves (IsClosed()=false) are locus
      discontinuous at the ends of their domains.  All closed 
      curves (IsClosed()=true) are at least C0_locus_continuous at 
      the ends of their domains.
  */
  bool GetNextDiscontinuity( 
                  int dir,
                  ON::continuity c,
                  double t0,
                  double t1,
                  double* t,
                  int* hint=NULL,
                  int* dtype=NULL,
                  double cos_angle_tolerance=ON_DEFAULT_ANGLE_TOLERANCE_COSINE,
                  double curvature_tolerance=ON_SQRT_EPSILON
                  ) const;

/*
  Description:
    Test continuity at a surface parameter value.
  Parameters:
    c - [in] continuity to test for
    s - [in] surface parameter to test
    t - [in] surface parameter to test
    hint - [in] evaluation hint
    point_tolerance - [in] if the distance between two points is
        greater than point_tolerance, then the surface is not C0.
    d1_tolerance - [in] if the difference between two first derivatives is
        greater than d1_tolerance, then the surface is not C1.
    d2_tolerance - [in] if the difference between two second derivatives is
        greater than d2_tolerance, then the surface is not C2.
    cos_angle_tolerance - [in] default = cos(1 degree) Used only when
        c is ON::G1_continuous or ON::G2_continuous.  If the cosine
        of the angle between two normal vectors 
        is <= cos_angle_tolerance, then a G1 discontinuity is reported.
    curvature_tolerance - [in] (default = ON_SQRT_EPSILON) Used only when
        c is ON::G2_continuous.  If K0 and K1 are curvatures evaluated
        from above and below and |K0 - K1| > curvature_tolerance,
        then a curvature discontinuity is reported.
  Returns:
    true if the surface has at least the c type continuity at the parameter t.
  Remarks:
    Overrides virtual ON_Surface::IsContinuous
  */
  bool IsContinuous(
    ON::continuity c,
    double s, 
    double t, 
    int* hint = NULL,
    double point_tolerance=ON_ZERO_TOLERANCE,
    double d1_tolerance=ON_ZERO_TOLERANCE,
    double d2_tolerance=ON_ZERO_TOLERANCE,
    double cos_angle_tolerance=ON_DEFAULT_ANGLE_TOLERANCE_COSINE,
    double curvature_tolerance=ON_SQRT_EPSILON
    ) const;

  ON_BOOL32 Reverse(  // reverse parameterizatrion, Domain changes from [a,b] to [-b,-a]
    int // dir  0 = "s", 1 = "t"
    );

  ON_BOOL32 Transpose(); // transpose surface parameterization (swap "s" and "t")

  ON_BOOL32 Evaluate( // returns false if unable to evaluate
         double, double, // evaluation parameters  (see m_bTransposed)
         int,            // number of derivatives (>=0)
         int,            // array stride (>=Dimension())
         double*,        // array of length stride*(ndir+1)*(ndir+2)/2
         int = 0,        // optional - determines which quadrant to evaluate from
                         //         0 = default
                         //         1 from NE quadrant
                         //         2 from NW quadrant
                         //         3 from SW quadrant
                         //         4 from SE quadrant
         int* = 0        // optional - evaluation hint (int[2]) used to speed
                         //            repeated evaluations
         ) const;

  /*
  Description:
    Get isoparametric curve.
    Overrides virtual ON_Surface::IsoCurve.
  Parameters:
    dir - [in] 0 first parameter varies and second parameter is constant
                 e.g., point on IsoCurve(0,c) at t is srf(t,c)
               1 first parameter is constant and second parameter varies
                 e.g., point on IsoCurve(1,c) at t is srf(c,t)

    c - [in] value of constant parameter 
  Returns:
    Isoparametric curve.
  */
  ON_Curve* IsoCurve(
         int dir,
         double c
         ) const;

  /*
  Description:
    Removes the portions of the surface outside of the specified interval.

  Parameters:
    dir - [in] 0  The domain specifies an sub-interval of Domain(0)
                  (the first surface parameter).
               1  The domain specifies an sub-interval of Domain(1)
                  (the second surface parameter).
    domain - [in] interval of the surface to keep. If dir is 0, then
        the portions of the surface with parameters (s,t) satisfying
        s < Domain(0).Min() or s > Domain(0).Max() are trimmed away.
        If dir is 1, then the portions of the surface with parameters
        (s,t) satisfying t < Domain(1).Min() or t > Domain(1).Max() 
        are trimmed away.
  */
  ON_BOOL32 Trim(
         int dir,
         const ON_Interval& domain
         );

  /*
   Description:
     Where possible, analytically extends surface to include domain.
   Parameters:
     dir - [in] 0  new Domain(0) will include domain.
                   (the first surface parameter).
                1  new Domain(1) will include domain.
                   (the second surface parameter).
     domain - [in] if domain is not included in surface domain, 
     surface will be extended so that its domain includes domain.  
     Will not work if surface is closed in direction dir. 
     Original surface is identical to the restriction of the
     resulting surface to the original surface domain, 
   Returns:
     true if successful.
     */
  bool Extend(
    int dir,
    const ON_Interval& domain
    );

  /*
  Description:
    Splits (divides) the surface into two parts at the 
    specified parameter.

  Parameters:
    dir - [in] 0  The surface is split vertically.  The "west" side
                  is returned in "west_or_south_side" and the "east"
                  side is returned in "east_or_north_side".
               1  The surface is split horizontally.  The "south" side
                  is returned in "west_or_south_side" and the "north"
                  side is returned in "east_or_north_side".
    c - [in] value of constant parameter in interval returned
               by Domain(dir)
    west_or_south_side - [out] west/south portion of surface returned here
    east_or_north_side - [out] east/north portion of surface returned here

  Example:

          ON_NurbsSurface srf = ...;
          int dir = 1;
          ON_RevSurface* south_side = 0;
          ON_RevSurface* north_side = 0;
          srf.Split( dir, srf.Domain(dir).Mid() south_side, north_side );

  */
  ON_BOOL32 Split(
         int dir,
         double c,
         ON_Surface*& west_or_south_side,
         ON_Surface*& east_or_north_side
         ) const;

  int GetNurbForm( // returns 0: unable to create NURBS representation
                   //            with desired accuracy.
                   //         1: success - returned NURBS parameterization
                   //            matches the surface's to wthe desired accuracy
                   //         2: success - returned NURBS point locus matches
                   //            the surfaces's to the desired accuracy but, on
                   //            the interior of the surface's domain, the 
                   //            surface's parameterization and the NURBS
                   //            parameterization may not match to the 
                   //            desired accuracy.
        ON_NurbsSurface&,
        double = 0.0
        ) const;

  int HasNurbForm( // returns 0: unable to create NURBS representation
                   //            with desired accuracy.
                   //         1: success - returned NURBS parameterization
                   //            matches the surface's to wthe desired accuracy
                   //         2: success - returned NURBS point locus matches
                   //            the surfaces's to the desired accuracy but, on
                   //            the interior of the surface's domain, the 
                   //            surface's parameterization and the NURBS
                   //            parameterization may not match to the 
                   //            desired accuracy.
        ) const;

  bool GetSurfaceParameterFromNurbFormParameter(
        double nurbs_s, double nurbs_t,
        double* surface_s, double* surface_t
        ) const;

  bool GetNurbFormParameterFromSurfaceParameter(
        double surface_s, double surface_t,
        double* nurbs_s,  double* nurbs_t
        ) const;
};

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_SUM_SURFACE_INC_)
#define OPENNURBS_SUM_SURFACE_INC_

class ON_SumSurface;

// surface of revolution
class ON_CLASS ON_SumSurface : public ON_Surface
{
  ON_OBJECT_DECLARE(ON_SumSurface);

public:
  // virtual ON_Object::DestroyRuntimeCache override
  void DestroyRuntimeCache( bool bDelete = true );

public:

  // for expert users
  // surface-PointAt(s,t) 
  //  = m_curve[0]->PointAt(s) + m_curve[1]->PointAt(t) + m_basepoint;
  ON_Curve*  m_curve[2]; // m_curve[0] and m_curve[1] are deleted by ~ON_SumSuface.  
                         // Use a ON_ProxyCurve if this is problem.
  ON_3dVector m_basepoint;
  ON_BoundingBox m_bbox; // lazy evaluation used in ON_SumSurface::BoundingBox()

public:

  /*
  Description:
    Use ON_SumSurface::New(...) instead of new ON_SumSurface(...)
  Returns:
    Pointer to an ON_SumSurface.  Destroy by calling delete.
  Remarks:
    See static ON_Brep* ON_Brep::New() for details.
  */
  static ON_SumSurface* New();
  static ON_SumSurface* New( const ON_SumSurface& rev_surface );

  ON_SumSurface();
  ~ON_SumSurface();
  ON_SumSurface( const ON_SumSurface& );
  ON_SumSurface& operator=(const ON_SumSurface&);

  /*
  Description:
    Extrude a curve to create a surface.
  Parameters:
    curve - [in] curve is copied.
    extrusion_vector - [in] extrusion vector (must be nonzero)
  Returns:
    true if a valid surface is created.
  */
  ON_BOOL32 Create( const ON_Curve& curve, ON_3dVector extrusion_vector );

  /*
  Description:
    Extrude a curve to create a surface.
  Parameters:
    pCurve - [in] pointer to a curve. This pointer will
      be assigned to m_curve[0] and will be deleted
      by ~ON_SumSurface.
    extrusion_vector - [in] extrusion vector (must be nonzero)
  Returns:
    true if a valid surface is created.
  */
  ON_BOOL32 Create( ON_Curve* pCurve, ON_3dVector extrusion_vector );

  /*
  Description:
    Extrude a curve along a path to create a surface.
  Parameters:
    curve - [in] curve is copied.
    path_curve - [in] path_curve is copied.
  Returns:
    true if a valid surface is created.
  */
  ON_BOOL32 Create( const ON_Curve& curve, 
               const ON_Curve& path_curve
               );

  /*
  Description:
    Extrude a curve to create a surface.
  Parameters:
    pCurve - [in] pointer to a curve. This pointer will
      be assigned to m_curve[0] and will be deleted
      by ~ON_SumSurface.
    pPathCurve - [in] pointer to a path curve. This pointer will
      be assigned to m_curve[1] and will be deleted
      by ~ON_SumSurface.
  Returns:
    true if a valid surface is created.
  */
  ON_BOOL32 Create( 
          ON_Curve* pCurve, 
          ON_Curve* pPathCurve
          );

  void Destroy();

  void EmergencyDestroy();


  ////////////////////////////////////////////////////////////
  //
  // overrides of virtual ON_Object functions
  //

  // virtual ON_Object::SizeOf override
  unsigned int SizeOf() const;

  // virtual ON_Object::DataCRC override
  ON__UINT32 DataCRC(ON__UINT32 current_remainder) const;

  /*
  Description:
    Tests an object to see if its data members are correctly
    initialized.
  Parameters:
    text_log - [in] if the object is not valid and text_log
        is not NULL, then a brief englis description of the
        reason the object is not valid is appened to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     object is valid
    false    object is invalid, uninitialized, etc.
  */
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  void Dump( ON_TextLog& ) const; // for debugging

  // Use ON_BinaryArchive::WriteObject() and ON_BinaryArchive::ReadObject()
  // for top level serialization.  These Read()/Write() members should just
  // write/read specific definitions.  In particular, they should not write/
  // read any chunk typecode or length information.  The default 
  // implementations return false and do nothing.
  ON_BOOL32 Write(
         ON_BinaryArchive&  // serialize definition to binary archive
       ) const;

  ON_BOOL32 Read(
         ON_BinaryArchive&  // restore definition from binary archive
       );

  ////////////////////////////////////////////////////////////
  //
  // overrides of virtual ON_Geometry functions
  //
  int Dimension() const;

  ON_BOOL32 GetBBox(
         double* boxmin,
         double* boxmax,
         int bGrowBox = false
         ) const;

  void ClearBoundingBox();

  ON_BOOL32 Transform( 
         const ON_Xform&
         );

  // virtual ON_Geometry::IsDeformable() override
  bool IsDeformable() const;

  // virtual ON_Geometry::MakeDeformable() override
  bool MakeDeformable();

  ////////////////////////////////////////////////////////////
  //
  // overrides of virtual ON_Surface functions
  //
  ON_BOOL32 SetDomain( 
    int dir, // 0 sets first parameter's domain, 1 gets second parameter's domain
    double t0, 
    double t1
    );

  ON_Interval Domain(
    int // 0 gets first parameter's domain, 1 gets second parameter's domain
    ) const;

  /*
  Description:
    Get an estimate of the size of the rectangle that would
    be created if the 3d surface where flattened into a rectangle.
  Parameters:
    width - [out]  (corresponds to the first surface parameter)
    height - [out] (corresponds to the first surface parameter)
  Remarks:
    overrides virtual ON_Surface::GetSurfaceSize
  Returns:
    true if successful.
  */
  ON_BOOL32 GetSurfaceSize( 
      double* width, 
      double* height 
      ) const;

  int SpanCount(
    int // 0 gets first parameter's domain, 1 gets second parameter's domain
    ) const; // number of smooth spans in curve

  ON_BOOL32 GetSpanVector( // span "knots" 
    int, // 0 gets first parameter's domain, 1 gets second parameter's domain
    double* // array of length SpanCount() + 1 
    ) const; // 

  int Degree( // returns maximum algebraic degree of any span 
                  // ( or a good estimate if curve spans are not algebraic )
    int // 0 gets first parameter's domain, 1 gets second parameter's domain
    ) const; 

  ON_BOOL32 GetParameterTolerance( // returns tminus < tplus: parameters tminus <= s <= tplus
         int,     // 0 gets first parameter, 1 gets second parameter
         double,  // t = parameter in domain
         double*, // tminus
         double*  // tplus
         ) const;

  /*
  Description:
    Test a surface to see if it is planar.
  Parameters:
    plane - [out] if not NULL and true is returned,
                  the plane parameters are filled in.
    tolerance - [in] tolerance to use when checking
  Returns:
    true if there is a plane such that the maximum distance from
    the surface to the plane is <= tolerance.
  Remarks:
    Overrides virtual ON_Surface::IsPlanar.
  */
  ON_BOOL32 IsPlanar(
        ON_Plane* plane = NULL,
        double tolerance = ON_ZERO_TOLERANCE
        ) const;

  ON_BOOL32 IsClosed(   // true if surface is closed in direction
        int        // dir  0 = "s", 1 = "t"
        ) const;

  ON_BOOL32 IsPeriodic( // true if surface is periodic in direction
        int        // dir  0 = "s", 1 = "t"
        ) const;

  ON_BOOL32 IsSingular( // true if surface side is collapsed to a point
        int        // side of parameter space to test
                   // 0 = south, 1 = east, 2 = north, 3 = west
        ) const;
  
  /*
  Description:
    Search for a derivatitive, tangent, or curvature 
    discontinuity.
  Parameters:
    dir - [in] If 0, then "u" parameter is checked.  If 1, then
               the "v" parameter is checked.
    c - [in] type of continity to test for.
    t0 - [in] Search begins at t0. If there is a discontinuity
              at t0, it will be ignored.  This makes it 
              possible to repeatedly call GetNextDiscontinuity
              and step through the discontinuities.
    t1 - [in] (t0 != t1)  If there is a discontinuity at t1 is 
              will be ingored unless c is a locus discontinuity
              type and t1 is at the start or end of the curve.
    t - [out] if a discontinuity is found, then *t reports the
          parameter at the discontinuity.
    hint - [in/out] if GetNextDiscontinuity will be called 
       repeatedly, passing a "hint" with initial value *hint=0
       will increase the speed of the search.       
    dtype - [out] if not NULL, *dtype reports the kind of 
        discontinuity found at *t.  A value of 1 means the first 
        derivative or unit tangent was discontinuous.  A value 
        of 2 means the second derivative or curvature was 
        discontinuous.  A value of 0 means teh curve is not
        closed, a locus discontinuity test was applied, and
        t1 is at the start of end of the curve.
    cos_angle_tolerance - [in] default = cos(1 degree) Used only
        when c is ON::G1_continuous or ON::G2_continuous.  If the
        cosine of the angle between two tangent vectors is 
        <= cos_angle_tolerance, then a G1 discontinuity is reported.
    curvature_tolerance - [in] (default = ON_SQRT_EPSILON) Used 
        only when c is ON::G2_continuous.  If K0 and K1 are 
        curvatures evaluated from above and below and 
        |K0 - K1| > curvature_tolerance, then a curvature 
        discontinuity is reported.
  Returns:
    Parametric continuity tests c = (C0_continuous, ..., G2_continuous):

      true if a parametric discontinuity was found strictly 
      between t0 and t1. Note well that all curves are 
      parametrically continuous at the ends of their domains.

    Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):

      true if a locus discontinuity was found strictly between
      t0 and t1 or at t1 is the at the end of a curve.
      Note well that all open curves (IsClosed()=false) are locus
      discontinuous at the ends of their domains.  All closed 
      curves (IsClosed()=true) are at least C0_locus_continuous at 
      the ends of their domains.
  */
  bool GetNextDiscontinuity( 
                  int dir,
                  ON::continuity c,
                  double t0,
                  double t1,
                  double* t,
                  int* hint=NULL,
                  int* dtype=NULL,
                  double cos_angle_tolerance=ON_DEFAULT_ANGLE_TOLERANCE_COSINE,
                  double curvature_tolerance=ON_SQRT_EPSILON
                  ) const;

  /*
  Description:
    Test continuity at a surface parameter value.
  Parameters:
    c - [in] continuity to test for
    s - [in] surface parameter to test
    t - [in] surface parameter to test
    hint - [in] evaluation hint
    point_tolerance - [in] if the distance between two points is
        greater than point_tolerance, then the surface is not C0.
    d1_tolerance - [in] if the difference between two first derivatives is
        greater than d1_tolerance, then the surface is not C1.
    d2_tolerance - [in] if the difference between two second derivatives is
        greater than d2_tolerance, then the surface is not C2.
    cos_angle_tolerance - [in] default = cos(1 degree) Used only when
        c is ON::G1_continuous or ON::G2_continuous.  If the cosine
        of the angle between two normal vectors 
        is <= cos_angle_tolerance, then a G1 discontinuity is reported.
    curvature_tolerance - [in] (default = ON_SQRT_EPSILON) Used only when
        c is ON::G2_continuous.  If K0 and K1 are curvatures evaluated
        from above and below and |K0 - K1| > curvature_tolerance,
        then a curvature discontinuity is reported.
  Returns:
    true if the surface has at least the c type continuity at the parameter t.
  Remarks:
    Overrides virtual ON_Surface::IsContinuous
  */
  bool IsContinuous(
    ON::continuity c,
    double s, 
    double t, 
    int* hint = NULL,
    double point_tolerance=ON_ZERO_TOLERANCE,
    double d1_tolerance=ON_ZERO_TOLERANCE,
    double d2_tolerance=ON_ZERO_TOLERANCE,
    double cos_angle_tolerance=ON_DEFAULT_ANGLE_TOLERANCE_COSINE,
    double curvature_tolerance=ON_SQRT_EPSILON
    ) const;

  ON_BOOL32 Reverse(  // reverse parameterizatrion, Domain changes from [a,b] to [-b,-a]
    int // dir  0 = "s", 1 = "t"
    );

  ON_BOOL32 Transpose(); // transpose surface parameterization (swap "s" and "t")

  ON_BOOL32 Evaluate( // returns false if unable to evaluate
         double, double, // evaluation parameters
         int,            // number of derivatives (>=0)
         int,            // array stride (>=Dimension())
         double*,        // array of length stride*(ndir+1)*(ndir+2)/2
         int = 0,        // optional - determines which quadrant to evaluate from
                         //         0 = default
                         //         1 from NE quadrant
                         //         2 from NW quadrant
                         //         3 from SW quadrant
                         //         4 from SE quadrant
         int* = 0        // optional - evaluation hint (int[2]) used to speed
                         //            repeated evaluations
         ) const;

  ON_Curve* IsoCurve(
         int,              // 0 first parameter varies and second parameter is constant
                           //   e.g., point on IsoCurve(0,c) at t is srf(t,c)
                           // 1 first parameter is constant and second parameter varies
                           //   e.g., point on IsoCurve(1,c) at t is srf(c,t)
         double            // value of constant parameter 
         ) const;

  int GetNurbForm( // returns 0: unable to create NURBS representation
                   //            with desired accuracy.
                   //         1: success - returned NURBS parameterization
                   //            matches the surface's to wthe desired accuracy
                   //         2: success - returned NURBS point locus matches
                   //            the surfaces's to the desired accuracy but, on
                   //            the interior of the surface's domain, the 
                   //            surface's parameterization and the NURBS
                   //            parameterization may not match to the 
                   //            desired accuracy.
        ON_NurbsSurface&,
        double = 0.0
        ) const;

  int HasNurbForm( // returns 0: unable to create NURBS representation
                   //            with desired accuracy.
                   //         1: success - returned NURBS parameterization
                   //            matches the surface's to wthe desired accuracy
                   //         2: success - returned NURBS point locus matches
                   //            the surfaces's to the desired accuracy but, on
                   //            the interior of the surface's domain, the 
                   //            surface's parameterization and the NURBS
                   //            parameterization may not match to the 
                   //            desired accuracy.
        ) const;

  bool GetSurfaceParameterFromNurbFormParameter(
        double nurbs_s, double nurbs_t,
        double* surface_s, double* surface_t
        ) const;

  bool GetNurbFormParameterFromSurfaceParameter(
        double surface_s, double surface_t,
        double* nurbs_s,  double* nurbs_t
        ) const;


  /*
  Description:
    Removes the portions of the surface outside of the specified interval.

  Parameters:
    dir - [in] 0  The domain specifies an sub-interval of Domain(0)
                  (the first surface parameter).
               1  The domain specifies an sub-interval of Domain(1)
                  (the second surface parameter).
    domain - [in] interval of the surface to keep. If dir is 0, then
        the portions of the surface with parameters (s,t) satisfying
        s < Domain(0).Min() or s > Domain(0).Max() are trimmed away.
        If dir is 1, then the portions of the surface with parameters
        (s,t) satisfying t < Domain(1).Min() or t > Domain(1).Max() 
        are trimmed away.
  */
  ON_BOOL32 Trim(
         int dir,
         const ON_Interval& domain
         );

  /*
   Description:
     Where possible, analytically extends surface to include domain.
   Parameters:
     dir - [in] 0  new Domain(0) will include domain.
                   (the first surface parameter).
                1  new Domain(1) will include domain.
                   (the second surface parameter).
     domain - [in] if domain is not included in surface domain, 
     surface will be extended so that its domain includes domain.  
     Will not work if surface is closed in direction dir. 
     Original surface is identical to the restriction of the
     resulting surface to the original surface domain, 
   Returns:
     true if successful.
     */
  bool Extend(
    int dir,
    const ON_Interval& domain
    );

  /*
  Description:
    Splits (divides) the surface into two parts at the 
    specified parameter.

  Parameters:
    dir - [in] 0  The surface is split vertically.  The "west" side
                  is returned in "west_or_south_side" and the "east"
                  side is returned in "east_or_north_side".
               1  The surface is split horizontally.  The "south" side
                  is returned in "west_or_south_side" and the "north"
                  side is returned in "east_or_north_side".
    c - [in] value of constant parameter in interval returned
               by Domain(dir)
    west_or_south_side - [out] west/south portion of surface returned here
    east_or_north_side - [out] east/north portion of surface returned here

  Example:

          ON_SumSurface srf = ...;
          int dir = 1;
          ON_SumSurface* south_side = 0;
          ON_SumSurface* north_side = 0;
          srf.Split( dir, srf.Domain(dir).Mid() south_side, north_side );

  */
  ON_BOOL32 Split(
         int dir,
         double c,
         ON_Surface*& west_or_south_side,
         ON_Surface*& east_or_north_side
         ) const;
};

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

////////////////////////////////////////////////////////////////
//
//   Definition of b-rep and its parts
//
////////////////////////////////////////////////////////////////

#if !defined(OPENNURBS_BREP_INC_)
#define OPENNURBS_BREP_INC_

class ON_BrepTrim;
class ON_BrepEdge;
class ON_BrepLoop;
class ON_BrepFace;


// TEMPORARY DEFINES SO I DON'T BREAK THE BUILD
#define m_vertex_user_i m_vertex_user.i
#define m_trim_user_i m_trim_user.i
#define m_edge_user_i m_edge_user.i
#define m_loop_user_i m_loop_user.i
#define m_face_user_i m_face_user.i

// Description:
//   Brep vertex information is stored in ON_BrepVertex classes.
//   ON_Brep.m_V[] is an array of all the vertices in the brep.
//
//   If a vertex is a point on a face, then brep.m_E[m_ei]
//   will be an edge with no 3d curve.  This edge will have
//   a single trim with type ON_BrepTrim::ptonsrf.  There
//   will be a loop containing this single trim.
//   Use ON_Brep::NewPointOnFace() to create vertices that are
//   points on faces. 
class ON_CLASS ON_BrepVertex : public ON_Point
{
  ON_OBJECT_DECLARE(ON_BrepVertex);

public:
  // Union available for application use.
  // The constructor zeros m_vertex_user.
  // The value is of m_vertex_user is not saved in 3DM
  // archives and may be changed by some computations.
  ON_U m_vertex_user; 

  // index of the vertex in the ON_Brep.m_V[] array
  int m_vertex_index;

  /////////////////////////////////////////////////////////////////
  // Construction
  //
  // In general, you should not directly create ON_BrepVertex classes.
  // Use ON_Brep::NewVertex instead.
  ON_BrepVertex();
  ON_BrepVertex(
    int // vertex index
    );
  ON_BrepVertex& operator=(const ON_BrepVertex&);

  // virtual ON_Object::SizeOf override
  unsigned int SizeOf() const;

  // virtual ON_Object::DataCRC override
  ON__UINT32 DataCRC(ON__UINT32 current_remainder) const;

  /*
  Description:
    Tests an object to see if its data members are correctly
    initialized.
  Parameters:
    text_log - [in] if the object is not valid and text_log
        is not NULL, then a brief englis description of the
        reason the object is not valid is appened to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     object is valid
    false    object is invalid, uninitialized, etc.
  Remarks:
    Overrides virtual ON_Object::IsValid
  */
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  // virtual ON_Object::Dump() override
  void Dump( ON_TextLog& ) const; // for debugging

  // virtual ON_Object::Write() override
  ON_BOOL32 Write( ON_BinaryArchive& ) const;

  // virtual ON_Object::Read() override
  ON_BOOL32 Read( ON_BinaryArchive& );

  // virtual ON_Geometry::ComponentIndex() override
  ON_COMPONENT_INDEX ComponentIndex() const;

  /////////////////////////////////////////////////////////////////
  // Interface

  // Description:
  //   Set vertex location.
  // Parameters:
  //   point - [in] 3d vertex location
  bool SetPoint( 
          const ON_3dPoint& // point
          );

  // Returns:
  //   Vertex location.
  ON_3dPoint Point() const;

  // Returns:
  //   value of ON_BrepVertex::m_tolerance
  // Remarks:
  //   Use ON_Brep::SetVertexTolerance( ON_BrepVertex& ) to set tolerances.
  double Tolerance() const;

  // Returns:
  //   number of edges that begin or end at this vertex.
  int EdgeCount() const;

  /////////////////////////////////////////////////////////////////
  // Implementation

  // indices of edges starting/ending at this vertex
  //
  // For closed edges, edge.m_vi[0] = edge.m_vi[1] and 
  // edge.m_edge_index appears twice in the m_ei[] array.
  // The first occurance of edge.m_edge_index in m_ei[]
  // is for the closed edge starting the vertex.
  // The second occurance of edge,m_edge_index in m_ei[]
  // is for the closed edge ending at the vertex.
  // C.f. ON_Brep::Next/PrevEdge().
  ON_SimpleArray<int> m_ei;

  // accuracy of vertex point (>=0.0 or ON_UNSET_VALUE)
  //
  // A value of ON_UNSET_VALUE indicates that the
  // tolerance should be computed.
  //
  // A value of 0.0 indicates that the distance
  // from the vertex to any applicable edge or trim
  // end is <=  ON_ZERO_TOLERANCE
  //
  // If an edge begins or ends at this vertex,
  // then the distance from the vertex's 
  // 3d point to the appropriate end of the
  // edge's 3d curve must be <= this tolerance.
  //
  // If a trim begins or ends at this vertex,
  // then the distance from the vertex's 3d point
  // to the 3d point on the surface obtained by
  // evaluating the surface at the appropriate
  // end of the trimming curve must be <= this
  // tolerance.
  double m_tolerance;

private:
  ON_BrepVertex( const ON_BrepVertex& ); // no implementation

};

/*
Description:
  Brep edge information is stored in ON_BrepEdge classes.
  ON_Brep.m_E[] is an array of all the edges in the brep.

  An ON_BrepEdge is derived from ON_CurveProxy so the the
  edge can supply easy to use evaluation tools via 
  the ON_Curve virtual member functions.

  Note well that the domains and orientations of the curve
  m_C3[edge.m_c3i] and the edge as a curve may not
  agree.
*/
class ON_CLASS ON_BrepEdge : public  ON_CurveProxy
{
  ON_OBJECT_DECLARE(ON_BrepEdge);
public:

  // Union available for application use.
  // The constructor zeros m_edge_user.
  // The value is of m_edge_user is not saved in 3DM
  // archives and may be changed by some computations.
  ON_U m_edge_user;

  // index of edge in ON_Brep.m_E[] array
  int m_edge_index;    


  // virtual ON_Curve::IsClosed override
  ON_BOOL32 IsClosed() const;

  /////////////////////////////////////////////////////////////////
  // Construction
  //
  // In general, you should not directly create ON_BrepEdge classes.
  // Use ON_Brep::NewVertex instead.
  ON_BrepEdge();
  ON_BrepEdge(int); // edge index
  ON_BrepEdge& operator=(const ON_BrepEdge&);

  // virtual ON_Object function
  // The ON_BrepEdge override returns ON::curve_object.
  ON::object_type ObjectType() const;

  /*
  Returns:
    Brep this edge belongs to.
  */
  ON_Brep* Brep() const;


  /*
  Parameters:
    eti - [in] index into the edge's m_ti[] array.
  Returns:
    The trim brep.m_T[edge.m_ti[eti]];
  */
  using ON_CurveProxy::Trim;
  ON_BrepTrim* Trim( int eti ) const;

  /*
  Returns:
    Number of trims attached to this edge.
  */
  int TrimCount() const;

  /*
  Parameters:
    evi - [in] 0 or 1
  Returns:
    Brep vertex at specified end of the edge.
  */
  ON_BrepVertex* Vertex(int evi) const;

  // virtual ON_Object::SizeOf override
  unsigned int SizeOf() const;

  // virtual ON_Object::DataCRC override
  ON__UINT32 DataCRC(ON__UINT32 current_remainder) const;

  /*
  Description:
    Tests an object to see if its data members are correctly
    initialized.
  Parameters:
    text_log - [in] if the object is not valid and text_log
        is not NULL, then a brief englis description of the
        reason the object is not valid is appened to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     object is valid
    false    object is invalid, uninitialized, etc.
  Remarks:
    Overrides virtual ON_Object::IsValid
  */
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  // virtual ON_Object::Dump() override
  void Dump( ON_TextLog& ) const; // for debugging

  // virtual ON_Object::Write() override
  ON_BOOL32 Write( ON_BinaryArchive& ) const;

  // virtual ON_Object::Read() override
  ON_BOOL32 Read( ON_BinaryArchive& );

  // virtual ON_Geometry::ComponentIndex() override
  ON_COMPONENT_INDEX ComponentIndex() const;

  // virtual ON_Curve::Reverse override
  ON_BOOL32 Reverse();

  // virtual ON_Curve::SetStartPoint override
  ON_BOOL32 SetStartPoint(
          ON_3dPoint start_point
          );

  // virtual ON_Curve::SetEndPoint override
  ON_BOOL32 SetEndPoint(
          ON_3dPoint end_point
          );

  /////////////////////////////////////////////////////////////////
  // Implementation

  /*
  Returns:
    brep.m_C3[] index of the 3d curve geometry used by this edge 
    or -1.
  */
  int EdgeCurveIndexOf() const;

  /*
  Returns:
    3d curve geometry used by this edge or NULL.
  */
  const ON_Curve* EdgeCurveOf() const;

  /*
  Description:
    Expert user tool that replaces the 3d curve geometry
    of an edge
  Parameters;
    c3i - [in] brep 3d curve index of new curve
  Returns:
    True if successful.
  Example:

            ON_Curve* pCurve = ...;
            int c3i = brep.AddEdgeCurve(pCurve);
            edge.ChangeEdgeCurve(c3i);

  Remarks:
    Sets m_c3i, calls SetProxyCurve, cleans runtime caches.
  */
  bool ChangeEdgeCurve(
    int c3i 
    );

  /*
  Description:
    When an edge is modified, the m_pline[].e values need
    to be set to ON_UNSET_VALUE by calling UnsetPlineEdgeParameters().
  */
  void UnsetPlineEdgeParameters();

  // index of 3d curve in m_C3[] array
  // (edge.m_curve also points to m_C3[m_c3i])
  int m_c3i;

  // indices of starting/ending vertex
  //
  // For closed edges, m_vi[0] = m_vi[1] and m_edge_index
  // appears twice in the m_V[m_vi[0]].m_ei[] array.
  // The first occurance of m_edge_index in m_V[m_vi[0]].m_ei[]
  // is for the closed edge starting the vertex.  The second
  // occurance of m_edge_index in m_V[m_vi[0]].m_ei[]
  // is for the closed edge edge ending at the vertex.
  // C.f. ON_Brep::Next/PrevEdge().
  int m_vi[2];

  // indices of Trims that use this edge
  ON_SimpleArray<int> m_ti;

  // accuracy of edge curve (>=0.0 or ON_UNSET_VALUE)
  //
  // A value of ON_UNSET_VALUE indicates that the
  // tolerance should be computed.
  //
  // The maximum distance from the edge's 3d curve
  // to any surface of a face that has this edge as
  // a portion of its boundary must be <= this
  // tolerance.
  double m_tolerance;

private:
  friend class ON_Brep;
  ON_Brep* m_brep; // so isolated edge class edge can get at it's 3d curve
  ON_BrepEdge( const ON_BrepEdge& ); // no implementation
};

struct ON_BrepTrimPoint
{
  ON_2dPoint p; // 2d surface parameter space point
  double t;     // corresponding trim curve parameter
  double e;     // corresponding edge curve parameter (ON_UNSET_VALUE if unknown)
};

#if defined(ON_DLL_TEMPLATE)
// This stuff is here because of a limitation in the way Microsoft
// handles templates and DLLs.  See Microsoft's knowledge base 
// article ID Q168958 for details.
#pragma warning( push )
#pragma warning( disable : 4231 )
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_BrepTrimPoint>;
#pragma warning( pop )
#endif


/*
Description:
  Brep trim information is stored in ON_BrepTrim classes.
  ON_Brep.m_T[] is an array of all the trim in the brep.

  An ON_BrepTrim is derived from ON_CurveProxy so the the
  trim can supply easy to use evaluation tools via 
  the ON_Curve virtual member functions.

  Note well that the domains and orientations of the curve
  m_C2[trim.m_c2i] and the trim as a curve may not
  agree.
*/
class ON_CLASS ON_BrepTrim : public  ON_CurveProxy
{
  ON_OBJECT_DECLARE(ON_BrepTrim);

public:
  void DestroyRuntimeCache( bool bDelete = true );

  // virtual ON_Object::SizeOf override
  unsigned int SizeOf() const;

  // Union available for application use.
  // The constructor zeros m_trim_user.
  // The value is of m_trim_user is not saved in 3DM
  // archives and may be changed by some computations.
  ON_U m_trim_user;

  int m_trim_index;  // index of trim in ON_Brep.m_T[] array

  // types of trim - access through m_type member.  Also see m_iso and ON_Surface::ISO
  enum TYPE 
  {
    unknown  = 0,
    boundary = 1,       // trim is connected to an edge, is part of an outer, 
                        // inner or slit loop, and is the only trim connected
                        // to the edge.
    mated    = 2,       // trim is connected to an edge, is part of an outer,
                        // inner or slit loop, no other trim from the same 
                        // loop is connected to the edge, and at least one 
                        // trim from a different loop is connected to the edge.
    seam     = 3,       // trim is connected to an edge, is part of an outer, 
                        // inner or slit loop, and one other trim from the 
                        // same loop is connected to the edge.
                        // (There can be other mated trims that are also
                        // connected to the edge.  For example, the non-mainfold
                        // edge that results when a surface edge lies in the
                        // middle of another surface.)  Non-mainfold "cuts"
                        // have seam trims too.
    singular = 4,       // trim is part of an outer loop, the trim's 2d curve
                        // runs along the singular side of a surface, and the
                        // trim is NOT connected to an edge. (There is no 3d
                        // edge because the surface side is singular.)
    crvonsrf = 5,       // trim is connected to an edge, is the only trim in
                        // a crfonsrf loop, and is the only trim connected to
                        // the edge.
    ptonsrf  = 6,       // trim is a point on a surface, trim.m_pbox is records
                        // surface parameters, and is the only trim
                        // in a ptonsrf loop.  This trim is not connected
                        // to an edge and has no 2d curve.
    slit     = 7,       // 17 Nov 2006 - reserved for future use
                        //   currently an invalid value
    trim_type_count = 8,
    force_32_bit_trim_type = 0xFFFFFFFF
  };

  /////////////////////////////////////////////////////////////////
  // Construction
  //
  // In general, you should not directly create ON_BrepTrim classes.
  // Use ON_Brep::NewTrim instead.
  ON_BrepTrim();
  ON_BrepTrim(int); // trim index
  ON_BrepTrim& operator=(const ON_BrepTrim&);

  /*
  Returns:
    Brep that this trim belongs to.
  */
  ON_Brep* Brep() const;

  /*
  Returns:
    Brep loop that this trim belongs to.
  */
  ON_BrepLoop* Loop() const;

  /*
  Returns:
    Brep face this trim belongs to.
  */
  ON_BrepFace* Face() const;

  /*
  Returns:
    Brep edge this trim uses or belongs to.  This will
    be NULL for singular trims.
  */
  ON_BrepEdge* Edge() const;

  /*
  Parameters:
    tvi - [in] 0 or 1
  Returns:
    Brep vertex at specified end of the trim.
  */
  ON_BrepVertex* Vertex(int tvi) const;

  /////////////////////////////////////////////////////////////////
  // ON_Object overrides
  //
  // (Trims are purely topologicial - geometry queries should be 
  //  directed at the trim's 2d curve or the trim's edge's 3d curve.)

  /*
  Description:
    Tests an object to see if its data members are correctly
    initialized.
  Parameters:
    text_log - [in] if the object is not valid and text_log
        is not NULL, then a brief englis description of the
        reason the object is not valid is appened to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     object is valid
    false    object is invalid, uninitialized, etc.
  Remarks:
    Overrides virtual ON_Object::IsValid
  */
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  void Dump( ON_TextLog& ) const; // for debugging

  ON_BOOL32 Write( ON_BinaryArchive& ) const;

  ON_BOOL32 Read( ON_BinaryArchive& );

  // virtual ON_Geometry::ComponentIndex() override
  ON_COMPONENT_INDEX ComponentIndex() const;

  // virtual ON_Curve::Reverse override
  // Reverses curve - caller must make sure trim's m_bRev3d
  // flags are properly updated.  Use
  // ON_Brep::FlipTrim to reverse and trim and update all
  // m_bRev3d informtion.
  ON_BOOL32 Reverse();

  // virtual ON_Curve::SetStartPoint override
  ON_BOOL32 SetStartPoint(
          ON_3dPoint start_point
          );

  // virtual ON_Curve::SetEndPoint override
  ON_BOOL32 SetEndPoint(
          ON_3dPoint end_point
          );

  /////////////////////////////////////////////////////////////////
  // Interface
  
  /*
  Description:
    Expert user tool that replaces the 2d curve geometry
    of a trim
  Parameters;
    c2i - [in] brep 2d curve index of new curve
  Returns:
    True if successful.
  Example:

            ON_Curve* pCurve = ...;
            int c2i = brep.AddTrimCurve(pCurve);
            trim.ChangeTrimCurve(c2i);

  Remarks:
    Sets m_c2i, calls SetProxyCurve, cleans runtime caches,
    and updates m_pbox.
  */
  bool ChangeTrimCurve( int c2i );

  /*
  Description:
    Destroy parameter space information.
    Currently, this involves destroying m_pline
    and m_pbox. Parameter space information should
    be destroyed when the location of a trim
    curve is changed.
  */
  void DestroyPspaceInformation();
  
  /*
  Description:
    Expert user function.
    Removes a trim from an edge.
  Parameters:
    bRemoveFromStartVertex - [in] if true, the trim
      is removed from its start vertex by setting
      m_vi[0] to -1.
    bRemoveFromEndVertex - [in] if true, the trim
      is removed from its start vertex by setting
      m_vi[1] to -1.
  Remarks:
    If the trim is attached to an edge (m_ei>=0), then
    the trim is removed from the edge and the edge's
    m_ti[] list.  The trim's m_bRev3d and tolerance values
    are not changed.
  */
  bool RemoveFromEdge( 
        bool bRemoveFromStartVertex,
        bool bRemoveFromEndVertex
        );

  /*
  Description:
    Expert user function.
    Attaches a trim to an edge.
  Parameters:
    edge_index - [in] index of an edge.
    bRev3d - [in] value for trim's m_bRev3d field.
  Remarks:
    If the trim is attached to an edge (m_ei>=0), then
    the trim is removed from the edge and the edge's
    m_ti[] list.  The trim's tolerance values are not
    changed.
  */
  bool AttachToEdge(
        int edge_index,
        bool bRev3d
        );

  /*
  Returns:
    2d curve geometry used by this trim or NULL
  */
  const ON_Curve* TrimCurveOf() const;

  /*
  Returns:
    3d curve geometry used by this trim or NULL.
  */
  const ON_Curve* EdgeCurveOf() const;

  /*
  Returns:
    3d surface geometry used by this trim or NULL
  */
  const ON_Surface* SurfaceOf() const;

  /*
  Returns:
    brep.m_C2[] 2d curve index of the 2d curve geometry used by 
    this trim or -1.
  */
  int TrimCurveIndexOf() const;

  /*
  Returns:
    brep.m_C3[] 3d curve index of the 3d curve geometry used by 
    this trim or -1.
  */
  int EdgeCurveIndexOf() const;

  /*
  Returns:
    brep.m_S[] surface index of the 3d surface geometry used by 
    this trim or -1.
  */
  int SurfaceIndexOf() const;

  /*
  Returns:
    brep.m_F[] face index of the face used by this trim or -1.
  */
  int FaceIndexOf() const;

  /*
  Returns:
    True if the trim satisfies these four criteria.
      1) is part of a loop
      2) is connected to a 3d edge
      3) one other trim from the same loop is connected to the edge
      4) The 2d trim curve for the other trim is the reverse
         of the 2d trim curve for this trim.
  Remarks:
    In order for IsSlit() to work correctly, the m_type and m_iso
    fields must be set correctly.  In V4 SR1, this function will
    be removed and ON_BrepTrim::slit will be added as a type.
  */
  bool IsSlit() const;

  /*
  Returns:
    True if the trim satisfies these four criteria.
      1) is part of a loop
      2) is connected to a 3d edge
      3) one other trim from the same loop is connected to the edge
      4) the 2d trim curve for this trim lies along the side of 
         the face's parameter space and the 2d curve for the other
         trim lies on the opposite side of the face's parameter
         space.
  Remarks:
    In order for IsSeam() to work correctly, the m_type and m_iso
    fields must be set correctly.  In V4 SR1, this function will
    be removed and ON_BrepTrim::slit will be added as a type.
  */
  bool IsSeam() const;

  /*
  Description:
    Expert user tool that tranforms all the parameter space (2d)
    trimming curves in this loop.  Only 2d curve geometry is
    changed.  The caller is responsible for reversing loops,
    toggle m_bRev, flags, etc.
  Parameters:
    xform - [in] Transformation applied to 2d curve geometry.
  Returns
    True if successful.  If false is returned, the brep
    may be invalid.
  */
  bool TransformTrim( const ON_Xform& xform );

  // index of the 2d parameter space trimming curve
  int m_c2i;

  // index of 3d edge (-1 if ON_BrepTrim is singular)
  int m_ei;

  // Indices of start/end vertices.  Trims along singular
  // sides and trims that correspond to closed 3d edges
  // have m_vi[0] = m_vi[1].  Note that singular trims
  // and trims on the closed edge of a closed surface can
  // have an open 2d trimming curve and still have 
  // m_vi[0] = m_vi[1].
  int m_vi[2];
        
  // true if the 2d trim and 3d edge have opposite orientations.
  bool   m_bRev3d;

  TYPE   m_type;
  ON_Surface::ISO  m_iso;

  // index of loop that uses this trim
  int    m_li;

  // The values in m_tolerance[] record the accuracy of
  // the parameter space trimming curves.
  //
  // Remarks:
  //   m_tolerance[0] = accuracy of parameter space curve
  //   in first ( "u" ) parameter
  //
  //   m_tolerance[1] = accuracy of parameter space curve
  //   in second ( "v" ) parameter
  //
  //   A value of ON_UNSET_VALUE indicates that the 
  //   tolerance should be computed. If the value >= 0.0, 
  //   then the tolerance is set.  If the value is 
  //   ON_UNSET_VALUE, then the tolrance needs to be
  //   computed.
  //
  //   If the trim is not singular, then the trim must
  //   have an edge.  If P is a 3d point on the edge's
  //   curve and surface(u,v) = Q is the point on the 
  //   surface that is closest to P, then there must
  //   be a parameter t in the interval [m_t[0], m_t[1]]
  //   such that
  //
  //   |u - curve2d(t)[0]| <= m_tolerance[0]
  //
  //   and 
  //
  //   |v - curve2d(t)[1]| <= m_tolerance[1]
  //
  //   If P is the 3d point for the vertex brep.m_V[m_vi[k]]
  //   and (uk,vk) is the corresponding end of the trim's
  //   parameter space curve, then there must be a surface
  //   parameter (u,v) such that:
  //
  //   *  the distance from the 3d point surface(u,v) to P
  //      is <= brep.m_V[m_vi[k]].m_tolerance,
  //   *  |u-uk| <= m_tolerance[0].
  //   *  |v-vk| <= m_tolerance[1].
  double m_tolerance[2]; 

  // Runtime polyline approximation of trimming curve.
  // This information is not saved in 3DM archives.
  ON_SimpleArray<ON_BrepTrimPoint> m_pline;
  /*
  Description:
    When an edge is modified, the m_pline[].e values need
    to be set to ON_UNSET_VALUE by calling UnsetPlineEdgeParameters().
  */
  void UnsetPlineEdgeParameters();


  // Runtime parameter space trimming curve bounding box.
  // This information is not saved in 3DM archives.
  ON_BoundingBox m_pbox;

public:
  // values stored in legacy file formats - ignore

  void m__legacy_flags_Set(int,int);   // used internally - ignore
  bool m__legacy_flags_Get(int*,int*) const; // used internally - ignore
  double m__legacy_2d_tol; // used internally - ignore
  double m__legacy_3d_tol; // used internally - ignore
  int    m__legacy_flags;  // used internally - ignore

private:
  friend class ON_Brep;
  ON_Brep* m_brep; // so isolated edge class edge can get at it's 3d curve
  ON_BrepTrim( const ON_BrepTrim& ); // no implementation
};

class ON_CLASS ON_BrepLoop : public  ON_Geometry
{
  ON_OBJECT_DECLARE(ON_BrepLoop);

public:
  void DestroyRuntimeCache( bool bDelete = true );

  // virtual ON_Geometry overrides
  // A loop is derived from ON_Geometry so that is can 
  // be passed around to things that expect ON_Geometry
  // pointers.  It is not a very useful stand-alone object.

  /*
  Description:
    virtual ON_Geometry::Dimension() override.
  Returns:
    2
  */
  int Dimension() const;

  // virtual ON_Geometry::GetBBox() override.
  ON_BOOL32 GetBBox(
         double* boxmin,
         double* boxmax,
         int bGrowBox = false
         ) const;

  // virtual ON_Geometry::Transform() override.
  ON_BOOL32 Transform( 
         const ON_Xform& xform
         );
public:
  /*
  Returns:
   Brep that the loop belongs to.
  */
  ON_Brep* Brep() const;

  /*
  Returns:
    Brep face this loop belongs to.
  */
  ON_BrepFace* Face() const;

  /*
  Parameters:
    lti - [in] index into the loop's m_ti[] array.
  Returns:
    The trim brep.m_T[loop.m_ti[lti]];
  */
  ON_BrepTrim* Trim( int lti ) const;

  /*
  Returns:
    Number of trims in this loop.
  */
  int TrimCount() const;

  // Union available for application use.
  // The constructor zeros m_loop_user.
  // The value is of m_loop_user is not saved in 3DM
  // archives and may be changed by some computations.
  ON_U m_loop_user;

  int m_loop_index;  // index of loop in ON_Brep.m_L[] array

  enum TYPE {
    unknown  = 0,
    outer    = 1,  // 2d loop curves form a simple closed curve with a counterclockwise orientation
    inner    = 2,  // 2d loop curves form a simple closed curve with a clockwise orientation
    slit     = 3,  // always closed - used internally during splitting operations
    crvonsrf = 4,  // "loop" is a curveonsrf made from a single 
                   // (open or closed) trim that is has type ON_BrepTrim::crvonsrf.
    ptonsrf = 5,   // "loop" is a ptonsrf made from a single 
                   // trim that is has type ON_BrepTrim::ptonsrf.
    type_count = 6
  };

  ON_BrepLoop();
  ON_BrepLoop(int); // loop index
  ON_BrepLoop& operator=(const ON_BrepLoop&);

  /////////////////////////////////////////////////////////////////
  // ON_Object overrides
  //
  // (Loops and trims are purely topologicial - geometry queries should be 
  // directed at the trim's 2d curve or the trim's edge's 3d curve.)

  // virtual ON_Object::SizeOf override
  unsigned int SizeOf() const;

  /*
  Description:
    Tests an object to see if its data members are correctly
    initialized.
  Parameters:
    text_log - [in] if the object is not valid and text_log
        is not NULL, then a brief englis description of the
        reason the object is not valid is appened to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     object is valid
    false    object is invalid, uninitialized, etc.
  Remarks:
    Overrides virtual ON_Object::IsValid
  */
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  void Dump( ON_TextLog& ) const; // for debugging

  ON_BOOL32 Write( ON_BinaryArchive& ) const;

  ON_BOOL32 Read( ON_BinaryArchive& );

  // virtual ON_Geometry::ComponentIndex() override
  ON_COMPONENT_INDEX ComponentIndex() const;

  /////////////////////////////////////////////////////////////////
  // Interface

  //////////
  // Returns the index i such that loop.m_ti[i] = trim.m_trim_index.
  // Returns -1 if the trim is not in this loop
  int IndexOfTrim( const ON_BrepTrim& ) const;

  /*
  Returns:
    brep.m_S[] surface index of the 3d surface geometry used by 
    this loop or -1.
  */
  int SurfaceIndexOf() const;

  /*
  Returns:
    Pointer to the surface geometry used by the loop.   
  */
  const ON_Surface* SurfaceOf() const;

  /*
  Description:
    Expert user tool that tranforms all the parameter space (2d)
    trimming curves in this loop.  Only 2d curve geometry is
    changed.  The caller is responsible for reversing loops,
    toggle m_bRev, flags, etc.
  Parameters:
    xform - [in] Transformation applied to 2d curve geometry.
  Returns
    True if successful.  If false is returned, the brep
    may be invalid.
  */
  bool TransformTrim( const ON_Xform& xform );

  ON_SimpleArray<int> m_ti;   // trim indices
  TYPE         m_type;
  int          m_fi;   // index of face that uses this loop

  //////////
  // parameter space trimming loop bounding box
  // runtime information - not saved
  ON_BoundingBox m_pbox;
private:
  friend class ON_Brep;
  ON_Brep* m_brep;
  ON_BrepLoop(const ON_BrepLoop&); // no implementation
};

class ON_CLASS ON_BrepFace : public ON_SurfaceProxy
{
  ON_OBJECT_DECLARE(ON_BrepFace);

public:
  void DestroyRuntimeCache( bool bDelete = true );

  // Union available for application use.
  // The constructor zeros m_face_user.
  // The value is of m_face_user is not saved in 3DM
  // archives and may be changed by some computations.
  ON_U m_face_user;

  int m_face_index;  // index of face in ON_Brep.m_F[] array

  ON_BrepFace();
  ~ON_BrepFace();
  ON_BrepFace(int);
  ON_BrepFace& operator=(const ON_BrepFace&);

  /*
  Returns:
   Brep that the face belongs to.
  */
  ON_Brep* Brep() const;

  /*
  Parameters:
    fli - [in] index into the face's m_li[] array.
  Returns:
    The loop brep.m_L[face.m_li[fli]];
  */
  ON_BrepLoop* Loop( int fli ) const;

  /*
  Returns:
    Number of loops in this face.
  */
  int LoopCount() const;

  /*
  Returns:
    Outer boundary loop for this face.
  */
  ON_BrepLoop* OuterLoop() const;

  /*
  Parameters:
    dir
       1: side with underlying surface normal
         pointing into the topology region
      -1: side with underlying surface normal
          pointing out of the topology region
  Returns:
    Brep region topology face side.  If the region
    topology has not be created by calling
    ON_Brep::RegionToplogy(), then NULL is returned.
  */
  class ON_BrepFaceSide* FaceSide(int dir) const;


  /////////////////////////////////////////////////////////////////
  // ON_Object overrides
  //
  // (Faces are purely topologicial - geometry queries should be 
  //  directed at the face's 3d surface.)

  // virtual ON_Object::SizeOf override
  unsigned int SizeOf() const;

  // virtual ON_Object::DataCRC override
  ON__UINT32 DataCRC(ON__UINT32 current_remainder) const;

  /*
  Description:
    Tests an object to see if its data members are correctly
    initialized.
  Parameters:
    text_log - [in] if the object is not valid and text_log
        is not NULL, then a brief englis description of the
        reason the object is not valid is appened to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     object is valid
    false    object is invalid, uninitialized, etc.
  Remarks:
    Overrides virtual ON_Object::IsValid
  */
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  void Dump( ON_TextLog& ) const; // for debugging

  ON_BOOL32 Write( ON_BinaryArchive& ) const;

  ON_BOOL32 Read( ON_BinaryArchive& );

  // virtual ON_Geometry::ComponentIndex() override
  ON_COMPONENT_INDEX ComponentIndex() const;

  // virtual ON_Geometry::ClearBoundingBox() override
  void ClearBoundingBox();

  // virtual ON_Geometry::GetBBox() override
  ON_BOOL32 GetBBox( // returns true if successful
         double*,    // minimum
         double*,    // maximum
         ON_BOOL32 = false  // true means grow box
         ) const;

  /*
  Description:
    This is an override of the virtual ON_Surface::Reverse
    function.  It toggles the face's m_bRev flag so the abstract
    orientation of the face does not change.
  Parameters:
    dir - [in] 0 = reverse "s" parameter, 1 = reverse "t" parameter
         The domain changes from [a,b] to [-a,-b]
  Returns:
    True if successful.
  Remarks:
    The range of the face's trimming curves and the orientation direction
    of then loops are changed so that the resulting face is still valid.
  */
  ON_BOOL32 Reverse(
    int dir
    );

  /*
  Description:
    This is an override of the virtual ON_Surface::Transpose
    function.  It toggles the face's m_bRev flag so the abstract
    orientation of the face does not change.
  Returns:
    True if successful.
  Remarks:
    The range of the face's trimming curves and the orientation direction
    of then loops are changed so that the resulting face is still valid.
  */
  ON_BOOL32 Transpose();

  /*
  Description:
    This is an override of the virtual ON_Surface::SetDomain
    function.
  Parameters:
    dir - [in] 0 = set "u" domain, 1 = set "v" domain.
    t0 - [in]
    t1 - [in] t0 < t1  The new domain is the interval (t0,t1)
  Returns:
    True if successful.
  */
  ON_BOOL32 SetDomain(
    int dir,
    double t0,
    double t1
    );

  /*
  //////////
  // Change the domain of a face
  // This changes the parameterization of the face's surface and transforms
  // the "u" and "v" coordinates of all the face's parameter space trimming
  // curves.  The locus of the face is not changed.
  */
  bool SetDomain(
         ON_Interval udom,
         ON_Interval vdom
         );

  /////////////////////////////////////////////////////////////////
  // Rendering Interface
  //int MaterialIndex() const; // if -1, use parent's material definition
  //void SetMaterialIndex(int);

  // If true is returne, then ~ON_BrepFace will delete mesh.
  bool SetMesh( ON::mesh_type, ON_Mesh* mesh );

  const ON_Mesh* Mesh( ON::mesh_type mesh_type ) const;

  /*
  Description:
    Destroy meshes used to render and analyze surface and polysrf
    objects.
  Parameters:
    mesh_type - [in] type of mesh to destroy
    bDeleteMesh - [in] if true, cached mesh is deleted.
      If false, pointer to cached mesh is just set to NULL.
  See Also:
    CRhinoObject::GetMeshes
    CRhinoObject::MeshCount
    CRhinoObject::IsMeshable
  */
  void DestroyMesh( ON::mesh_type mesh_type, bool bDeleteMesh = true );

  /////////////////////////////////////////////////////////////////
  // "Expert" Interface

  /*
  Description:
    Expert user tool that tranforms all the parameter space (2d)
    trimming curves on this face.  Only 2d curve geometry is
    changed.  The caller is responsible for reversing loops,
    toggle m_bRev, flags, etc.
  Parameters:
    xform - [in] Transformation applied to 2d curve geometry.
  Returns
    True if successful.  If false is returned, the brep
    may be invalid.
  */
  bool TransformTrim( const ON_Xform& xform );

  /*
  Description:
    Expert user tool that replaces the 3d surface geometry
    use by the face.
  Parameters;
    si - [in] brep surface index of new surface
    bTransformTrimCurves - [in]
      If unsure, then pass true.
      If the surface's domain has changed and you are certain
      its parameterization still jibes with the trim curve
      locations, then pass false.
  Returns:
    True if successful.
  Example:

            ON_Surface* pSurface = ...;
            int si = brep.AddSurface(pSurface);
            face.ChangeSurface(si);

  Remarks:
    If the face had a surface and new surface has a different
    shape, then you probably want to call something like
    ON_Brep::RebuildEdges() to move the 3d edge curves so they
    will lie on the new surface. This doesn't delete the old 
    surface; call ON_Brep::CullUnusedSurfaces() or ON_Brep::Compact
    to remove unused surfaces.
  See Also:
    ON_Brep::RebuildEdges
    ON_Brep::CullUnusedSurfaces
  */
  bool ChangeSurface(
    int si
    );
  /*
  Returns:
    brep.m_S[] surface index of the 3d surface geometry used by 
    this face or -1.
  */
  int SurfaceIndexOf() const;

  /*
  Returns:
    Pointer to the surface geometry used by the face.   
  */
  const ON_Surface* SurfaceOf() const;

  ON_SimpleArray<int> m_li; // loop indices (outer loop is m_li[0])
  int m_si;            // index of surface in b-rep m_S[] array
  bool m_bRev;         // true if face orientation is opposite
                       //      of natural surface orientation

  // m_face_material_channel provides a way to have individual
  // brep faces use a rendering material that is different
  // from the rendering material used by the parent brep.
  // If m_face_material_channel is zero 
  // channel and m_face_material_channel.m_j is the back face
  // materal. The default is (0,0) which indicates the face
  // should use the parent brep's material.
  // If "mat" is the brep's rendering material and
  // 0 < m_material_channel.m_i < mat.m_material_channel.Count(),
  // then this face should use the material with id
  // mat.m_material_channel[face.m_material_channel.m_i-1].m_id.
  // If m_material_channel.m_i or the id is invalid in any way,
  // then the default should be used.
  int m_face_material_channel;

  // Persistent id for this face.  Default is ON_nil_uuid.
  ON_UUID m_face_uuid;
private:
  ON_BoundingBox m_bbox;      // 3d bounding box
  ON_Interval    m_domain[2]; // rectangular bounds of 2d curves
  ON_Mesh* m_render_mesh;
  ON_Mesh* m_analysis_mesh;
  ON_Mesh* m_preview_mesh;
  //int m_material_index; // if 0 (default), ON_Brep's object attributes
  //                      // determine material.
private:
  friend class ON_Brep;
  ON_Brep* m_brep;
  ON_BrepFace( const ON_BrepFace& );
};

class ON_CLASS ON_BrepFaceSide : public ON_Object
{
  ON_OBJECT_DECLARE(ON_BrepFaceSide);
public:
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  // Union available for application use.
  // The constructor zeros m_faceside_user.
  // The value is of m_faceside_user is not saved in 3DM
  // archives and may be changed by some computations.
  ON_U m_faceside_user;

  // index of face side in ON_BrepRegionTopology.m_FS[] array
  int m_faceside_index;  

  ON_BrepFaceSide();
  ~ON_BrepFaceSide();
  ON_BrepFaceSide& operator=(const ON_BrepFaceSide&);

  ON_BOOL32 Write(ON_BinaryArchive& binary_archive) const;
  ON_BOOL32 Read(ON_BinaryArchive& binary_archive);


  /*
  Returns:
   Brep this face side belongs to.
  */
  ON_Brep* Brep() const;

  /*
  Returns:
    Region topology this face side belongs to.
  */
  class ON_BrepRegionTopology* RegionTopology() const;

  /*
  Returns:
   Region the face side belongs to.
  */
  class ON_BrepRegion* Region() const;

  /*
  Returns:
   Face this side belongs to.
  */
  class ON_BrepFace* Face() const;

  /*
  Returns:
   +1: underlying geometric surface normal points
       into region.
   -1: underlying geometric surface normal points
       out of region.
  */
  int SurfaceNormalDirection() const;

public:
  int m_ri; // region index 
            // m_ri = -1 indicates this faceside overlaps
            // another faceside. Generally this is a flaw
            // in an ON_Brep.
  int m_fi; // face index
  int m_srf_dir; //  1 ON_BrepFace's surface normal points into region
                 // -1 ON_BrepFace's surface normal points out of region

private:
  friend class ON_Brep;
  friend class ON_BrepRegionTopology;
  ON_BrepRegionTopology* m_rtop;
  ON_BrepFaceSide( const ON_BrepFaceSide& );
};

class ON_CLASS ON_BrepRegion : public ON_Object
{
  ON_OBJECT_DECLARE(ON_BrepRegion);
public:
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  // Union available for application use.
  // The constructor zeros m_region_user.
  // The value is of m_region_user is not saved in 3DM
  // archives and may be changed by some computations.
  ON_U m_region_user;

  // index of region in ON_BrepRegionTopology.m_R[] array
  int m_region_index;

  ON_BrepRegion();
  ~ON_BrepRegion();
  ON_BrepRegion& operator=(const ON_BrepRegion&);

  ON_BOOL32 Write(ON_BinaryArchive& binary_archive) const;
  ON_BOOL32 Read(ON_BinaryArchive& binary_archive);

  /*
  Returns:
   Brep this region belongs to.
  */
  ON_Brep* Brep() const;

  /*
  Returns:
    Region topology this region belongs to.
  */
  class ON_BrepRegionTopology* RegionTopology() const;

  /*
  Parameter:
    rfsi - [in] index into the region's m_fsi[] array.
  Returns:
    The face side in rtop.m_FS[m_fsi[rsi]], where
    rtop is the ON_BrepRegionTopology class this
    region belongs to.
  */
  ON_BrepFaceSide* FaceSide(int rfsi) const;

  /*
  Returns:
    True if the region is finite.
  */
  bool IsFinite() const;

  /*
  Returns:
   Region bounding box.
  */
  const ON_BoundingBox& BoundingBox() const;

  ON_SimpleArray<int> m_fsi; // indices of face sides
  int m_type; // 0 = infinte, 1 = bounded
  ON_BoundingBox m_bbox;

  /*
  Description:
    Get the boundary of a region as a brep object.  
    If the region is finite, the boundary will be a closed
    manifold brep.  The boundary may have more than one
    connected component.
  Parameters:
    brep - [in] if not NULL, the brep form is put into
                this brep.
  Returns: the region boundary as a brep or NULL if the
           calculation fails.
  */
  ON_Brep* RegionBoundaryBrep( ON_Brep* brep = NULL ) const;

private:
  friend class ON_Brep;
  friend class ON_BrepRegionTopology;
  ON_BrepRegionTopology* m_rtop;
  ON_BrepRegion( const ON_BrepRegion& );
};

#if defined(ON_DLL_TEMPLATE)
// This stuff is here because of a limitation in the way Microsoft
// handles templates and DLLs.  See Microsoft's knowledge base 
// article ID Q168958 for details.
#pragma warning( push )
#pragma warning( disable : 4231 )
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ON_BrepVertex>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ObjectArray<ON_BrepVertex>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ON_BrepEdge>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ObjectArray<ON_BrepEdge>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ON_BrepTrim>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ObjectArray<ON_BrepTrim>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ON_BrepLoop>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ObjectArray<ON_BrepLoop>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ON_BrepFace>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ObjectArray<ON_BrepFace>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ObjectArray<ON_BrepFaceSide>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ObjectArray<ON_BrepRegion>;
#pragma warning( pop )
#endif

class ON_CLASS ON_BrepVertexArray : public ON_ObjectArray<ON_BrepVertex>
{
public:
  ON_BrepVertexArray();
  ~ON_BrepVertexArray();

  ON_BOOL32 Read( ON_BinaryArchive& );
  ON_BOOL32 Write( ON_BinaryArchive& ) const;

  unsigned int SizeOf() const;
};

class ON_CLASS ON_BrepEdgeArray   : public  ON_ObjectArray<ON_BrepEdge>
{
public:
  ON_BrepEdgeArray();
  ~ON_BrepEdgeArray();
  ON_BOOL32 Read( ON_BinaryArchive& );
  ON_BOOL32 Write( ON_BinaryArchive& ) const;

  unsigned int SizeOf() const;
};

class ON_CLASS ON_BrepTrimArray   : public  ON_ObjectArray<ON_BrepTrim>
{
public:
  ON_BrepTrimArray();
  ~ON_BrepTrimArray();
  ON_BOOL32 Read( ON_BinaryArchive& );
  ON_BOOL32 Write( ON_BinaryArchive& ) const;

  unsigned int SizeOf() const;
};

class ON_CLASS ON_BrepLoopArray   : public  ON_ObjectArray<ON_BrepLoop>
{
public:
  ON_BrepLoopArray();
  ~ON_BrepLoopArray();
  ON_BOOL32 Read( ON_BinaryArchive& );
  ON_BOOL32 Write( ON_BinaryArchive& ) const;

  unsigned int SizeOf() const;
};

class ON_CLASS ON_BrepFaceArray   : public  ON_ObjectArray<ON_BrepFace>
{
public:
  ON_BrepFaceArray();
  ~ON_BrepFaceArray();
  ON_BOOL32 Read( ON_BinaryArchive& );
  ON_BOOL32 Write( ON_BinaryArchive& ) const;

  unsigned int SizeOf() const;
};

class ON_CLASS ON_BrepFaceSideArray : public ON_ObjectArray<ON_BrepFaceSide>
{
public:
  ON_BrepFaceSideArray();
  ~ON_BrepFaceSideArray();

  bool Read( ON_BinaryArchive& );
  bool Write( ON_BinaryArchive& ) const;

  unsigned int SizeOf() const;
};

class ON_CLASS ON_BrepRegionArray : public ON_ObjectArray<ON_BrepRegion>
{
public:
  ON_BrepRegionArray();
  ~ON_BrepRegionArray();

  bool Read( ON_BinaryArchive& );
  bool Write( ON_BinaryArchive& ) const;

  unsigned int SizeOf() const;
};

class ON_CLASS ON_BrepRegionTopology
{
public:
  ON_BrepRegionTopology();
  ON_BrepRegionTopology(const ON_BrepRegionTopology& src);
  ~ON_BrepRegionTopology();
  ON_BrepRegionTopology& operator=(const ON_BrepRegionTopology&);

  ON_BrepFaceSideArray m_FS;
  ON_BrepRegionArray m_R;

  ON_Brep* Brep() const;
  bool IsValid( ON_TextLog* text_log = 0 ) const;
  bool Read( ON_BinaryArchive& );
  bool Write( ON_BinaryArchive& ) const;

  unsigned int SizeOf() const;

private:
  friend class ON_BrepRegionTopologyUserData;
  friend class ON_Brep;
  ON_Brep* m_brep;
};

class ON_CLASS ON_Brep : public ON_Geometry 
{
  ON_OBJECT_DECLARE(ON_Brep);

public:
  // virtual ON_Object::DestroyRuntimeCache override
  void DestroyRuntimeCache( bool bDelete = true );

  // virtual ON_Object::SizeOf override
  unsigned int SizeOf() const;

  // virtual ON_Object::DataCRC override
  ON__UINT32 DataCRC(ON__UINT32 current_remainder) const;

  // virtual ON_Geometry override
  bool EvaluatePoint( const class ON_ObjRef& objref, ON_3dPoint& P ) const;

public:


  /*
  Description:
    Use ON_Brep::New() instead of new ON_Brep() when writing
    Rhino plug-ins (or when openNURBS is used as a Microsoft 
    DLL and you need to create a new ON_Brep in a different 
    .EXE or .DLL).
  Example:

              // bad - ON_Brep* pBrep = new ON_Brep();
              ON_Brep* pBrep = ON_Brep::New(); // good
              ...
              delete pBrep;
              pBrep = NULL;

  Returns:
    Pointer to an ON_Brep.  Destroy by calling delete.
  Remarks:
    When openNURBS is used as a Microsoft DLL, the CL.EXE
    compiler uses local vtables for classes that are new-ed
    in other executables but uses the ordinary vtable for
    for classes that are allocated in functions like
    ON_BrepCylinder(), ON_NurbsSurfaceQuadrilateral(),
    ON_Cylinder::RevSurfaceForm(NULL), etc.
    Using static New() functions like ON_Brep::New() insures
    that identical classes has the same vtable and makes
    all code run identically.
  */
  static ON_Brep* New();

  /*
  Description:
    Use ON_Brep::New(const ON_Brep& src) instead 
    of new ON_Brep(const ON_Brep& src).
  Returns:
    Pointer to an ON_Brep.  Destroy by calling delete.
  Remarks:
    See static ON_Brep* ON_Brep::New() for details.
  */
  static ON_Brep* New(const ON_Brep&);

	// Construction
  ON_Brep();
	~ON_Brep();		
  ON_Brep(const ON_Brep&);
  ON_Brep& operator=(const ON_Brep&);

  // Override of virtual ON_Object::MemoryRelocate
  void MemoryRelocate();


  /*
  Description:
    See if this and other are same brep geometry.
  Parameters:
    other - [in] other brep
    tolerance - [in] tolerance to use when comparing
                     control points.
  Returns:
    true if breps are the same
  */
  bool IsDuplicate( 
          const ON_Brep& other, 
          double tolerance = ON_ZERO_TOLERANCE 
          ) const;

  /////////////////////////////////////////////////////////////////
  // construction/destruction helpers

  // returns Brep to state it has after default construction
  void Destroy(); 

  // call if memory pool used by b-rep members becomes invalid
  void EmergencyDestroy(); 

  /*
  Description:
    Calculates polygon mesh approximation of the brep
    and appends one mesh for each face to the mesh_list[]
    array.
  Parameters:
    mp - [in] meshing parameters
    mesh_list - [out] meshes are appended to this array.
  Returns:
    Number of meshes appended to mesh_list[] array.
  */
  int CreateMesh( 
    const ON_MeshParameters& mp,
    ON_SimpleArray<ON_Mesh*>& mesh_list
    ) const;

  /*
  Description:
    Destroy meshes used to render and analyze brep.
  Parameters:
    mesh_type - [in] type of mesh to destroy
    bDeleteMesh - [in] if true, cached meshes are deleted.
      If false, pointers to cached meshes are just set to NULL.
  See Also:
    ON_Brep::GetMesh
    ON_BrepFace::DestroyMesh
    ON_BrepFace::Mesh
    ON_BrepFace::SetMesh
  */
  void DestroyMesh( ON::mesh_type mesh_type, bool bDeleteMesh = true );

  /*
  Description:
    Get cached meshes used to render and analyze brep.
  Parameters:
    mesh_type - [in] type of mesh to get
    meshes - [out] meshes are appended to this array.  The ON_Brep
      owns these meshes so they cannot be modified.
  Returns:
    Number of meshes added to array. (Same as m_F.Count())
  See Also:
    ON_Brep::DestroyMesh
    ON_BrepFace::DestroyMesh
    ON_BrepFace::Mesh
    ON_BrepFace::SetMesh
  */
  int GetMesh( ON::mesh_type mesh_type, ON_SimpleArray< const ON_Mesh* >& meshes ) const;

  /*
  Description:
    Create a brep from a surface.  The resulting surface has an outer
    boundary made from four trims.  The trims are ordered so that
    they run along the south, east, north, and then west side of the
    surface's parameter space.
  Parameters:
    pSurface - [in] pointer to a surface.  The brep will manage this
       pointer and delete it in ~ON_Brep.
  Returns:
    @untitled table
    true     successful
      When true is returned, the pSurface pointer is added to the
      brep's m_S[] array and it will be deleted by the brep's
      destructor.
    false
      brep cannot be created from this surface.
      When false is returned, then the caller is responsible
      for deleting pSurface unless it was previously added
      to the brep's m_S[] array.     
  Remarks:
    The surface class must be created with new so that the
    delete in ~ON_Brep will not cause a crash.
  */
  bool Create( 
          ON_Surface*& pSurface
          );

  bool Create( 
          ON_NurbsSurface*& pNurbsSurface
          );

  bool Create( 
          ON_PlaneSurface*& pPlaneSurface
          );

  bool Create( 
          ON_RevSurface*& pRevSurface
          );

  bool Create( 
          ON_SumSurface*& pSumSurface
          );

  /*
  Description:
    Tests an object to see if its data members are correctly
    initialized.
  Parameters:
    text_log - [in] if the object is not valid and text_log
        is not NULL, then a brief englis description of the
        reason the object is not valid is appened to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     object is valid
    false    object is invalid, uninitialized, etc.
  Remarks:
    Overrides virtual ON_Object::IsValid
  See Also:
    ON_Brep::SetTolerancesAndFlags
  */
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  /*
  Description:
    Tests the brep to see if its topology information is
    valid.
  Parameters:
    text_log - [in] if the brep topology is not valid and 
        text_log is not NULL, then a brief english 
        description of the problem is appended to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     brep topology is valid
    false    brep topology is not valid
  Remarks:
    ON_Brep::IsValidTopology can be called at any time.
  See Also:
    ON_Brep::IsValid
    ON_Brep::IsValidGeometry
    ON_Brep::IsValidTolerancesAndFlags
  */
  bool IsValidTopology( ON_TextLog* text_log = NULL ) const;


  /*
  Description:
    Expert user function that tests the brep to see if its
    geometry information is valid.  The value of 
    brep.IsValidTopology() must be true before 
    brep.IsValidGeometry() can be safely called.
  Parameters:
    text_log - [in] if the brep geometry is not valid and 
        text_log is not NULL, then a brief english 
        description of the problem is appended to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     brep geometry is valid
    false    brep geometry is not valid
  Remarks:
    ON_Brep::IsValidTopology must be true before you can
    safely call ON_Brep::IsValidGeometry.
  See Also:
    ON_Brep::IsValid
    ON_Brep::IsValidTopology
    ON_Brep::IsValidTolerancesAndFlags
  */
  bool IsValidGeometry( ON_TextLog* text_log = NULL ) const;

  /*
  Description:
    Expert user function that tests the brep to see if its
    tolerances and flags are valid.  The values of 
    brep.IsValidTopology() and brep.IsValidGeometry() must
    be true before brep.IsValidTolerancesAndFlags() can 
    be safely called.
  Parameters:
    text_log - [in] if the brep tolerance or flags are not
        valid and text_log is not NULL, then a brief english 
        description of the problem is appended to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     brep tolerance and flags are valid
    false    brep tolerance and flags are not valid
  Remarks:
    ON_Brep::IsValidTopology and ON_Brep::IsValidGeometry
    must be true before you can safely call
    ON_Brep::IsValidTolerancesAndFlags.
  See Also:
    ON_Brep::IsValid
    ON_Brep::IsValidTopology
    ON_Brep::IsValidGeometry
  */
  bool IsValidTolerancesAndFlags( ON_TextLog* text_log = NULL ) const;

  // Description:
  //   Tests brep to see if it is valid for 
  //   saving in V2 3DM archives.
  // Returns:
  //   true if brep is valid for V2 3DM archives.
  // Remarks:
  //   V2 breps could not have dangling curves.
  bool IsValidForV2() const;
  bool IsValidForV2( const ON_BrepTrim& ) const;
  bool IsValidForV2( const ON_BrepEdge& ) const;

  /*
  Description:
    Split any faces with creases into G1 pieces.
  Parameters:
    kink_tol_radians - [in] kink tolerance
    bCompactIfNeeded - [in]
      If true and splitting is performed, ON_Brep::Compact()
      will be called to clean up the unsued parts.
  Returns:
    True if successful.
  Remarks:
    If you need to detect when splitting occured, comare the
    before and after values of m_F.Count().
  */
  bool SplitKinkyFaces( 
                       double kink_tol_radians = ON_DEFAULT_ANGLE_TOLERANCE,
          bool bCompactIfNeeded = true
                        );

  /*
  Description:
    Split the face into G1 pieces.
  Parameters:
    face_index - [in] Index of the face to test and split.
    kink_tol_radians - [in] kink tolerance
  Returns:
    True if successful.
  Remarks:
    This function leaves deleted stuff in the brep.  
    Call ON_Brep::Compact() to remove deleted stuff.
  */
  virtual
    bool SplitKinkyFace( 
                        int face_index, 
                        double kink_tol_radians = ON_DEFAULT_ANGLE_TOLERANCE // ON_PI/180.0
                         );

  /*
  Description:
    Split the edge into G1 pieces.
  Parameters:
    edge_index - [in] Index of the edge to test and split.
    kink_tol_radians - [in] kink tolerance
  Returns:
    True if successful.
  Remarks:
    This function leaves deleted stuff in the brep.  
    Call ON_Brep::Compact() to remove deleted stuff.
  */
  virtual
    bool SplitKinkyEdge( 
                        int edge_index, 
                        double kink_tol_radians = ON_DEFAULT_ANGLE_TOLERANCE //ON_PI/180.0
                         );

  // virtual ON_Objet::Dump() override
  void Dump( ON_TextLog& ) const; // for debugging

  // virtual ON_Objet::Write() override
  ON_BOOL32 Write( ON_BinaryArchive& ) const;

  // virtual ON_Objet::Read() override
  ON_BOOL32 Read( ON_BinaryArchive& );

  // virtual ON_Objet::ObjectType() override
  ON::object_type ObjectType() const;

  // virtual ON_Geometry::Dimension() override
  int Dimension() const;

  // virtual ON_Geometry::ClearBoundingBox() override
  void ClearBoundingBox();

  // virtual ON_Geometry::GetBBox() override
  ON_BOOL32 GetBBox( // returns true if successful
         double*,    // minimum
         double*,    // maximum
         ON_BOOL32 = false  // true means grow box
         ) const;

  // virtual ON_Geometry::Transform() override
  ON_BOOL32 Transform( 
         const ON_Xform&
         );

  // virtual ON_Geometry::SwapCoordinates() override
  ON_BOOL32 SwapCoordinates(
        int, int        // indices of coords to swap
        );

  // virtual ON_Geometry::HasBrepForm() override
  ON_BOOL32 HasBrepForm() const; // returns true

  /*
  Description:
    If possible, BrepForm() creates a brep form of the
    ON_Geometry. 
  Parameters:
    brep - [in] if not NULL, brep is used to store the brep
        form of the geometry.
  Result:
    If brep is not NULL, then brep = this, otherwise
    a duplicate of this is returned.
  Remarks:
    Override of virtual ON_Geometry::BrepForm
  */
  ON_Brep* BrepForm( ON_Brep* brep = NULL ) const;

  /////////////////////////////////////////////////////////////////
  // Creation Interface

  // These add a new geometry piece to the b-rep and return the
  // index that should be used to reference the geometry.
  // -1 is returned if the input is not acceptable.
  // ~ON_Brep() will delete the geometry.
  int AddTrimCurve( ON_Curve* ); // 2d curve used by ON_BrepTrim
  int AddEdgeCurve( ON_Curve* ); // 3d curve used by ON_BrepEdge
  int AddSurface( ON_Surface* ); // 3d surface used by ON_BrepFace

  // Description:
  //   Set 3d curve geometry used by a b-rep edge.
  // Parameters:
  //   edge - [in]
  //   c3_index - [in] index of 3d curve in m_C3[] array
  //   sub_domain - [in] if not NULL, sub_domain is an increasing
  //      sub interval of m_C3[c3_index]->Domain().
  // Returns:
  //   true if successful.
  bool SetEdgeCurve( 
    ON_BrepEdge& edge,
    int c3_index,
    const ON_Interval* sub_domain = NULL
    );

  // Description:
  //   Set 2d curve geometry used by a b-rep trim.
  // Parameters:
  //   trim - [in]
  //   c2_index - [in] index of 2d curve in m_C2[] array
  //   sub_domain - [in] if not NULL, sub_domain is an increasing
  //      sub interval of m_C2[c2_index]->Domain().
  // Returns:
  //   true if successful.
  bool SetTrimCurve( 
    ON_BrepTrim& trim,
    int c2_index,
    const ON_Interval* sub_domain = NULL
    );

  // These add a new topology piece to the b-rep and return a 
  // reference that is intended to be used for initialization.
  ON_BrepVertex& NewVertex();
  ON_BrepVertex& NewVertex( 
    ON_3dPoint vertex_point,
    double vertex_tolerance = ON_UNSET_VALUE
    );

  ON_BrepEdge& NewEdge(
                  int = -1              // 3d curve index
                  );
  ON_BrepEdge& NewEdge( 
                  ON_BrepVertex&, // start vertex
                  ON_BrepVertex&, // end vertex
                  int = -1,       // 3d curve index
                  const ON_Interval* = NULL, // sub_domain
                  double edge_tolerance = ON_UNSET_VALUE
                  );

  /*
  Description:
    Add a new face to a brep.  An incomplete face is added.
    The caller must create and fill in the loops used by
    the face.
  Parameters:
    si - [in] index of surface in brep's m_S[] array
  Returns:
    Reference to new face.
  Remarks:
    Adding a new face may grow the dynamic m_F array.  When
    this happens pointers and references to memory in the
    previous m_F[] array may become invalid.  Use face indices
    if this is an issue.
  Example:
    See ON_BrepBox and ON_BrepSphere source code.
  See Also:
    ON_Brep::AddSurface
  */
  ON_BrepFace& NewFace(
                  int si = -1
                  );

  /*
  Description:
    Add a new face to a brep.  This creates a complete face with
    new vertices at the surface corners, new edges along the surface
    boundary, etc.  The loop of the returned face has four trims that
    correspond to the south, east, north, and west side of the 
    surface in that order.  If you use this version of NewFace to
    add an exiting brep, then you are responsible for using a tool
    like ON_Brep::JoinEdges() to hook the new face to its
    neighbors.
  Parameters:
    surface - [in] surface is copied.
  Returns:
    Pointer to new face.
  Remarks:
    Adding a new face may grow the dynamic arrays used to store
    vertices, edges, faces, loops, and trims.  When these dyamic
    arrays are grown, any pointers and references to memory in
    the previous arrays may become invalid.  Use indices
    if this is an issue.
  See Also:
    ON_Brep::JoinEdges
    ON_Brep::AddSurface
  */
  ON_BrepFace* NewFace( 
    const ON_Surface& surface 
    );

  /*
  Description:
    Add a new face to brep.  This version is for expert users.
  Parameters:
    pSurface - [in] the returned face will have an outer loop
                    that goes around the edges of the surface.
    vid - [in/out] four vertex indices that specify the vertices at
                   the (sw,se,nw,ne) corners.  If the input value
                   of a vertex index is -1, then the vertex will be 
                   created.
    eid - [in/out] four edge indices that specify the edges for
                   the (south,east,north,west) sides.  If the input value
                   of an edge index is -1, then the edge will be created.
    bRev3d - [in/out] four values of the trim m_bRev3d flags of
                   the (south,east,north,west) sides.
  Returns:
    If null is returned, then the caller must delete pSurace
    unless it was previously added to the brep's m_S[] array.
    Pointer to the new face or NULL if input is not valid.
  Remarks:
    Adding a new face may grow the dynamic m_F array.  When
    this happens pointers and references to memory in the
    previous m_F[] array may become invalid.  Use face indices
    if this is an issue.
  Example:
    See ON_BrepBox and ON_BrepSphere source code.
  See Also:
    ON_Brep::AddSurface
    ON_Brep::AddFace( int si )
    ON_Brep::Create( ON_Surface*& )
  */
  ON_BrepFace* NewFace(
       ON_Surface* pSurface,
       int vid[4],
       int eid[4],
       ON_BOOL32 bRev3d[4]
       );

  /*
  Description:
    Add a new face to the brep whose surface geometry is a 
    ruled surface between two edges.
  Parameters:
    edgeA - [in] The south side of the face's surface will
          run along edgeA.
    bRevEdgeA - [in] true if the new face's outer boundary
          orientation along edgeA is opposite the orientation
          of edgeA.
    edgeB - [in] The north side of the face's surface will
          run along edgeA.
    bRevEdgeB - [in] true if the new face's outer boundary
          orientation along edgeB is opposite the orientation
          of edgeB.
  Returns:
    A pointer to the new face or a NULL if the new face could
    not be created.
  */
  ON_BrepFace* NewRuledFace(
        const ON_BrepEdge& edgeA,
        bool bRevEdgeA,
        const ON_BrepEdge& edgeB, 
        bool bRevEdgeB
        );

  /*
  Description:
    Add a new face to the brep whose surface geometry is a 
    ruled cone with the edge as the base and the vertex as
    the apex point.
  Parameters:
    vertex - [in] The apex of the cone will be at this vertex.
                   The north side of the surface's parameter
                   space will be a singular point at the vertex.
    edge - [in] The south side of the face's surface will
          run along this edge.
    bRevEdge - [in] true if the new face's outer boundary
          orientation along the edge is opposite the 
          orientation of edge.
  Returns:
    A pointer to the new face or a NULL if the new face could
    not be created.
  */
  ON_BrepFace* NewConeFace(
        const ON_BrepVertex& vertex,
        const ON_BrepEdge& edge,
        bool bRevEdge
        );

  /*
  Description:
    Create a new outer boundary loop that runs along the edges
    of the underlying surface.
  Returns:
    New outer boundary loop.
  */
  ON_BrepLoop& NewLoop( ON_BrepLoop::TYPE );

  /*
  Description:
    Create a new boundary loop on a face.  After you get this
    ON_BrepLoop, you still need to create the vertices, edges, 
    and trims that define the loop.
  Returns:
    New loop that needs to be filled in.
  */
  ON_BrepLoop& NewLoop( ON_BrepLoop::TYPE loop_type, ON_BrepFace& face );

  /*
  Description:
    Create a new outer boundary loop that runs along the sides
    of the face's surface.  All the necessary trims, edges,
    and vertices are created and added to the brep.
  Parameters:
    face_index - [in] index of face that needs an outer boundary
                      that runs along the sides of its surface.
  Returns:
    New outer boundary loop that is complete.
  */
  ON_BrepLoop* NewOuterLoop( int face_index );

  /*
  Description:
    Add a new face to brep.  This version is for expert users.
  Parameters:
    face_index - [in] index of face that will get a new outer
                   loop running around the sides of the face's
                   underlying surface.
    vid - [in/out] four vertex indices that specify the vertices at
                   the (sw,se,nw,ne) corners.  If the input value
                   of a vertex index is -1, then the vertex will be 
                   created.
    eid - [in/out] four edge indices that specify the edges for
                   the (south,east,north,west) sides.  If the input value
                   of an edge index is -1, then the edge will be created.
    bRev3d - [in/out] four values of the trim m_bRev3d flags of
                   the (south,east,north,west) sides.
  Returns:
    Pointer to the new loop or NULL if input is not valid.
  Remarks:
    Adding a new loop may grow the dynamic m_L array.  When
    this happens pointers and references to memory in the
    previous m_L[] array may become invalid.  Use face indices
    if this is an issue.
  See Also:
    ON_Brep::NewFace
  */
  ON_BrepLoop* NewOuterLoop(
         int face_index,
         int vid[4],
         int eid[4],
         ON_BOOL32 bRev3d[4]
         );

  /*
  Description:
    Add a planar trimming loop to a planar face.
  Parameters:
    face_index - [in] index of planar face.  The underlying
        suface must be an ON_PlaneSurface.
    loop_type - [in] type of loop to add.  If loop_type is
        ON_BrepLoop::unknown, then the loop direction is tested
        and the the new loops type will be set to 
        ON_BrepLoop::outer or ON_BrepLoop::inner.  If the loop_type
        is ON_BrepLoop::outer, then the direction of the new loop
        is tested and flipped if it is clockwise. If the loop_type
        is ON_BrepLoop::inner, then the direction of the new loop
        is tested and flipped if it is counter-clockwise.
    boundary - [in] a list of 3d curves that form a simple (no self
        intersections) closed curve.  These curves define the 3d
        edge geometry and should be near the planar surface.
    bDuplicateCurves - [in] If true, then duplicates of the curves 
        in the boundary array are added to the brep.  If false, the
        curves in the boundary array are added to the brep and will
        be deleted by ON_Brep::~ON_Brep.
    Returns:
      true if successful.  The new loop will be brep.m_L.Last().
  */
  bool NewPlanarFaceLoop(
        int face_index,
        ON_BrepLoop::TYPE loop_type,
        ON_SimpleArray<ON_Curve*>& boundary,
        ON_BOOL32 bDuplicateCurves = true
        );


  /*
  Description:
    Add a new trim that will be part of an inner, outer, or slit loop
    to the brep.
  Parameters:
    c2i - [in] index of 2d trimming curve
  Returns:
    new trim
  Example:
    int c2i = brep->AddTrimCurve( p2dCurve );
    ON_BrepTrim& trim = NewTrim( edge, bRev3d, loop, c2i );
    trim.m_ei = ...;
    trim.m_li = ...;
    trim.m_tolerance[0] = ...;
    trim.m_tolerance[1] = ...;
    trim.m_type = ...;
    trim.m_iso = ...;
  Remarks:
    You should set the trim's ON_BrepTrim::m_tolerance, ON_BrepTrim::m_type,
    ON_BrepTrim::m_iso, ON_BrepTrim::m_li, and ON_BrepTrim::m_ei values.
        In general, you should try to use the
    ON_BrepTrim::NewTrim( edge, bRev3d, loop, c2i ) version of NewTrim.
    If you want to add a singular trim, use ON_Brep::NewSingularTrim.
    If you want to add a crvonsrf trim, use ON_Brep::NewCurveOnFace.
    If you want to add a ptonsrf trim, use ON_Brep::NewPointOnFace.
  See Also:
    ON_Brep::SetTrimTypeFlags
    ON_Brep::SetTrimIsoFlags
    ON_Brep::NewSingularTrim
    ON_Brep::NewPointOnFace
    ON_Brep::NewCurveOnFace
  */
  ON_BrepTrim& NewTrim(
                  int c2i = -1
                  );

  /*
  Description:
    Add a new trim that will be part of an inner, outer, or slit loop
    to the brep.
  Parameters:
    bRev3d - [in] ON_BrepTrim::m_bRev3d value.  true if the
       edge and trim have opposite directions.
    loop - [in] trim is appended to this loop
    c2i - [in] index of 2d trimming curve
  Returns:
    new trim
  Example:
    int c2i = brep->AddTrimCurve( p2dCurve );
    ON_BrepTrim& trim = NewTrim( edge, bRev3d, loop, c2i );
    trim.m_ei = ...;
    trim.m_tolerance[0] = ...;
    trim.m_tolerance[1] = ...;
    trim.m_type = ...;
    trim.m_iso = ...;
  Remarks:
    You should set the trim's ON_BrepTrim::m_tolerance, ON_BrepTrim::m_type,
    ON_BrepTrim::m_iso, and ON_BrepTrim::m_ei values.
        In general, you should try to use the
    ON_BrepTrim::NewTrim( edge, bRev3d, loop, c2i ) version of NewTrim.
    If you want to add a singular trim, use ON_Brep::NewSingularTrim.
    If you want to add a crvonsrf trim, use ON_Brep::NewCurveOnFace.
    If you want to add a ptonsrf trim, use ON_Brep::NewPointOnFace.
  See Also:
    ON_Brep::SetTrimTypeFlags
    ON_Brep::SetTrimIsoFlags
    ON_Brep::NewSingularTrim
    ON_Brep::NewPointOnFace
    ON_Brep::NewCurveOnFace
  */
  ON_BrepTrim& NewTrim(
                  ON_BOOL32 bRev3d,
                  ON_BrepLoop& loop,
                  int c2i = -1
                  );

  /*
  Description:
    Add a new trim that will be part of an inner, outer, or slit loop
    to the brep.
  Parameters:
    edge - [in] 3d edge associated with this trim
    bRev3d - [in] ON_BrepTrim::m_bRev3d value.  true if the
       edge and trim have opposite directions.
    c2i - [in] index of 2d trimming curve
  Returns:
    new trim
  Example:
    int c2i = brep->AddTrimCurve( p2dCurve );
    ON_BrepTrim& trim = NewTrim( edge, bRev3d, c2i );
    trim.m_li = ...;
    trim.m_tolerance[0] = ...;
    trim.m_tolerance[1] = ...;
    trim.m_type = ...;
    trim.m_iso = ...;
  Remarks:
    You should set the trim's ON_BrepTrim::m_tolerance, 
    ON_BrepTrim::m_type, ON_BrepTrim::m_iso, 
    and ON_BrepTrim::m_li values.
        In general, you should try to use the
    ON_BrepTrim::NewTrim( edge, bRev3d, loop, c2i ) version of NewTrim.
    If you want to add a singular trim, use ON_Brep::NewSingularTrim.
    If you want to add a crvonsrf trim, use ON_Brep::NewCurveOnFace.
    If you want to add a ptonsrf trim, use ON_Brep::NewPointOnFace.
  See Also:
    ON_Brep::SetTrimTypeFlags
    ON_Brep::SetTrimIsoFlags
    ON_Brep::NewSingularTrim
    ON_Brep::NewPointOnFace
    ON_Brep::NewCurveOnFace
  */
  ON_BrepTrim& NewTrim(
                  ON_BrepEdge& edge,
                  ON_BOOL32 bRev3d,
                  int c2i = -1
                  );

  /*
  Description:
    Add a new trim that will be part of an inner, outer, or slit loop
    to the brep.
  Parameters:
    edge - [in] 3d edge associated with this trim
    bRev3d - [in] ON_BrepTrim::m_bRev3d value.  true if the
       edge and trim have opposite directions.
    loop - [in] trim is appended to this loop
    c2i - [in] index of 2d trimming curve
  Returns:
    new trim
  Example:
    int c2i = brep->AddTrimCurve( p2dCurve );
    ON_BrepTrim& trim = brep->NewTrim( edge, bRev3d, loop, c2i );
    trim.m_tolerance[0] = ...;
    trim.m_tolerance[1] = ...;
  Remarks:
    You should set the trim's ON_BrepTrim::m_tolerance values.
    If c2i is -1, you must set the trim's ON_BrepTrim::m_iso values.
    This version of NewTrim sets the trim.m_type value.  If the
    input edge or loop are not currently valid, then you may
    need to adjust the trim.m_type value.
    If you want to add a singular trim, use ON_Brep::NewSingularTrim.
    If you want to add a crvonsrf trim, use ON_Brep::NewCurveOnFace.
    If you want to add a ptonsrf trim, use ON_Brep::NewPointOnFace.
  See Also:
    ON_Brep::SetTrimTypeFlags
    ON_Brep::SetTrimIsoFlags
    ON_Brep::NewSingularTrim
    ON_Brep::NewPointOnFace
    ON_Brep::NewCurveOnFace
  */
  ON_BrepTrim& NewTrim(
                  ON_BrepEdge& edge,
                  ON_BOOL32 bRev3d,
                  ON_BrepLoop& loop,
                  int c2i = -1
                  );

  /*
  Description:
    Add a new singular trim to the brep.
  Parameters:
    vertex - [in] vertex along collapsed surface edge
    loop - [in] trim is appended to this loop
    iso - [in] one of ON_Surface::S_iso, ON_Surface::E_iso, 
               ON_Surface::N_iso, or ON_Surface::W_iso.
    c2i - [in] index of 2d trimming curve
  Returns:
    new trim
  See Also:
    ON_Brep::NewTrim
  */
  ON_BrepTrim& NewSingularTrim(
                  const ON_BrepVertex& vertex,
                  ON_BrepLoop& loop,
                  ON_Surface::ISO iso,
                  int c2i = -1
                  );

  /*
  Description:
    Adds a new point on face to the brep.
  Parameters:
    face - [in] face that vertex lies on
    s,t - [in] surface parameters
  Returns:
    new vertex that represents the point on face.
  Remarks:
    If a vertex is a point on a face, then brep.m_E[m_ei]
    will be an edge with no 3d curve.  This edge will have
    a single trim with type ON_BrepTrim::ptonsrf.  There
    will be a loop containing this single trim.
  */
  ON_BrepVertex& NewPointOnFace( 
    ON_BrepFace& face,
    double s,
    double t
    );

  /*
  Description:
    Add a new curve on face to the brep.
  Parameters:
    face - [in] face that curve lies on
    edge - [in] 3d edge associated with this curve on surface
    bRev3d - [in] true if the 3d edge and the 2d parameter space 
                  curve have opposite directions.
    c2i - [in] index of 2d curve in face's parameter space
  Returns:
    new trim that represents the curve on surface
  Remarks:
    You should set the trim's ON_BrepTrim::m_tolerance and
    ON_BrepTrim::m_iso values.
  */
  ON_BrepTrim& NewCurveOnFace(
                  ON_BrepFace& face,
                  ON_BrepEdge& edge,
                  ON_BOOL32 bRev3d = false,
                  int c2i = -1
                  );

  // appends a copy of brep to this and updates
  // indices of appended brep parts.  Duplicates are not removed.
  void Append( 
    const ON_Brep& // brep
    ); 

  // This function can be used to compute vertex information for a
  // b-rep when everything but the m_V array is properly filled in.
  // It is intended to be used when creating a ON_Brep from a 
  // definition that does not include explicit vertex information.
  void SetVertices(void);

  // This function can be used to set the ON_BrepTrim::m_iso
  // flag. It is intended to be used when creating a ON_Brep from
  // a definition that does not include compatible parameter space
  // type information.
  // See Also: ON_BrepSetFlagsAndTolerances
  bool SetTrimIsoFlags();    // sets all trim iso flags
  bool SetTrimIsoFlags( ON_BrepFace& );
  bool SetTrimIsoFlags( ON_BrepLoop& );
  bool SetTrimIsoFlags( ON_BrepTrim& );


  /*
  Description:
    Calculate the type (singular, mated, boundary, etc.) of
    an ON_BrepTrim object.
  Parameters:
    trim - [in]
    bLazy - [in] if true and trim.m_type is set to something other
       than ON_BrepTrim::unknown, then no calculation is
       performed and the value of trim.m_type is returned.
       If false, the value of trim.m_type is ignored and is caluculated.
  Returns:
    Type of trim.
  Remarks:
    The trim must be connected to a valid loop.
  See Also:
    ON_Brep::SetTrimTypeFlags
  */
  ON_BrepTrim::TYPE TrimType( 
    const ON_BrepTrim& trim, 
    ON_BOOL32 bLazy = true
    ) const;

  // This function can be used to set the ON_BrepTrim::m_type
  // flag.  If the optional bLazy argument is true, then only
  // trims with m_type = unknown are set.
  // See Also: ON_BrepSetFlagsAndTolerances
  bool SetTrimTypeFlags( ON_BOOL32 bLazy = false );    // sets all trim iso flags
  bool SetTrimTypeFlags( ON_BrepFace&, ON_BOOL32 bLazy = false );
  bool SetTrimTypeFlags( ON_BrepLoop&, ON_BOOL32 bLazy = false );
  bool SetTrimTypeFlags( ON_BrepTrim&, ON_BOOL32 bLazy = false );

  // GetTrim2dStart() evaluates the start of the
  // parameter space (2d) trim curve.
  bool GetTrim2dStart( 
          int trim_index,         // index of ON_BrepTrim in m_T[] array
          ON_2dPoint& 
          ) const;

  // GetTrim2dEnd() evaluates end of the
  // parameter space (2d) trim curve.
  bool GetTrim2dEnd(
          int,         // index of ON_BrepTrim in m_T[] array
          ON_2dPoint& 
          ) const;

  // GetTrim3dStart() evaluates the 3d surface at the start of the
  // parameter space (2d) trim curve.
  bool GetTrim3dStart( 
          int,         // index of ON_BrepTrim in m_T[] array
          ON_3dPoint& 
          ) const;

  // GetTrim3dEnd() evaluates the 3d surface at the end of the
  // parameter space (2d) trim curve.
  bool GetTrim3dEnd(
          int,         // index of ON_BrepTrim in m_T[] array
          ON_3dPoint& 
          ) const;

  // This function examines the 2d parameter space curves and returns
  // the loop's type based on their orientation.  Use this function for
  // debugging loop orientation problems.
  ON_BrepLoop::TYPE ComputeLoopType( const ON_BrepLoop& ) const;

  // These set the various tolerances.  The optional ON_BOOL32 argument
  // is called bLazy.  If bLazy is false, the tolerance is recomputed
  // from its definition.  If bLazy is true, the tolerance is computed
  // only if its current value is negative.
  bool SetVertexTolerance( ON_BrepVertex& vertex, ON_BOOL32 bLazy = false ) const;
  virtual
  bool SetTrimTolerance( ON_BrepTrim& trim, ON_BOOL32 bLazy = false ) const;
  virtual
  bool SetEdgeTolerance( ON_BrepEdge& edge, ON_BOOL32 bLazy = false ) const;

  /*
  Description:
    Set the brep's vertex tolerances.
  Parameters:
    bLazy - [in] if true, only vertex tolerances with the value
       ON_UNSET_VALUE will be set.  If false, the vertex tolerance
       is recomputed from the geometry in the brep.
  Returns:
    true if successful.
  See Also:
    ON_Brep::SetVertexTolerance
    ON_Brep::SetTrimTolerance
    ON_Brep::SetEdgeTolerance
    ON_Brep::SetVertexTolerances
    ON_Brep::SetTrimTolerances
    ON_Brep::SetEdgeTolerances
    ON_Brep::SetTolerancesAndFlags
  */
  bool SetVertexTolerances( ON_BOOL32 bLazy = false );

  /*
  Description:
    Set the brep's trim tolerances.
  Parameters:
    bLazy - [in] if true, only trim tolerances with the value
       ON_UNSET_VALUE will be set.  If false, the trim tolerance
       is recomputed from the geometry in the brep.
  Returns:
    true if successful.
  See Also:
    ON_Brep::SetVertexTolerance
    ON_Brep::SetTrimTolerance
    ON_Brep::SetEdgeTolerance
    ON_Brep::SetVertexTolerances
    ON_Brep::SetTrimTolerances
    ON_Brep::SetEdgeTolerances
    ON_Brep::SetTolerancesAndFlags
  */
  bool SetTrimTolerances( ON_BOOL32 bLazy = false );

  /*
  Description:
    Set the brep's edge tolerances.
  Parameters:
    bLazy - [in] if true, only edge tolerances with the value
       ON_UNSET_VALUE will be set.  If false, the edge tolerance
       is recomputed from the geometry in the brep.
  Returns:
    true if successful.
  See Also:
    ON_Brep::SetVertexTolerance
    ON_Brep::SetTrimTolerance
    ON_Brep::SetEdgeTolerance
    ON_Brep::SetVertexTolerances
    ON_Brep::SetTrimTolerances
    ON_Brep::SetEdgeTolerances
    ON_Brep::SetTolerancesAndFlags
  */
  bool SetEdgeTolerances( ON_BOOL32 bLazy = false );


  /*
  Description:
    Set the trim parameter space bounding box (trim.m_pbox).
  Parameters:
    trim - [in]
    bLazy - [in] if true and trim.m_pbox is valid, then
       the box is not set.
  Returns:
    true if trim ends up with a valid bounding box.
  */
  virtual
  bool SetTrimBoundingBox( ON_BrepTrim& trim, ON_BOOL32 bLazy=false );

  /*
  Description:
    Set the loop parameter space bounding box (loop.m_pbox).
  Parameters:
    loop - [in]
    bLazy - [in] if true and loop trim trim.m_pbox is valid, 
       then that trim.m_pbox is not recalculated.
  Returns:
    true if loop ends up with a valid bounding box.
  */
  virtual
  bool SetTrimBoundingBoxes( ON_BrepLoop& loop, ON_BOOL32 bLazy=false );


  /*
  Description:
    Set the loop and trim parameter space bounding boxes
    for every loop and trim in the face 
  Parameters:
    face - [in]
    bLazy - [in] if true and trim trim.m_pbox is valid, 
       then that trim.m_pbox is not recalculated.
  Returns:
    true if all the face's loop and trim parameter space bounding 
    boxes are valid.
  */
  virtual
  bool SetTrimBoundingBoxes( ON_BrepFace& face, ON_BOOL32 bLazy=false );

  /*
  Description:
    Set the loop and trim parameter space bounding boxes
    for every loop and trim in the brep.
  Parameters:
    bLazy - [in] if true and trim trim.m_pbox is valid, 
       then that trim.m_pbox is not recalculated.
  Returns:
    true if all the loop and trim parameter space bounding boxes
    are valid.
  */
  virtual
  bool SetTrimBoundingBoxes( ON_BOOL32 bLazy=false );

  /*
  Description:
    Set tolerances and flags in a brep
  Parameters:
    bLazy - [in] if true, only flags and tolerances that are not
       set will be calculated.
    bSetVertexTolerances - [in] true to compute vertex.m_tolerance values
    bSetEdgeTolerances - [in] true to compute edge.m_tolerance values
    bSetTrimTolerances - [in] true to compute trim.m_tolerance[0,1] values
    bSetTrimIsoFlags - [in] true to compute trim.m_iso values
    bSetTrimTypeFlags - [in] true to compute trim.m_type values
    bSetLoopTypeFlags - [in] true to compute loop.m_type values
    bSetTrimBoxes - [in] true to compute trim.m_pbox values
  See Also:
    ON_Brep::SetVertexTolerance
    ON_Brep::SetEdgeTolerance
    ON_Brep::SetTrimTolerance
    ON_Brep::SetTrimTypeFlags
    ON_Brep::SetTrimIsoFlags
    ON_Brep::ComputeLoopType
    ON_Brep::SetTrimBoundingBox
    ON_Brep::SetTrimBoundingBoxes
  */
  void SetTolerancesBoxesAndFlags(
       ON_BOOL32 bLazy = false,
       ON_BOOL32 bSetVertexTolerances = true,
       ON_BOOL32 bSetEdgeTolerances = true,
       ON_BOOL32 bSetTrimTolerances = true,
       ON_BOOL32 bSetTrimIsoFlags = true,
       ON_BOOL32 bSetTrimTypeFlags = true,
       ON_BOOL32 bSetLoopTypeFlags = true,
       ON_BOOL32 bSetTrimBoxes = true
       );


  /////////////////////////////////////////////////////////////////
  // Query Interface

  /*
  Description:
    Determine how many brep faces reference m_S[surface_index].
  Parameters:
    surface_index - [in] index of the surface in m_S[] array
    max_count - [in] counting stops if max_count > 0 and
                     at least max_count faces use the surface.
  Returns:
    Number of brep faces that reference the surface.
  */
  int SurfaceUseCount( 
              int surface_index,
              int max_count=0 ) 
              const;
  /*
  Description:
    Determine how many brep edges reference m_C3[c3_index].
  Parameters:
    c3_index - [in] index of the 3d curve in m_C3[] array
    max_count - [in] counting stops if max_count > 0 and
                     at least max_count edges use the 3d curve.
  Returns:
    Number of brep edges that reference the 3d curve.
  */
  int EdgeCurveUseCount( 
              int c3_index,
              int max_count=0 ) 
              const;

  /*
  Description:
    Determine how many brep trims reference m_C2[c2_index].
  Parameters:
    c2_index - [in] index of the 2d curve in m_C2[] array
    max_count - [in] counting stops if max_count > 0 and
                     at least max_count trims use the 2d curve.
  Returns:
    Number of brep trims that reference the 2d curve.
  */
  int TrimCurveUseCount( 
              int c2_index,
              int max_count=0 ) 
              const;

  /*
  Description:
    Get a single 3d curve that traces the entire loop
  Parameters:
    loop - [in] loop whose 3d curve should be duplicated
    bRevCurveIfFaceRevIsTrue - [in] If false, the returned
       3d curve has an orientation compatible with the
       2d curve returned by Loop2dCurve().
       If true and the m_bRev flag of the loop's face
       is true, then the returned curve is reversed.
  Returns:
    A pointer to a 3d ON_Curve.  The caller must delete
    this curve.
  */
  ON_Curve* Loop3dCurve( 
    const ON_BrepLoop& loop,
    ON_BOOL32 bRevCurveIfFaceRevIsTrue = false
    ) const;

  /*
  Description:
    Get a list of 3d curves that trace the non-seam edge
    portions of an entire loop
  Parameters:
    loop - [in] loop whose 3d curve should be duplicated
    curve_list - [out] 3d curves are appended to this list
    bRevCurveIfFaceRevIsTrue - [in] If false, the returned
       3d curves have an orientation compatible with the
       2d curve returned by Loop2dCurve().
       If true and the m_bRev flag of the loop's face
       is true, then the returned curves are reversed.
  Returns:
    Number of curves appended to curve_list.
  */
  int Loop3dCurve( 
    const ON_BrepLoop& loop,
    ON_SimpleArray<ON_Curve*>& curve_list,
    ON_BOOL32 bRevCurveIfFaceRevIsTrue = false
    ) const;


  /*
  Description:
    Get a 3d curve that traces the entire loop
  Parameters:
    loop - [in] loop whose 2d curve should be duplicated
  Returns:
    A pointer to a 2d ON_Curve.  The caller must delete
    this curve.
  */
  ON_Curve* Loop2dCurve( const ON_BrepLoop& loop ) const;

  /*
  Description:
    Determine orientation of a brep.
  Returns:
    @untitle table
    +2     brep is a solid but orientation cannot be computed
    +1     brep is a solid with outward facing normals
    -1     brep is a solid with inward facing normals
     0     brep is not a solid
  Remarks:
    The base class implementation returns 2 or 0.  This
    function is overridden in the Rhino SDK and returns
    +1, -1, or 0.
  See Also:
    ON_Brep::IsSolid
  */
  virtual
  int SolidOrientation() const;

  /*
  Description:
    Test brep to see if it is a solid.  (A "solid" is
    a closed oriented manifold.)
  Returns:
    @untitled table
    true       brep is a solid
    fals       brep is not a solid
  See Also:
    ON_Brep::SolidOrientation
    ON_Brep::IsManifold
  */
  bool IsSolid() const;
  
  /*
  Description:
    Test brep to see if it is an oriented manifold.
  Parameters:
    pbIsOriented - [in]  if not null, *pbIsOriented is set
        to true if b-rep is an oriented manifold and false
        if brep is not an oriented manifold.
    pbHasBoundary - [in]  if not null, *pbHasBoundary is set
        to true if b-rep has a boundary edge and false if
        brep does not have a boundary edge.
  Returns:
    true       brep is a manifold
    fals       brep is not a manifold
  See Also:
    ON_Brep::IsSolid
  */
  bool IsManifold( // returns true if b-rep is an oriented manifold
    ON_BOOL32* pbIsOriented = NULL,
    ON_BOOL32* pbHasBoundary = NULL
    ) const;



  bool IsSurface() const;      // returns true if the b-rep has a single face
                               // and that face is geometrically the same
                               // as the underlying surface.  I.e., the face
                               // has trivial trimming.  In this case, the
                               // surface is m_S[0].
                               // The flag m_F[0].m_bRev records
                               // the correspondence between the surface's
                               // natural parametric orientation and the
                               // orientation of the b-rep.


  bool FaceIsSurface(          // returns true if the face has a single
         int // index of face  // outer boundary and that boundary runs
         ) const;              // along the edges of the underlying surface.
                               // In this case the geometry of the surface
                               // is the same as the geometry of the face.
                               // If FaceIsSurface() is true, then
                               // m_S[m_F[face_index].m_si] is the surface.
                               // The flag m_F[face_index].m_bRev records
                               // the correspondence between the surface's
                               // natural parametric orientation and the
                               // orientation of face in the b-rep.

  bool LoopIsSurfaceBoundary(  // returns true if the loop's trims all run
         int // index of loop  // along the edge's of the underlying surface's
         ) const;              // parameter space.

  /////////////////////////////////////////////////////////////////
  // Modification Interface

  //////////
  // Clears all ON_BrepFace.m_bRev flags by ON_BrepFace::Transpose
  // on each face with a true m_bRev.
  bool FlipReversedSurfaces();

  //////////
  // Change the domain of a trim's 2d curve.  This changes only the
  // parameterization of the 2d trimming curve; the locus of the 
  // 2d trimming curve is not changed.
  bool SetTrimDomain(
         int, // index of trim in m_T[] array
         const ON_Interval&
         );

  //////////
  // Change the domain of an edge.  This changes only the
  // parameterization of the 3d edge curve; the locus of the 
  // 3d edge curve is not changed.
  bool SetEdgeDomain(
         int, // index of edge in m_E[] array
         const ON_Interval&
         );

  // Reverses entire brep orientation of all faces by toggling 
  // value of all face's ON_BrepFace::m_bRev flag.
  void Flip();

  // reverses orientation of a face by toggling ON_BrepFace::m_bRev
  void FlipFace(ON_BrepFace&);

  // Reverses orientation of trimming loop. 
  // This function is intended to be used by brep experts and does
  // does NOT modify ON_BrepLoop::m_type.  You should make sure 
  // ON_BrepLoop::m_type jibes with the loop's direction.  (Outer loops
  // should be counter-clockwise and inner loops should be clockwise.)
  // You can use ON_Brep::LoopDirection() to determine the direction of
  // a loop.
  void FlipLoop(ON_BrepLoop&); // reverses orientation of trimming loop

  // LoopDirection() examines the 2d trimming curve geometry that defines
  // the loop and returns
  //
  //   @untitled table
  //   +1    the loop is a counter-clockwise loop.
  //   -1    the loop is a clockwise loop.
  //    0    the loop is not a continuous closed loop.
  //
  // Since LoopDirection() calculates its result based on the 2d trimming
  // curve geometry, it can be use to set ON_BrepLoop::m_type to outer/inner
  // when translating from data definition where this distinction is murky.
  int LoopDirection( const ON_BrepLoop& ) const;


  /*
  Description:
    Sort the face.m_li[] array by loop type 
    (outer, inner, slit, crvonsrf, ptonsrf)
  Parameters:
    face - [in/out] face whose m_li[] array should be sorted.
  Returns:
    @untitled table
    true      success
    false     failure - no loops or loops with unset loop.m_type
  See Also:
    ON_Brep::ComputeLoopType
    ON_Brep::LoopDirection
  */
  bool SortFaceLoops( ON_BrepFace& face ) const;

  /*
  Description:
    Join coincident edges.
  Parameters:
    edge - [in] this edge will survive the joining process
      and the vertices at its ends will survive the joining process.
    other_edge - [in] this edge and the vertices at its ends will
      be removed.
    join_tolerance - [in] The distances between the ends
      of edge and other_edge must be at most join_tolerance
      in order for the edges to be joined.  The caller is
      responsible for insuring that the 3d location of 
      other_edge is within join_tolerance of edge.
    bCheckFaceOrientaion - [in]
      If true and edge and other_edge are boundary edges,
      then the orientation of the face using other_edge
      is adjusted to match the orientation of the face using
      edge.
  Returns:
    true if join is successful
  Example:

    // extrude an edge of a brep to make a new face
    // NOTE WELL:
    //   THIS IS A SIMPLE EXAMPLE THAT IS NOT VERY EFFICIENT
    //   Use ON_BrepExtrudeEdge if you really want to extrude an edge.
    ON_Brep brep = ...;
    // edge = some valid edge in brep
    const ON_BrepEdge& edge = brep.m_E[...];

    // extrude edge to make a surface
    ON_3dVector v = ...;
    ON_SumSurface* new_surface = new ON_SumSurface();
    new_surface->Create( edge, v );

    // 
    ON_Brep new_brep;
    new_brep.AddFace( Create( new_surface );
    brep.

  See Also:
    ON_Brep:CullUnusedEdges
    ON_Brep:CullUnusedVertices
    ON_Brep:CullUnused3dCurves
  */
  bool JoinEdges( 
                 ON_BrepEdge& edge, 
                 ON_BrepEdge& other_edge,
                 double join_tolerance,
    ON_BOOL32 bCheckFaceOrientaion = true
                  );

  /*
  Description:
    Expert user function.
  See Also:
    ON_Brep::JoinEdges
  */
  bool CombineCoincidentVertices(ON_BrepVertex&, ON_BrepVertex&); // moves information to first vertex and deletes second

  /*
  Description:
    Expert user function.
  See Also:
    ON_Brep::JoinEdges
  */
  bool CombineCoincidentEdges(ON_BrepEdge&, ON_BrepEdge&); // moves information to first edge and deletes second

  /*
  Description:
    Expert user function.
    Combines contiguous edges into a single edge.  The edges
    must share a common vertex, then angle between the edge
    tangents are the common vertex must be less than or
    equal to angle_tolerance_radians, and any associated
    trims must be contiguous in there respective boundaries.
  Parameters;
    edge_index0 - [in]
    edge_index1 - [in]
    angle_tolerance_radians - [in]
  Returns:
    Pointer to the new edge or NULL if the edges cannot
    be combined into a single edge.
  Remarks:
    The input edges are deleted but are still in the
    brep's m_E[] arrays.  Use ON_Brep::Compact to remove 
    the unused edges.
  */
  ON_BrepEdge* CombineContiguousEdges( 
    int edge_index0, 
    int edge_iindex1, 
    double angle_tolerance_radians = ON_PI/180.0
    );

  /*
  Description:
    Given a trim and parameter on the corresponding 3d edge,
    get the corresponding parameter on the 2d trim curve.
  Parameters:
    trim_index - [in] index of trim in m_T array
    edge_t - [in] parameter on 3d edge
    trim_t - [out] parameter on 2d trim curve
    bOkToBuildTrimPline - [in] 
       if true and m_T[trim_index].m_pline[] does not
       have its edge parameters set, then they are filled
       in.  This is slow the first time, but greatly
       increases the speed of GetTrimParameter
       and GetEdgeParameter on subsequent calls.
  Returns:
    @untitled table
    true        successful
    false       failure - trim_t not set
  See Also:
    TL_Brep::GetEdgeParameter
  */
  virtual
    bool GetTrimParameter(
                          int trim_index,
                          double edge_t,
                          double* trim_t,
          bool bOkToBuildTrimPline=true
                          ) const;

  /*
  Description:
    Given a trim and parameter on the 2d trim curve,
    get the corresponding parameter on the 3d edge curve.
  Parameters:
    trim_index - [in] index of trim in m_T array
    trim_t - [in] parameter on 2d trim curve
    edge_t - [out] parameter on 3d edge
  Returns:
    @untitled table
    true        successful
    false       failure - edge_t not set
  See Also:
    TL_Brep::GetTrimParameter
  */
  virtual
    bool GetEdgeParameter(
                          int trim_index,
                          double trim_t,
          double* edge_t
                          ) const;

  /*
  Description:
    Expert user function.
    Splits an edge into two edges.  The input edge
    becomes the left portion and a new edge is created
    for the right portion.
  Parameters:
    edge_index - [in] index of edge in brep.m_E[]
    edge_t - [in] 3d edge splitting parameter
    trim_t - [in] array of trim splitting parameters.
             trim_t[eti] is the parameter for splitting the
             trim brep.m_T[edge.m_ti[eti]].
    vertex_index - [in] if not -1, then this vertex will be
             used for the new vertex.  Otherwise a new
             vertex is created.
    bSetTrimBoxesAndFlags - [in] if true, trim boxes and flags
             are set.  If false, the user is responsible for
             doing this.  Set to true if you are unsure
             what to use.  If you pass false, then need to
             call SetTrimBoundingBoxes(..,bLazy=true)
             so that the trim iso flags and bounding info
             is correctly updated.  If you pass true, then
             the trim flags and bounding boxes get set
             inside of SplitEdge.
  Returns:
    True if successful.
  */
  bool SplitEdge(
                 int edge_index,
                 double edge_t,
                 const ON_SimpleArray<double>& trim_t,
                 int vertex_index = -1,
        bool bSetTrimBoxesAndFlags = true
                 );

  // These remove a topology piece from a b-rep but do not
  // rearrange the arrays that hold the brep objects.  The
  // deleted objects have their indices set to -1.  Deleting
  // an object that is connected to other objects will 
  // modify thos objects.
  void DeleteVertex(ON_BrepVertex& vertex);
  void DeleteEdge(ON_BrepEdge& edge, ON_BOOL32 bDeleteEdgeVertices); // pass true to delete vertices used only by edge
  void DeleteTrim(ON_BrepTrim& trim, ON_BOOL32 bDeleteTrimEdges); // pass true to delete edges and vertices used only by trim
  void DeleteLoop(ON_BrepLoop& loop, ON_BOOL32 bDeleteLoopEdges); // pass true to delete edges and vertices used only by trim
  void DeleteFace(ON_BrepFace& face, ON_BOOL32 bDeleteFaceEdges); // pass true to delete edges and vertices used only by face
  void DeleteSurface(int s_index);
  void Delete2dCurve(int c2_index);
  void Delete3dCurve(int c3_index);

  // Description:
  //   Set m_vertex_user.i, m_edge_user.i, m_face_user.i, m_loop_user.i,
  //   and m_trim_user.i values of faces of component including 
  //   m_F[face_index] to label. Numbering starts at 1.
  // Parameters:
  //   face_index - [in] index of face in component
  //   label - [in] value for m_*_user.i
  // Returns:
  // Remarks:
  //   Chases through trim lists of face edges to find adjacent faces.
  //   Does NOT check for vertex-vertex connections
  void LabelConnectedComponent(
    int face_index,
    int label
    );

  /*
  Description:
    Set  m_vertex_user.i, m_edge_user.i, m_face_user.i, m_loop_user.i,
    and m_trim_user.i values values to distinguish connected components.
  Parameters:
  Returns:
    number of connected components
  Remarks:
    For each face in the ith component, sets m_face_user.i to i>0.
    Chases through trim lists of face edges to find adjacent faces.
	  Numbering starts at 1. Does NOT check for vertex-vertex connections.
  See Also:
    ON_Brep::GetConnectedComponents
  */
  int LabelConnectedComponents();

  /*
  Description:
    If this brep has two or more connected components, 
    then duplicates of the connected components are appended
    to the components[] array.
  Parameters:
    components - [in] connected components are appended to this array.
    bDuplicateMeshes - [in] if true, any meshes on this brep are copied
         to the output breps.
  Returns:
    Number of connected components appended to components[] or zero
    if this brep has only one connected component.
  See Also:
    ON_Brep::GetConnectedComponents
  */
  int GetConnectedComponents( 
          ON_SimpleArray< ON_Brep* >& components,
          bool bDuplicateMeshes
          ) const;

  /*
  Description:
    Copy a subset of this brep.
  Parameters:
    subfi_count - [in] length of sub_fi[] array.
    sub_fi - [in] array of face indices in this
      brep to copy. (If any values inf sub_fi[]
      are out of range or if sub_fi[] contains
      duplicates, this function will return null.)
    sub_brep - [in] if this pointer is not null,
      then the subbrep will be created in this
      class.
  Returns:
    If the input is valid, a pointer to the
    subbrep is returned.  If the input is not
    valid, null is returned.  The faces in
    in the subbrep's m_F array are in the same
    order as they were specified in sub_fi[].
  */
  ON_Brep* SubBrep( 
    int subfi_count, 
    const int* sub_fi, 
    ON_Brep* sub_brep = 0 
    ) const;

  ///////////////////////////////////////////////////////////////////////
  //
  // region topology
  //
  bool HasRegionTopology() const;

  /*
  Description:
    Get region topology information:
    In order to keep the ON_Brep class efficient, rarely used
    region topology information is not maintained.  If you 
    require this information, call RegionTopology().
  */
  const ON_BrepRegionTopology& RegionTopology() const;

  /*
  Description:
    Get region topology information:
    In order to keep the ON_Brep class efficient, rarely used
    region topology information is not maintained.  If you 
    require this information, call RegionTopology().
  */
  void DestroyRegionTopology();
  // Description:
  //   Duplicate a single brep face.
  // Parameters:
  //   face_index - [in] index of face to duplicate
  //   bDuplicateMeshes - [in] if true, any attached meshes are duplicated
  // Returns:
  //   Single face brep.
  // Remarks:
  //   The m_vertex_user.i, m_edge_user.i, m_face_user.i, m_loop_user.i,
  //   and m_trim_user.i values of the returned brep are are set to the 
  //   indices of the objects they duplicate.
  // See Also:
  //   ON_Brep::DeleteFace, ON_Brep::ExtractFace
  ON_Brep* DuplicateFace(
    int face_index,
    ON_BOOL32 bDuplicateMeshes
    ) const;

  // Description:
  //   Duplicate a a subset of a brep
  // Parameters:
  //   face_count - [in] length of face_index[] array
  //   face_index - [in] array of face indices
  //   bDuplicateMeshes - [in] if true, any attached meshes are duplicated
  // Returns:
  //   A brep made by duplicating the faces listed in the face_index[] array.
  // Remarks:
  //   The m_vertex_user.i, m_edge_user.i, m_face_user.i, m_loop_user.i,
  //   and m_trim_user.i values of the returned brep are are set to the 
  //   indices of the objects they duplicate.
  // See Also:
  //   ON_Brep::DuplicateFace
  ON_Brep* DuplicateFaces(
    int face_count,
    const int* face_index,
    ON_BOOL32 bDuplicateMeshes
    ) const;

  // Description:
  //   Extract a face from a brep.
  // Parameters:
  //   face_index - [in] index of face to extract
  // Returns:
  //   Single face brep.
  // See Also:
  //   ON_Brep::DeleteFace, ON_Brep::DuplicateFace
  ON_Brep* ExtractFace(
    int face_index
    );


  /*
  Description:
    Standardizes the relationship between an ON_BrepEdge
    and the 3d curve it uses.  When done, the edge will
    be the only edge that references its 3d curve, the 
    domains of the edge and 3d curve will be the same, 
    and the edge will use the entire locus of the 3d curve.
  Parameters:
    edge_index - [in] index of edge to standardize.
    bAdjustEnds - [in] if true, move edge curve endpoints to vertices
  See Also:
    ON_Brep::StandardizeEdgeCurves
    ON_Brep::Standardize
  */
  bool StandardizeEdgeCurve( int edge_index, bool bAdjustEnds );


  /*
  Description:
    Expert user only.  Same as above, but to be used when the edge
    curve use count is known for the edge.
    Standardizes the relationship between an ON_BrepEdge
    and the 3d curve it uses.  When done, the edge will
    be the only edge that references its 3d curve, the 
    domains of the edge and 3d curve will be the same, 
    and the edge will use the entire locus of the 3d curve.
  Parameters:
    edge_index - [in] index of edge to standardize.
    bAdjustEnds - [in] if true, move edge curve endpoints to vertices
    EdgeCurveUse - [in] if > 1, then the edge curve for this edge is used by more than one
        edge.  if 1, then the edge curve is used only for this edge. 
        If <= 0, then use count is unknown.
  See Also:
    ON_Brep::StandardizeEdgeCurves
    ON_Brep::Standardize
  */
  bool StandardizeEdgeCurve( int edge_index, bool bAdjustEnds, int EdgeCurveUse );


  /*
  Description:
    Standardize all edges in the brep.
  Parameters:
    bAdjustEnds - [in] if true, move edge curve endpoints to vertices
  See Also:
    ON_Brep::StandardizeEdgeCurve
    ON_Brep::Standardize
  */
  void StandardizeEdgeCurves( bool bAdjustEnds );

  /*
  Description:
    Standardizes the relationship between an ON_BrepTrim
    and the 2d curve it uses.  When done, the trim will
    be the only trim that references its 2d curve, the 
    domains of the trim and 2d curve will be the same, 
    and the trim will use the entire locus of the 2d curve.
  Parameters:
    trim_index - [in] index of trim to standardize.
  See Also:
    ON_Brep::StandardizeTrimCurves
    ON_Brep::Standardize
  */
  bool StandardizeTrimCurve( int trim_index );

  /*
  Description:
    Standardize all trims in the brep.
  See Also:
    ON_Brep::StandardizeTrimCurve
    ON_Brep::Standardize
  */
  void StandardizeTrimCurves();

  /*
  Description:
    Standardizes the relationship between an ON_BrepFace
    and the 3d surface it uses.  When done, the face will
    be the only face that references its 3d surface, and
    the orientations of the face and 3d surface will be 
    the same. 
  Parameters:
    face_index - [in] index of face to standardize.
  See Also:
    ON_Brep::StardardizeFaceSurfaces
    ON_Brep::Standardize
  */
  bool StandardizeFaceSurface( int face_index );

  /*
  Description:
    Standardize all faces in the brep.
  See Also:
    ON_Brep::StandardizeFaceSurface
    ON_Brep::Standardize
  */
  void StandardizeFaceSurfaces();

  // misspelled function name is obsolete
  ON_DEPRECATED void StardardizeFaceSurfaces();

  /*
  Description:
    Standardize all trims, edges, and faces in the brep.
  Remarks:
    After standardizing, there may be unused curves and surfaces
    in the brep.  Call ON_Brep::Compact to remove these unused
    curves and surfaces.
  See Also:
    ON_Brep::StandardizeTrimCurves
    ON_Brep::StandardizeEdgeCurves
    ON_Brep::StandardizeFaceSurface
    ON_Brep::Compact
  */
  void Standardize();
  

  /*
  Description:
    Sometimes the ON_Surface used by a face extends far
    beyond the face's outer boundary.  ShrinkSurface uses
    ON_Surface::Trim to remove portions of the surface that
    extend beyond the face's outer boundary loop.
  Parameters:
    face - [in] face to test and whose surface should be shrunk.
    DisableSide - [in] This is a bit field.  A set bit indicates not to shrink
                the surface on a given side.  The default of 0 enables shrinking 
                on all four sides.
      @table  
      value       meaning
      0x0001     Dont shrink on the west side of domain.
      0x0002     Dont shrink on the south side of domain.
      0x0004     Dont shrink on the east side of domain.
      0x0008     Dont shrink on the north side of domain.
  Returns:
    @untitled table
    true        successful
    false       failure
  Remarks:
    If a surface needs to be shrunk it is copied.  After shrinking,
    you may want to call ON_Brep::CullUnusedSurfaces to remove
    any unused surfaces.
  See Also:
    ON_Brep::ShrinkSurfaces
    ON_Brep::CullUnusedSurfaces
  */
  bool ShrinkSurface( ON_BrepFace& face, int DisableSide=0 );

  /*
  Description:
    Sometimes the ON_Surface used by a face extends far
    beyond the face's outer boundary.  ShrinkSurfaces calls
    ON_Shrink::ShrinkSurface on each face to remove portions
    of surfaces that extend beyond their face's outer boundary
    loop.
  Returns:
    @untitled table
    true        successful
    false       failure
  Remarks:
    If a surface needs to be shrunk it is copied.  After shrinking,
    you may want to call ON_Brep::CullUnusedSurfaces to remove
    any unused surfaces.
  See Also:
    ON_Brep::ShrinkSurface
    ON_Brep::CullUnusedSurfaces
  */
  bool ShrinkSurfaces();

  /*
  Description:
    Uses the CullUnused*() members to delete any unreferenced
    objects from arrays, reindexes as needed, and shrinks
    arrays to minimum required size.
  See Also:
    ON_Brep::CullUnusedFaces
    ON_Brep::CullUnusedLoops
    ON_Brep::CullUnusedTrims
    ON_Brep::CullUnusedEdges
    ON_Brep::CullUnusedVertices
    ON_Brep::CullUnused3dCurves
    ON_Brep::CullUnused2dCurves
    ON_Brep::CullUnusedSurfaces
  */
  bool Compact();

  bool CullUnusedFaces(); // culls faces with m_face_index == -1
  bool CullUnusedLoops(); // culls loops with m_loop_index == -1
  bool CullUnusedTrims(); // culls trims with m_trim_index == -1
  bool CullUnusedEdges(); // culls edges with m_edge_index == -1
  bool CullUnusedVertices(); // culls vertices with m_vertex_index == -1
  bool CullUnused3dCurves(); // culls 2d curves not referenced by a trim
  bool CullUnused2dCurves(); // culls 3d curves not referenced by an edge
  bool CullUnusedSurfaces(); // culls surfaces not referenced by a face

  /////////////////////////////////////////////////////////////////
  // Navigation Interface

  // for moving around loops - returns trim index of prev/next trim in loop
  int PrevTrim(
        int // index of current trim (m_trim_index)
        ) const;
  int NextTrim(
        int // index of current trim (m_trim_index)
        ) const;

  /*
  Description:
    This is a simple tool for getting running through the edges
    that begin and end at a vertex.
  Parameters:
    current_edge_index - [in]
    endi - [in] 0 = use the edge start vertex, 1 = use the edge end vertex
    prev_endi - [out] 0 if previous edge begins at the vertex, 
                      1 if previous edge ends at the vertex
  Returns:
    edge index of the previous edge or -1 if there is only one edge
    that begins or ends at the vertex.
  Remarks:
    This is a tool that simplifies searching through the
    ON_BrepVertex.m_ei[] array.
    The edges are in no particular order.
  See Also:
    ON_Brep::NextEdge
  */
  int PrevEdge(
        int current_edge_index,
        int endi,
        int* prev_endi = NULL
        ) const;

  /*
  Description:
    This is a simple tool for getting running through the edges
    that begin and end at a vertex.
  Parameters:
    current_edge_index - [in]
    endi - [in] 0 = use the edge start vertex, 1 = use the edge end vertex
    next_endi - [out] 0 if next edge begins at the vertex, 
                      1 if next edge ends at the vertex
  Returns:
    edge index of the next edge or -1 if there is only one edge
    that begins or ends at the vertex.
  Remarks:
    This is a tool that simplifies searching through the
    ON_BrepVertex.m_ei[] array.  
    The edges are in no particular order.
  See Also:
    ON_Brep::NextEdge
  */
  int NextEdge(
        int current_edge_index,
        int endi,
        int* next_endi = NULL
        ) const;

  /*
  Description:
    Get a brep component from its index.
  Parameters:
    component_index - [in] 
  Returns:
    A const pointer to the component.  Do not delete
    the returned object.  It points to an object managed
    by this brep.
  See Also:
    ON_Brep::Face
    ON_Brep::Edge
    ON_Brep::Loop
    ON_Brep::Trim
    ON_Brep::Vertex
  */
  const ON_Geometry* BrepComponent( 
    ON_COMPONENT_INDEX ci
    ) const;

  /*
  Description:
    Get vertex from trim index or component index.
  Parameters:
    vertex_index - [in] either an index into m_V[] or a component index
                      of type brep_vertex.
  Returns:
    If the index is a valid vertex index or a valid vertex component
    index, then a pointer to the ON_BrepVertex is returned.  Otherwise
    NULL is returned.
  See Also
    ON_Brep::Component( const ON_BrepVertex& )
  */
  ON_BrepVertex* Vertex( int vertex_index ) const;
  ON_BrepVertex* Vertex( ON_COMPONENT_INDEX vertex_index ) const;

  /*
  Description:
    Get edge from edge index or component index.
  Parameters:
    edge_index - [in] either an index into m_E[] or a component index
                      of type brep_edge.
  Returns:
    If the index is a valid edge index or a valid edge component
    index, then a pointer to the ON_BrepEdge is returned.  Otherwise
    NULL is returned.
  See Also
    ON_Brep::Component( const ON_BrepEdge& )
  */
  ON_BrepEdge* Edge( int edge_index ) const;
  ON_BrepEdge* Edge( ON_COMPONENT_INDEX edge_index ) const;

  /*
  Description:
    Get trim from trim index or component index.
  Parameters:
    trim_index - [in] either an index into m_T[] or a component index
                      of type brep_trim.
  Returns:
    If the index is a valid trim index or a valid trim component
    index, then a pointer to the ON_BrepTrim is returned.  Otherwise
    NULL is returned.
  See Also
    ON_Brep::Component( const ON_BrepTrim& )
  */
  ON_BrepTrim* Trim( int trim_index ) const;
  ON_BrepTrim* Trim( ON_COMPONENT_INDEX trim_index ) const;

  /*
  Description:
    Get loop from loop index or component index.
  Parameters:
    loop_index - [in] either an index into m_L[] or a component index
                      of type brep_loop.
  Returns:
    If the index is a valid loop index or a valid loop component
    index, then a pointer to the ON_BrepLoop is returned.  Otherwise
    NULL is returned.
  See Also
    ON_Brep::Component( const ON_BrepLoop& )
  */
  ON_BrepLoop* Loop( int loop_index ) const;
  ON_BrepLoop* Loop( ON_COMPONENT_INDEX loop_index ) const;

  /*
  Description:
    Get face from face index or component index.
  Parameters:
    face_index - [in] either an index into m_F[] or a component index
                      of type brep_face.
  Returns:
    If the index is a valid face index or a valid face component
    index, then a pointer to the ON_BrepFace is returned.  Otherwise
    NULL is returned.
  See Also
    ON_Brep::Component( const ON_BrepFace& )
  */
  ON_BrepFace* Face( int face_index ) const;
  ON_BrepFace* Face( ON_COMPONENT_INDEX face_index ) const;

  /*
  Description:
    remove slit trims and slit boundaries from each face.
  Returns:
    true if any slits were removed
  Remarks:
    Caller should call Compact() afterwards.
  */
  bool RemoveSlits();

  /*
  Description:
    remove slit trims and slit boundaries from a face.
  Parameters:
    F - [in] brep face
  Returns:
    true if any slits were removed
  Remarks:
    Caller should call Compact() when done.
  */
  bool RemoveSlits(ON_BrepFace& F);


  /*
  Description:
    Removes nested polycurves from the m_C2[] and m_C3[] arrays.
  Parameters:
    bExtractSingleSegments - [in] if true, polycurves with a
      single segment are replaced with the segment curve.
    bEdges - [in] if true, the m_C3[] array is processed
    bTrimCurves - [in] if true, the m_C2[] array is processed.  
  Returns:
    True if any nesting was removed and false if no nesting
    was removed.
  */
  bool RemoveNesting(
          bool bExtractSingleSegments,
          bool bEdges = true, 
          bool bTrimCurves = true
          );

  /*
  Description:
    Expert user tool to collapse a "short" edge to a vertex.
    The edge is removed and the topology is repaired
    so that everything that used to connect to the edge
    connects the specified vertex.
  Parameters:
    edge_index - [in] index of edge to remove
    bCloseTrimGap - [in] if true and the removal of the
       edge creates a gap in the parameter space trimming
       loop, then the 2d trim curves will be adjusted to
       close the gap.
    vertex_index - [in] if >= 0, this the edge is collapsed
       to this vertex.  Otherwise a vertex is automatically
       selected or created.
  Returns:
    True if edge was successfully collapsed.
  Remarks:
    After you finish cleaning up the brep, you need
    to call ON_Brep::Compact() to remove unused edge,
    trim, and vertex information from the brep's m_E[], 
    m_V[], m_T[], m_C2[], and m_C3[] arrays.
  */
  bool CollapseEdge(
    int edge_index,
    bool bCloseTrimGap = true,
    int vertex_index = -1
    );

  /*
  Description:
    Expert user tool to move trims and edges from
    one vertex to another.
  Parameters:
    old_vi - [in] index of old vertex
    new_vi - [in] index of new vertex
    bClearTolerances - [in] if true, then tolerances of
       edges and trims that are connected ot the old
       vertex are set to ON_UNSET_VALUE.
    vertex_index - [in] if >= 0, this the edge is collapsed
       to this vertex.  Otherwise a vertex is automatically
       selected or created.
  Returns:
    True if successful.
  Remarks:
    After you finish cleaning up the brep, you need
    to call ON_Brep::Compact() to remove unused edge,
    trim, and vertex information from the brep's m_E[], 
    m_V[], m_T[], m_C2[], and m_C3[] arrays.
  */
  bool ChangeVertex( 
    int old_vi, 
    int new_vi, 
    bool bClearTolerances 
    );

  /*
  Description:
    Expert user tool to remove any gap between adjacent trims.
  Parameters:
    trim0 - [in]
    trim1 - [in]
  Returns:
    True if successful.
  Remarks:
    The trims must be in the same trimming loop.  The vertex
    at the end of trim0 must be the same as the vertex at
    the start of trim1.  The trim's m_iso and m_type flags
    need to be correctly set.
  */
  bool CloseTrimGap( 
    ON_BrepTrim& trim0, 
    ON_BrepTrim& trim1 
    );

  /*
  Description:
    Remove edges that are not connected to a face.
  Parameters:
    bDeleteVertices - [in] if true, then the vertices
      at the ends of the wire edges are deleted if 
      they are not connected to face trimming edges.
  Returns:
    Number of edges that were removed.
  Remarks:
    After you finish cleaning up the brep, you need
    to call ON_Brep::Compact() to remove unused edge,
    trim, and vertex information from the brep's m_E[], 
    m_V[], m_T[], m_C2[], and m_C3[] arrays.

    If you want to remove wire edges and wiere
    After you finish cleaning up the brep, you need
    to call ON_Brep::Compact() to remove deleted vertices
    from the m_V[] array.
  See Also:
    ON_Brep::RemoveWireVertices
  */
  int RemoveWireEdges( bool bDeleteVertices = true );

  /*
  Description:
    Remove vertices that are not connected to an edge.
  Returns:
    Number of vertices that were deleted.
  Remarks:
    After you finish cleaning up the brep, you need
    to call ON_Brep::Compact() to remove deleted 
    vertices from the m_V[] array.
  See Also:
    ON_Brep::RemoveWireEdges
  */
  int RemoveWireVertices();

  /////////////////////////////////////////////////////////////////
  // "Expert" Interface

  void Set_user(ON_U u); // set every brep m_*_user value to u
  void Clear_vertex_user_i(); // zero all brep's m_vertex_user values
  void Clear_edge_user_i(int);   // zero all brep's m_edge_user values
  void Clear_edge_user_i();   // zero all brep's m_edge_user values
  void Clear_trim_user_i();   // zero all brep's m_trim_user values
  void Clear_loop_user_i();   // zero all brep's m_loop_user values
  void Clear_face_user_i();   // zero all brep's m_face_user values
  void Clear_user_i();        // zero all brep's m_*_user values

  // Union available for application use.
  // The constructor zeros m_brep_user.
  // The value is of m_brep_user is not saved in 3DM
  // archives and may be changed by some computations.
  ON_U m_brep_user; 

  // geometry 
  // (all geometry is deleted by ~ON_Brep().  Pointers can be NULL
  // or not referenced.  Use Compact() to remove unreferenced geometry.
  ON_CurveArray   m_C2;  // Pointers to parameter space trimming curves
                         // (used by trims).
  ON_CurveArray   m_C3;  // Pointers to 3d curves (used by edges).
  ON_SurfaceArray m_S;   // Pointers to parametric surfaces (used by faces)

  // topology
  // (all topology is deleted by ~ON_Brep().  Objects can be unreferenced.
  // Use Compact() to to remove unreferenced geometry.
  ON_BrepVertexArray  m_V;   // vertices
  ON_BrepEdgeArray    m_E;   // edges
  ON_BrepTrimArray    m_T;   // trims
  ON_BrepLoopArray    m_L;   // loops
  ON_BrepFaceArray    m_F;   // faces

protected:	
  friend class ON_BrepFace;
  friend class ON_BrepRegion;
  friend class ON_BrepFaceSide;
  ON_BoundingBox m_bbox;

  // Never directly set m_is_solid, use calls to IsSolid() and/or 
  // SolidOrientation() when you need to know the answer to this
  // question.
  // 0 = unset
  // 1 = solid with normals pointing out
  // 2 = solid with normals pointing in
  // 3 = not solid
  int m_is_solid;

  // These are friends so legacy tol values stored in v1 3dm files
  // can be used to set brep edge and trimming tolerances with a call
  // to ON_Brep::SetTolsFromLegacyValues().
  friend bool ON_BinaryArchive::ReadV1_TCODE_LEGACY_FAC(ON_Object**,ON_3dmObjectAttributes*);
  friend bool ON_BinaryArchive::ReadV1_TCODE_LEGACY_SHL(ON_Object**,ON_3dmObjectAttributes*);
  void Initialize();

  // helpers to set ON_BrepTrim::m_iso flag
  void SetTrimIsoFlag(int,double[6]);
  void SetTrimIsoFlag(int);

  // helpers to create and set vertices
  bool SetEdgeVertex(const int, const int, const int );
  bool HopAcrossEdge( int&, int& ) const;
  bool SetTrimStartVertex( const int, const int);
  void SetLoopVertices(const int);
  void ClearTrimVertices();
  void ClearEdgeVertices();

  // helpers for SwapFaceParameters()
  bool SwapLoopParameters(
        int // index of loop
        );
  bool SwapTrimParameters(
        int // index of trim
        );

  // helpers for validation checking
  bool IsValidTrim(int trim_index,ON_TextLog* text_log) const;
  bool IsValidTrimTopology(int trim_index,ON_TextLog* text_log) const;
  bool IsValidTrimGeometry(int trim_index,ON_TextLog* text_log) const;
  bool IsValidTrimTolerancesAndFlags(int trim_index,ON_TextLog* text_log) const;

  bool IsValidLoop(int loop_index,ON_TextLog* text_log) const;
  bool IsValidLoopTopology(int loop_index,ON_TextLog* text_log) const;
  bool IsValidLoopGeometry(int loop_index,ON_TextLog* text_log) const;
  bool IsValidLoopTolerancesAndFlags(int loop_index,ON_TextLog* text_log) const;

  bool IsValidFace(int face_index,ON_TextLog* text_log) const;
  bool IsValidFaceTopology(int face_index,ON_TextLog* text_log) const;
  bool IsValidFaceGeometry(int face_index,ON_TextLog* text_log) const;
  bool IsValidFaceTolerancesAndFlags(int face_index,ON_TextLog* text_log) const;
  
  bool IsValidEdge(int edge_index,ON_TextLog* text_log) const;
  bool IsValidEdgeTopology(int edge_index,ON_TextLog* text_log) const;
  bool IsValidEdgeGeometry(int edge_index,ON_TextLog* text_log) const;
  bool IsValidEdgeTolerancesAndFlags(int edge_index,ON_TextLog* text_log) const;

  bool IsValidVertex(int vertex_index,ON_TextLog* text_log) const;
  bool IsValidVertexTopology(int vertex_index,ON_TextLog* text_log) const;
  bool IsValidVertexGeometry(int vertex_index,ON_TextLog* text_log) const;
  bool IsValidVertexTolerancesAndFlags(int vertex_index,ON_TextLog* text_log) const;

  void SetTolsFromLegacyValues();

  // read helpers to support various versions
  bool ReadOld100( ON_BinaryArchive& ); // reads legacy old RhinoIO toolkit b-rep
  bool ReadOld101( ON_BinaryArchive& ); // reads legacy Rhino 1.1 b-rep
  bool ReadOld200( ON_BinaryArchive&, int ); // reads legacy trimmed surface
  ON_Curve* Read100_BrepCurve( ON_BinaryArchive& ) const;
  ON_Surface* Read100_BrepSurface( ON_BinaryArchive& ) const;

  // helpers for reading legacy v1 trimmed surfaces and breps
  bool ReadV1_LegacyTrimStuff( ON_BinaryArchive&, ON_BrepFace&, ON_BrepLoop& );
  bool ReadV1_LegacyTrim( ON_BinaryArchive&, ON_BrepFace&, ON_BrepLoop& );
  bool ReadV1_LegacyLoopStuff( ON_BinaryArchive&, ON_BrepFace& );
  bool ReadV1_LegacyLoop( ON_BinaryArchive&, ON_BrepFace& );
  bool ReadV1_LegacyFaceStuff( ON_BinaryArchive& );
  bool ReadV1_LegacyShellStuff( ON_BinaryArchive& );
};

///////////////////////////////////////////////////////////////////////////////
//
// brep construction tools
// 

/*
Description:
  Create a brep representation of a mesh.
Parameters:
  mesh_topology - [in]
  bTrimmedTriangles - [in] if true, triangles in the mesh
     will be represented by trimmed planes in the brep.
     If false, triangles in the mesh will be represented by
     untrimmed singular bilinear NURBS surfaces in the brep.
  pBrep - [in] If not NULL, this the mesh representation will
     be put into this brep.
Example:

          ON_Mesh mesh = ...;
          ON_Brep* pBrep = ON_BrepFromMesh( mesh.Topology() );
          ...
          delete pBrep;

See Also
  ON_BrepFromMesh( const ON_Mesh& mesh, ... );
*/
ON_DECL
ON_Brep* ON_BrepFromMesh( 
          const ON_MeshTopology& mesh_topology, 
          ON_BOOL32 bTrimmedTriangles = true,
          ON_Brep* pBrep = NULL 
          );

/*
Description:
  Get an ON_Brep definition of a box.
Parameters:
  box_corners - [in] 8 points defining the box corners
     arranged as the vN lables indicate.

          v7_______e6_____v6
           |\             |\
           | e7           | e5
           |  \ ______e4_____\ 
          e11  v4         |   v5
           |   |        e10   |
           |   |          |   |
          v3---|---e2----v2   e9
           \   e8         \   |
            e3 |           e1 |
             \ |            \ |
              \v0_____e0_____\v1

  pBrep - [in] if not NULL, this brep will be used and
               returned.
Returns:
  An ON_Brep representation of the box with topology

   edge              vertices
    m_E[ 0]           m_V[0], m_V[1]
    m_E[ 1]           m_V[1], m_V[2]
    m_E[ 2]           m_V[2], m_V[3]
    m_E[ 3]           m_V[3], m_V[0]
    m_E[ 4]           m_V[4], m_V[5]
    m_E[ 5]           m_V[5], m_V[6]
    m_E[ 6]           m_V[6], m_V[7]
    m_E[ 7]           m_V[7], m_V[4]
    m_E[ 8]           m_V[0], m_V[4]
    m_E[ 9]           m_V[1], m_V[5]
    m_E[10]           m_V[2], m_V[6]
    m_E[11]           m_V[3], m_V[7]

   face              boundary edges
    m_F[0]            +m_E[0] +m_E[9]  -m_E[4] -m_E[8]
    m_F[1]            +m_E[1] +m_E[10] -m_E[5] -m_E[9]
    m_F[2]            +m_E[2] +m_E[11] -m_E[6] -m_E[10]
    m_F[3]            +m_E[3] +m_E[8]  -m_E[7] -m_E[11]
    m_F[4]            -m_E[3] -m_E[2]  -m_E[1] -m_E[0]
//     m_F[5]            +m_E[4] +m_E[5]  +m_E[6] +m_E[7]
*/
ON_DECL
ON_Brep* ON_BrepBox( const ON_3dPoint* box_corners, ON_Brep* pBrep = NULL );

/*
Description:
  Get an ON_Brep definition of a wedge.
Parameters:
  corners - [in] 6 points defining the box corners
     arranged as the vN lables indicate.

                     /v5    
                    /|\       
                   / | \     
                  e5 |  e4   
                 /   e8  \     
                /__e3_____\  
              v3|    |    |v4     
                |    |    |       
                |    /v2  |   
                e6  / \   e7   
                |  /   \  |   
                | e2    e1|   
                |/       \|     
                /____e0___\  
              v0           v1

  pBrep - [in] if not NULL, this brep will be used and
               returned.
Returns:
  An ON_Brep representation of the wedge with topology

  edge              vertices
    m_E[ 0]           m_V[0], m_V[1]
    m_E[ 1]           m_V[1], m_V[2]
    m_E[ 2]           m_V[2], m_V[0]
    m_E[ 3]           m_V[3], m_V[4]
    m_E[ 4]           m_V[4], m_V[5]
    m_E[ 5]           m_V[5], m_V[0]
    m_E[ 6]           m_V[0], m_V[3]
    m_E[ 7]           m_V[1], m_V[4]
    m_E[ 8]           m_V[2], m_V[5]

  face              boundary edges
    m_F[0]            +m_E[0] +m_E[7]  -m_E[3] -m_E[6]
    m_F[1]            +m_E[1] +m_E[8]  -m_E[4] -m_E[7]
    m_F[2]            +m_E[2] +m_E[6]  -m_E[5] -m_E[8]
    m_F[3]            +m_E[3] +m_E[8]  -m_E[7] -m_E[11]
    m_F[4]            -m_E[2]  -m_E[1] -m_E[0]
    m_F[5]            +m_E[3] +m_E[4]  +m_E[5]
*/
ON_DECL
ON_Brep* ON_BrepWedge( const ON_3dPoint* corners, ON_Brep* pBrep = NULL );

/*
Description:
  Get an ON_Brep definition of a sphere.
Parameters:
  sphere - [in]
  pBrep - [in] if not NULL, this brep will be used and
               returned.
Returns:
  An ON_Brep representation of the sphere with a single face,
  a single edge along the seam, and vertices at the north
  and south poles.
*/
ON_DECL
ON_Brep* ON_BrepSphere( const ON_Sphere& sphere, ON_Brep* pBrep = NULL );

/*
Description:
  Get an ON_Brep definition of a torus.
Parameters:
  torus - [in]
  pBrep - [in] if not NULL, this brep will be used and
               returned.
Returns:
  An ON_Brep representation of the torus with a single face
  a two edges along the seams.
*/
ON_DECL
ON_Brep* ON_BrepTorus( const ON_Torus& torus, ON_Brep* pBrep = NULL );

/*
Description:
  Get an ON_Brep definition of a cylinder.
Parameters:
  cylinder - [in] cylinder.IsFinite() must be true
  bCapBottom - [in] if true end at cylinder.m_height[0] should be capped
  bCapTop - [in] if true end at cylinder.m_height[1] should be capped
  pBrep - [in] if not NULL, this brep will be used and
               returned.
Returns:
  An ON_Brep representation of the cylinder with a single
  face for the cylinder, an edge along the cylinder seam, 
  and vertices at the bottom and top ends of this seam edge.
  The optional bottom/top caps are single faces with one
  circular edge starting and ending at the bottom/top vertex.
*/
ON_DECL
ON_Brep* ON_BrepCylinder( const ON_Cylinder& cylinder, 
                          ON_BOOL32 bCapBottom,
                          ON_BOOL32 bCapTop,
                          ON_Brep* pBrep = NULL );

/*
Description:
  Get an ON_Brep definition of a cone.
Parameters:
  cylinder - [in] cylinder.IsFinite() must be true
  bCapBase - [in] if true the base of the cone should be capped.
  pBrep - [in] if not NULL, this brep will be used and
               returned.
Returns:
  An ON_Brep representation of the cone with a single
  face for the cone, an edge along the cone seam, 
  and vertices at the base and apex ends of this seam edge.
  The optional cap is asingle face with one circular edge 
  starting and ending at the base vertex.
*/
ON_DECL
ON_Brep* ON_BrepCone( 
          const ON_Cone& cone, 
          ON_BOOL32 bCapBottom,
          ON_Brep* pBrep = NULL 
          );

/*
Description:
  Get an ON_Brep form of a surface of revolution.
Parameters:
  pRevSurface - [in] pointer to a surface of revolution.
     The brep will manage this pointer and delete it in ~ON_Brep.
  bCapStart - [in] if true, the start of the revolute is
     not on the axis of revolution, and the surface of revolution
     is closed, then a circular cap will be added to close
     of the hole at the start of the revolute.
  bCapEnd - [in] if true, the end of the revolute is
     not on the axis of revolution, and the surface of revolution
     is closed, then a circular cap will be added to close
     of the hole at the end of the revolute.
  pBrep - [in] if not NULL, this brep will be used and
               returned.
Returns:
  @untitled table
  true     successful
  false    brep cannot be created from this surface.
Remarks:
  The surface class must be created with new because
  it will be destroyed with the delete operator
  in ~ON_Brep.
*/
ON_DECL
ON_Brep* ON_BrepRevSurface( 
          ON_RevSurface*& pRevSurface,
          ON_BOOL32 bCapStart,
          ON_BOOL32 bCapEnd,
          ON_Brep* pBrep = NULL 
          );


          
/*
Description:
  Create an ON_Brep trimmed plane.
Parameters:
  plane - [in] plane that will be trimmed.
  boundary - [in] a simple (no self intersections) closed
      curve that defines the outer boundary of the trimmed
      plane.  This curve is copied for use in the brep.
  pBrep - [in] if not NULL, this brep will be used and returned.
Returns:
  An ON_Brep representation of the trimmed plane with a single face.
See Also:
  ON_Brep::NewPlanarFaceLoop()
*/
ON_DECL
ON_Brep* ON_BrepTrimmedPlane( 
            const ON_Plane& plane, 
            const ON_Curve& boundary,
            ON_Brep* pBrep = NULL );

/*
Description:
  Get an ON_Brep definition of a trimmed plane.
Parameters:
  plane - [in] plane that will be trimmed.
  boundary - [in] a list of 3d curves that form a simple 
      (no self intersections) closed curve that defines the
      outer boundary of the trimmed plane.
  bDuplicateCurves - [in] if true, duplicates of the
       curves in the boundary array are used in the brep.  If false
       the curves in the boundary array are used in the brep
       and the brep's destructor will delete the curves.
  pBrep - [in] if not NULL, this brep will be used and
               returned.
Returns:
  An ON_Brep representation of the trimmed plane with a singe face.
See Also:
  ON_Brep::NewPlanarFaceLoop()
*/
ON_DECL
ON_Brep* ON_BrepTrimmedPlane( 
            const ON_Plane& plane, 
            ON_SimpleArray<ON_Curve*>& boundary,
            ON_BOOL32 bDuplicateCurves = true,
            ON_Brep* pBrep = NULL );


/*
Description:
  Extrude a brep
Parameters:
  brep - [in/out]
  path_curve - [in] path to extrude along.
  bCap - [in] if true, the extusion is capped with a translation
              of the input brep.
Returns:
  True if successful.
See Also:
  ON_BrepExtrudeFace
  ON_BrepExtrudeLoop
  ON_BrepExtrudeEdge
  ON_BrepExtrudeVertex
  ON_BrepConeFace
  ON_BrepConeLoop
  ON_BrepConeEdge
Remarks:
  The new faces are appended to brep.m_F[]. It is the caller's
  responsibility to insure the result does not self intersect.
*/
ON_DECL
bool ON_BrepExtrude( 
          ON_Brep& brep,
          const ON_Curve& path_curve,
          bool bCap = true
          );

/*
Description:
  Extrude a face in a brep.
Parameters:
  brep - [in/out]
  face_index - [in] index of face to extrude.
  path_curve - [in] path to extrude along.
  bCap - [in] if true, the extusion is capped with a translation
              of the face being extruded.
Example:
  Extrude a face along a vector.

          ON_Brep brep = ...;
          int face_index = ...;
          ON_3dVector v = ...;
          ON_LineCurve line_curve( ON_Line( ON_origin, vector ) );
          ON_BrepExtrudeFace( brep, face_index, line_curve, true );

Returns:
  @untitled table
  0    failure
  1    successful - no cap added
  2    successful - cap added as last face
See Also:
  ON_BrepExtrude
  ON_BrepExtrudeLoop
  ON_BrepExtrudeEdge
  ON_BrepExtrudeVertex
  ON_BrepConeFace
  ON_BrepConeLoop
  ON_BrepConeEdge
Remarks:
  The new faces are appended to brep.m_F[].  If a cap is requested
  it is the last face in the returned brep.m_F[]
*/
ON_DECL
int ON_BrepExtrudeFace( 
          ON_Brep& brep,
          int face_index,
          const ON_Curve& path_curve,
          bool bCap = true
          );

/*
Description:
  Extrude a loop in a brep.
Parameters:
  brep - [in/out]
  loop_index - [in] index of face to extrude.
  path_curve - [in] path to extrude along.
  bCap - [in] if true and the loop is closed, the extusion
              is capped.
Returns:
  @untitled table
  0    failure
  1    successful - no cap added
  2    successful - cap added as last face
See Also:
  ON_BrepExtrude
  ON_BrepExtrudeFace
  ON_BrepExtrudeEdge
  ON_BrepExtrudeVertex
  ON_BrepConeFace
  ON_BrepConeLoop
  ON_BrepConeEdge
Remarks:
  The new faces are appended to brep.m_F[].  If a cap is requested
  it is the last face in the returned brep.m_F[]
*/
ON_DECL
int ON_BrepExtrudeLoop( 
          ON_Brep& brep,
          int loop_index,
          const ON_Curve& path_curve,
          bool bCap = true
          );

/*
Description:
  Extrude an edge in a brep.
Parameters:
  brep - [in/out]
  edge_index - [in] index of face to extrude.
  path_curve - [in] path to extrude along.
Returns:
  @untitled table
  0    failure
  1    successful
See Also:
  ON_BrepExtrude
  ON_BrepExtrudeFace
  ON_BrepExtrudeLoop
  ON_BrepExtrudeVertex
  ON_BrepConeFace
  ON_BrepConeLoop
  ON_BrepConeEdge
Remarks:
  The new face is appended to brep.m_F[].
*/
ON_DECL
int ON_BrepExtrudeEdge( 
          ON_Brep& brep,
          int edge_index,
          const ON_Curve& path_curve
          );


/*
Description:
  Extrude a vertex in a brep.
Parameters:
  brep - [in/out]
  vertex_index - [in] index of vertex to extrude.
  path_curve - [in] path to extrude along.
Returns:
  @untitled table
  0    failure
  1    successful
See Also:
  ON_BrepExtrude
  ON_BrepExtrudeFace
  ON_BrepExtrudeLoop
  ON_BrepExtrudeEdge
  ON_BrepConeFace
  ON_BrepConeLoop
  ON_BrepConeEdge
Remarks:
  The new vertex is appended to brep.m_V[] and
  the new edge is appended to brep.m_E[].
*/
ON_DECL
int ON_BrepExtrudeVertex( 
          ON_Brep& brep,
          int vertex_index,
          const ON_Curve& path_curve
          );


/*
Description:
  Cone a face in a brep.
Parameters:
  brep - [in/out]
  face_index - [in] index of face to extrude.
  apex_point - [in] apex of cone.
Returns:
  @untitled table
  0    failure
  1    successful
See Also:
  ON_BrepExtrudeFace
  ON_BrepExtrudeLoop
  ON_BrepExtrudeEdge
  ON_BrepExtrudeVertex
  ON_BrepConeFace
  ON_BrepConeLoop
  ON_BrepConeEdge
Remarks:
  The new faces are appended to brep.m_F[].
*/
ON_DECL
int ON_BrepConeFace( 
          ON_Brep& brep,
          int face_index,
          ON_3dPoint apex_point
          );

/*
Description:
  Cone a loop in a brep.
Parameters:
  brep - [in/out]
  loop_index - [in] index of face to extrude.
  apex_point - [in] apex of cone.
Returns:
  @untitled table
  0    failure
  1    successful
See Also:
  ON_BrepExtrudeFace
  ON_BrepExtrudeLoop
  ON_BrepExtrudeEdge
  ON_BrepExtrudeVertex
  ON_BrepConeFace
  ON_BrepConeLoop
  ON_BrepConeEdge
Remarks:
  The new faces are appended to brep.m_F[].
*/
ON_DECL
bool ON_BrepConeLoop( 
          ON_Brep& brep,
          int loop_index,
          ON_3dPoint apex_point
          );

/*
Description:
  Cone an edge in a brep.
Parameters:
  brep - [in/out]
  edge_index - [in] index of face to extrude.
  apex_point - [in] apex of cone.
Returns:
  @untitled table
  0    failure
  1    successful
See Also:
  ON_BrepExtrudeFace
  ON_BrepExtrudeLoop
  ON_BrepExtrudeEdge
  ON_BrepExtrudeVertex
  ON_BrepConeFace
  ON_BrepConeLoop
  ON_BrepConeEdge
Remarks:
  The new face is appended to brep.m_F[].
*/
ON_DECL
int ON_BrepConeEdge( 
          ON_Brep& brep,
          int edge_index,
          ON_3dPoint apex_point
          );

//These merge adjacent faces that have the same underlying surface.
ON_DECL
int ON_BrepMergeFaces(ON_Brep& B, int fid0, int fid1);

ON_DECL
bool ON_BrepMergeFaces(ON_Brep& B);

//This removes all slit trims  from F that are not joined to another face.
//Unlike ON_Brep::RemoveSlits(), this will remove slit pairs from a loop in cases 
//that will result in the creation of more loops. Caller is responsible for calling 
//ON_Brep::Compact() to get rid of deleted trims and loops.

ON_DECL
bool ON_BrepRemoveSlits(ON_BrepFace& F);

//Merges all possible edges
ON_DECL
void ON_BrepMergeAllEdges(ON_Brep& B);

/*
Description:
  Merges two breps into a single brep.  The
  result may be non-manifold or have multiple
  connected components.
Parameters:
  brep0 - [in]
  brep1 - [in]
  tolerance - [in]
Returns:
  Merged brep or NULL if calculation failed.
*/
ON_DECL
ON_Brep* ON_MergeBreps(
          const ON_Brep& brep0,
          const ON_Brep& brep1,
          double tolerance
          );

#endif
#if !defined(OPENNURBS_EXTRUSION_INC_)
#define OPENNURBS_EXTRUSION_INC_

/*
Description:
  Get the transformation that maps the ON_Extrusion 
  2d xy profile to 3d world space.
Parameters:
  P - [in] start or end of path
  T - [in] unit tanget to path
  U - [in] unit up vector perpendicular to T
  Normal - [in] optional unit vector with Normal->z > 0 that
     defines the unit normal to the miter plane.
  xform - [out]
    transformation that maps the profile curve to 3d world space
  scale2d - [out]
    If not NULL, this is the scale part of the transformation.
    If there is no mitering, then this is the identity.
  rot2d - [out]
    If not null, this is the part of the transformation
    that rotates the xy plane into its 3d world location.
Returns:
  true if successful.
*/
ON_DECL
bool ON_GetEndCapTransformation(
          ON_3dPoint P, 
          ON_3dVector T, 
          ON_3dVector U, 
          const ON_3dVector* Normal,
          ON_Xform& xform, // = rot3d*scale2d
          ON_Xform* scale2d,
          ON_Xform* rot2d
          );

class ON_CLASS ON_Extrusion : public ON_Surface
{
  ON_OBJECT_DECLARE(ON_Extrusion);
public:
  ON_Extrusion();
  ON_Extrusion(const ON_Extrusion& src);
  ~ON_Extrusion();

  ON_Extrusion& operator=(const ON_Extrusion&);

  ////////////////////////////////////////////////////////////
  //
  // overrides of virtual ON_Object functions
  // 
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;
  void Dump( ON_TextLog& ) const;
  unsigned int SizeOf() const;
  ON__UINT32 DataCRC( ON__UINT32 current_remainder ) const;
  ON_BOOL32 Write( ON_BinaryArchive& binary_archive) const;
  ON_BOOL32 Read( ON_BinaryArchive& binary_archive );
  ON::object_type ObjectType() const;

  ////////////////////////////////////////////////////////////
  //
  // overrides of virtual ON_Geometry functions
  // 
  int Dimension() const;
  ON_BOOL32 GetBBox(
        double* boxmin,
        double* boxmax,
        int bGrowBox = false
        ) const;
	bool GetTightBoundingBox( 
        ON_BoundingBox& tight_bbox, 
        int bGrowBox = false,
        const ON_Xform* xform = 0
        ) const;
  ON_BOOL32 Transform( 
        const ON_Xform& xform
        );

  /*
  Description:
    Build a brep form of the extrusion.  The outer profile is always 
    the first face in the brep.  If there are inner profiles, 
    additional brep faces are created for each profile.  If the
    outer profile is closed, then end caps are added as the last
    two faces in the brep.
  Parameters:
    brep - [in]
      If the brep pointer is not null, then the brep form is constructed
      in brep.  If the brep pointer is null, then an ON_Brep is allocated
      on the heap.
  Returns:
    If successful, a pointer to the brep form.  If unsuccessful, null.
  */
  ON_Brep* BrepForm(
        ON_Brep* brep = NULL 
        ) const;

  /*
  Description:
    Build a brep form of the extrusion.  The outer profile is always 
    the first face in the brep.  If there are inner profiles, 
    additional brep faces are created for each profile.  If the
    outer profile is closed, then end caps are added as the last
    two faces in the brep.
  Parameters:
    brep - [in]
      If the brep pointer is not null, then the brep form is constructed
      in brep.  If the brep pointer is null, then an ON_Brep is allocated
      on the heap.
    bSmoothFaces - [in]
      If true and the profiles have kinks, then the faces corresponding
      to those profiles are split so they will be G1.
  Returns:
    If successful, a pointer to the brep form.  If unsuccessful, null.
  */
  ON_Brep* BrepForm(
    ON_Brep* brep,
    bool bSmoothFaces 
    ) const;

  /*
  Description:
    Build a sum surface form of the extrusion.
  Parameters:
    sum_surface - [in]
      If the sum_surface pointer is not null, then the sum surface 
      form is constructed in sum_surface.  If the sum_surface pointer 
      is null, then an ON_SumSurface is allocated on the heap.
  Returns:
    If successful, a pointer to the sum surface form.
    If unsuccessful, null. In particular, extrusions with
    mitered ends do not have sum surface forms.
  */
  ON_SumSurface* SumSurfaceForm( 
    ON_SumSurface* sum_surface 
    ) const;

  /*
  Description:
    Convert a component index that identifies a part of this extrusion
    to a component index that identifies a part of the brep created
    by BrepForm(...,false).
  Parameters:
    extrusion_ci - [in]
    extrusion_profile_parameter - [in]
    brep_form - [in]
      brep created by ON_Extrusion::BrepForm()
    brep_ci - [out]
  Returns:
    True if successful.  False if input is not valid, in which case brep_ci
    is set by calling ON_COMPONENT_INDEX::UnSet().
  Remarks:
    If the wall surfaces have creases, then this function cannot
    be used to identify brep components created by BrepForm(...,true).
  */
  bool GetBrepFormComponentIndex(
    ON_COMPONENT_INDEX extrusion_ci,
    ON_COMPONENT_INDEX& brep_ci
    ) const;

  bool GetBrepFormComponentIndex(
    ON_COMPONENT_INDEX extrusion_ci,
    double extrusion_profile_parameter,
    const ON_Brep& brep_form,
    ON_COMPONENT_INDEX& brep_ci
    ) const;

  ////////////////////////////////////////////////////////////
  //
  // overrides of virtual ON_Surface functions
  // 
  ON_BOOL32 SetDomain( 
        int dir,
        double t0, 
        double t1
        );
  ON_Interval Domain(
        int dir
        ) const;
  ON_BOOL32 GetSurfaceSize( 
        double* width, 
        double* height 
        ) const;
  int SpanCount(
        int dir
        ) const;
  ON_BOOL32 GetSpanVector(
        int dir,
        double* span_vector
        ) const;
  ON_BOOL32 GetSpanVectorIndex(
        int dir,
        double t,
        int side,
        int* span_vector_index,
        ON_Interval* span_interval
        ) const;
  int Degree(
        int dir
        ) const; 
  ON_BOOL32 GetParameterTolerance(
         int dir,
         double t,
         double* tminus,
         double* tplus
         ) const;
  ISO IsIsoparametric(
        const ON_Curve& curve,
        const ON_Interval* curve_domain = NULL
        ) const;
  ON_BOOL32 IsPlanar(
        ON_Plane* plane = NULL,
        double tolerance = ON_ZERO_TOLERANCE
        ) const;
  ON_BOOL32 IsClosed(
        int
        ) const;
  ON_BOOL32 IsPeriodic(
        int
        ) const;
  bool GetNextDiscontinuity( 
                  int dir,
                  ON::continuity c,
                  double t0,
                  double t1,
                  double* t,
                  int* hint=NULL,
                  int* dtype=NULL,
                  double cos_angle_tolerance=ON_DEFAULT_ANGLE_TOLERANCE_COSINE,
                  double curvature_tolerance=ON_SQRT_EPSILON
                  ) const;
  bool IsContinuous(
    ON::continuity c,
    double s, 
    double t, 
    int* hint = NULL,
    double point_tolerance=ON_ZERO_TOLERANCE,
    double d1_tolerance=ON_ZERO_TOLERANCE,
    double d2_tolerance=ON_ZERO_TOLERANCE,
    double cos_angle_tolerance=ON_DEFAULT_ANGLE_TOLERANCE_COSINE,
    double curvature_tolerance=ON_SQRT_EPSILON
    ) const;
  ISO IsIsoparametric(
        const ON_BoundingBox& bbox
        ) const;
  ON_BOOL32 Reverse( int dir );
  ON_BOOL32 Transpose();
  ON_BOOL32 Evaluate(
         double u, double v,
         int num_der,
         int array_stride,
         double* der_array,
         int quadrant = 0,
         int* hint = 0
         ) const;
  ON_Curve* IsoCurve(
         int dir,
         double c
         ) const;

  ON_BOOL32 Trim(
         int dir,
         const ON_Interval& domain
         );
  bool Extend(
    int dir,
    const ON_Interval& domain
    );
  ON_BOOL32 Split(
         int dir,
         double c,
         ON_Surface*& west_or_south_side,
         ON_Surface*& east_or_north_side
         ) const;

  ON_BOOL32 GetLocalClosestPoint( const ON_3dPoint&, // test_point
          double,double,     // seed_parameters
          double*,double*,   // parameters of local closest point returned here
          const ON_Interval* = NULL, // first parameter sub_domain
          const ON_Interval* = NULL  // second parameter sub_domain
          ) const;

  //ON_Surface* Offset(
  //      double offset_distance, 
  //      double tolerance, 
  //      double* max_deviation = NULL
  //      ) const;

  int GetNurbForm(
        ON_NurbsSurface& nurbs_surface,
        double tolerance = 0.0
        ) const;
  int HasNurbForm() const;
  bool GetSurfaceParameterFromNurbFormParameter(
        double nurbs_s, double nurbs_t,
        double* surface_s, double* surface_t
        ) const;
  bool GetNurbFormParameterFromSurfaceParameter(
        double surface_s, double surface_t,
        double* nurbs_s,  double* nurbs_t
        ) const;

  ////////////////////////////////////////////////////////////
  //
  // ON_Extrusion interface
  // 
  void Destroy();

  /*
  Description:
    Sets m_path to (A,B), m_path_domain to [0,Length(AB)],
    and m_t to [0,1].
  Parameters:
    A - [in] path start
    B - [in] path end
  Returns:
    true  A and B are valid, the distance from A to B is larger
          than ON_ZERO_TOLERANCE, and the path was set.
    false A or B is not valid or the distance from A to B is
          at most ON_ZERO_TOLERANCE. In this case nothing is set.
  Remark:
    You must also set the up direction to be perpendicular to the path.
  */
  bool SetPath(ON_3dPoint A, ON_3dPoint B);

  /*
  Description:
    Sets m_path to (A,B), m_path_domain to [0,Length(AB)],
    m_t to [0,1], and m_up.
  Parameters:
    A - [in] path start
    B - [in] path end
    up - [in] up direction
      If up is a unit vector and perpendicular to the line 
      segment from A to B, then m_up is set to up.
      Otherwise up will be adjusted so it is perpendicular
      to the line segment from A to B and unitized.
  Returns:
    true  A and B are valid, the distance from A to B is larger
          than ON_ZERO_TOLERANCE, and the path was set.
    false A or B is not valid, or the distance from A to B is
          at most ON_ZERO_TOLERANCE, or up is invalid, or up
          is zero, or up is parallel to the line segment.
          In this case nothing is set.
  */
  bool SetPathAndUp(ON_3dPoint A, ON_3dPoint B, ON_3dVector up );

  /*
  Description:
    Get the surface parameter for the path.
  Returns:
    0: The first surface parameter corresponds to the path direction.
       (m_bTransposed = true)
    1: The second surface parameter corresponds to the path direction.
       (m_bTransposed = false)
  Remarks:
    The default ON_Extrusion constructor sets 
    m_bTransposed = false which corresponds to the 1 = PathParameter().
  */
  int PathParameter() const;

  ON_3dPoint PathStart() const;
  ON_3dPoint PathEnd() const;
  ON_3dVector PathTangent() const;

  /*
  Description:
    Set miter plane normal.
  Parameters:
    N - [in] If ON_UNSET_VECTOR or N is parallel to the z-axis,
             then the miter plane is the default plane 
             perpendicular to the path.
             If N is valid and the z coordinate of a unitized
             N is greater than m_Nz_tol, then the miter plane 
             normal is set.
    end - [in] 0 = set miter plane at the start of the path.
               1 = set miter plane at the end of the path.
  */
  bool SetMiterPlaneNormal(ON_3dVector N, int end);

  void GetMiterPlaneNormal(int end, ON_3dVector& N) const;

  /*
  Returns:
    0: not mitered.
    1: start of path is mitered.
    2: end of path is mitered.
    3: start and end are mitered.
  */
  int IsMitered() const;

  /*
  Returns:
    True if extrusion object is a capped solid.
  */
  bool IsSolid() const;

  /*
  Returns:
    0: no or profile is open
    1: bottom cap
    2: top cap
    3: both ends capped.
  */
  int IsCapped() const;

  /*
  Returns:
    0: no caps
    1: exrusion has either a top cap or a bottom cap
    2: both ends are capped.
  See Also:
    ON_Extrusion::ProfileCount()
    ON_Extrusion::ProfileSmoothSegmentCount()
  */
  int CapCount() const;

  /*
  Description:
    Deprecated function.

    Use CapCount() to determine how many end caps there are.
    Use ProfileCount() to determine how many profiles there are.
    Use ProfileSmoothSegmentCount() to determine how many 
    smooth subsegments are in a profile. Each smooth subsegment
    becomes a wall face in the brep form.

  Returns:
    Number of "faces" the extrusion has.
    0: extrusion is not valid
    1: extrusion is not capped
    2: extrusion has a closed outer profile and one cap
    3: extrusion has a closed outer profile and two caps

  Remarks:
    This function was written before extrusions supported "holes"
    and before the brep form was divided at profile creases.
    At this point it simply leads to confusion. See the Description
    function replacements.
  */
  ON_DEPRECATED int FaceCount() const;

  /*
  Description:
    Get the transformation that maps the xy profile curve
    to its 3d location.
  Parameters:
    s - [in] 0.0 = starting profile
             1.0 = ending profile
  */
  bool GetProfileTransformation( double s, ON_Xform& xform ) const;

  /*
  Description:
    Get the the 3d plane containing the profile curve at a
    normalized path parameter.
  Parameters:
    s - [in] 0.0 = starting plane
             1.0 = ending plane
    plane - [out]
      Plane containing profile is returned in plane.  If
      false is returned, then the input value of plane
      is not changed.
  Returns:
    true if plane was set.  False if this is invalid and plane
    could not be set.
  Remarks:
    When no mitering is happening, GetPathPlane() and
    GetProfilePlane() return the same plane.
  */
  bool GetProfilePlane( double s, ON_Plane& plane ) const;


  /*
  Description:
    Get the the 3d plane perpendicular to the path at a
    normalized path parameter.
  Parameters:
    s - [in] 0.0 = starting plane
             1.0 = ending plane
    plane - [out]
      Plane is returned here.  If
      false is returned, then the input value of plane
      is not changed.
  Returns:
    true if plane was set.  False if this is invalid and plane
    could not be set.
  Remarks:
    When no mitering is happening, GetPathPlane() and
    GetProfilePlane() return the same plane.
  */
  bool GetPathPlane( double s, ON_Plane& plane ) const;

  /*
  Description:
    Set the outer profile of the extrusion.
  Paramters:
    outer_profile - [in] 
      curve in the xy plane or a 2d curve.
    bCap - [in]
      If outer_profile is a closed curve, then bCap
      determines if the extrusion has end caps.
      If outer_profile is an open curve, bCap is ignored.
  Returns:
    True if the profile was set. In this case the ON_Extrusion class
    manages the curve and ~ON_Extrusion will delete it.  If the outer
    profile is closed, then the extrusion may also have inner profiles.
    If the outer profile is open, the extrusion may not have inner
    profiles. If the extrusion already has a profile, the set will
    fail.
  Remarks:
    If needed, outer_profile will be converted to a 2d
    curve. If outer_curve is closed but not correctly oriented,
    it will reversed so it has a counter-clockwise orientation.
  */
  bool SetOuterProfile( ON_Curve* outer_profile, bool bCap );

  /*
  Description:
    Add an inner profile.
  Paramters:
    inner_profile - [in]
      closed curve in the xy plane or a 2d curve.
  Returns:
    True if the profile was set. In this case the 
    ON_Extrusion class  manages the curve and ~ON_Extrusion will 
    delete it. The extrusion must already have an outer profile.
    If the extrusion already has a profile, the set will
    fail.
  Remarks:
    If needed, innter_profile will be converted to a 2d
    curve. If inner_profile is not correctly oriented, it
    will be reversed so it has a clockwise orientation.
  */
  bool AddInnerProfile( ON_Curve* inner_profile );

  /*
  Returns:
    Number of profile curves.
  See Also:
    ON_Extrusion::CapCount()
    ON_Extrusion::ProfileSmoothSegmentCount()
  */
  int ProfileCount() const;

  /*
  Parameter:
    profile_index - [in]
      0 <= profile_index < ProfileCount().
      The outer profile has index 0.
  Returns:
    Number of smooth segments in the profile curve.
  See Also:
    ON_Extrusion::CapCount()
    ON_Extrusion::GetProfileKinkParameters()
    ON_Extrusion::ProfileCount()
  */
  int ProfileSmoothSegmentCount( int profile_index ) const;

  /*
  Description:
    Get the surface parameter for the profile.
  Returns:
    0: The first surface parameter corresponds to the profile direction.
       (m_bTransposed = false)
    1: The second surface parameter corresponds to the profile direction.
       (m_bTransposed = true)
  Remarks:
    The default ON_Extrusion constructor sets 
    m_bTransposed = false which corresponds to the 0 = ProfileParameter().
  */
  int ProfileParameter() const;

  /*
  Paramters:
    profile_index - [in]
      0 <= profile_index < ProfileCount().
      The outer profile has index 0.
  Returns:
    Pointer to the i-th 2d profile.  The ON_Extrusion
    class manages this curve.  Do not delete it
    and do not use the pointer if the ON_Extrusion
    class changes.
  */
  const ON_Curve* Profile(int profile_index) const;

  /*
  Paramters:
    profile_index - [in]
      0 <= profile_index < ProfileCount().
      The outer profile has index 0.
    s - [in] ( 0.0 <= s <= 1.0 )
      A relative parameter controling which priofile
      is returned. s = 0.0 returns the bottom profile
      and s = 1.0 returns the top profile.
  Returns:
    NULL if the input parameters or the ON_Extrusion class is
    not valid.  Otherwise a pointer to a 3d curve for 
    the requested profile. This curve is on the heap and
    the caller is responsible for deleting this curve.
  */
  ON_Curve* Profile3d(int profile_index, double s ) const;

  /*
  Paramters:
    ci - [in]
      component index identifying a 3d extrusion profile curve.
  Returns:
    NULL if the component index or the ON_Extrusion class is
    not valid.  Otherwise a pointer to a 3d curve for 
    the requested profile. This curve is on the heap and
    the caller is responsible for deleting this curve.
  */
  ON_Curve* Profile3d( ON_COMPONENT_INDEX ci ) const;

  /*
  Paramters:
    ci - [in]
      component index identifying a wall edge curve.
  Returns:
    NULL if the component index or the ON_Extrusion class is
    not valid.  Otherwise a pointer to a 3d curve for 
    the requested wall edge. This curve is on the heap and
    the caller is responsible for deleting this curve.
  */
  ON_Curve* WallEdge( ON_COMPONENT_INDEX ci ) const;

  /*
  Paramters:
    ci - [in]
      component index identifying a wall surface.
  Returns:
    NULL if the component index or the ON_Extrusion class is
    not valid.  Otherwise a pointer to a surface for 
    the requested wall surface. This curve is on the heap and
    the caller is responsible for deleting this curve.
  */
  ON_Surface* WallSurface( ON_COMPONENT_INDEX ci ) const;

  /*
  Paramters:
    line_curve - [in]
      If null, a line curve will be allocated using new.
  Returns:
    Null if the extrusion path is not valid.  Otherwise
    a pointer to an ON_LineCurve that is set to the 
    extrusion's path. The caller must delete this curve.
  */
  ON_LineCurve* PathLineCurve(ON_LineCurve* line_curve) const;

  /*
  Paramters:
    profile_parameter - [in]
      parameter on profile curve
  Returns:
      -1: if the profile_parameter does not correspond 
          to a point on the profile curve.
    >= 0: index of the profile curve with domain containing
          this paramter.  When the profile_parameter corresponds
          to the end of one profile and the beginning of the next
          profile, the index of the next profile is returned.
  */
  int ProfileIndex( double profile_parameter ) const;


  /*
  Returns:
    If m_profile_count >= 2 and m_profile is an ON_PolyCurve
    with m_profile_count segments defining outer and inner
    profiles, a pointer to the polycurve is returned.
    Otherwise null is returned.
  */
  const ON_PolyCurve* PolyProfile() const;

  /*
  Description:
    Get a list of the 2d profile curves.
  Returns:
    Number of curves appended to the list.
  */
  int GetProfileCurves( ON_SimpleArray<const ON_Curve*>& profile_curves ) const;


  /*
  Description:
    Get the parameters where a profile curve has kinks.
  Parameters:
    profile_index - [in]
    profile_kink_parameters - [out]
      parameters at internal kinks are appended to this array.
  Returns:
    Number of parameters appended to profile_kink_parameters[]
  Remarks:
    This function is used when making the brep form that has
    smooth faces.
  */
  int GetProfileKinkParameters( int profile_index, ON_SimpleArray<double>& profile_kink_parameters ) const;

  /*
  Parameters:
    profile_index - [in]
  Returns:
    True if the profile has at least one kink.
  */
  bool ProfileIsKinked( int profile_index ) const;

  /*
  Description:
    Test a polycurve to determine if it meets the necessary 
    conditions to be used as a multi-segment profile in a extrusion.
  Returns:
    True if the returned polycurve can be used a a multi-segment 
    profile in a extrusion.
  */
  static bool IsValidPolyCurveProfile( const ON_PolyCurve& polycurve, ON_TextLog* text_log = 0 );

  /*
  Description:
    If possible, modify a polycurve so it meets the necessary conditions
    to be used as a multi-segment profile in a extrusion.
  Returns:
    True if the returned polycurve can be used a a multi-segment 
    profile in a extrusion.
  */
  static bool CleanupPolyCurveProfile( ON_PolyCurve& polycurve );

  // path definition:
  //   The line m_path must have length > m_path_length_min.
  //   The interval m_t must statisfy 0 <= m_t[0] < m_t[1] <= 1.
  //   The extrusion starts at m_path.PointAt(m_t[0]) and ends
  //   at m_path.PointAt(m_t[1]).
  //   The "up" direction m_up is a unit vector that must
  //   be perpendicular to m_path.Tangent().
  ON_Line m_path;
  ON_Interval m_t;
  ON_3dVector m_up;

  // profile information:
  //   In general, use SetOuterProfile() and AddInnerProfile()
  //   to set m_profile_count and m_profile.  If you are
  //   a glutton for punishment, then you might be interested
  //   in the following.
  //   The profile curves must be in the x-y plane.
  //   The profile's "y" axis corresponds to m_up.
  //   The point (0,0) is extruded along the m_path line.
  //   If m_profile_count = 1, then m_profile can be any
  //   type of continous curve.  If m_profile_count > 1,
  //   then m_profile must be an ON_PolyCurve with
  //   m_profile_count segments, the domain of each segment
  //   must exactly match the polycurve's segment domain,
  //   every segment must be continuous and closed,
  //   the first segement curve must have counter-clockwise
  //   orientation, and the rest must have clockwise 
  //   orientations.
  int m_profile_count;
  ON_Curve* m_profile;

  // capped end information:
  //   If the profile is closed, then m_bCap[] determines
  //   if the ends are capped.
  bool m_bCap[2];

  // mitered end information:
  //   The normals m_N[] are with respect to the xy plane.
  //   A normal parallel to the z axis has no mitering.
  //   If m_bHaveN[i] is true, then m_N[i] must be a 3d unit
  //   vector with m_N[i].z > m_Nz_tol;  If m_bHaveN[i]
  //   is false, then m_N[i] is ignored.  The normal m_N[0]
  //   defines the start miter plane and m_N[1] defines the
  //   end miter plane.
  bool m_bHaveN[2];
  ON_3dVector m_N[2];

  // Surface parameterization information
  ON_Interval m_path_domain;
  bool m_bTransposed; // false: (s,t) = (profile,path)

  // The z coordinates of miter plane normals must be
  // greater than m_Nz_tol
  static const double m_Nz_min; // 1/64;

  // The length of the m_path line must be greater than
  // m_path_length_min
  static const double m_path_length_min; // ON_ZERO_TOLERANCE;

  /*
  Description:
    Get an ON_Exrusion form of a cylinder.
  Parameters:
    cylinder - [in] cylinder.IsFinite() must be true
    bCapBottom - [in] if true, the end at cylinder.m_height[0] will be capped
    bCapTop - [in] if true, the end at cylinder.m_height[1] will be capped
    extrusion - [in] 
      If the input extrusion pointer is null, one will be allocated on the heap
      and it is the caller's responsibility to delte it at an appropriate time.
      If the input pointer is not null, this extrusion will be used and the same
      pointer will be returned, provided the input is valid.
  Returns:
    If the input is valid, a pointer to an ON_Exrusion form of the cylinder.
    If the input is not valid, then null, even when the input extrusion
    object is not null.
  Example:

          ON_Cylinder cylinder = ...;
          bool bCapBottom = true;
          bool bCapTop = true;
          ON_Extrusion extrusion;
          if ( 0 == ON_Extrusion::Cylinder(cylinder,bCapBottom,bCapTop,&extrusion) )
          {
            // input is not valid - nothing set
            ...
          }
          else
          {
            // extrusion = cylinder
            ...
          }
  */
  static ON_Extrusion* Cylinder( 
    const ON_Cylinder& cylinder, 
    bool bCapBottom,
    bool bCapTop,
    ON_Extrusion* extrusion = 0 
    );

  /*
  Description:
    Get an ON_Exrusion form of a pipe.
  Parameters:
    cylinder - [in] cylinder.IsFinite() must be true
      The cylinder can be either the inner or outer wall of the pipe.
    other_radius - [in] ( != cylinder.Radius() )
      If cylinder.Radius() < other_radius, then the cylinder will be
      the inside of the pipe.  If cylinder.Radius() > other_radius, then
      the cylinder will be the outside of the pipe.
    bCapBottom - [in] if true, the end at cylinder.m_height[0] will be capped
    bCapTop - [in] if true, the end at cylinder.m_height[1] will be capped
    extrusion - [in] 
      If the input extrusion pointer is null, one will be allocated on the heap
      and it is the caller's responsibility to delte it at an appropriate time.
      If the input pointer is not null, this extrusion will be used and the same
      pointer will be returned, provided the input is valid.
  Returns:
    If the input is valid, a pointer to an ON_Exrusion form of the pipe.
    If the input is not valid, then null, even when the input extrusion
    object is not null.
  Example:

          ON_Cylinder cylinder = ...;
          double other_radius = cylinder.Radius()+1.0;
          bool bCapBottom = true;
          bool bCapTop = true;
          ON_Extrusion extrusion;
          if ( 0 == ON_Extrusion::Pipe(cylinder,other_radius,bCapBottom,bCapTop,&extrusion) )
          {
            // input is not valid - nothing set
            ...
          }
          else
          {
            // extrusion = pipe
            ...
          }
  */
  static ON_Extrusion* Pipe( 
    const ON_Cylinder& cylinder, 
    double other_radius,
    bool bCapBottom,
    bool bCapTop,
    ON_Extrusion* extrusion = 0 
    );

  /*
  Description:
    Create an ON_Exrusion from a 3d curve, a plane and a height.
  Parameters:
    curve - [in] 
      A continuous 3d curve.
    plane - [in]
      If plane is null, then the plane returned by curve.IsPlanar() is used.
      The 3d curve is projected to this plane and the result is passed to
      ON_Extrusion::SetOuterProfile().
    height - [in]
      If the height > 0, the bottom of the extrusion will be in plane and
      the top will be height units above the plane.
      If the height < 0, the top of the extrusion will be in plane and
      the bottom will be height units below the plane.
    bCap - [in]
      If the curve is closed and bCap is true, then the resulting extrusion
      is capped.
    extrusion - [in] 
      If the input extrusion pointer is null, one will be allocated on the heap
      and it is the caller's responsibility to delte it at an appropriate time.
      If the input pointer is not null, this extrusion will be used and the same
      pointer will be returned, provided the input is valid.
  Returns:
    If the input is valid, a pointer to an ON_Exrusion form of the pipe.
    If the input is not valid, then null, even when the input extrusion
    object is not null.
  */
  static ON_Extrusion* CreateFrom3dCurve( 
    const ON_Curve& curve,
    const ON_Plane* plane,
    double height,
    bool bCap,
    ON_Extrusion* extrusion = 0 
    );

};


#endif

/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

////////////////////////////////////////////////////////////////
//
//  Defines ON_WindowsBITMAPINFO class that is used to provide OS independent
//  serialization of Windows device independent bitmaps (BITMAPINFO) used
//  to store preview images.
//
////////////////////////////////////////////////////////////////

#if !defined(OPENNURBS_BITMAP_INC_)
#define OPENNURBS_BITMAP_INC_

class ON_CLASS ON_Bitmap : public ON_Object
{
  // virtual base class for bitmap objects
  ON_OBJECT_DECLARE(ON_Bitmap);
public:
  ON_Bitmap();
  ~ON_Bitmap();

  // C++ defaults work fine
  //ON_Bitmap(const ON_Bitmap&);
  //ON_Bitmap& operator=(const ON_Bitmap&);

  // virtual
  ON_UUID ModelObjectId() const;


  void Dump( ON_TextLog& ) const; // for debugging

  void EmergencyDestroy();
  void Destroy();

  void Defaults();

  virtual
  int Width() const = 0;
  virtual
  int Height() const = 0; // >0 means it's a bottom-up bitmap with origin at lower right
                          // <0 means it's a top-down bitmap with origin at upper left
  virtual
  int BitsPerPixel() const = 0; // bits per pixel
  virtual
  int SizeofScan() const = 0;  // number of bytes per scan line
  virtual
  int SizeofImage() const = 0; // size of current map in bytes

  virtual
  unsigned char* Bits(
    int // index of scan line 
    ) = 0;
  virtual
  const unsigned char* Bits(
    int // index of scan line 
    ) const = 0;

  ON_UUID    m_bitmap_id;
  int        m_bitmap_index;
  ON_wString m_bitmap_name;     // descriptive name
  ON_wString m_bitmap_filename; // full path to file
};

/*
  ON_EmbeddedFile is derived from ON_Bitmap so it can be stored 
  in the Rhino document's CRhinoDoc::m_bitmap_table[] array.
  The ON_EmbeddedFile class is used to embed any type of file
  in a Rhino document.
*/
class ON_CLASS ON_EmbeddedFile : public ON_Object
{
  ON_OBJECT_DECLARE(ON_EmbeddedFile);
public:
  ON_EmbeddedFile();
  ON_EmbeddedFile(const ON_EmbeddedFile& src);
  ON_EmbeddedFile& operator=(const ON_EmbeddedFile& src);

  virtual ~ON_EmbeddedFile();
  void EmergencyDestroy();
  void Destroy();
  void DestroyBuffer();

  /*
  Description:
    Store the specified file in an ON_EmbeddedFile class.
  Parameters:
    filename - [in]
      full path to the file.
    bCompress - [in]
      true if the image of the file should be compressed.
      (Pass false if the file is already in a compressed
      format, like jpg, png, zip files.)
  Returns:
    true if successful.  When true is returned m_id is set to
    a new unique id, m_full_file_name is set to filename,
    and m_relative_file_name is empty.
  */
  bool Create( 
    const wchar_t* filename, 
    bool bCompress
    );

  /*
  Description:
    Store the specified file in an ON_EmbeddedFile class.
  Parameters:
    fp - [in]
      Result of calling ON::OpenFile( ..., "rb" )
    bCompress - [in]
      true if the image of the file should be compressed.
      (Pass false if the file is already in a compressed
      format, like jpg, png, zip files.)
  */
  bool Create( 
    FILE* fp,
    bool bCompress 
    );
  
  /*
  Description:
    Store the specified buffer in an ON_EmbeddedFile class.
  Parameters:
    source_buffer - [in]
    source_buffer_size - [in]
      number of bytes in source_buffer.
    bCompress - [in]
      true if the source_buffer should be compressed.
      (Pass false if source_buffer is already in a compressed format.)
  */
  bool Create( 
    const void* source_buffer,
    ON__UINT64 sizeof_source_buffer,
    bool bCompress 
    );

  bool Extract( 
    const wchar_t* destination_filename
    ) const;

  bool Extract( 
    FILE* fp
    ) const;

  /*
  Description:
    Extracts the file into a buffer.
  Parameters:
    buffer - [out]
      buffer must point to FileSize() bytes of memory.
      The extracted file will be copied to this buffer.
  Returns:
    True if successful.
    False if not successful.
  */
  bool Extract( 
    void* buffer
    ) const;
        
  /*
  Returns
    full path file name
  */
  const wchar_t* FullFileName() const;
    
  /*
  Returns
    Relative file name.  Usually relative to the directory
    where the archive containing this embedded file was last
    saved.
  */
  const wchar_t* RelativeFileName() const;

  ON_UUID Id() const;

  void SetId( ON_UUID id );

  void SetFullFileName( const wchar_t* full_file_name );


  void SetRelativeFileName( const wchar_t* relative_file_name );

  ON__UINT64 FileSize() const;
  ON__UINT64 FileLastModifiedTime() const;
  ON__UINT32 FileCRC() const;
  
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  ON_BOOL32 Write( ON_BinaryArchive& ) const;
  ON_BOOL32 Read( ON_BinaryArchive& );

  // The relative path is typically set when the .3dm file is
  // saved and is the path to the file relative to the location
  // of the saved file.
  // (The full path to the file is in ON_Bitmap::m_bitmap_filename.)
  ON_UUID    m_id;
  ON_wString m_full_file_name; // full path file name
  ON_wString m_relative_file_name; // relative path when the archive was last saved.

private:
  void* m_reserved;

public:
  ON__UINT64 m_file_size;
  ON__UINT64 m_file_time;  // last modified time returned by ON::GetFileStats()
  ON__UINT32 m_file_crc;   // 32 bit crc of the file from ON_CRC32

public:
  ON__UINT32 m_buffer_crc; // will be different from m_file_crc if the buffer is compressed.
  ON_Buffer m_buffer;
  unsigned char m_bCompressedBuffer; // true if m_buffer is compressed.

private:
  unsigned char m_reserved3[7];
};


#if !defined(ON_OS_WINDOWS_GDI)

// These are the values of the Windows defines mentioned
// in the comment below.  If you're running on Windows,
// they get defined by Windows system header files.
// If you aren't running on Windows, then you don't
// need them.
//#define BI_RGB        0L
//#define BI_RLE8       1L
//#define BI_RLE4       2L
//#define BI_BITFIELDS  3L

// Mimics Windows BITMAPINFOHEADER structure.
// For details searh for "BITMAPINFOHEADER" at http://msdn.microsoft.com/default.asp 
struct ON_WindowsBITMAPINFOHEADER
{
  unsigned int   biSize;          // DWORD = sizeof(BITMAPINFOHEADER)
  int            biWidth;         // LONG  = width (in pixels) of (decompressed) bitmap
  int            biHeight;        // LONG  = height (in pixels) of (decompressed) bitmap
                                  //         >0 means it's a bottom-up bitmap with origin
                                  //            in the lower left corner.
                                  //         <0 means it's a top-down bitmap with origin
                                  //            in the upper left corner.
  unsigned short biPlanes;        // WORD  = number of planes 
                                  //         (always 1 in current Windows versions)
  unsigned short biBitCount;      // WORD  = bits per pixel (0,1,4,8,16,24,32 are valid)
                                  //         1 See http://msdn.microsoft.com/default.asp  
                                  //         4 See http://msdn.microsoft.com/default.asp  
                                  //         8 The bitmap has a maximum of 256 colors, 
                                  //           and the bmiColors member contains up 
                                  //           to 256 entries. In this case, each byte
                                  //           in the array represents a single pixel. 
                                  //        16 See http://msdn.microsoft.com/default.asp  
                                  //        24 If biClrUsed=0 and biCompression=BI_RGB(0),
                                  //           then each 3-byte triplet in the bitmap 
                                  //           array represents the relative intensities
                                  //           of blue, green, and red, respectively, for
                                  //           a pixel. For other possibilities, see
                                  //           http://msdn.microsoft.com/default.asp  
                                  //        32 If biClrUsed=0 and biCompression=BI_RGB(0),
                                  //           then each 4-byte DWORD in the bitmap 
                                  //           array represents the relative intensities
                                  //           of blue, green, and red, respectively, for
                                  //           a pixel. The high byte in each DWORD is not
                                  //           used.  
                                  //           If biClrUsed=3, biCompression=BITFIELDS(3),
                                  //           biColors[0] = red mask (0x00FF0000), 
                                  //           biColors[1] = green mask (0x0000FF00), and
                                  //           biColors[2] = blue mask (0x000000FF),
                                  //           then tese masks are used with each 4-byte
                                  //           DWORD in the bitmap array to determine
                                  //           the pixel's relative intensities.                                 //           
                                  //           For other possibilities, see
                                  //           http://msdn.microsoft.com/default.asp  
  unsigned int   biCompression;   // DWORD   Currently, Windows defines the following
                                  //         types of compression.
                                  //         =0  BI_RGB (no compression)
                                  //         =1  BI_RLE8 (run length encoded used for 8 bpp)
                                  //         =2  BI_RLE4 (run length encoded used for 4 bpp)
                                  //         =3  BI_BITFIELDS  Specifies that the bitmap is
                                  //             not compressed and that the color table 
                                  //             consists of three DWORD color masks that
                                  //             specify the red, green, and blue components,
                                  //             respectively, of each pixel. This is valid
                                  //             when used with 16- and 32-bit-per-pixel
                                  //             bitmaps.
                                  //         =4  BI_JPEG (not supported in Win 95/NT4)
                                  //
  unsigned int   biSizeImage;     // DWORD = bytes in image
  int            biXPelsPerMeter; // LONG
  int            biYPelsPerMeter; // LONG
  unsigned int   biClrUsed;       // DWORD = 0 or true length of bmiColors[] array.  If 0,
                                  //           then the value of biBitCount determines the
                                  //           length of the bmiColors[] array.
  unsigned int   biClrImportant;  // DWORD
};

struct ON_WindowsRGBQUAD {
  // Mimics Windows RGBQUAD structure.
  // For details searh for "RGBQUAD" at http://msdn.microsoft.com/default.asp 
  unsigned char rgbBlue;      // BYTE
  unsigned char rgbGreen;     // BYTE
  unsigned char rgbRed;       // BYTE
  unsigned char rgbReserved;  // BYTE
};

struct ON_WindowsBITMAPINFO
{
  // Mimics Windows BITMAPINFO structure.
  // For details searh for "BITMAPINFO" at http://msdn.microsoft.com/default.asp 
  ON_WindowsBITMAPINFOHEADER bmiHeader;
  ON_WindowsRGBQUAD bmiColors[1]; // The "[1]" is for the compiler.  In
                                  // practice this array commonly has
                                  // length 0, 3, or 256 and a BITMAPINFO*
                                  // points to a contiguous piece of memory
                                  // that contains
                                  //
                                  //          BITMAPINFOHEADER
                                  //          RGBQUAD[length determined by flags]
                                  //          unsigned char[biSizeImage]
                                  //
                                  // See the ON_WindowsBITMAPINFOHEADER comments
                                  // and http://msdn.microsoft.com/default.asp
                                  // for more details.
};

#endif

// OBSOLETE // class ON_OpenGLBitmap;

class ON_CLASS ON_WindowsBitmap : public ON_Bitmap
{
  ON_OBJECT_DECLARE(ON_WindowsBitmap);
  // Uncompressed 8 bpp, 24 bpp, or 32 bpp Windows device 
  // independent bitmaps (DIB)
public:

  ON_WindowsBitmap();
  ON_WindowsBitmap( const ON_WindowsBitmap& );
  ~ON_WindowsBitmap();

  ON_WindowsBitmap& operator=( const ON_WindowsBitmap& );

  void EmergencyDestroy();
  void Destroy();

  bool Create( 
         int, // width
         int, // height
         int  // bits per pixel ( 1, 2, 4, 8, 16, 24, or 32 )
         );

  /*
  Description:
    Tests an object to see if its data members are correctly
    initialized.
  Parameters:
    text_log - [in] if the object is not valid and text_log
        is not NULL, then a brief englis description of the
        reason the object is not valid is appened to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     object is valid
    false    object is invalid, uninitialized, etc.
  Remarks:
    Overrides virtual ON_Object::IsValid
  */
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  ON_BOOL32 Write( ON_BinaryArchive& ) const; // writes compressed image
  ON_BOOL32 Read( ON_BinaryArchive& );        // reads compressed image
  bool WriteCompressed( ON_BinaryArchive& ) const;
  bool ReadCompressed( ON_BinaryArchive& );
  bool WriteUncompressed( ON_BinaryArchive& ) const;
  bool ReadUncompressed( ON_BinaryArchive& );

  int Width() const;
  int Height() const; // >0 means it's a bottom-up bitmap with origin at lower right
                      // <0 means it's a top-down bitmap with origin at upper left

  int PaletteColorCount() const; // number of colors in palette
  int SizeofPalette() const;     // number of bytes in palette
  int BitsPerPixel() const;
  //int SizeofPixel() const;       // number of bytes per pixel
  int SizeofScan() const;        // number of bytes per scan line
  int SizeofImage() const;       // number of bytes in image

  unsigned char* Bits(
    int // index of scan line 
    );
  const unsigned char* Bits(
    int // index of scan line 
    ) const;

  //int PaletteIndex( ON_Color ) const; // for 8bpp bitmaps

  ON_Color Pixel( 
    int, // 0 <= i < width
    int  // 0 <= j < height
    ) const;
  ON_Color Pixel( 
    int,  // 0 <= i < width
    const unsigned char* // value of Bits( j )
    ) const;

  //ON_BOOL32 SetColor( // sets entire map to specified color 
  //       ON_Color
  //       );

#if defined(ON_OS_WINDOWS_GDI)

  /*
  Description:
    Create an ON_WindowsBitmap from a contiguous bitmap.
    Copies src.
  Parameters:
    src - [in] contiguous Windows device independent bitmap.
  Remarks:
    If the current Windows BITMAPINFO is identical to ON_WindowsBITMAPINFO,
    then the result of this call is identical to

         int color_count = number of colors in bitmap's palette;
         ON_WindowsBitmap::Create( &src, &src.bmiColors[color_count], true ).

  See Also:
    ON_WindowsBitmap::Create    
  */
  ON_WindowsBitmap( const BITMAPINFO& src );

  /*
  Description:
    Create an ON_WindowsBitmap from a contiguous bitmap.
    Shares bitmap memory with src.
  Parameters:
    src - [in] contiguous Windows device independent bitmap.
  See Also:
    ON_WindowsBitmap::Create    
  Remarks:
    ~ON_WindowsBitmap will not delete src.
  */
  ON_WindowsBitmap( const BITMAPINFO* src );

  /*
  Description:
    Create an ON_WindowsBitmap from a contiguous bitmap.
    Copies src.
  Parameters:
    src - [in] contiguous Windows device independent bitmap.
  See Also:
    ON_WindowsBitmap::Create    
  */
  ON_WindowsBitmap& operator=( const BITMAPINFO& src );

  /*
  Description:
    Create and ON_WindowsBitmap from a Windows BITMAPINFO pointer
    and a pointer to the bits.

    This is intended to make it easy to write compressed bimaps.
    For ON_WindowsBitmap classes created with ON_WindowsBitmap::Share,
    ON_WindowsBitmap::Destroy and ~ON_WindowsBitmap will
    not free the bmi and bits memory.

  Parameters:
    bmi  - [in] valid BITMAPINFO
    bits - [in] bits for BITMAPINFO
    bCopy - [in] If true, the bmi and bits are copied into a contiguous
                 bitmap that will be deleted by ~ON_WindowsBitmap.
                 If false, the m_bmi and m_bits pointers on this class
                 are simply set to bmi and bits.  In this case,
                 ~ON_WindowsBitmap will not free the bmi or bits
                 memory.

  Example:

          ON_BinaryArchive archive = ...;
          BITMAPINFO* bmi = 0;
          unsigned char* bits = 0;
          int color_count = ...; // number of colors in palette

          int sizeof_palette = sizeof(bmi->bmiColors[0]) * color_count;

          BITMAPINFO* bmi = (LPBITMAPINFO)calloc( 1, sizeof(*bmi) + sizeof_palette );

          bmi->bmiHeader.biSize          = sizeof(bmi->bmiHeader);
          bmi->bmiHeader.biWidth         = width;
          bmi->bmiHeader.biHeight        = height;
          bmi->bmiHeader.biPlanes        = 1;
          bmi->bmiHeader.biBitCount      = (USHORT)color_depth;
          bmi->bmiHeader.biCompression   = BI_RGB;                  
          bmi->bmiHeader.biXPelsPerMeter = 0;
          bmi->bmiHeader.biYPelsPerMeter = 0;
          bmi->bmiHeader.biClrUsed       = 0;
          bmi->bmiHeader.biClrImportant  = 0;
          bmi->bmiHeader.biSizeImage     = GetStorageSize();

          // initialize palette
          ...

          HBITMAP hbm = ::CreateDIBSection( NULL, bmi, ..., (LPVOID*)&bits, NULL, 0);

          {
            // Use ON_WindowsBitmap to write a compressed bitmap to 
            // archive.  Does not modify bmi or bits.
            ON_WindowsBitmap onbm;
            onbm.Create(bmi,bit,false);
            onbm.Write( arcive );
          }

  */
  bool Create( const BITMAPINFO* bmi, 
               const unsigned char* bits,
               bool bCopy
             );

#endif

  /*
  Returns:
    True if m_bmi and m_bits are in a single contiguous 
    block of memory.
    False if m_bmi and m_bits are in two blocks of memory.    
  */
  bool IsContiguous() const;

#if defined(ON_OS_WINDOWS_GDI)
  BITMAPINFO*                  m_bmi;
#else
  struct ON_WindowsBITMAPINFO* m_bmi;
#endif

  unsigned char*               m_bits;

private:
  int m_bFreeBMI; // 0 m_bmi and m_bits are not freed by ON_WindowsBitmap::Destroy
                  // 1 m_bmi  memory is freed by ON_WindowsBitmap::Destroy
                  // 2 m_bits memory is freed by ON_WindowsBitmap::Destroy
                  // 3 m_bmi and m_bits memory is freed by ON_WindowsBitmap::Destroy                    
};

/*
Description:
  ON_WindowsBitmapEx is identical to ON_WindowsBitmap except that
  it's Read/Write functions save bitmap names.
*/
class ON_CLASS ON_WindowsBitmapEx : public ON_WindowsBitmap
{
  ON_OBJECT_DECLARE(ON_WindowsBitmapEx);
public:
  ON_WindowsBitmapEx();
  ~ON_WindowsBitmapEx();
  ON_BOOL32 Write( ON_BinaryArchive& ) const; // writes compressed image
  ON_BOOL32 Read( ON_BinaryArchive& );        // reads compressed image
};

class ON_CLASS ON_EmbeddedBitmap : public ON_Bitmap
{
  ON_OBJECT_DECLARE(ON_EmbeddedBitmap);
public:
  ON_EmbeddedBitmap();
  ~ON_EmbeddedBitmap();
  void EmergencyDestroy();
  void Destroy();
  void Create( int sizeof_buffer );

  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  ON_BOOL32 Write( ON_BinaryArchive& ) const;
  ON_BOOL32 Read( ON_BinaryArchive& );

  int Width() const;
  int Height() const;
  int BitsPerPixel() const;
  int SizeofScan() const;
  int SizeofImage() const;
  unsigned char* Bits(int);
  const unsigned char* Bits(int) const;

  void* m_buffer;
  size_t m_sizeof_buffer;
  int m_free_buffer; // 1 = ~ON_EmbeddedBitmap will onfree m_buffer.
  ON__UINT32 m_biffer_crc32; // 32 bit crc from ON_CRC32
};


#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_INSTANCE_INC_)
#define OPENNURBS_INSTANCE_INC_

/*
Description:
  An ON_InstanceDefinition defines the geometry used by 
  instance references.
See Also:
  ON_InstanceRef
*/
class ON_CLASS ON_InstanceDefinition : public ON_Geometry
{
  ON_OBJECT_DECLARE(ON_InstanceDefinition);

public:

  // IDEF_UPDATE_TYPE lists the possible relationships between
  // the instance definition geometry and the archive 
  // (m_source_archive) containing the original defition.
  enum IDEF_UPDATE_TYPE
  {
    static_def = 0,
    embedded_def = 1,
      // As of 7 February, "static_def" and "embedded_def" 
      // and shall be treated the same. Using "static_def"
      // is prefered and "embedded_def" is obsolete.
      // The geometry for the instance definition
      // is saved in archives, is fixed and has no
      // connection to a source archive.
      // All source archive information should be
      // empty strings and m_source_archive_checksum
      // shoule be "zero".
    linked_and_embedded_def = 2,
      // The geometry for the instance definition
      // is saved in archives.  Complete source
      // archive and checksum information will be 
      // present. The document setting 
      // ON_3dmIOSettings.m_idef_link_update 
      // determines if, when and how the instance
      // definition geometry is updated by reading the
      // source archive.
    linked_def = 3,   
      // The geometry for this instance definition
      // is not saved in the archive that contains
      // this instance definition. This instance 
      // definition geometry is imported from a
      // "source archive" The "source archive" file
      // name and checksum information are saved
      // in m_source_archive and m_source_archive_checksum.
      // If file named in m_source_archive is not available, 
      // then this instance definition is not valid and any
      // references to it are not valid.
    force_32bit_idef_update_type = 0xFFFFFFFF
  };

  // Converts and integer into an IDEF_UPDATE_TYPE enum.
  static IDEF_UPDATE_TYPE IdefUpdateType(int i);

  // Bits that identify subsets of the instance defintion
  // fields. These bits are used to determine which fields to
  // set when an ON_InstanceDefinition class is used to
  // modify an existing instance definition.
  enum
  {
    no_idef_settings            =    0,
    idef_name_setting           =    1,  // m_name
    idef_description_setting    =    2,  // m_description
    idef_url_setting            =    4,  // all m_url_* fields
    idef_units_setting          =    8,  // m_us and m_unit_scale
    idef_source_archive_setting = 0x10,  // all m_source_*, layer style, update depth fields
    idef_userdata_setting       = 0x20, 
    all_idef_settings           = 0xFFFFFFFF
  };

public:
  ON_InstanceDefinition();
  ~ON_InstanceDefinition();

  // virtual ON_Object overrides
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  // virtual ON_Object::Dump override
  void Dump( ON_TextLog& ) const;

  ON_BOOL32 Write(
         ON_BinaryArchive& binary_archive
       ) const;
  ON_BOOL32 Read(
         ON_BinaryArchive& binary_archive
       );
  ON::object_type ObjectType() const;
  unsigned int SizeOf() const;

  // virtual ON_Geometry overrides
  int Dimension() const;
  ON_BOOL32 GetBBox(
         double* boxmin,
         double* boxmax,
         int bGrowBox = false
         ) const;
  ON_BOOL32 Transform( 
         const ON_Xform& xform
         );

  // virtual
  ON_UUID ModelObjectId() const;

  // Interface
  const wchar_t* Name() const;
  void SetName( const wchar_t* name );

  const wchar_t* Description() const;
  void SetDescription( const wchar_t* description );

  const wchar_t* URL() const;
  void SetURL( const wchar_t* url );

  const wchar_t* URL_Tag() const;
  void SetURL_Tag( const wchar_t* url_tag );

  ON_UUID Uuid() const;
  void SetUuid( ON_UUID uuid );

  void SetBoundingBox( ON_BoundingBox bbox );

  // list of object ids in the instance geometry table.
  ON_SimpleArray<ON_UUID> m_object_uuid;

  /*
  Description:
    If the instance definition is linked or embedded, use
    SetSource to specify the source archive.
  Parameters:
    source_archive - [in] name of source archive
    checksum - [in] check sum used to detect changed.
      Generally, you will pass ON_CheckSum::UnsetCheckSum
      for this argument and Rhino will handle setting
      the checksum to the appropriate value at the appropriate
      time.
    source_type - [in]
      If source_archive and checksum are empty, then
      source_type is ignored and static_def will be used.
      If source_archive is a nonempty string and checksum
      is set, then source_type must be either 
      linked_and_embedded_def or linked_def.  If you
      are changing the source archive of a valid idef,
      then simply pass this->IdefUpdateType().
  Remarks:
    See the IDEF_UPDATE_TYPE comments for more details.
  */
  void SetSourceArchive( 
        const wchar_t* source_archive, 
        ON_CheckSum checksum,
        IDEF_UPDATE_TYPE update_type
        );

  /*
  Description:
    Destroys all source archive information.
    Specifically:
      * m_source_archive is set to the empty string.
      * m_source_bRelativePath is set to false
      * The alternative source archive path is set
        to the empty string.
      * m_source_archive_checksum.Zero() is used to
        destroy all checksum information.
      * m_idef_update_type is set to static_def.
  */
  void DestroySourceArchive();

  /*
  Returns:
    Name of source archive.
  */
  const wchar_t* SourceArchive() const;

  /*
  Returns:
    Check sum of source archive.
  */
  ON_CheckSum SourceArchiveCheckSum() const;

  const ON_UnitSystem& UnitSystem() const;

  /*
  Description:
    Use this function to specify an alternate location to
    look for a linked instance defininition archive if it
    cannot be found in the location specified by m_source_archive.
  Parameters:
    alternate_source_archive_path - [in]
      alterate location. pass null to delete the alternate path.
    bRelativePath - [in]
      true if alternate_source_archive_path is a relative path.
  */
  void SetAlternateSourceArchivePath( 
        const wchar_t* alternate_source_archive_path,
        bool bRelativePath
        );

  /*
  Description:
    If there is an alternate location to look for a linked instance
    defininition archive when it cannot be found in the location 
    specified by m_source_archive, then function will return the
    alterate location.
  Parameters:
    alternate_source_archive_path - [out]
    bRelativePath - [out]
      true if alternate_source_archive_path is a relative path.
  */
  bool GetAlternateSourceArchivePath( 
        ON_wString& alternate_source_archive_path,
        bool& bRelativePath
        ) const;
  /*
  Description:
    Sets m_us and m_unit_scale.
  */
  void SetUnitSystem( ON::unit_system us );
  void SetUnitSystem( const ON_UnitSystem& us );

  /*
  Returns:
    True if this is a linked instance definition with
    layer settings information.
  */
  bool HasLinkedIdefLayerSettings() const;

  /*
  Description:
    Set linked instance definition reference file layer settings.
  Parameters:
    layer_settings - [in/out]
      input: layer settings read from the linked file.
      output: layer settings to use in the context of the idef.
  */
  void UpdateLinkedIdefReferenceFileLayerSettings( unsigned int layer_count, ON_Layer** layer_settings );

  /*
  Description:
    Set linked instance definition parent layer information. 
    Typically this is done just before the linked idef is 
    saved to a file.
  Parameters:
    linked_idef_parent_layer - [in]
  */
  void UpdateLinkedIdefParentLayerSettings( const ON_Layer* linked_idef_parent_layer );

  const ON_Layer* LinkedIdefParentLayerSettings() const;

  /*
  Description:
    When a linked instance definition is read and its layers are added to the
    context when the idef exists, runtime layer ids may need to be changed
    when an id collision occures.  In this case, use this function to
    inform the linked instance definition of the map from runtime layer
    id to the layer id found in the linked file.
  Parameters:
    id_map - [in]
      The first id in the pair is the layer id in the current context
      where the idef is being used.
      The second id in the pair is the layer id found in the linked file.
  */
  void UpdateLinkedIdefReferenceFileLayerRuntimeId( const ON_UuidPairList& id_map );

  /*
  Description:
    Set linked instance definition layer settings.
    Typically this is done just before the linked idef is 
    saved to a file.
  Parameters:
    layer_settings - [in]
      Layer settings in the context where the linked idef is being used.
  Remarks:
    Linked idefs save the original layer informtion from the linked file.
    In the context where the idef is used, some of those settings (color,
    visibility, ...) can be modified. This function saves those modifications
    so the can be applied the next time the linked idef is read.
  */
  void UpdateLinkedIdefLayerSettings( unsigned int layer_count, const ON_Layer*const* layer_settings );

public:

  ON_UUID m_uuid;     // unique id for this instance definition
  ON_wString m_name;  // The "name" is for human comfort.  
                      // It can be empty and duplicates
                      // may exist. Instance reference use
                      // m_uuid to find instance definitions.
  ON_wString m_description; 

  ON_wString m_url;
  ON_wString m_url_tag;     // UI link text for m_url

#if defined(ON_32BIT_POINTER)
private:
  // 24 January 2011:
  //   Because the Rhino 4 and 5 SDKs are fixed, the offset of 
  //   existing fields cannot be changed and the m_reserved1
  //   value has to be located in different places for 
  //   32 and 64 bit builds.
  unsigned int m_reserved1;
#endif

public:
  ON_BoundingBox m_bbox;

  ON_UnitSystem  m_us;
  
  // Note: the embedded_def type is obsolete.
  //  To avoid having to deal with this obsolete type in
  //  your code, using ON_InstanceDefintion::IdefUpdateType()
  //  to get this value.  The IdefUpdateType() function
  //  with convert the obsolte value to the correct
  //  value.
  IDEF_UPDATE_TYPE m_idef_update_type; 

  IDEF_UPDATE_TYPE IdefUpdateType() const;

  int m_idef_update_depth; // Controls how much geometry is read when
                           // a linked idef is updated.
                           //   0: read everything, included nested linked idefs
                           //   1: skip nested linked idefs.

  ON_wString m_source_archive;   // filename used to update idef 
                                 // (it can be empty or relative)
  bool m_source_bRelativePath;  // True if the filename in m_source_archive is
                                 // a relative the location of the 3dm file
                                 // containing this instance definition.

  // A static or linked_and_embedded idef must have m_layer_style = 0
  // A linked idef must have m_layer_style = 1 or 2
  //   0 = unset
  //   1 = active (linked idef layers will be active)
  //   2 = reference (linked idef layers will be reference)
  unsigned char m_idef_layer_style;
                               
private:
  unsigned char m_reserved2[2];

#if defined(ON_64BIT_POINTER)
private:
  // 24 January 2011:
  //   Because the Rhino 4 and 5 SDKs are fixed, the offset of 
  //   existing fields cannot be changed and the m_runtime_sn
  //   value has to be located in different places for 
  //   32 and 64 bit builds.
  unsigned int m_reserved1;
#endif

public:
  ON_CheckSum m_source_archive_checksum; // used to detect when idef is out of
                                         // synch with source archive.
};


/*
Description:
  An ON_InstanceRef is a reference to an instance definition
  along with transformation to apply to the definition.
See Also:
  ON_InstanceRef
*/
class ON_CLASS ON_InstanceRef : public ON_Geometry
{
  ON_OBJECT_DECLARE(ON_InstanceRef);

public:
  ON_InstanceRef();

  /////////////////////////////////////////////////////////////
  //
  // virtual ON_Object overrides
  //
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;
  ON_BOOL32 Write(
         ON_BinaryArchive& binary_archive
       ) const;
  ON_BOOL32 Read(
         ON_BinaryArchive& binary_archive
       );
  ON::object_type ObjectType() const;

  /////////////////////////////////////////////////////////////
  //
  // virtual ON_Geometry overrides
  //
  int Dimension() const;
  ON_BOOL32 GetBBox(
         double* boxmin,
         double* boxmax,
         int bGrowBox = false
         ) const;
  ON_BOOL32 Transform( 
         const ON_Xform& xform
         );

  // virtual ON_Geometry::IsDeformable() override
  bool IsDeformable() const;

  // virtual ON_Geometry::MakeDeformable() override
  bool MakeDeformable();

  /////////////////////////////////////////////////////////////
  //

  // Unique id of the instance definition (ON_InstanceDefinition) 
  // in the instance definition table that defines the geometry
  // used by this reference.
  ON_UUID m_instance_definition_uuid;

  // Transformation for this reference.
  ON_Xform m_xform;

  // Bounding box for this reference.
  ON_BoundingBox m_bbox;

  // Tolerance to use for flagging instance xforms
  // as singular.
  static const double m_singular_xform_tol;
};

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_3DM_PROPERTIES_INC_)
#define OPENNURBS_3DM_PROPERTIES_INC_

//////////////////////////////////////////////////////////////////////////////////////////

class ON_CLASS ON_3dmRevisionHistory
{
public:
  ON_3dmRevisionHistory();
  ~ON_3dmRevisionHistory();
  // C++ default operator= and copy constructor work fine.

  void Default();
  ON_BOOL32 IsValid() const;
  int NewRevision(); // returns updated revision count

  ON_BOOL32 Read( ON_BinaryArchive& );
  ON_BOOL32 Write( ON_BinaryArchive& ) const;

  void Dump( ON_TextLog& ) const;

  /*
  Returns:
    true 
      if m_create_time is >= January 1, 1970
  */
  bool CreateTimeIsSet() const;

  /*
  Returns:
    true 
      if m_last_edit_time is >= January 1, 1970
  */
  bool LastEditedTimeIsSet() const;

  ON_wString m_sCreatedBy;
  ON_wString m_sLastEditedBy;
  struct tm  m_create_time;     // UCT create time
  struct tm  m_last_edit_time;  // UCT las edited time
  int        m_revision_count;
};

//////////////////////////////////////////////////////////////////////////////////////////

class ON_CLASS ON_3dmNotes
{
public:
  ON_3dmNotes();
  ON_3dmNotes( const ON_3dmNotes& );
  ~ON_3dmNotes();
  ON_3dmNotes& operator=(const ON_3dmNotes&);

  void Default();
  ON_BOOL32 IsValid() const;

  ON_BOOL32 Read( ON_BinaryArchive& );
  ON_BOOL32 Write( ON_BinaryArchive& ) const;

  void Dump(ON_TextLog&) const;

  ////////////////////////////////////////////////////////////////
  //
  // Interface - this information is serialized.  Applications
  // may want to derive a runtime class that has additional
  // window and font information.
  ON_wString m_notes; // UNICODE
  ON_BOOL32 m_bVisible;    // true if notes window is showing
  ON_BOOL32 m_bHTML;       // true if notes are in HTML

  // last window position
  int m_window_left;
  int m_window_top;
  int m_window_right;
  int m_window_bottom;
};

//////////////////////////////////////////////////////////////////////////////////////////

class ON_CLASS ON_3dmApplication
{
  // application that created the 3dm file
public:
  ON_3dmApplication();
  ON_3dmApplication( const ON_3dmApplication& );
  ~ON_3dmApplication();
  ON_3dmApplication& operator=(const ON_3dmApplication&);

  void Default();
  ON_BOOL32 IsValid() const;

  ON_BOOL32 Read( ON_BinaryArchive& );
  ON_BOOL32 Write( ON_BinaryArchive& ) const;

  void Dump( ON_TextLog& ) const;

  ON_wString m_application_name;    // short name like "Rhino 2.0"
  ON_wString m_application_URL;     // URL
  ON_wString m_application_details; // whatever you want
};

//////////////////////////////////////////////////////////////////////////////////////////

class ON_CLASS ON_3dmProperties
{
public:
  ON_3dmProperties();
  ~ON_3dmProperties();
  ON_3dmProperties(const ON_3dmProperties&);
  ON_3dmProperties& operator=(const ON_3dmProperties&);

  void Default();

  ON_BOOL32 Read(ON_BinaryArchive&);
  ON_BOOL32 Write(ON_BinaryArchive&) const;

  void Dump( ON_TextLog& ) const;

  ON_3dmRevisionHistory  m_RevisionHistory;
  ON_3dmNotes            m_Notes;
  ON_WindowsBitmap       m_PreviewImage;     // preview image of model
  ON_3dmApplication      m_Application;      // application that created 3DM file
};

//////////////////////////////////////////////////////////////////////////////////////////

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_3DM_SETTINGS_INC_)
#define OPENNURBS_3DM_SETTINGS_INC_


///////////////////////////////////////////////////////////////////////
//
// units and tolerances
//

class ON_CLASS ON_3dmUnitsAndTolerances
{
public:
  ON_3dmUnitsAndTolerances();
  ON_3dmUnitsAndTolerances(const ON_3dmUnitsAndTolerances&);
  ~ON_3dmUnitsAndTolerances();
  ON_3dmUnitsAndTolerances& operator=(const ON_3dmUnitsAndTolerances&);

  void Default();

  bool Read( ON_BinaryArchive& );
  bool Write( ON_BinaryArchive& ) const;

  void Dump( ON_TextLog& ) const;

  //////////
  // Returns scale factor that needs to be applied to change from
  // the argument's unit system to m_unit_system.
  // When m_unit_system is not ON::custom_unit_system,
  // Scale(us) = ON::UnitScale(us,m_unit_system).  When Scale(us)
  // When m_unit_system is ON::custom_unit_system,
  // Scale(us) = ON::UnitScale(us,ON::meters)*m_custom_unit_scale.
  double Scale( ON::unit_system ) const;

  //ON::unit_system m_unit_system;
  ON_UnitSystem   m_unit_system;

  double          m_absolute_tolerance;  // in units (default = 1/100)
  double          m_angle_tolerance;     // in radians (default = 3 degrees)
  double          m_relative_tolerance;  // fraction >= 0 and < 1 (default = 1%)

  ON::distance_display_mode m_distance_display_mode;
  int m_distance_display_precision; // decimal mode: number of decimal places
                                    // fractional modes:
                                    //    denominator = (1/2)^m_distance_display_precision

  ////////////
  // These settings apply when m_unit_system is ON::custom_unit_system
  //
  //double m_custom_unit_scale;      // 1 meter = m_custom_unit_scale custom units
  //ON_wString m_custom_unit_name;   // name of custom units
};

///////////////////////////////////////////////////////////////////////
//
// Model settings
//   render mesh defaults
//   viewports
//   construction planes
//

class ON_CLASS ON_3dmAnnotationSettings
{
public:
  ON_3dmAnnotationSettings();
  ~ON_3dmAnnotationSettings();
  ON_3dmAnnotationSettings(const ON_3dmAnnotationSettings&);
  ON_3dmAnnotationSettings& operator=(const ON_3dmAnnotationSettings&);

  void Default();

  bool Read( ON_BinaryArchive& );
  bool Write( ON_BinaryArchive& ) const;

  void Dump( ON_TextLog& text_log ) const;

  // these are the running defaults for making dimensions
  // they are also the things written to the 3dm file as dimension settings
  double m_dimscale;       // model size / plotted size
  double m_textheight;
  double m_dimexe;
  double m_dimexo;
  double m_arrowlength;
  double m_arrowwidth;
  double m_centermark;

  /*
  Returns:
    Value of m_world_view_text_scale;
  */
  double WorldViewTextScale() const;

  /*
  Parameters:
    world_view_text_scale - [in]
      Sets value of m_world_view_text_scale.
  */
  void SetWorldViewTextScale(double world_view_text_scale );

  /*
  Returns:
    Value of m_world_view_hatch_scale;
  */
  double WorldViewHatchScale() const;

  /*
  Parameters:
    world_view_hatch_scale - [in]
      Sets value of m_world_view_hatch_scale.
  */
  void SetWorldViewHatchScale(double world_view_hatch_scale );


  /*
  Returns:
    Value of m_bEnableAnnotationScaling;
  */
  bool IsAnnotationScalingEnabled() const;

  /*
  Parameters:
    bEnable - [in]
      Sets value of m_bEnableAnnotationScaling.
  */
  void EnableAnnotationScaling( bool bEnable );

  /*
  Returns:
    Value of m_bEnableHatchScaling;
  */
  bool IsHatchScalingEnabled() const;

  /*
  Parameters:
    bEnable - [in]
      Sets value of m_bEnableHatchScaling.
  */
  void EnableHatchScaling( bool bEnable );

  // Present but not used in V4 or V5 - removed 5 August 2010 to make room
  // for m_world_view_text_scale and m_bEnableAnnotationScaling
  //// added 12/28/05 LW
  //double m_dimdle;
  //double m_dimgap;
private:
  // If m_bEnableAnnotationScaling is true,
  // and ON_Annotation2::m_annotative_scale is true,
  // and ON_Annotation2::m_type == ON::dtTextBlock,
  // and the text object is being displayed in a world
  // view (not a detail view and not a page view),
  // then the text will be scaled by m_world_view_text_scale.
  // The default is 1.0. Values <= 0.0 are not valid.
  float m_world_view_text_scale;
  float m_world_view_hatch_scale;
  
private:
  // If m_bEnableAnnotationScaling is false:
  //   * m_world_view_text_scale is ignored.
  //   * text is not scaled.
  //   * ON_DimStyle::DimScale() determines the scale 
  //     applied to all other annotation objects in all 
  //     types of views.
  //   * The value of ON_DetailView::m_page_per_model_ratio
  //     is applied to all objects (annotation and geometry)
  //     in the detail view.
  //
  // If m_bEnableAnnotationScaling is true:
  //   * m_world_view_text_scale is used as described above.
  //   * ON_DimStyle::DimScale() determines the scale 
  //     applied to all non text annotation objects in 
  //     world views. 
  //   * ON_DimStyle::DimScale() is ignored in page and 
  //     detail views. 
  //   * ON_DetailView::m_page_per_model_ratio is ingored
  //     for annotation objects in detail views, other
  //     geometry is scaled.
  //
  // Default is true.
  unsigned char m_bEnableAnnotationScaling;

  unsigned char m_bEnableHatchScaling;

private:
  unsigned char m_reserved[6];

public:

  ON::unit_system m_dimunits;  // units used to measure the dimension
  int m_arrowtype;     // 0: filled narrow triangular arrow
  int m_angularunits;  // 0: degrees, 1: radians
  int m_lengthformat;  // 0: decimal, ...
  int m_angleformat;   // 0: decimal degrees, ...
  int m_textalign;     // 0: above line, 1: in line, 2: horizontal
  int m_resolution;    // depends on m_lengthformat
                       // for decimal, digits past the decimal point

  ON_wString m_facename; // [LF_FACESIZE] // windows font name
};

//////////////////////////////////////////////////////////////////////////////////////////
//
// ON_3dmConstructionPlaneGridDefaults
//
// Default settings used for construction plane grids
class ON_CLASS ON_3dmConstructionPlaneGridDefaults
{
public:
  ON_3dmConstructionPlaneGridDefaults();
  ~ON_3dmConstructionPlaneGridDefaults();
  ON_3dmConstructionPlaneGridDefaults(const ON_3dmConstructionPlaneGridDefaults&);
  ON_3dmConstructionPlaneGridDefaults& operator=(const ON_3dmConstructionPlaneGridDefaults&);

  void Default();

  bool Write( ON_BinaryArchive& ) const;
  bool Read( ON_BinaryArchive& );

  void Dump( ON_TextLog& text_log ) const;

	double m_grid_spacing;   // distance between grid lines
  double m_snap_spacing;   // when "grid snap" is enabled, the
                           // distance between snap points.  Typically
                           // this is the same distance as grid spacing.
	int m_grid_line_count;   // number of grid lines in each direction
  int m_grid_thick_frequency; // thick line frequency
                            // 0: none,
                            // 1: all lines are thick,
                            // 2: every other is thick, ...

  ON_BOOL32 m_bShowGrid;
  ON_BOOL32 m_bShowGridAxes;
  ON_BOOL32 m_bShowWorldAxes;
};

//////////////////////////////////////////////////////////////////////////////////////////
//
// ON_3dmConstructionPlane
//
class ON_CLASS ON_3dmConstructionPlane
{
public:
  ON_3dmConstructionPlane();
  ~ON_3dmConstructionPlane();

  // default copy constructor and operator= work fine
  //ON_3dmConstructionPlane(const ON_3dmConstructionPlane&);
  //ON_3dmConstructionPlane& operator=(const ON_3dmConstructionPlane&);

  void Default();

  bool Write( ON_BinaryArchive& ) const;
  bool Read( ON_BinaryArchive& );

  void Dump( ON_TextLog& text_log ) const;

  ON_Plane    m_plane;

  // construction grid appearance
	double m_grid_spacing;   // distance between grid lines
  double m_snap_spacing;   // when "grid snap" is enabled, the
                           // distance between snap points.  Typically
                           // this is the same distance as grid spacing.
	int m_grid_line_count;   // number of grid lines in each direction
  int m_grid_thick_frequency; // thick line frequency
                            // 0: none,
                            // 1: all lines are thick,
                            // 2: every other is thick, ...
  bool m_bDepthBuffer; // false=grid is always drawn behind 3d geometry
                       // true=grid is drawn at its depth as a 3d plane
                       // and grid lines obscure things behind the grid.

  ON_wString  m_name;
};

#if defined(ON_DLL_TEMPLATE)
// This stuff is here because of a limitation in the way Microsoft
// handles templates and DLLs.  See Microsoft's knowledge base
// article ID Q168958 for details.
#pragma warning( push )
#pragma warning( disable : 4231 )
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ON_3dmConstructionPlane>;
#pragma warning( pop )
#endif

//////////////////////////////////////////////////////////////////////////////////////////
//
// ON_3dmViewPosition
//
class ON_CLASS ON_3dmViewPosition
{
public:
  // view window relative position and state in parent frame
  ON_3dmViewPosition();
  ~ON_3dmViewPosition();
  ON_3dmViewPosition(const ON_3dmViewPosition&);
  ON_3dmViewPosition& operator=(const ON_3dmViewPosition&);

  void Default();

  bool Write( ON_BinaryArchive& ) const;
  bool Read( ON_BinaryArchive& );

  // relative position of view window in main frame
  // if m_floating_viewport>0, this is relative position of the view window
  // on the virtual screen (union of potentially multiple monitors)
  double m_wnd_left;    // 0.0 to 1.0
  double m_wnd_right;
  double m_wnd_top;
  double m_wnd_bottom;
  ON_BOOL32 m_bMaximized;    // true if view window is maximized

  // m_floating_viewport is used to track floating viewport information.
  //  0 = the view is docked in the main application window.
  // >0 = the view is floating. When floating, this corresponds to the
  //      number of monitors on on the user's computer when the file was saved
  unsigned char m_floating_viewport;
private:
  // reserved for future use
  unsigned char m_reserved_1;
  unsigned char m_reserved_2;
  unsigned char m_reserved_3;
};

//////////////////////////////////////////////////////////////////////////////////////////
//
// ON_3dmViewTraceImage
//
class ON_CLASS ON_3dmViewTraceImage
{
public:
  ON_3dmViewTraceImage();
  ~ON_3dmViewTraceImage();
  bool operator==( const ON_3dmViewTraceImage& ) const;
  bool operator!=( const ON_3dmViewTraceImage& ) const;

  void Default();

  bool Write( ON_BinaryArchive& ) const;
  bool Read( ON_BinaryArchive& );

  // view window relative position and state in parent frame
  ON_Plane m_plane;
  double   m_width;
  double   m_height;

  ON_wString m_bitmap_filename;
  bool m_bGrayScale; // true if image should be black and white
  bool m_bHidden;    // true if image is currently hidden from view
  bool m_bFiltered;  // true if image should be filtered (bilinear) before displayed.
};


//////////////////////////////////////////////////////////////////////////////////////////
//
// ON_3dmViewTraceImage
//
class ON_CLASS ON_3dmWallpaperImage
{
public:
  ON_3dmWallpaperImage();
  ~ON_3dmWallpaperImage();
  bool operator==( const ON_3dmWallpaperImage& ) const;
  bool operator!=( const ON_3dmWallpaperImage& ) const;

  void Default();

  bool Write( ON_BinaryArchive& ) const;
  bool Read( ON_BinaryArchive& );

  ON_wString m_bitmap_filename;
  bool m_bGrayScale; // true if image should be black and white
  bool m_bHidden;    // true if image is currently hidden from view
};

//////////////////////////////////////////////////////////////////////////////////////////
//
// ON_3dmView
//

class ON_CLASS ON_3dmPageSettings
{
public:
  ON_3dmPageSettings();
  ~ON_3dmPageSettings();

  bool IsValid( ON_TextLog* text_log = 0 ) const;

  void Default();

  int m_page_number;

  // Overall size of the page in millimeters
  double m_width_mm;
  double m_height_mm;

  // Page margins in millimeters
  double m_left_margin_mm;
  double m_right_margin_mm;
  double m_top_margin_mm;
  double m_bottom_margin_mm;

  ON_wString m_printer_name;

  bool Write(ON_BinaryArchive& archive) const;
  bool Read(ON_BinaryArchive& archive);
};


class ON_CLASS ON_3dmView
{
public:
  ON_3dmView();
  ~ON_3dmView();

  // The C++ default copy constructor and operator= work fine.
  // Do not provide customized versions.
  // NO // ON_3dmView(const ON_3dmView&);
  // NO // ON_3dmView& operator=(const ON_3dmView&);

  void Default();

  bool Write( ON_BinaryArchive& ) const;
  bool Read( ON_BinaryArchive& );

  void Dump( ON_TextLog& text_log ) const;

  bool IsValid( ON_TextLog* text_log = 0 ) const;

  // view projection information
  ON_Viewport m_vp;

  // clipping planes
  // Prior to Dec 14, 2010 m_clipping_planes was not saved with the view. 
  // After Dec 14, 2010 m_clipping_planes is saved.
  ON_SimpleArray<ON_ClippingPlaneInfo> m_clipping_planes;

  // If true, the the camera location, camera direction,
  // and lens angle should not be changed.
  // It is ok to adjust clipping planes.
  bool m_bLockedProjection;

  ///////////////////////////////////////////////////////////////////////
  //
  // target point
  //

  /*
  Returns:
    Target point.  This point is saved on m_vp.m_target_point.
    The default constructor sets the target point to
    ON_3dPoint::UnsetPoint. You must explicitly set the target
    point if you want to use it.
  Remarks:
    The target point is stored on m_vp.m_target_point.  The
    value ON_3dmView.m_target is obsolete. This function always
    returns the value of m_vp.m_target_point.

  */
  ON_3dPoint TargetPoint() const;

  /*
  Description:
    Sets the target point.
  Parameters:
    target_point - [in]
      When in double, the point m_vp.FrustumCenterPoint(ON_UNSET_VALUE)
      is a good choice.
  Remarks:
    This point is saved on m_vp.m_target_point. Using this function
    keeps the obsolete ON_3dmView.m_target value equal to
    m_vp.m_target_point.
  */
  bool SetTargetPoint(ON_3dPoint target_point);

  ///////////////////////////////////////////////////////////////////////
  // OBSOLETE                                                          //
  //   Use ON_3dmView::SetTargetPoint() and ON_3dmView::TargetPoint()  //
  //   functions to set and get the target point. The m_target member  //
  //   will be removed in V6. The only reason m_target is still here   //
  //   is to avoid breaking the public SDK.                            //
  /* OBSOLETE */ ON_3dPoint m_target; // OBSOLETE                      //
  //   Hmm, did you notice that m_target is obsolete?  Try using the   //
  //   SetTargetPoint() and TargetPoint() functions instead.           //
  // OBSOLETE                                                          //
  ///////////////////////////////////////////////////////////////////////

  //
  ///////////////////////////////////////////////////////////////////////

  ON_wString  m_name;   // name on window

  // If m_display_mode_id is nil, then use m_display_mode
  // to show one of the "standard" (wireframe, shaded, rendered)
  // display modes.  If m_display_mode_id is not nil, then
  // ignore m_display_mode.
  ON_UUID m_display_mode_id;
  ON::display_mode m_display_mode;

  // position of view in parent window
  // (relative display device coordinates)
  ON_3dmViewPosition m_position;

  ON::view_type m_view_type; // model, page, or nested

  // If m_view_type == ON::page_view_type, then the m_page_settings
  // records the page size.  Otherwise, m_page_settings should
  // be ignored.
  ON_3dmPageSettings m_page_settings;

  // construction plane
  ON_3dmConstructionPlane m_cplane;
  bool m_bShowConstructionGrid;
  bool m_bShowConstructionAxes;

  // world axes icon
  bool m_bShowWorldAxes;

  // tracing image
  ON_3dmViewTraceImage m_trace_image;

  // wallpaper image
  ON_3dmWallpaperImage m_wallpaper_image;
};

#if defined(ON_DLL_TEMPLATE)
// This stuff is here because of a limitation in the way Microsoft
// handles templates and DLLs.  See Microsoft's knowledge base
// article ID Q168958 for details.
#pragma warning( push )
#pragma warning( disable : 4231 )
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ON_3dmView>;
#pragma warning( pop )
#endif

//////////////////////////////////////////////////////////////////////////////////////////
//
// ON_3dmRenderSettings
//

class ON_CLASS ON_3dmRenderSettings
{
public:
  ON_3dmRenderSettings();
  ~ON_3dmRenderSettings();
  ON_3dmRenderSettings(const ON_3dmRenderSettings&);
  ON_3dmRenderSettings& operator=(const ON_3dmRenderSettings&);

  void Default();

  bool Write( ON_BinaryArchive& ) const;
  bool Read( ON_BinaryArchive& );

  void Dump( ON_TextLog& text_log ) const;

  bool ScaleBackgroundToFit() const;
  void SetScaleBackgroundToFit( bool bScaleBackgroundToFit );

  //////////
  // false: image pixel size = current viewport size
  // true:  image pixel size = m_image_width X m_image_height pixels
  ON_BOOL32 m_bCustomImageSize;
  int  m_image_width;   // image width in pixels
  int  m_image_height;  // image height in pixels

private:
  bool m_bScaleBackgroundToFit;
  unsigned char m_reserved1[3];
public:

  ////////
  // Number of dots/inch (dots=pixels) to use when printing and
  // saving bitmaps. The default is 72.0 dots/inch.
  double m_image_dpi;
  //////////
  // unit system to use when converting image pixel size and dpi
  // information into a print size.  Default = inches
  ON::unit_system m_image_us;

  ON_Color m_ambient_light;

  int m_background_style; // 0 = solid color, 1 = "wallpaper" image, 2 = Gradient, 3 = Environment
  ON_Color m_background_color; // also Top color of gradient...
  ON_wString m_background_bitmap_filename;

  ON_BOOL32 m_bUseHiddenLights;

  ON_BOOL32 m_bDepthCue;
  ON_BOOL32 m_bFlatShade;

  ON_BOOL32 m_bRenderBackfaces;
  ON_BOOL32 m_bRenderPoints;
  ON_BOOL32 m_bRenderCurves;
  ON_BOOL32 m_bRenderIsoparams;
  ON_BOOL32 m_bRenderMeshEdges;
  ON_BOOL32 m_bRenderAnnotation;

  int m_antialias_style; // 0 = none, 1 = normal, 2 = best

  int m_shadowmap_style;    // 0 = none, 1 = normal, 2 = best
  int m_shadowmap_width;
  int m_shadowmap_height;
  double m_shadowmap_offset;

  ON_Color  m_background_bottom_color;

  // Flags that are used to determine which render settings a render
  // plugin uses, and which ones the display pipeline should use.
  // Note: Render plugins set these, and they don't need to persist
  //       in the document...Also, when set, they turn OFF their
  //       corresponding setting in the Display Attributes Manager's
  //       UI pages for "Rendered" mode.
  bool    m_bUsesAmbientAttr;
  bool    m_bUsesBackgroundAttr;
  bool    m_bUsesBackfaceAttr;
  bool    m_bUsesPointsAttr;
  bool    m_bUsesCurvesAttr;
  bool    m_bUsesIsoparmsAttr;
  bool    m_bUsesMeshEdgesAttr;
  bool    m_bUsesAnnotationAttr;
  bool    m_bUsesHiddenLightsAttr;

private:
  unsigned char m_reserved2[3];
};


//////////////////////////////////////////////////////////////////////////////////////////
//
// ON_EarthAnchorPoint
//

class ON_CLASS ON_EarthAnchorPoint
{
public:
  ON_EarthAnchorPoint();
  ~ON_EarthAnchorPoint();

  static
  int Compare(
          const ON_EarthAnchorPoint*,
          const ON_EarthAnchorPoint*
          );

  static
  int CompareEarthLocation(
          const ON_EarthAnchorPoint*,
          const ON_EarthAnchorPoint*
          );

  static
  int CompareModelDirection(
          const ON_EarthAnchorPoint*,
          const ON_EarthAnchorPoint*
          );

  static
  int CompareIdentification(
          const ON_EarthAnchorPoint*,
          const ON_EarthAnchorPoint*
          );

  void Default();
  bool Read( ON_BinaryArchive& );
  bool Write( ON_BinaryArchive& ) const;

  // Point on the Earth
  //   Latitude (degrees):  +90 = north pole, 0 = equator, -90 = south pole
  //   Longitude (degrees):   0 = prime meridian (Greenwich meridian)
  //   Elevation (meters):
  double m_earth_basepoint_latitude;  // in decimal degrees
  double m_earth_basepoint_longitude; // in decimal degrees
  double m_earth_basepoint_elevation; // in meters
  int m_earth_basepoint_elevation_zero; // 0 = ground level
                                        // 1 = mean sea level
                                        // 2 = center of earth

  // Corresponding model point in model coordinates.
  ON_3dPoint  m_model_basepoint; // in model coordinates

  // Earth directions in model coordinates
  ON_3dVector m_model_north; // in model coordinates
  ON_3dVector m_model_east;  // in model coordinates

  // Identification information about this location
  ON_UUID    m_id;           // unique id for this anchor point
  ON_wString m_name;
  ON_wString m_description;
  ON_wString m_url;
  ON_wString m_url_tag;      // UI link text for m_url

  /*
  Parameters:
    model_compass - [out]
      A plane in model coordinates whose xaxis points East,
      yaxis points North and zaxis points up.  The origin
      is set to m_model_basepoint.
  */
  bool GetModelCompass(
          ON_Plane& model_compass
          ) const;

  /*
  Description:
    Get a transformation from model coordinates to earth coordinates.
    This transformation assumes the model is small enough that
    the curvature of the earth can be ignored.
  Parameters:
    model_unit_system - [in]
    model_to_earth - [out]
      Transformation from model coordinates to earth locations
      (degrees latitude,degrees longitude,elevation in meters)
  Remarks:
    If M is a point in model coordinates and E = model_to_earth*M,
    then
       E.x = latitude in decimal degrees
       E.y = longitude in decimal degrees
       E.z = elevation in meters above mean sea level

    Because the earth is not flat, there is a small amount of error
    when using a linear transformation to calculate oblate spherical
    coordinates.  This error is small.  If the distance from P to M
    is d meters, then the approximation error is

       latitude error  <=
       longitude error <=
       elevation error <= 6379000*((1 + (d/6356000)^2)-1) meters

    In particular, if every point in the model is within 1000 meters of
    the m_model_basepoint, then the maximum approximation errors are

       latitude error  <=
       longitude error <=
       elevation error <= 8 centimeters
  */
  bool GetModelToEarthXform(
          const ON_UnitSystem& model_unit_system,
          ON_Xform& model_to_earth
          ) const;
};



class ON_CLASS ON_3dmIOSettings
{
public:
  ON_3dmIOSettings();

  void Default();

  bool Read(ON_BinaryArchive&);
  bool Write(ON_BinaryArchive&) const;

  // bitmaps associated with rendering materials
  bool m_bSaveTextureBitmapsInFile;

  // As of 7 February 2012, the m_idef_link_update setting
  // controls if, when and how linked and linked_and_embedded
  // instance defintions are updated when the source archive
  // that was used to create the idef has changed.
  int m_idef_link_update;  
      // 1 = prompt - ask the user if the idef should be updated.
      // 2 = always update - no prompting
      // 3 = never update - no prompting
      // Any value not equal to 1,2 or 3 shall be treated as 1.
};

//////////////////////////////////////////////////////////////////////////////////////////
//
// ON_3dmSettings
//

class ON_CLASS ON_3dmSettings
{
public:
  ON_3dmSettings();
  ~ON_3dmSettings();

  // C++ copy constructor and operator= work fine.
  // Do not provide custom versions.
  // NO // ON_3dmSettings(const ON_3dmSettings&);
  // NO // ON_3dmSettings& operator=(const ON_3dmSettings&);

  void Default();

  bool Read(ON_BinaryArchive&);
  bool Write(ON_BinaryArchive&) const;

  void Dump( ON_TextLog& ) const;

  // model URL (can be empty)
  ON_wString m_model_URL;

  // Model basepoint is used when the file is read as
  // an instance definition and is the point that is
  // mapped to the origin in the instance definition.
  ON_3dPoint m_model_basepoint;


  // If set, this is the model's location on the earth.
  // This information is used when the model is used
  // with GIS information.
  ON_EarthAnchorPoint m_earth_anchor_point;

  // Model space tolerances and unit system
  ON_3dmUnitsAndTolerances m_ModelUnitsAndTolerances;

  // Page space (printing/paper) tolerances and unit system
  ON_3dmUnitsAndTolerances m_PageUnitsAndTolerances;

  // settings used for automatically created rendering meshes
  ON_MeshParameters m_RenderMeshSettings;

  // saved custom settings
  ON_MeshParameters m_CustomRenderMeshSettings;

  // settings used for automatically created analysis meshes
  ON_MeshParameters m_AnalysisMeshSettings;

  // settings used when annotation objects are created
  ON_3dmAnnotationSettings m_AnnotationSettings;

  ON_ClassArray<ON_3dmConstructionPlane> m_named_cplanes;
  ON_ClassArray<ON_3dmView>              m_named_views;
  ON_ClassArray<ON_3dmView>              m_views; // current viewports
  ON_UUID m_active_view_id; // id of "active" viewport

  // These fields determine what layer, material, color, line style, and
  // wire density are used for new objects.
  int m_current_layer_index;

  int m_current_material_index;
  ON::object_material_source m_current_material_source;

  ON_Color m_current_color;
  ON::object_color_source m_current_color_source;

  ON_Color m_current_plot_color;
  ON::plot_color_source m_current_plot_color_source;

  int m_current_linetype_index;
  ON::object_linetype_source m_current_linetype_source;

  int m_current_font_index;

  int m_current_dimstyle_index;

  // Surface wireframe density
  //
  //   @untitled table
  //   0       boundary + "knot" wires
  //   1       boundary + "knot" wires + 1 interior wire if no interior "knots"
  //   N>=2    boundary + "knot" wires + (N-1) interior wires
  int m_current_wire_density;

  ON_3dmRenderSettings m_RenderSettings;

  // default settings for construction plane grids
  ON_3dmConstructionPlaneGridDefaults m_GridDefaults;

  // World scale factor to apply to non-solid linetypes
  // for model display.  For plotting, the linetype settings
  // are used without scaling.
  double m_linetype_display_scale;

  // Plugins that were loaded when the file was saved.
  ON_ClassArray<ON_PlugInRef> m_plugin_list;

  ON_3dmIOSettings m_IO_settings;
private:
  bool Read_v1(ON_BinaryArchive&);
  bool Read_v2(ON_BinaryArchive&);
  bool Write_v1(ON_BinaryArchive&) const;
  bool Write_v2(ON_BinaryArchive&) const;
};

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

////////////////////////////////////////////////////////////////
//
//   defines ON_3dmObjectAttributes
//
////////////////////////////////////////////////////////////////

#if !defined(OPENNURBS_3DM_ATTRIBUTES_INC_)
#define OPENNURBS_3DM_ATTRIBUTES_INC_


/*
Description:
  Top level OpenNURBS objects have geometry and attributes.  The
  geometry is stored in some class derived from ON_Geometry and
  the attributes are stored in an ON_3dmObjectAttributes class.
  Examples of attributes are object name, object id, display
  attributes, group membership, layer membership, and so on.

Remarks:
  7 January 2003 Dale Lear
    Derived from ON_Object so ON_UserData can be attached
    to ON_3dmObjectAttributes.
*/

class ON_CLASS ON_3dmObjectAttributes : public ON_Object
{
  ON_OBJECT_DECLARE(ON_3dmObjectAttributes);

public:
  // ON_Object virtual interface.  See ON_Object
  // for details.

  // virtual
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;
  // virtual
  void Dump( ON_TextLog& ) const;
  // virtual
  unsigned int SizeOf() const;
  // virtual
  ON_BOOL32 Write(ON_BinaryArchive&) const;
  // virtual
  ON_BOOL32 Read(ON_BinaryArchive&);

  /*
  Returns:
    True if successful.
    (xform is invertable or didn't need to be).
  */
  bool Transform( const ON_Xform& xform );

  // attributes of geometry and dimension table objects
public:
  ON_3dmObjectAttributes();
  ~ON_3dmObjectAttributes();

  // Default C++ copy constructor and operator= work fine
  // Do not provide custom versions
  // NO // ON_3dmObjectAttributes(const ON_3dmObjectAttributes&);
  // NO // ON_3dmObjectAttributes& operator=(const ON_3dmObjectAttributes&);

  bool operator==(const ON_3dmObjectAttributes&) const;
  bool operator!=(const ON_3dmObjectAttributes&) const;

  // Initializes all attributes to the default values.
  void Default();

  // Interface ////////////////////////////////////////////////////////

  // An OpenNURBS object must be in one of three modes: normal, locked
  // or hidden.  If an object is in normal mode, then the object's layer
  // controls visibility and selectability.  If an object is locked, then
  // the object's layer controls visibility by the object cannot be selected.
  // If the object is hidden, it is not visible and it cannot be selected.
  ON::object_mode Mode() const;
  void SetMode( ON::object_mode ); // See Mode().

  /*
  Description:
    Use this query to determine if an object is part of an
    instance definition.
  Returns:
    True if the object is part of an instance definition.
  */
  bool IsInstanceDefinitionObject() const;

  /*
  Returns:
    Returns true if object is visible.
  See Also:
    ON_3dmObjectAttributes::SetVisible
  */
  bool IsVisible() const;

  /*
  Description:
    Controls object visibility
  Parameters:
    bVisible - [in] true to make object visible,
                    false to make object invisible
  See Also:
    ON_3dmObjectAttributes::IsVisible
  */
  void SetVisible( bool bVisible );

  // The Linetype used to display an OpenNURBS object is specified in one of two ways.
  // If LinetypeSource() is ON::linetype_from_layer, then the object's layer
  // ON_Layer::Linetype() is used.
  // If LinetypeSource() is ON::linetype_from_object, then value of m_linetype is used.
  ON::object_linetype_source LinetypeSource() const;
  void SetLinetypeSource( ON::object_linetype_source ); // See LinetypeSource().

  // The color used to display an OpenNURBS object is specified in one of three ways.
  // If ColorSource() is ON::color_from_layer, then the object's layer
  // ON_Layer::Color() is used.
  // If ColorSource() is ON::color_from_object, then value of m_color is used.
  // If ColorSource() is ON::color_from_material, then the diffuse color of the object's
  // render material is used.  See ON_3dmObjectAttributes::MaterialSource() to
  // determine where to get the definition of the object's render material.
  ON::object_color_source ColorSource() const;
  void SetColorSource( ON::object_color_source ); // See ColorSource().

  // The color used to plot an OpenNURBS object on paper is specified
  // in one of three ways.
  // If PlotColorSource() is ON::plot_color_from_layer, then the object's layer
  // ON_Layer::PlotColor() is used.
  // If PlotColorSource() is ON::plot_color_from_object, then value of PlotColor() is used.
  ON::plot_color_source PlotColorSource() const;
  void SetPlotColorSource( ON::plot_color_source ); // See PlotColorSource().

  ON::plot_weight_source PlotWeightSource() const;
  void SetPlotWeightSource( ON::plot_weight_source );


  // OpenNURBS objects can be displayed in one of three ways: wireframe,
  // shaded, or render preview.  If the display mode is ON::default_display,
  // then the display mode of the viewport detrmines how the object
  // is displayed.  If the display mode is ON::wireframe_display,
  // ON::shaded_display, or ON::renderpreview_display, then the object is
  // forced to display in that mode.
  ON::display_mode DisplayMode() const;
  void SetDisplayMode( ON::display_mode  ); // See DisplayMode().

  /*
  Description:
    If "this" has attributes (color, plot weight, ...) with
    "by parent" sources, then the values of those attributes
    on parent_attributes are copied.
  Parameters:
    parent_attributes - [in]
    parent_layer - [in]
    control_limits - [in]
      The bits in control_limits determine which attributes may
      may be copied.
                1: visibility
                2: color
                4: render material
                8: plot color
            0x10: plot weight
            0x20: linetype
            0x40: display order

  Returns:
     The bits in the returned integer indicate which attributes were
     actually modified.

                1: visibility
                2: color
                4: render material
                8: plot color
            0x10: plot weight
            0x20: linetype
            0x40: display order
  */
  ON_DEPRECATED unsigned int ApplyParentalControl(
         const ON_3dmObjectAttributes& parent_attributes,
         unsigned int control_limits = 0xFFFFFFFF
         );

  unsigned int ApplyParentalControl(
         const ON_3dmObjectAttributes& parent_attributes,
         const ON_Layer& parent_layer,
         unsigned int control_limits = 0xFFFFFFFF
         );

  // Every OpenNURBS object has a UUID (universally unique identifier).  The
  // default value is NULL.  When an OpenNURBS object is added to a model, the
  // value is checked.  If the value is NULL, a new UUID is created.  If the
  // value is not NULL but it is already used by another object in the model,
  // a new UUID is created.  If the value is not NULL and it is not used by
  // another object in the model, then that value persists. When an object
  // is updated, by a move for example, the value of m_uuid persists.
  ON_UUID m_uuid;

  // OpenNURBS object have optional text names.  More than one object in
  // a model can have the same name and some objects may have no name.
  ON_wString m_name;

  // OpenNURBS objects may have an URL.  There are no restrictions on what
  // value this URL may have.  As an example, if the object came from a
  // commercial part library, the URL might point to the definition of that
  // part.
  ON_wString m_url;

  // Layer definitions in an OpenNURBS model are stored in a layer table.
  // The layer table is conceptually an array of ON_Layer classes.  Every
  // OpenNURBS object in a model is on some layer.  The object's layer
  // is specified by zero based indices into the ON_Layer array.
  int m_layer_index;

  // Linetype definitions in an OpenNURBS model are stored in a linetype table.
  // The linetype table is conceptually an array of ON_Linetype classes.  Every
  // OpenNURBS object in a model references some linetype.  The object's linetype
  // is specified by zero based indices into the ON_Linetype array.
  // index 0 is reserved for continuous linetype (no pattern)
  int m_linetype_index;

  // Rendering material:
  //   If you want something simple and fast, set
  //   m_material_index to the index of the rendering material
  //   and ignore m_rendering_attributes.
  //   If you are developing a high quality plug-in renderer,
  //   and a user is assigning one of your fabulous rendering
  //   materials to this object, then add rendering material
  //   information to the  m_rendering_attributes.m_materials[]
  //   array.
  //
  // Developers:
  //   As soon as m_rendering_attributes.m_materials[] is not empty,
  //   rendering material queries slow down.  Do not populate
  //   m_rendering_attributes.m_materials[] when setting
  //   m_material_index will take care of your needs.
  int m_material_index;
  ON_ObjectRenderingAttributes m_rendering_attributes;

  //////////////////////////////////////////////////////////////////
  //
  // BEGIN: Per object mesh parameter support
  //

  /*
  Parameters:
    mp - [in]
      per object mesh parameters
  Returns:
    True if successful.
  */
  bool SetCustomRenderMeshParameters(const class ON_MeshParameters& mp);

  /*
  Parameters:
    bEnable - [in]
      true to enable use of the per object mesh parameters.
      false to disable use of the per object mesh parameters.
  Returns:
    False if the object doe not have per object mesh parameters
    and bEnable was true.  Use SetMeshParameters() to set
    per object mesh parameters.
  Remarks:
    Sets the value of ON_MeshParameters::m_bCustomSettingsDisabled 
    to !bEnable
  */
  bool EnableCustomRenderMeshParameters(bool bEnable);

  /*
  Returns:
    Null or a pointer to fragile mesh parameters.
    If a non-null pointer is returned, copy it and use the copy.
    * DO NOT SAVE THIS POINTER FOR LATER USE. A call to 
      DeleteMeshParameters() will delete the class.
    * DO NOT const_cast the returned pointer and change its
      settings.  You must use either SetMeshParameters()
      or EnableMeshParameters() to change settings.
  Remarks:
    If the value of ON_MeshParameters::m_bCustomSettingsDisabled is
    true, then do no use these parameters to make a render mesh.
  */
  const ON_MeshParameters* CustomRenderMeshParameters() const;

  /*
  Description:
    Deletes any per object mesh parameters.
  */
  void DeleteCustomRenderMeshParameters();

  //
  // END: Per object mesh parameter support
  //
  //////////////////////////////////////////////////////////////////


  /*
  Description:
    Determine if the simple material should come from
    the object or from it's layer.
    High quality rendering plug-ins should use m_rendering_attributes.
  Returns:
    Where to get material information if you do are too lazy
    to look in m_rendering_attributes.m_materials[].
  */
  ON::object_material_source MaterialSource() const;

  /*
  Description:
    Specifies if the simple material should be the one
    indicated by the material index or the one indicated
    by the object's layer.
  Parameters:
    ms - [in]
  */
  void SetMaterialSource( ON::object_material_source ms );

  // If ON::color_from_object == ColorSource(), then m_color is the object's
  // display color.
  ON_Color      m_color;

  // If ON::plot_color_from_object == PlotColorSource(), then m_color is the object's
  // display color.
  ON_Color      m_plot_color;

  // Display order used to force objects to be drawn on top or behind each other
  // 0  = draw object in standard depth buffered order
  // <0 = draw object behind "normal" draw order objects
  // >0 = draw object on top of "noraml" draw order objects
  // Larger number draws on top of smaller number.
  int m_display_order;

  // Plot weight in millimeters.
  //   =0.0 means use the default width
  //   <0.0 means don't plot (visible for screen display, but does not show on plot)
  double m_plot_weight_mm;

  // Used to indicate an object has a decoration (like an arrowhead on a curve)
  ON::object_decoration  m_object_decoration;

  // When a surface object is displayed in wireframe, m_wire_density controls
  // how many isoparametric wires are used.
  //
  //   @table
  //   value    number of isoparametric wires
  //   -1       boundary wires
  //    0       boundary and knot wires
  //    1       boundary and knot wires and, if there are no
  //            interior knots, a single interior wire.
  //   N>=2     boundary and knot wires and (N-1) interior wires
  int m_wire_density;


  // If m_viewport_id is nil, the object is active in
  // all viewports. If m_viewport_id is not nil, then
  // this object is only active in a specific view.
  // This field is primarily used to assign page space
  // objects to a specific page, but it can also be used
  // to restrict model space to a specific view.
  ON_UUID m_viewport_id;

  // Starting with V4, objects can be in either model space
  // or page space.  If an object is in page space, then
  // m_viewport_id is not nil and identifies the page it
  // is on.
  ON::active_space m_space;

private:
  bool m_bVisible;
  unsigned char m_mode;               // (m_mode % 16) = ON::object_mode values
                                      // (m_mode / 16) = ON::display_mode values
  unsigned char m_color_source;       // ON::object_color_source values
  unsigned char m_plot_color_source;  // ON::plot_color_source values
  unsigned char m_plot_weight_source; // ON::plot_weight_source values
  unsigned char m_material_source;    // ON::object_material_source values
  unsigned char m_linetype_source;    // ON::object_linetype_source values

  unsigned char m_reserved_0;
  
  ON_SimpleArray<int> m_group; // array of zero based group indices
public:

  // group interface

  // returns number of groups object belongs to
  int GroupCount() const;

  // Returns and array an array of GroupCount() zero based
  // group indices.  If GroupCount() is zero, then GroupList()
  // returns NULL.
  const int* GroupList() const;

  // Returns GroupCount() and puts a list of zero based group indices
  // into the array.
  int GetGroupList(ON_SimpleArray<int>&) const;

  // Returns the index of the last group in the group list
  // or -1 if the object is not in any groups
  int TopGroup() const;

  // Returns true if object is in group with the specified index
  ON_BOOL32 IsInGroup(
    int // zero based group index
    ) const;

  // Returns true if the object is in any of the groups in the list
  ON_BOOL32 IsInGroups(
    int,       // group_list_count
    const int* // group_list[] array
    ) const;

  // Returns true if object is in any of the groups in the list
  ON_BOOL32 IsInGroups(
    const ON_SimpleArray<int>& // group_list[] array
    ) const;

  // Adds object to the group with specified index by appending index to
  // group list (If the object is already in group, nothing is changed.)
  void AddToGroup(
    int // zero based group index
    );

  // Removes object from the group with specified index.  If the
  // object is not in the group, nothing is changed.
  void RemoveFromGroup(
    int // zero based group index
    );

  // removes the object from the last group in the group list
  void RemoveFromTopGroup();

  // Removes object from all groups.
  void RemoveFromAllGroups();


  // display material references

  /*
  Description:
    Searches for a matching display material.  For a given
    viewport id, there is at most one display material.
    For a given display material id, there can be multiple
    viewports.  If there is a display reference in the
    list with a nil viewport id, then the display material
    will be used in all viewports that are not explictly
    referenced in other ON_DisplayMaterialRefs.

  Parameters:
    search_material - [in]
    found_material - [out]

    If FindDisplayMaterialRef(), the input value of search_material
    is never changed.  If FindDisplayMaterialRef() returns true,
    the chart shows the output value of display_material.  When
    there are multiple possibilities for a match, the matches
    at the top of the chart have higher priority.

    search_material  found_material
    input value      output value

    (nil,nil)        (nil,did) if (nil,did) is in the list.
    (nil,did)        (vid,did) if (vid,did) is in the list.
    (nil,did)        (nil,did) if (nil,did) is in the list.
    (vid,nil)        (vid,did) if (vid,did) is in the list
    (vid,nil)        (vid,did) if (nil,did) is in the list
    (vid,did)        (vid,did) if (vid,did) is in the list.

  Example:
    ON_UUID display_material_id = ON_nil_uuid;
    ON_Viewport vp = ...;
    ON_DisplayMaterialRef search_dm;
    search_dm.m_viewport_id = vp.ViewportId();
    ON_DisplayMaterialRef found_dm;
    if ( attributes.FindDisplayMaterial(search_dm, &found_dm) )
    {
      display_material_id = found_dm.m_display_material_id;
    }

  Returns:
    True if a matching display material is found.
  See Also:
    ON_3dmObjectAttributes::AddDisplayMaterialRef
    ON_3dmObjectAttributes::RemoveDisplayMaterialRef
  */
  bool FindDisplayMaterialRef(
      const ON_DisplayMaterialRef& search_material,
      ON_DisplayMaterialRef* found_material = NULL
    ) const;

  /*
  Description:
    Quick way to see if a viewport has a special material.
  Parameters:
    viewport_id - [in]
    display_material_id - [out]
  Returns:
    True if a material_id is assigned.
  */
  bool FindDisplayMaterialId(
        const ON_UUID& viewport_id,
        ON_UUID* display_material_id = NULL
        ) const;

  /*
  Description:
    Add a display material reference to the attributes.  If
    there is an existing entry with a matching viewport id,
    the existing entry is replaced.
  Parameters:
    display_material - [in]
  Returns:
    True if input is valid (material id != nil)
  See Also:
    ON_3dmObjectAttributes::FindDisplayMaterialRef
    ON_3dmObjectAttributes::RemoveDisplayMaterialRef
  */
  bool AddDisplayMaterialRef(
    ON_DisplayMaterialRef display_material
    );

  /*
  Description:
    Remove a display material reference from the list.
  Parameters:
    viewport_id - [in] Any display material references
      with this viewport id will be removed.  If nil,
      then viewport_id is ignored.
    display_material_id - [in]
      Any display material references that match the
      viewport_id and have this display_material_id
      will be removed.  If nil, then display_material_id
      is ignored.
  Returns:
    True if a display material reference was removed.
  See Also:
    ON_3dmObjectAttributes::FindDisplayMaterialRef
    ON_3dmObjectAttributes::AddDisplayMaterialRef
  */
  bool RemoveDisplayMaterialRef(
    ON_UUID viewport_id,
    ON_UUID display_material_id = ON_nil_uuid
    );

  /*
  Description:
    Remove a the entire display material reference list.
  */
  void RemoveAllDisplayMaterialRefs();

  /*
  Returns:
    Number of display material references.
  */
  int DisplayMaterialRefCount() const;

  ON_SimpleArray<ON_DisplayMaterialRef> m_dmref;

private:
  bool WriteV5Helper( ON_BinaryArchive& file ) const;
  bool ReadV5Helper( ON_BinaryArchive& file );
};

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_ANNOTATION_INC_)
#define OPENNURBS_ANNOTATION_INC_


class ON_CLASS ON_AnnotationTextDot : public ON_Point
{
  // 3d annotation dot with text
  ON_OBJECT_DECLARE(ON_AnnotationTextDot);
public:
  ON_AnnotationTextDot();
  ~ON_AnnotationTextDot();
  ON_AnnotationTextDot(const ON_AnnotationTextDot&);
  ON_AnnotationTextDot& operator=(const ON_AnnotationTextDot&);

  /////////////////////////////////////////////////////////////////
  //
  // ON_Object overrides
  //

  /*
  Description:
    Tests an object to see if its data members are correctly
    initialized.
  Parameters:
    text_log - [in] if the object is not valid and text_log
        is not NULL, then a brief englis description of the
        reason the object is not valid is appended to the log.
        The information appended to text_log is suitable for
        low-level debugging purposes by programmers and is
        not intended to be useful as a high level user
        interface tool.
  Returns:
    @untitled table
    true     object is valid
    false    object is invalid, uninitialized, etc.
  Remarks:
    Overrides virtual ON_Object::IsValid
  */
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  void Dump( ON_TextLog& ) const; // for debugging

  ON_BOOL32 Write(
         ON_BinaryArchive&  // serialize definition to binary archive
       ) const;

  ON_BOOL32 Read(
         ON_BinaryArchive&  // restore definition from binary archive
       );

  ON_wString m_text;
};

class ON_CLASS ON_AnnotationArrow : public ON_Geometry
{
  // 3d annotation arrow
  ON_OBJECT_DECLARE(ON_AnnotationArrow);
public:
  ON_AnnotationArrow();
  ~ON_AnnotationArrow();
  ON_AnnotationArrow(const ON_AnnotationArrow&);
  ON_AnnotationArrow& operator=(const ON_AnnotationArrow&);

  /////////////////////////////////////////////////////////////////
  //
  // ON_Object overrides
  //

  /*
  Description:
    Tests an object to see if its data members are correctly
    initialized.
  Parameters:
    text_log - [in] if the object is not valid and text_log
        is not NULL, then a brief englis description of the
        reason the object is not valid is appended to the log.
        The information appended to text_log is suitable for
        low-level debugging purposes by programmers and is
        not intended to be useful as a high level user
        interface tool.
  Returns:
    @untitled table
    true     object is valid
    false    object is invalid, uninitialized, etc.
  Remarks:
    Overrides virtual ON_Object::IsValid
  */
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  void Dump( ON_TextLog& ) const; // for debugging

  ON_BOOL32 Write(
         ON_BinaryArchive&  // serialize definition to binary archive
       ) const;

  ON_BOOL32 Read(
         ON_BinaryArchive&  // restore definition from binary archive
       );

  ON::object_type ObjectType() const;

  /////////////////////////////////////////////////////////////////
  //
  // ON_Geometry overrides
  //

  int Dimension() const;

  // work horse bounding box getter
  ON_BOOL32 GetBBox( // returns true if successful
         double*,    // boxmin[dim]
         double*,    // boxmax[dim]
         ON_BOOL32 = false  // true means grow box
         ) const;

  ON_BOOL32 Transform(
         const ON_Xform&
         );

  /////////////////////////////////////////////////////////////////
  //
  // Interface
  //
  ON_3dVector Vector() const;
  ON_3dPoint Head() const;
  ON_3dPoint Tail() const;

  ON_3dPoint m_tail;
  ON_3dPoint m_head;
};

////////////////////////////////////////////////////////////////
//
//   ON_Annotation - used to serialize definitions of annotation
//                   objects (dimensions, text blocks, etc.).
//

class ON_CLASS ON_Annotation : public ON_Geometry
{
  ON_OBJECT_DECLARE(ON_Annotation);

  enum SYMBOLS
  {
    degreesym = 176,
    radiussym = 'R',
    diametersym = 216,
    plusminussym = 177
  };



public:

  virtual ON_BOOL32 IsRealObject() const = 0;

  ON_Annotation();
  ON_Annotation(const ON_Annotation&);
  ~ON_Annotation();
  ON_Annotation& operator=(const ON_Annotation&);

  void Create();  // initialize class's fields assuming
                  // memory is uninitialized
  void Destroy();
  void EmergencyDestroy();

  /////////////////////////////////////////////////////////////////
  //
  // ON_Object overrides
  //

  /*
  Description:
    Tests an object to see if its data members are correctly
    initialized.
  Parameters:
    text_log - [in] if the object is not valid and text_log
        is not NULL, then a brief englis description of the
        reason the object is not valid is appended to the log.
        The information appended to text_log is suitable for
        low-level debugging purposes by programmers and is
        not intended to be useful as a high level user
        interface tool.
  Returns:
    @untitled table
    true     object is valid
    false    object is invalid, uninitialized, etc.
  Remarks:
    Overrides virtual ON_Object::IsValid
  */
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  void Dump( ON_TextLog& ) const; // for debugging

  ON_BOOL32 Write(
         ON_BinaryArchive&  // serialize definition to binary archive
       ) const;

  ON_BOOL32 Read(
         ON_BinaryArchive&  // restore definition from binary archive
       );

  ON::object_type ObjectType() const;

  /////////////////////////////////////////////////////////////////
  //
  // ON_Geometry overrides
  //

  int Dimension() const;

  ON_BOOL32 GetBBox( // returns true if successful
         double*,    // boxmin[dim]
         double*,    // boxmax[dim]
         ON_BOOL32 = false  // true means grow box
         ) const;

  ON_BOOL32 Transform(
         const ON_Xform&
         );

  /////////////////////////////////////////////////////////////////
  //
  // ON_Annotation interface
  //

  // use these to get/set the current annotation settings
  static const ON_3dmAnnotationSettings& AnnotationSettings();
  static void SetAnnotationSettings( const ON_3dmAnnotationSettings* );

  bool IsText() const;
  bool IsLeader() const;
  bool IsDimension() const;

  virtual double NumericValue();
  virtual void SetTextToDefault();

  void SetType( ON::eAnnotationType type );
  ON::eAnnotationType Type() const;
  void SetTextDisplayMode( ON::eTextDisplayMode mode);
  ON::eTextDisplayMode TextDisplayMode() const;

  void SetPlane( const ON_Plane& plane );
  ON_Plane Plane() const;
  int PointCount() const;
  void SetPoints( const ON_SimpleArray<ON_2dPoint>& points );
  const ON_SimpleArray<ON_2dPoint>& Points() const;
  void SetPoint( int idx, ON_3dPoint point );
  ON_2dPoint Point( int idx ) const;
  void SetUserText( const wchar_t* string );
  const ON_wString& UserText() const;
  void SetDefaultText( const wchar_t* string );
  const ON_wString& DefaultText() const;
  void SetUserPositionedText( int bUserPositionedText );
  bool UserPositionedText() const;

  // to convert world 3d points to and from annotation 2d points
  bool GetECStoWCSXform( ON_Xform& xform ) const;
  bool GeWCStoECSXform( ON_Xform& xform ) const;

  ON::eAnnotationType m_type;          // enum for type of annotation
                                       // DimLinear, DimRadius, etc.

  ON::eTextDisplayMode m_textdisplaymode; // how the text is displayed
                                       // Horizontal, InLine, AboveLine

  ON_Plane m_plane;                    // ECS reference plane in WCS coordinates
  ON_SimpleArray<ON_2dPoint> m_points; // Definition points for the dimension

  ON_wString m_usertext;               // "<>", or user override
  ON_wString m_defaulttext;            // The displayed text string

  bool m_userpositionedtext;           // true: User has positioned text
                                       // false: use default location
};


class ON_CLASS ON_LinearDimension : public ON_Annotation
{
  ON_OBJECT_DECLARE(ON_LinearDimension);

public:
  ON_BOOL32 IsRealObject() const;
  ON_LinearDimension();
  ON_LinearDimension(const ON_LinearDimension&);
  ~ON_LinearDimension();
  ON_LinearDimension& operator=(const ON_LinearDimension&);

  double NumericValue();
  void SetTextToDefault();
  void EmergencyDestroy();
};

class ON_CLASS ON_RadialDimension : public ON_Annotation
{
  ON_OBJECT_DECLARE(ON_RadialDimension);

public:
  ON_BOOL32 IsRealObject() const;
  ON_RadialDimension();
  ON_RadialDimension(const ON_RadialDimension&);
  ~ON_RadialDimension();
  ON_RadialDimension& operator=(const ON_RadialDimension&);

  double NumericValue();
  void SetTextToDefault();

  void EmergencyDestroy();
};

class ON_CLASS ON_AngularDimension : public ON_Annotation
{
  ON_OBJECT_DECLARE(ON_AngularDimension);

public:
  ON_BOOL32 IsRealObject() const;

  ON_AngularDimension();
  ON_AngularDimension(const ON_AngularDimension&);
  ~ON_AngularDimension();
  ON_AngularDimension& operator=(const ON_AngularDimension&);

  void EmergencyDestroy();

  ON_BOOL32 Write( ON_BinaryArchive& file ) const;
  ON_BOOL32 Read( ON_BinaryArchive& file );

  void SetAngle( double angle ) { m_angle = angle; }
  double Angle() const { return m_angle; }
  void SetRadius( double radius ) { m_radius = radius; }
  double Radius() const { return m_radius; }

  double NumericValue();
  void SetTextToDefault();


private:
  double m_angle;      // angle being dimensioned
  double m_radius;     // radius for dimension arc
};

class ON_CLASS ON_TextEntity : public ON_Annotation
{
  ON_OBJECT_DECLARE(ON_TextEntity);

public:
  ON_BOOL32 IsRealObject() const;
  ON_TextEntity();
  ON_TextEntity(const ON_TextEntity&);
  ~ON_TextEntity();
  ON_TextEntity& operator=(const ON_TextEntity&);

  void EmergencyDestroy();

  ON_BOOL32 Write( ON_BinaryArchive& file ) const;
  ON_BOOL32 Read( ON_BinaryArchive& file );

  void SetFaceName( ON_wString string ) { m_facename = string; }
  ON_wString FaceName() const { return m_facename; }
  void SetFontWeight( int weight ) { m_fontweight = weight; }
  int FontWeight() const { return m_fontweight; }
  void SetHeight( double height ) { m_height = height; }
  double Height() const { return m_height; }

private:
  ON_wString m_facename;
  int m_fontweight;  // windows - 400 = NORMAL )
  double m_height;   // gets multiplied by dimscale
};

class ON_CLASS ON_Leader : public ON_Annotation
{
  ON_OBJECT_DECLARE(ON_Leader);

public:
  ON_BOOL32 IsRealObject() const;
  ON_Leader();
  ON_Leader(const ON_Leader&);
  ~ON_Leader();
  ON_Leader& operator=(const ON_Leader&);

  void EmergencyDestroy();
};




#endif

/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#ifndef OPENNURBS_ANNOTATION2_H_INC
#define OPENNURBS_ANNOTATION2_H_INC

#if defined(ON_OS_WINDOWS_GDI)

#define ON_RECT RECT

#else

typedef struct tagON_RECT
{
  int left;
  int top;
  int right;
  int bottom;
} ON_RECT;

#endif


class ON_CLASS ON_Annotation2Text : public ON_wString
{
public:
  ON_Annotation2Text();
  ~ON_Annotation2Text();

  // 24 Sep 2010 Dale Lear
  //    None of these were implmented and they don't make any sense.
  //    ON_Annotation2Text is derived from ON_wString, not ON_Object.
  //    I'm commenting out these functions and it doesn't break the
  //    SDK because linking would fail for anybody trying to use
  //    these functions.

  //////void SetDefaults();
  //////  // override virtual ON_Object::Dump function
  //////void Dump( ON_TextLog& text_log ) const;
  //////// override virtual ON_Object::Dump function
  //////unsigned int SizeOf() const;
  //////// override virtual ON_Object::Write function
  //////ON_BOOL32 Write(ON_BinaryArchive& binary_archive) const;
  //////// override virtual ON_Object::Read function
  //////ON_BOOL32 Read(ON_BinaryArchive& binary_archive);
  //////// override virtual ON_UserData::GetDescription function
  //////ON_BOOL32 GetDescription( ON_wString& description );
  //////// override virtual ON_UserData::Archive function
  //////ON_BOOL32 Archive() const; 

  ON_Annotation2Text& operator=(const char*);
  ON_Annotation2Text& operator=(const wchar_t*);

  void SetText( const char* s );
  void SetText( const wchar_t* s );

  // m_rect is a Windows gdi RECT that bounds text
  // ("x" increases to the right and "y" increases downwards).
  // If all fields are 0, then m_rect is not set.
  // If left < right and top < bottom, then the rect bounds
  // the text when it is drawn with its font's
  // lfHeight=ON_Font::normal_font_height and (0,0) left baseline
  // point of the leftmost character on the first line
  // of text. If (x,y) is a point on the drawn text, then
  // left <= x < right and top <= y < bottom.
  ON_RECT m_rect;
};

// Extension to ON_TextEntity added 12/10/2009 for Text background drawing
class ON_CLASS ON_TextExtra : public ON_UserData
{
  ON_OBJECT_DECLARE(ON_TextExtra);
public:

  ON_TextExtra();
  ~ON_TextExtra();

  static
  ON_TextExtra* TextExtension(class ON_TextEntity2* pDim, bool bCreate);
  static const
  ON_TextExtra* TextExtension(const class ON_TextEntity2* pDim, bool bCreate);

  void SetDefaults();

  // override virtual ON_Object::Dump function
  void Dump( ON_TextLog& text_log ) const;

  // override virtual ON_Object::Dump function
  unsigned int SizeOf() const;

  // override virtual ON_Object::Write function
  ON_BOOL32 Write(ON_BinaryArchive& binary_archive) const;

  // override virtual ON_Object::Read function
  ON_BOOL32 Read(ON_BinaryArchive& binary_archive);

  // override virtual ON_UserData::GetDescription function
  ON_BOOL32 GetDescription( ON_wString& description );

  // override virtual ON_UserData::Archive function
  ON_BOOL32 Archive() const;

  ON_UUID ParentUUID() const;
  void SetParentUUID( ON_UUID parent_uuid);

  bool DrawTextMask() const;
  void SetDrawTextMask(bool bDraw);

  int MaskColorSource() const;
  void SetMaskColorSource(int source);

  ON_Color MaskColor() const;  // Only works right if MaskColorSource returns 2.
                               // Does not return viewport background color
  void SetMaskColor(ON_Color color);

  double MaskOffsetFactor() const;
  void SetMaskOffsetFactor(double offset);

  ON_UUID  m_parent_uuid;    // uuid of the text using this extension

  bool     m_bDrawMask;      // do or don't draw a mask

  int      m_color_source;   // 0: Use background color from viewport
                             // 1: Use specific color from m_mask_color

  ON_Color m_mask_color;     // Color to use for mask if m_color_source is 2

  double   m_border_offset;  // Offset for the border around text to the rectangle used to draw the mask
                             // This number * HeightOfI for the text is the offset on each side of the
                             // tight rectangle around the text characters to the mask rectangle.
};


class ON_CLASS ON_DimensionExtra : public ON_UserData
{
  ON_OBJECT_DECLARE(ON_DimensionExtra);
public:

  ON_DimensionExtra();
  ~ON_DimensionExtra();

  static
  ON_DimensionExtra* DimensionExtension(class ON_LinearDimension2* pDim, bool bCreate);
  static const
  ON_DimensionExtra* DimensionExtension(const class ON_LinearDimension2* pDim, bool bCreate);
  static
  ON_DimensionExtra* DimensionExtension(class ON_RadialDimension2* pDim, bool bCreate);
  static const 
  ON_DimensionExtra* DimensionExtension(const class ON_RadialDimension2* pDim, bool bCreate);
  static
  ON_DimensionExtra* DimensionExtension(class ON_OrdinateDimension2* pDim, bool bCreate);
  static const 
  ON_DimensionExtra* DimensionExtension(const class ON_OrdinateDimension2* pDim, bool bCreate);

  void SetDefaults();

  // override virtual ON_Object::Dump function
  void Dump( ON_TextLog& text_log ) const;

  // override virtual ON_Object::Dump function
  unsigned int SizeOf() const;

  // override virtual ON_Object::Write function
  ON_BOOL32 Write(ON_BinaryArchive& binary_archive) const;

  // override virtual ON_Object::Read function
  ON_BOOL32 Read(ON_BinaryArchive& binary_archive);

  // override virtual ON_UserData::GetDescription function
  ON_BOOL32 GetDescription( ON_wString& description );

  // override virtual ON_UserData::Archive function
  ON_BOOL32 Archive() const;

  ON_UUID ParentUUID() const;
  void SetParentUUID( ON_UUID parent_uuid);

  //  0: default position
  //  1: force inside
  // -1: force outside
  int ArrowPosition() const;
  void SetArrowPosition( int position);

  // For a dimension in page space that measures between points in model space
  // of a detail view, this is the ratio of the page distance / model distance.
  // When the dimension text is displayed, the distance measured in model space
  // is multiplied by this number to get the value to display.
  double DistanceScale() const;
  void SetDistanceScale(double s);

  // Basepont in modelspace coordinates for ordinate dimensions
  void SetModelSpaceBasePoint(ON_3dPoint basepoint);
  ON_3dPoint ModelSpaceBasePoint() const;

  //const wchar_t* ToleranceUpperString() const;
  //ON_wString& ToleranceUpperString();
  //void SetToleranceUpperString( const wchar_t* upper_string);
  //void SetToleranceUpperString( ON_wString& upper_string);

  //const wchar_t* ToleranceLowerString() const;
  //ON_wString& ToleranceLowerString();
  //void SetToleranceLowerString( const wchar_t* lower_string);
  //void SetToleranceLowerString( ON_wString& lower_string);

  //const wchar_t* AlternateString() const;
  //ON_wString& AlternateString();
  //void SetAlternateString( const wchar_t* alt_string);
  //void SetAlternateString( ON_wString& alt_string);

  //const wchar_t* AlternateToleranceUpperString() const;
  //ON_wString& AlternateToleranceUpperString();
  //void SetAlternateToleranceUpperString( const wchar_t* upper_string);
  //void SetAlternateToleranceUpperString( ON_wString& upper_string);

  //const wchar_t* AlternateToleranceLowerString() const;
  //ON_wString& AlternateToleranceLowerString();
  //void SetAlternateToleranceLowerString( const wchar_t* lower_string);
  //void SetAlternateToleranceLowerString( ON_wString& lower_string);

  ON_UUID m_partent_uuid;  // the dimension using this extension

  int m_arrow_position;

  // This is either NULL or an array of GDI rects for the substrings
  // that make up the dimension string.
  // If the dimension text is all on the same line, there is just one
  // rectangle needed to bound the text and that is the same as the
  // m_rect on the ON_Annotation2Text.
  // If the dimension has tolerances or for some other reason has more
  // than one line of text, m_text_rects is an array of 7 rects, one
  // each for the substrings that might be needed to display the dimension.
  // If some of the rects aren't used, they are empty at 0,0
  // The strings that correspond to these rectangles are generated from
  // info in the dimstyle
  ON_RECT* m_text_rects;

  double m_distance_scale;
  ON_3dPoint m_modelspace_basepoint;
};


/*
  class ON_Annotation2

    Description:
      Used to serialize definitions of annotation objects (dimensions, text, leaders, etc.).
      Virtual base class for annotation objects
      Replaces ON_Annotation
*/
class ON_CLASS ON_Annotation2 : public ON_Geometry
{
  ON_OBJECT_DECLARE(ON_Annotation2);

  // UNICODE symbol code to use for degrees, radius, diameter and plus/minus in dimensions
  enum SYMBOLS
  {
    degreesym = 176,
    radiussym = L'R',
    diametersym = 216,
    plusminussym = 177
  };

public:
  ON_Annotation2();
  ~ON_Annotation2();
  // C++ automatically provides the correct copy constructor and operator= .
  //ON_Annotation2(const ON_Annotation2&);
  //ON_Annotation2& operator=(const ON_Annotation2&);

  // convert from old style annotation
  ON_Annotation2(const ON_Annotation&);
  ON_Annotation2& operator=(const ON_Annotation&);

  // Description:
  //   Sets initial defaults
  void Create();

  void Destroy();

  void EmergencyDestroy();

  /////////////////////////////////////////////////////////////////
  //
  // ON_Object overrides
  //

  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;


  /*
    Description: Writes the object to a file

    Returns:
      @untitled Table
      true     Success
      false    Failure
  */
  ON_BOOL32 Write(
         ON_BinaryArchive&
       ) const;

  /*
    Description: Reads the object from a file

    Returns:
      @untitled Table
      true     Success
      false    Failure
  */
  ON_BOOL32 Read(
         ON_BinaryArchive&
       );

  /*
    Returns: The Object Type of this object
  */
  ON::object_type ObjectType() const;

  /////////////////////////////////////////////////////////////////
  //
  // ON_Geometry overrides
  //

  /*
    Returns the geometric dimension of the object ( usually 3)
  */
  int Dimension() const;

  // overrides virtual ON_Geometry::Transform()
  ON_BOOL32 Transform( const ON_Xform& xform );

  // virtual ON_Geometry override
  bool EvaluatePoint( const class ON_ObjRef& objref, ON_3dPoint& P ) const;

  /////////////////////////////////////////////////////////////////
  //
  // ON_Annotation2 interface
  //

  // Definitions of text justification
  // Not implemented on all annotation objects
  enum eTextJustification
  {
    tjUndefined = 0,
    tjLeft   = 1<<0,
    tjCenter = 1<<1,
    tjRight  = 1<<2,
    tjBottom = 1<<16,
    tjMiddle = 1<<17,
    tjTop    = 1<<18,
    tjBottomLeft   = tjBottom | tjLeft,
    tjBottomCenter = tjBottom | tjCenter,
    tjBottomRight  = tjBottom | tjRight,
    tjMiddleLeft   = tjMiddle | tjLeft,
    tjMiddleCenter = tjMiddle | tjCenter,
    tjMiddleRight  = tjMiddle | tjRight,
    tjTopLeft      = tjTop    | tjLeft,
    tjTopCenter    = tjTop    | tjCenter,
    tjTopRight     = tjTop    | tjRight
  };

  /*
    Description:
      Query if the annotation object is a text object
    Parameters:
      none
    Returns:
      @untitled table
      true    It is text
      false   Its not text
  */
  bool IsText() const;

  /*
    Description:
      Query if the annotation object is a leader
    Parameters:
      none
    Returns:
      @untitled table
      true    It is a leader
      false   Its not a leader
  */
  bool IsLeader() const;

  /*
    Description:
      Query if the annotation object is a dimension
    Parameters:
      none
    Returns:
      @untitled table
      true    It is a dimension
      false   Its not a dimension
  */
  bool IsDimension() const;

  /*
    Description:
      Set or get the index in the appropriate table for either the font or
      dimstyle of this object
    Parameters:
      [in] int  the new index (Set)
    Returns:
      int -  The index (Get)
    Remarks:
      If the object is a text object the index is of object's font in the Font Table
      If the object is anything else, the index is of the object's dimstyle in the DimStyle Table
      Derived objects can use FontIndex() and StyleIndex() to set/get these same values.
  */
  int Index() const;
  void SetIndex( int);

  /*
  Returns:
    Dimension type
    Linear dim:  distance between arrow tips
    Radial dim:  radius or diameter depending on m_type value
    Angular dim: angle in degrees
    Leader:      ON_UNSET_VALUE
    Text:        ON_UNSET_VALUE
  */
  virtual
  double NumericValue() const;

  /*
    Description:
      Set  or Get the height of the text in this annotation
    Parameters:
      [in] double new text height to set
    Returns:
      double Height of the text
    Remarks:
      Height is in model units
  */
  void SetHeight( double);
  double Height() const;

  /*
    Description:
      Sets or gets the object type member to a specific annotation type:
           dtDimLinear, dtDimAligned, dtDimAngular, etc.
    Parameters:
      [in] ON::eAnnotationType type - dtDimLinear, dtDimAligned, dtDimAngular, etc.
    Returns:
      ON::eAnnotationType of the object
  */
  void SetType( ON::eAnnotationType);
  ON::eAnnotationType Type() const;

  /*
    Description:
      Set or get the plane for the object's ECS
    Parameters:
      [in] ON_Plane& plane in WCS
    Returns:
      const ON_Plane& - the object's ECS plane in WCS coords
  */
  void SetPlane( const ON_Plane&);
  const ON_Plane& Plane() const;

  /*
    Description:
      Returns the number of definition points this object has
    Parameters:
      none
    Returns:
      @untitled table
      int   the object's point count
  */
  int PointCount() const;
  void SetPointCount( int count);

  /*
    Description:
      Set or get the object's whole points array at once
    Parameters:
      [in] ON_2dPointArray& pts
    Returns:
      const ON_2dPointArray& - ref to the object's point array
  */
  void SetPoints( const ON_2dPointArray&);
  const ON_2dPointArray& Points() const;

  /*
    Description:
      Set individual definition points for the annotation
    Parameters:
      @untitled table
      [in] int index               index of the point to set in ECS 2d coordinates
      [in] const ON_2dPoint& pt    the new point value
    Returns:
      ON_2dPoint   the point coordinates in ECS
  */
  void SetPoint( int, const ON_2dPoint&);
  ON_2dPoint Point( int) const;

  /*
    Description:
      
      Set or get the string value of the user text, with no substitution for "<>"
    Parameters:
      [in] const wchar_t* string   the new value for UserText
    Returns:
      const ON_wString&    The object's UserText
    Remarks:
      UserText is the string that gets printed when the dimension is drawn.
      If it contains the token "<>", that token is replaced with the measured
      value for the dimension, formatted according to the DimStyle settings.
      "<>" is the default for linear dimensions.
      Other dimensions include "<>" in their default string
  */

  // OBSOLETE - call SetTextValue( text_value );
  ON_DEPRECATED void SetUserText( const wchar_t* text_value );

  // OBSOLETE - call TextValue( text_value );
  ON_DEPRECATED const ON_wString& UserText() const;


  /*
  Description:
    Gets the value of the annotation text.
  Returns:
    Value of the annotation text.
  See Also:
    ON_Annotation2Text::SetTextValue()
    ON_Annotation2Text::SetTextFormula()
    ON_Annotation2Text::TextFormula()    
  Remarks:
    This gets the literal value of the text, there is no
    substitution for any "<>" substrings.  When a dimension
    is drawn, any occurance of "<>" will be replaced
    with the measured value for the dimension and formatted
    according to the DimStyle settings.

    Annotation text values can be constant or the result 
    of evaluating text formula containing %<...>% 
    expressions. The ...TextValue() functions set
    and get the text's value.  The ...TextFormula()
    functions get and set the text's formula.
  */
  const wchar_t* TextValue() const;

  /*
  Description:
    Sets the value of the annotation text.  No changes
    are made to the text_value string.
  Parameters:
    text_value - [in]
  Returns:
    Value of the annotation text.
  See Also:
    ON_Annotation2Text::SetTextFormula()
    ON_Annotation2Text::TextValue()    
    ON_Annotation2Text::TextFormula()    
  Remarks:
    Annotation text values can be constant or the result 
    of evaluating text formula containing %<...>% 
    expressions. The ...TextValue() functions set
    and get the text's value.  The ...TextFormula()
    functions get and set the text's formula.
  */
  void SetTextValue( const wchar_t* text_value );

  /*
  Description:
    Gets the formula for the annotation text.
  Parameters:
    text_value - [in]
  Returns:
    Value of the annotation text.
  See Also:
    ON_Annotation2Text::SetTextValue()
    ON_Annotation2Text::TextValue()    
    ON_Annotation2Text::TextFormula()    
  Remarks:
    Annotation text values can be constant or the result 
    of evaluating text formula containing %<...>% 
    expressions. The ...TextValue() functions set
    and get the text's value.  The ...TextFormula()
    functions get and set the text's formula.
  */
  const wchar_t* TextFormula() const;

  /*
  Description:
    Sets the formula for the annotation text.
  Parameters:
    text_value - [in]
  Returns:
    Value of the annotation text.
  See Also:
    ON_Annotation2Text::SetTextValue()
    ON_Annotation2Text::Value()    
    ON_Annotation2Text::Formula()    
  Remarks:
    Annotation text values can be constant or the result 
    of evaluating text formula containing %<...>% 
    expressions. The ...TextValue() functions set
    and get the text's value.  The ...TextFormula()
    functions get and set the text's formula.
  */
  void SetTextFormula( const wchar_t* s );

  /*
    Description:
      Set or get a flag indication that the dimension text has been moved
      from the default location.
    Parameters:
      bUserPositionedText - [in]
               true to indicate that the text has been placed by the user.
               false to indicate that it hasn't
    Returns:
      @untitled table
      true    The text has been moved
      false   The text is in the default location
    Remarks:
      If the text is in the default location, it should be repositioned
      automatically when the dimension is adjusted.
      If it has been moved, it should not be automatically positioned.
  */
  void SetUserPositionedText( int bUserPositionedText );
  bool UserPositionedText() const;

  /*
    Description:
      Set or get the text display mode for the annotation
    Parameters:
      [in] ON::eTextDisplayMode mode - new mode to set
    Returns:
      ON::eTextDisplayMode  - current mode
    Remarks:
      This is the way the text is oriented with respect to the dimension line or screen:
      Above line, In LIne, Horizontal
  */
  void SetTextDisplayMode( ON::eTextDisplayMode);
  ON::eTextDisplayMode TextDisplayMode() const;


  /*
    Description:
      Gets a transform matrix to change from the object's 2d ECS to 3d WCS
    Parameters:
      [out] xform   set to produce the ECS to WCS transform
    Returns:
      @untitled table
      true    Success
      false   Failure
  */
  ON_BOOL32 GetECStoWCSXform( ON_Xform&) const;

  /*
    Description:
      Gets a transform matrix to change from to 3d WCS to the object's 2d ECS
    Parameters:
      [out] xform - set to produce the WCS to ECS transform
    Returns:
      @untitled table
      true    Success
      false   Failure
  */
  ON_BOOL32 GetWCStoECSXform( ON_Xform& xform) const;

  /*
    Description:
      Set the object's point array to a specified length
    Parameters:
      [in] length - the new size of the array
    Returns:
      void
  */
  void ReservePoints( int);


  /*
    Description:
      static function to provide the default UserText string for the object
    Returns:
      const wchar_t* - the default string to use
  */
  static const wchar_t* DefaultText();

  /*
    Description:
      Convert back to the version of ON_Annotation used in Rhino 2
    Parameters:
      target [out] the old-style object
    Returns:
      @untitled table
      true     Success
      False    Failure
    See Also:  ON_AngularDimension::ConvertBack()
  */
  virtual
  void ConvertBack( ON_Annotation& target);

  /*
    Description:
      Set or Get the text justification
    Parameters:
      justification [in] See enum eJustification for meanings
    Returns:
      The justification for the text in this object
    Comments:
      This is not implemented on all annotation objects.
      The default SetJustification() does nothing
      The default Justification() always returns 0

  */
  virtual
  void SetJustification( unsigned int justification);

  virtual
  unsigned int Justification();

  /*
    Description:
      Get the transformation that maps the annotation's
      text to world coordinates.
      Added Oct 30, 07 LW
    Parameters:
      gdi_text_rect - [in]
              Windows gdi rect of text when it is drawn with
              LOGFONT lfHeight = ON_Font::normal_font_height.
      gdi_height_of_I - [in]
         Value returned by ON_Font::HeightOfI().
      dimstyle_textheight - [in]
         Height of text in world units.  If the annotation is
         an ON_TextEntity2, this is the m_textheight value.
         If the annotation is not an ON_TextEntity2, pass in
         the value returned by the dimension style's
         ON_DimStyle::TextHeight()
      dimstyle_textgap - [in]
         The value of the annotation's dimension style's
         ON_DimStyle::TextGap().
      dimstyle_textalignment - [in]
         ON::TextDisplayMode(ON_DimStyle::TextAlignment()).
      dimscale - [in]
         Global dimension scaling value.  If you are using the
         Rhino SDK, this value is returned by
         CRhinoDoc::Properties().AnnotationSettings().DimScale().
         If you are using the OpenNURBS IO toolkit, this value
         is on ON_3dmSettings::m_AnnotationSettings.m_dimscale.
      cameraX - [in]
         zero or the view's unit camera right vector
      cameraY - [in]
         zero or the view's unit camera up vector
      model_xform - [in] transforms the text's parent entity
         to world coordinates in case its instance geometry
         NULL == Identity
      text_xform - [out]
    Returns:
      True if text_xform is set.
  */
  bool GetTextXform(
        ON_RECT gdi_text_rect,
        int gdi_height_of_I,
        double dimstyle_textheight,
        double dimstyle_textgap,
        ON::eTextDisplayMode dimstyle_textalignment,
        double dimscale,
        ON_3dVector cameraX,
        ON_3dVector cameraY,
        const ON_Xform* model_xform,
        ON_Xform& text_xform // output
        ) const;

  /*
    Description:

    This function has been replaced with a version that
    takes a model transform to transform block instance
    geometry to world coordinates  Oct 30, 07 LW

      Get the transformation that maps the annotation's
      text to world coordinates.
    Parameters:
      gdi_text_rect - [in]
              Windows gdi rect of text when it is drawn with
              LOGFONT lfHeight = ON_Font::normal_font_height.
      gdi_height_of_I - [in]
         Value returned by ON_Font::HeightOfI().
      dimstyle_textheight - [in]
         Height of text in world units.  If the annotation is
         an ON_TextEntity2, this is the m_textheight value.
         If the annotation is not an ON_TextEntity2, pass in
         the value returned by the dimension style's
         ON_DimStyle::TextHeight()
      dimstyle_textgap - [in]
         The value of the annotation's dimension style's
         ON_DimStyle::TextGap().
      dimstyle_textalignment - [in]
         ON::TextDisplayMode(ON_DimStyle::TextAlignment()).
      dimscale - [in]
         Global dimension scaling value.  If you are using the
         Rhino SDK, this value is returned by
         CRhinoDoc::Properties().AnnotationSettings().DimScale().
         If you are using the OpenNURBS IO toolkit, this value
         is on ON_3dmSettings::m_AnnotationSettings.m_dimscale.
      cameraX - [in]
         zero or the view's unit camera right vector
      cameraY - [in]
         zero or the view's unit camera up vector
      xform - [out]
    Returns:
      True if xform is set.
  */
  bool GetTextXform(
        ON_RECT gdi_text_rect,
        int gdi_height_of_I,
        double dimstyle_textheight,
        double dimstyle_textgap,
        ON::eTextDisplayMode dimstyle_textalignment,
        double dimscale,
        ON_3dVector cameraX,
        ON_3dVector cameraY,
        ON_Xform& xform
        ) const;

  /*
    Description:
      Get the transformation that maps the annotation's
      text to world coordinates.
      Oct 30, 07 LW
    Parameters:
      gdi_text_rect - [in]
              Windows gdi rect of text when it is drawn with
              LOGFONT lfHeight = ON_Font::normal_font_height.
      font - [in]
      dimstyle - [in]
      dimscale - [in]
         Global dimension scaling value.  If you are using the
         Rhino SDK, this value is returned by
         CRhinoDoc::Properties().AnnotationSettings().DimScale().
         If you are using the OpenNURBS IO toolkit, this value
         is on ON_3dmSettings::m_AnnotationSettings.m_dimscale.
      vp - [in]
      model_xform - [in] transforms the text's parent entity
         to world coordinates in case its instance geometry
         NULL == Identity
      text_xform - [out]
    Returns:
      True if text_xform is set.
  */
  //bool GetTextXform( 
  //    const ON_RECT gdi_text_rect,
  //    const ON_Font& font,
  //    const ON_DimStyle& dimstyle,
  //    double dimscale,
  //    const ON_Viewport* vp,
  //    const ON_Xform* model_xform,
  //    ON_Xform& text_xform  // output
  //    ) const;
  bool GetTextXform(
      const ON_RECT gdi_text_rect,
      const ON_Font& font,
      const ON_DimStyle* dimstyle,
      double dimscale,
      const ON_Viewport* vp,
      const ON_Xform* model_xform,
      ON_Xform& text_xform  // output
      ) const;

  /*
    Description:

    This function has been replaced with a version that
    takes a model transform because the viewport doesn't
    contain block instance transform info  Oct 30, 07 LW

      Get the transformation that maps the annotation's
      text to world coordinates.
    Parameters:
      gdi_text_rect - [in]
              Windows gdi rect of text when it is drawn with
              LOGFONT lfHeight = ON_Font::normal_font_height.
      font - [in]
      dimstyle - [in]
      dimscale - [in]
         Global dimension scaling value.  If you are using the
         Rhino SDK, this value is returned by
         CRhinoDoc::Properties().AnnotationSettings().DimScale().
         If you are using the OpenNURBS IO toolkit, this value
         is on ON_3dmSettings::m_AnnotationSettings.m_dimscale.
      vp - [in]
      xform - [out]
    Returns:
      True if xform is set.
  */
  bool GetTextXform(
      ON_RECT gdi_text_rect,
      const ON_Font& font,
      const ON_DimStyle& dimstyle,
      double dimscale,
      const ON_Viewport* vp,
      ON_Xform& xform
      ) const;

  /*
  Description:
    Get the annotation plane coordinates (ECS) of the point
    that is used to position the text.  The relative position
    of the text to this points depends on the type of
    annotation, the dimstyle's text alignment flag, and the
    view projection.
    This point is not  the same as the base point of the text.
  Parameters:
    text_point - [out];
  Returns:
    True if text_point is set.
  */
  bool GetTextPoint( ON_2dPoint& text_2d_point ) const;

  // enum for tyoe of annotation DimLinear, DimRadius, etc.
  ON::eAnnotationType m_type;

  // m_textdisplaymode controls the orientation
  // of the text.
  // If m_textdisplaymode = dtHorizontal, then
  // the text is always horizontal and in the
  // view plane.  Otherwise it lies in m_plane.
  ON::eTextDisplayMode m_textdisplaymode;

  // m_plane is the plane containing the annotation.
  // All parts of the annotation that are not
  // text lie in this plane. If
  // m_textdisplaymode != dtHorizontal, then
  // the text lies in the plane too.
  // (ECS reference plane in WCS coordinates.)
  ON_Plane m_plane;

  // Definition points for the dimension.
  // These are 2d coordinates in m_plane.
  // The location of these points depends on the
  // type of annotation class.  There is a comment
  // at the start of the definions for
  // ON_LinearDimension2, ON_RadialDimension2,
  // ON_AngularDimension2, ON_TextEntity2, and
  // ON_Leader2 that explains how the points are used.
  ON_2dPointArray m_points;

  // With the addition of tolerances and therefore multi-line
  // text, the ON_wString in m_usertext will hold multiple
  // strings with NULLs between them.
  // The strings will be in this order:
  // Result of expanding "<>", or user override
  // Alternate dimension
  // Tolerance upper
  // Tolerance lower
  // Alt tolerance upper
  // Alt tolerance lower
  // Prefix
  // Suffix
  // Alt prefix
  // Alt suffix
  //
  ON_Annotation2Text m_usertext;

  // true: User has positioned text
  // false: use default location
  bool m_userpositionedtext;
  // Added 13 Aug, 2010 - Lowell
  // This determines whether the object will be scaled according to detail
  // scale factor or by 1.0 in paperspace rather than by 
  // dimscale or text scale.
  // For the first try this will only be used on text and its
  // here on the base class because it would fit and in case 
  // its needed later on dimensions.
  bool m_annotative_scale;
private:
  bool m_reserved_b1;
  bool m_reserved_b2;
public:

  // For dimensions, this is the ON_DimStyle index
  // For text, its the ON_Font index
  int m_index;

  // Text height in model units
  // This is used by text, but not by dimensions
  // Dimensions get their height from dimension styles
  double m_textheight;

  // Left, Center, Right / Bottom, Middle, Top text justification
  // See eTextJustification above
  unsigned int m_justification;
};


// Subclass of ON_Annotation2 to provide linear dimensions
class ON_CLASS ON_LinearDimension2 : public ON_Annotation2
{
  ON_OBJECT_DECLARE(ON_LinearDimension2);

public:

  /*
    The annotation's dimstyle controls the position of TEXT,
    the size of the arrowheads, and the amount the ends of
    linear dimension's extension lines extend beyond the
    dimension lines.

    In the picture below, [n] means ON_Annotation2::m_points[n].

                                                     [2]
                                                      |
        |                                             |
       [1]-------------------------------------------[3]
        |                                             |
        |                       TEXT
        |                       [4]
       [0]

      The "x" and "y" coordinates of [0] must be (0.0, 0.0).

      The "x" coordinate of [1] = "x" of [0]
      The "y" coordinate of [1] can be any value.

      The "x" and "y" coordinates of [2] can be any value.

      The "x" coordinate of [3] = "x" coordinate of [2].
      The "y" coordinate of [3] = "y" coordinate of [1].
  */

  enum POINT_INDEX
  {
    // Do not change these enum values.  They are saved in files as the
    // ON_COMPONENT_INDEX.m_index value.
    //
    // Indices of linear dimension definition points in
    // the m_points[] array
    ext0_pt_index    = 0, // end of first extension line
    arrow0_pt_index  = 1, // arrowhead tip on first extension line
    ext1_pt_index    = 2, // end of second extension line
    arrow1_pt_index  = 3, // arrowhead tip on second extension line
    userpositionedtext_pt_index = 4,
    dim_pt_count     = 5, // number of m_points[] in an angular dim

    // Points calculated from values in m_points[]
    text_pivot_pt = 10000, // center of dimension text
    dim_mid_pt    = 10001  // midpoint of dimension line
  };

  ON_LinearDimension2();
  ~ON_LinearDimension2();
  // C++ automatically provides the correct copy constructor and operator= .
  //ON_LinearDimension2( const ON_LinearDimension2& );
  //ON_LinearDimension2& operator=(const ON_LinearDimension2&);

  // overrides virtual ON_Geometry::Transform()
  ON_BOOL32 Transform( const ON_Xform& xform );

  /*
  Description:
    Checks the linear dimension and repairs any point locations or flags
    that are not set correctly.
  Returns:
    0:  linear dimension is damaged beyond repair
    1:  linear dimension was perfect and nothing needed to be repaired.
    2:  linear dimension had flaws that were repaired.
  */
  int Repair();

  /*
  Description:
    Get the m_plane coordinates of the dimension point.
  Parameters:
    point_index - [in] One of the POINT_INDEX enum values
  Returns:
    2d point or ON_UNSET_POINT if point_index or m_points[]
    array is not valid.
  */
  ON_2dPoint Dim2dPoint(
       int point_index
       ) const;

  /*
  Description:
    Get the m_plane coordinates of the dimension point.
  Parameters:
    point_index - [in] One of the POINT_INDEX enum values
  Returns:
    2d point or ON_UNSET_POINT if point_index or m_points[]
    array is not valid.
  */
  ON_3dPoint Dim3dPoint(
       int point_index
       ) const;

  // overrides virual ON_Object::IsValid
  ON_BOOL32 IsValid( ON_TextLog* text_log = 0 ) const;

  // overrides virual ON_Object::Write
  ON_BOOL32 Write(ON_BinaryArchive&) const;

  // overrides virual ON_Object::Read
  ON_BOOL32 Read(ON_BinaryArchive&);

  // overrides virual ON_Geometry::GetBBox
  ON_BOOL32 GetBBox(
         double*,
         double*,
         ON_BOOL32 = false
         ) const;

  // overrides virual ON_Geometry::GetTightBoundingBox
	bool GetTightBoundingBox(
			ON_BoundingBox& tight_bbox,
      int bGrowBox = false,
			const ON_Xform* xform = 0
      ) const;

  /*
  Description:
    Overrides virtual ON_Annotation2::NumericValue();
  Returns:
    distance between arrow tips
  */
  double NumericValue() const;

  /*
    Description:
      Get or set the DimStyle index in the dimstyle table for the dimension
    Parameters:
      [in] int  the new index (Set)
    Returns:
      int -  The current index (Get)
  */
  int StyleIndex() const;
  void SetStyleIndex( int);

  /*
    Description:
      static function to provide the default UserText string for the object
    Returns:
      const wchar_t* - the default string to use
  */
  static const wchar_t* DefaultText();


// 6-23-03 lw Added v2 file writing of annotation
  void GetV2Form( ON_LinearDimension& dim);

  bool CreateFromV2(
      const ON_Annotation& v2_ann,
      const ON_3dmAnnotationSettings& settings,
      int dimstyle_index
      );

  /*
  Description:
    Get the annotation plane x coordinates of the dimension
    line. The y coordinate of the dimension line is m_ponts[1].y.
  Parameters:
    gdi_text_rect - [in]
       Windows rect (left < right, top < bottom) that bounds text.
       The baseline of the text should be at y=0 in the rect coordinates.
    gdi_height_of_I - [in]
       Height of an I in the text in the same.
    gdi_to_world - [in]
       transform returned by ON_Annotation2::GetTextXform().
    dimstyle - [in]
      dimscale - [in]
    vp - [in]
    x - [out] plane x coordinates of the dimension line.
              The y coordinate = m_points[arrow0_pt_index].y
    bInside - [out] true if arrowheads go inside extension lines,
                    false if they go outside
  Returns:
    0: the input or class is not valid
    1: A single line from x[0] to x[1] with arrow heads at both ends.
        Arrowtips at x[4] & x[5]
    2: Two lines from x[0] to x[1] and from x[1] to x[2].  The
        Arrowtips at x[4] & x[5]

  */
  int GetDimensionLineSegments(
      ON_RECT gdi_text_rect,
      int gdi_height_of_I,
      ON_Xform gdi_to_world,
      const ON_DimStyle& dimstyle,
      double dimscale,
      const ON_Viewport* vp,
      double a[6],
      bool& bInside
      ) const;


  // Added for V5. 4/24/07 LW
  // Get the userdata extension for this dimension
  


};

//////////
// class ON_RadialDimension2
class ON_CLASS ON_RadialDimension2 : public ON_Annotation2
{
  ON_OBJECT_DECLARE(ON_RadialDimension2);

public:

  /*
    The annotation's dimstyle controls the position of TEXT,
    and the size of the arrowheads.

    In the picture below, [n] means ON_Annotation2::m_points[n].

    Radial dimensions do not permit user positioned text


           knee
            [3]--------[2] TEXT
            /         (tail)
           /
          /
        [1] (arrow head here)


    + [0] = (usually at (0,0) = center of circle)
  */

  enum POINT_INDEX
  {
    // Do not change these enum values.  They are saved in files as the
    // ON_COMPONENT_INDEX.m_index value.
    //
    // Indices of radial dimension definition points in
    // the m_points[] array
    center_pt_index = 0, // location of + (usually at center of circle)
    arrow_pt_index  = 1, // arrow tip
    tail_pt_index   = 2, // end of radial dimension
    knee_pt_index   = 3, // number of m_points[] in a radial dim
    dim_pt_count    = 4, // number of m_points[] in a radial dim

    // Points calculated from values in m_points[]
    text_pivot_pt = 10000 // start/end of dimension text at tail
  };

  ON_RadialDimension2();
  ~ON_RadialDimension2();
  // C++ automatically provides the correct copy constructor and operator= .
  //ON_RadialDimension2(const ON_RadialDimension2&);
  //ON_RadialDimension2& operator=(const ON_RadialDimension2&);

  // overrides virtual ON_Geometry::Transform()
  ON_BOOL32 Transform( const ON_Xform& xform );

  /*
  Description:
    Get the m_plane coordinates of the dimension point.
  Parameters:
    point_index - [in] One of the POINT_INDEX enum values
  Returns:
    2d point or ON_UNSET_POINT if point_index or m_points[]
    array is not valid.
  */
  ON_2dPoint Dim2dPoint(
       int point_index
       ) const;

  /*
  Description:
    Get the m_plane coordinates of the dimension point.
  Parameters:
    point_index - [in] One of the POINT_INDEX enum values
  Returns:
    2d point or ON_UNSET_POINT if point_index or m_points[]
    array is not valid.
  */
  ON_3dPoint Dim3dPoint(
       int point_index
       ) const;


  // overrides virual ON_Object::IsValid
  ON_BOOL32 IsValid( ON_TextLog* text_log = 0 ) const;

  // overrides virual ON_Object::Write
  ON_BOOL32 Write(ON_BinaryArchive&) const;

  // overrides virual ON_Object::Read
  ON_BOOL32 Read(ON_BinaryArchive&);

  // overrides virual ON_Geometry::GetBBox
  ON_BOOL32 GetBBox(
         double*,
         double*,
         ON_BOOL32 = false
         ) const;

  // overrides virual ON_Geometry::GetTightBoundingBox
	bool GetTightBoundingBox(
			ON_BoundingBox& tight_bbox,
      int bGrowBox = false,
			const ON_Xform* xform = 0
      ) const;

  /*
    Description:
      Set the plane and definition points from WCS 3d input
    Parameters:
      center - [in] center of circle
      arrowtip - [in] 3d point on the circle at the dimension arrow tip
      xaxis - [in] x axis of the dimension's plane
      normal - [in] normal to the dimension's plane
      offset_distance - [in] distance from arrow tip to knee point
    Returns:
      @untitled table
      true     Success
      false    Failure
  */
  bool CreateFromPoints(
          ON_3dPoint center,
          ON_3dPoint arrowtip,
          ON_3dVector xaxis,
          ON_3dVector normal,
          double offset_distance
          );

  /*
  Description:
    Overrides virtual ON_Annotation2::NumericValue();
  Returns:
    If m_type is ON::dtDimDiameter, then the diameter
    is returned, othewise the radius is returned.
  */
  double NumericValue() const;

  /*
    Description:
      Get or set the DimStyle index in the dimstyle table for the dimension
    Parameters:
      [in] int  the new index (Set)
    Returns:
      int -  The current index (Get)
  */
  int StyleIndex() const;
  void SetStyleIndex( int);

  /*
    Description:
      static function to provide the default UserText string for the object
    Returns:
      const wchar_t* - the default string to use
  */
  static const wchar_t* DefaultDiameterText();
  static const wchar_t* DefaultRadiusText();

// 6-23-03 lw Added v2 file writing of annotation
  void GetV2Form( ON_RadialDimension& dim);

  bool CreateFromV2(
      const ON_Annotation& v2_ann,
      const ON_3dmAnnotationSettings& settings,
      int dimstyle_index
      );

  bool GetArrowHeadDirection( ON_2dVector& arrowhead_dir ) const;
  bool GetArrowHeadTip( ON_2dPoint& arrowhead_tip ) const;
};


//////////
// class ON_AngularDimension2
class ON_CLASS ON_AngularDimension2 : public ON_Annotation2
{
  ON_OBJECT_DECLARE(ON_AngularDimension2);

public:

  /*
    The annotation's dimstyle controls the position of TEXT,
    the size of the arrowheads, and the amount the ends of
    linear dimension's extension lines extend beyond the
    dimension lines.

    In the picture below, [n] means ON_Annotation2::m_points[n].

    [0] = if m_userpositionedtext=true, this is the center of text.
          If m_userpositionedtext=false, this point is not used and
          the center of the text is at the arc's midpoint.

    Always counter clockwise arc in m_plane with center = (0,0)
    [1] = a point somewhere on the line from the center through the start point.
          The distance from center to [1] can be any value.
    [2] = a point somewhere on the line from the center through the end point.
          The distance from center to [2] can be any value.
    [3] = a point on the interior of the arc.  The distance
          from (0,0) to [3] is the radius of the arc.


                  /
                [2]
                /
               /         [0]TEXT
              /
             /    [3]
     -----(0,0)----------[1]---
           /
          /
         /

  */

  enum POINT_INDEX
  {
    // Do not change these enum values.  They are saved in files as the
    // ON_COMPONENT_INDEX.m_index value.
    //
    // Indices of angular dimension definition points in
    // the m_points[] array
    userpositionedtext_pt_index  = 0, //
    start_pt_index = 1, // point on the start ray (not necessarily on arc)
    end_pt_index   = 2, // point on the end ray (not necessarily on arc)
    arc_pt_index   = 3, // point on the interior of dimension arc
    dim_pt_count   = 4, // number of m_points[] in an angular dim

    // Points calculated from values in m_points[]
    text_pivot_pt = 10000, // center of dimension text
    arcstart_pt   = 10001,
    arcend_pt     = 10002,
    arcmid_pt     = 10003,
    arccenter_pt  = 10004, // center of circle arc lies on
    extension0_pt = 10005, // point where first extension line starts
    extension1_pt = 10006  // point where second extension line starts
  };

  ON_AngularDimension2();
  ~ON_AngularDimension2();
  // C++ copy constructor and operator= work fine.
  //ON_AngularDimension2(const ON_AngularDimension2&);
  //ON_AngularDimension2& operator=(const ON_AngularDimension2&);

  // overrides virtual ON_Geometry::Transform()
  ON_BOOL32 Transform( const ON_Xform& xform );

  /*
  Description:
    Get the m_plane coordinates of the dimension point.
  Parameters:
    point_index - [in] One of the POINT_INDEX enum values
  Returns:
    2d point or ON_UNSET_POINT if point_index or m_points[]
    array is not valid.
  */
  ON_2dPoint Dim2dPoint(
       int point_index
       ) const;

  /*
  Description:
    Get the m_plane coordinates of the dimension point.
  Parameters:
    point_index - [in] One of the POINT_INDEX enum values
  Returns:
    2d point or ON_UNSET_POINT if point_index or m_points[]
    array is not valid.
  */
  ON_3dPoint Dim3dPoint(
       int point_index
       ) const;


  // overrides virual ON_Object::IsValid
  ON_BOOL32 IsValid( ON_TextLog* text_log = 0 ) const;

  // overrides virual ON_Geometry::GetBBox
  ON_BOOL32 GetBBox(
         double*,
         double*,
         ON_BOOL32 = false
         ) const;

  // overrides virual ON_Geometry::GetTightBoundingBox
	bool GetTightBoundingBox(
			ON_BoundingBox& tight_bbox,
      int bGrowBox = false,
			const ON_Xform* xform = 0
      ) const;

  /*
    Description:
      Read from or write to a file
    Returns:
      @untitled Table
      true     Success
      false    Failure
  */
  ON_BOOL32 Write( ON_BinaryArchive& file ) const;
  ON_BOOL32 Read( ON_BinaryArchive& file );

  /*
    Description:
      Set the plane and definition points from 3d points
      in world coordinates.
    Parameters:
      apex - [in] 3d apex of the dimension
                  (center of arc)
      p0 - [in] 3d point on first line
      p1 - [in] 3d point on second line
      arcpt - [in] 3d point on dimension arc
                   (determines radius of arc)
      Normal - [in] normal of the plane on which to make the dimension
                    (must be perpendicular to p0-apex and p1-apex)
    Returns:
      @untitled table
      true     Success
      false    Failure
  */
  bool CreateFromPoints(
    const ON_3dPoint& apex,
    const ON_3dPoint& p0,
    const ON_3dPoint& p1,
    ON_3dPoint& arcpt,
    ON_3dVector& Normal
    );

  /*
    Description:
      Set the plane and definition points from a 3d arc.
    Parameters:
      arc - [in]
    Returns:
      @untitled table
      true     Success
      false    Failure
  */
  bool CreateFromArc(
    const ON_Arc& arc
    );

  bool CreateFromV2(
      const ON_Annotation& v2_ann,
      const ON_3dmAnnotationSettings& settings,
      int dimstyle_index
      );

  bool GetArc( ON_Arc& arc ) const;

  bool GetExtensionLines(ON_Line extensions[2]) const;

  // Set or get the measured angle in radians
  void SetAngle( double angle);
  double Angle() const;
  void SetRadius( double radius);
  double Radius() const;

  /*
  Description:
    Overrides virtual ON_Annotation2::NumericValue();
  Returns:
    Angle in degrees
  */
  double NumericValue() const;

  /*
    Description:
      Get or set the DimStyle index in the dimstyle table for the dimension
    Parameters:
      [in] int  the new index (Set)
    Returns:
      int -  The current index (Get)
  */
  int StyleIndex() const;
  void SetStyleIndex( int);

  /*
    Description:
      static function to provide the default UserText string for the object
    Returns:
      const wchar_t* - the default string to use
  */
  static const wchar_t* DefaultText();


  /*
    Description:
      Convert back to the version of ON_Annotation used in Rhino 2
    Parameters:
      target [out] the old-style object
    Returns:
      @untitled table
      true     Success
      False    Failure
    See Also:  ON_AnnotationObject::ConvertBack()
  */
  using ON_Annotation2::ConvertBack;
  void ConvertBack( ON_AngularDimension2& target);

// 6-23-03 lw Added v2 file writing of annotation
  void GetV2Form( ON_AngularDimension& dim);

  double m_angle;      // angle being dimensioned
  double m_radius;     // radius for dimension arc

  /*
  Description:
    Get the annotation plane angles of the dimension arc.
  Parameters:
    gdi_text_rect - [in] Windows rect (left < right, top < bottom)
       that bounds text.
    gdi_height_of_I - [in]
       Height of an I in the text.
    gdi_to_world - [in]
       transform returned by ON_Annotation2::GetTextXform().
    dimstyle - [in]
      dimscale - [in]
    vp - [in]
    a - [out]
      angles at the ends of the arc segment(s) and the arrow tips
    bInside - [out] true if arrowheads go inside, false if they go outside
  Returns:
    number of arc segments to draw
    0: the input or class is not valid
    1: A single arc from a[0] to a[1] with arrow heads at a[4] & a[5].
    2: Two arcs from a[0] to a[1] & from a[2] to a[3].
       Arrowheads are at a[4] & a[5].
  */
  int GetDimensionArcSegments(
      ON_RECT gdi_text_rect,
      int gdi_height_of_I,
      ON_Xform gdi_to_world,
      const ON_DimStyle& dimstyle,
      double dimscale,
      const ON_Viewport* vp,
      double a[6],
      bool& bInside
      ) const;


  /*
  Description:
    Get distance from dimension apex to extension line offset points
  Parameters:
    index - [in]  which distance to get
  Returns:
    Distance to offset point [index]
  */
  double DimpointOffset(
    int index) const;

  /*
  Description:
    Set distance from dimension apex to extension line offset points
  Parameters:
    index  - [in]  which distance to set
    offset - [in] Value to set
  */
  void SetDimpointOffset(
    int index,
    double offset);
};



/*
  class ON_LinearDimension2

  Description:
    Override od ON_Annotation2 to provide linear dimensions
*/
class ON_CLASS ON_OrdinateDimension2 : public ON_Annotation2
{
  ON_OBJECT_DECLARE(ON_OrdinateDimension2);

public:

  /*
    In the picture below, [n] means ON_Annotation2::m_points[n].

    Measures in X direction

                       [1]
                        |
                        |
                        |
                        |
                        |
                       [0]
       +
 [plane origin]                                      [plane origin]
                                                           +

      or - Measures in Y direction                                                   *---[1]
                                                                                    /
                                                                                   /
                   [0]--------------------[1]                   [0]---------------*


                                                                              * = calculated, not stored


       +
 [plane origin]


      The reference point of for the dimension is at the entity plane origin
      The "x" and "y" coordinates of [1] can be any value.
      The "x" and "y" coordinates of [2] can be any value.
      If Direction is "x", the dimension measures along the "x" axis
      If Direction is "y", the dimension measures along the "y" axis
      If Direction is "x" and [1][x] <> [0][x], an offset segment is drawn
      If Direction is "y" and [1][y] <> [0][y], an offset segment is drawn
      The dimension lines are always drawn in the X or Y directions of the entity plane
      The distance represented by the dimension is measured from the
        plane origin to point [0], parallel to the appropriate axis.
      The points of the offset segment are calculated rather than stored
  */

  enum POINT_INDEX
  {
    // Do not change these enum values.  They are saved in files as the
    // ON_COMPONENT_INDEX.m_index value.
    //
    // Indices of linear dimension definition points in
    // the m_points[] array
    definition_pt_index    = 0, // First end of the dimension line
    leader_end_pt_index    = 1, // Other end of the leader (near the text)
    dim_pt_count           = 2, // Number of m_points[] in an ordinate dim

    // Points calculated from values in m_points[]
    text_pivot_pt = 10000, // Center of dimension text
    offset_pt_0   = 10001, // First offset point  (nearest text)
    offset_pt_1   = 10002  // Second offset point
  };

  enum DIRECTION
  {
    x = 0,  // measures horizontally
    y = 1  // measures vertically
  };

  ON_OrdinateDimension2();
  ~ON_OrdinateDimension2();

  // overrides virtual ON_Geometry::Transform()
  ON_BOOL32 Transform( const ON_Xform& xform );

  /*
  Description:
    Get the m_plane coordinates of the dimension point.
  Parameters:
    point_index - [in] One of the POINT_INDEX enum values
    default_offset [in] - kink offset to use if m_kink_offset_0
                          or m_kink_offset_1 are ON_UNSET_VALUE
  Returns:
    2d point or ON_UNSET_POINT if point_index or m_points[]
    array is not valid.
  */
  ON_2dPoint Dim2dPoint(
       int point_index,
       double default_offset = 1.0
       ) const;

  /*
  Description:
    Get the m_plane coordinates of the dimension point.
  Parameters:
    point_index - [in] One of the POINT_INDEX enum values
    default_offset [in] - kink offset to use if m_kink_offset_0
                          or m_kink_offset_1 are ON_UNSET_VALUE
  Returns:
    2d point or ON_UNSET_POINT if point_index or m_points[]
    array is not valid.
  */
  ON_3dPoint Dim3dPoint(
       int point_index,
       double default_offset = 1.0
       ) const;

  // overrides virual ON_Object::IsValid
  ON_BOOL32 IsValid( ON_TextLog* text_log = 0 ) const;

  // overrides virual ON_Geometry::GetBBox
  ON_BOOL32 GetBBox(
         double* boxmin,
         double* boxmax,
         ON_BOOL32 bGrowBox = false
         ) const;

  // overrides virual ON_Geometry::GetTightBoundingBox
	bool GetTightBoundingBox(
			ON_BoundingBox& tight_bbox,
      int bGrowBox = false,
			const ON_Xform* xform = 0
      ) const;

  /*
    Description:
      Read from or write to a file
    Returns:
      @untitled Table
      true     Success
      false    Failure
  */
  ON_BOOL32 Write( ON_BinaryArchive& file ) const;
  ON_BOOL32 Read( ON_BinaryArchive& file );

  /*
  Description:
    Overrides virtual ON_Annotation2::NumericValue();
  Returns:
    If Direction is 'X', x coordinate of point[1]
    If Direction is 'Y', y coordinate of point[1]
  */
  double NumericValue() const;

  /*
    Description:
      Get or set the DimStyle index in the dimstyle table for the dimension
    Parameters:
      [in] int  the new index (Set)
    Returns:
      int -  The current index (Get)
  */
  int StyleIndex() const;
  void SetStyleIndex( int);

  /*
    Description:
      Gets the direction ( X or Y) that the ordinate dimension measures
      based on the relative location of the defining point and leader endpoint
    Returns:
      0: measures parallel to the entity plane x axis
      1: measures parallel to the entity plane y axis
    Remarks:
      This does not consider the dimension's explicit Direction setting
  */
  int ImpliedDirection() const;

  /*
    Description:
      Gets or sets the direction ( X or Y) that the ordinate dimension measures
    Returns:
     -1: direction determined by dim point and leader point
      0: measures parallel to the entity plane x axis
      1: measures parallel to the entity plane y axis
  */
  int Direction() const;
  void SetDirection( int direction);

  /*
    Description:
      Get the height of the text in this dimension
      by asking the dimension's dimstyle
    Returns:
      double Height of the text
    Remarks:
      Height is in model units
  double Height() const;
  */

  /*
    Description:
      static function to provide the default UserText string for the object
    Returns:
      const wchar_t* - the default string to use
  */
  static const wchar_t* DefaultText();

  /*
    Description:
      Returns or sets the offset distance parallel to the dimension
      line direction of from the text end of the dimension line to
      the offset point
      If the offset point hasn't been explicitly defined, returns
      ON_UNSET_VALUE and a default should be used to find the point.
    Parameters:
      index [in] - which offset distance to return
                   (0 is closer to the text)
      offset [in] - the offset distance to set
  */
  double KinkOffset( int index) const;
  void SetKinkOffset( int index, double offset);


  int m_direction;   // -1 == undetermined
                     //  0 == x direction
                     //  1 == y direction

  // kink offsets added 2-4-06 - LW
  double m_kink_offset_0;  // from leader_end_point to first break point
  double m_kink_offset_1;  // from first break point to second break point

  /*
    Description:
      Calculates the 2d point locations of the dimension line kinks

    Parameters:
      p0, p1 [in] - End points of the dimension line
      direction [in] - orientation of the dimension
      default_offset [in] - Use this if offsets are ON_UNSET_VALUE
      k0, k1 [out] - The kink points
    Remarks:
      The offsets must be set to the right values before calling this, or
      If they are ON_UNSET_VALUE, they will be set to the defaults
  */
  void CalcKinkPoints( ON_2dPoint p0, ON_2dPoint p1,
                       int direction, double default_offset,
                       ON_2dPoint& k0, ON_2dPoint& k1) const;

};



//////////
// class ON_TextEntity2
class ON_CLASS ON_TextEntity2 : public ON_Annotation2
{
  ON_OBJECT_DECLARE(ON_TextEntity2);

public:
  ON_TextEntity2();
  ~ON_TextEntity2();

  // overrides virual ON_Object::IsValid
  // Text entities with strings that contain no "printable" characters
  // are considered to be NOT valid.
  ON_BOOL32 IsValid( ON_TextLog* text_log = 0 ) const;

  // overrides virual ON_Object::Write
  ON_BOOL32 Write(ON_BinaryArchive&) const;

  // overrides virual ON_Object::Read
  ON_BOOL32 Read(ON_BinaryArchive&);

  // overrides virtual ON_Geometry::Transform()
  ON_BOOL32 Transform( const ON_Xform& xform );

  // overrides virual ON_Geometry::GetBBox
  // This just adds the text base point to the box
  // There is no calculation of the size of the text or its bounds
  ON_BOOL32 GetBBox(
         double*,
         double*,
         ON_BOOL32 = false
         ) const;

  // overrides virual ON_Geometry::GetTightBoundingBox
  // This just adds the text base point to the box
  // There is no calculation of the size of the text or its bounds
	bool GetTightBoundingBox(
			ON_BoundingBox& tight_bbox,
      int bGrowBox = false,
			const ON_Xform* xform = 0
      ) const;

  /*
    Description:
      Get or set the Font index in the Font Table for the text

    Parameters:
      [in] int  the new index (Set)

    Returns:
      int -  The current index (Get)
  */
  int FontIndex() const;
  void SetFontIndex( int);

// 6-23-03 lw Added v2 file writing of annotation
  void GetV2Form( ON_TextEntity& text);

  void SetJustification( unsigned int justification);

  unsigned int Justification();

  // Determines whether or not to draw a Text Mask
  bool DrawTextMask() const;
  void SetDrawTextMask(bool bDraw);

  // Determines where to get the color to draw a Text Mask
  // 0: Use background color of the viewport.  Initially, gradient backgrounds will not be supported
  // 1: Use the ON_Color returned by MaskColor()
  int MaskColorSource() const;
  void SetMaskColorSource(int source);

  ON_Color MaskColor() const;  // Only works right if MaskColorSource returns 1.
                               // Does not return viewport background color
  void SetMaskColor(ON_Color color);

  // Offset for the border around text to the rectangle used to draw the mask
  // This number * CRhinoAnnotation::TextHeight() for the text is the offset
  // on each side of the tight rectangle around the text characters to the mask rectangle.
  double MaskOffsetFactor() const;
  void SetMaskOffsetFactor(double offset);
  // Scale annotation according to detail scale factor in paperspace
  // or by 1.0 in paperspace and not in a detail
  // Otherwise, dimscale or text scale is used
  bool AnnotativeScaling() const;
  void SetAnnotativeScaling(bool b);

};

//////////
// class ON_Leader2
class ON_CLASS ON_Leader2 : public ON_Annotation2
{
  ON_OBJECT_DECLARE(ON_Leader2);

public:

  /*
    The annotation's dimstyle controls the position of TEXT,
    the size of the arrowheads, and the amount the ends of
    linear dimension's extension lines extend beyond the
    dimension lines.

    Leaders:

      Polyline with N=m_points.Count() points (N >= 2).

                      [N-2] ----- [N-1] TEXT
                        /         (tail)
                       /
                      /
            [1]------[2]
            /
           /
          /
        [0] (arrow)

      Leaders ignore the m_userpositionedtext setting.  If the
      default leader text handling is not adequate, then use
      a leader with no text and an ON_TextEntity2.
  */

  enum POINT_INDEX
  {
    // Do not change these enum values.  They are saved in files as the
    // ON_COMPONENT_INDEX.m_index value.
    //
    // Indices of leader definition points in
    // the m_points[] array
    arrow_pt_index  = 0, // arrow tip

    // Points calculated from values in m_points[]
    text_pivot_pt = 10000, // start/end of dimension text at tail
    tail_pt       = 10001
  };

  // Constructors
  ON_Leader2();
  ~ON_Leader2();
  // C++ automatically provides the correct copy constructor and operator= .
  //ON_Leader2(const ON_Leader2&);
  //ON_Leader2& operator=(const ON_Leader2&);

  // overrides virtual ON_Geometry::Transform()
  ON_BOOL32 Transform( const ON_Xform& xform );

  /*
  Description:
    Get the m_plane coordinates of the dimension point.
  Parameters:
    point_index - [in] One of the POINT_INDEX enum values
  Returns:
    2d point or ON_UNSET_POINT if point_index or m_points[]
    array is not valid.
  */
  ON_2dPoint Dim2dPoint(
       int point_index
       ) const;

  /*
  Description:
    Get the m_plane coordinates of the dimension point.
  Parameters:
    point_index - [in] One of the POINT_INDEX enum values
  Returns:
    2d point or ON_UNSET_POINT if point_index or m_points[]
    array is not valid.
  */
  ON_3dPoint Dim3dPoint(
       int point_index
       ) const;

  // overrides virual ON_Object::IsValid
  ON_BOOL32 IsValid( ON_TextLog* text_log = 0 ) const;

  // overrides virual ON_Object::Write
  ON_BOOL32 Write(ON_BinaryArchive&) const;

  // overrides virual ON_Object::Read
  ON_BOOL32 Read(ON_BinaryArchive&);

  // overrides virual ON_Geometry::GetBBox
  ON_BOOL32 GetBBox(
         double*,
         double*,
         ON_BOOL32 = false
         ) const;

  // overrides virual ON_Geometry::GetTightBoundingBox
	bool GetTightBoundingBox(
			ON_BoundingBox& tight_bbox,
      int bGrowBox = false,
			const ON_Xform* xform = 0
      ) const;

  /*
    Description:
      Add or delete points to the leader
    Parameters:
      index [in] the point to delete
      point [in]  The point to add
    Returns:
      @untitled table
      true     Success
      False    Failure
  */
  void AddPoint( const ON_2dPoint& point);
  bool RemovePoint( int index = -1);

  /*
    Description:
      Converts an ON_Leader2 to the v2 form ON_Leader
    Parameters:
      leader [out] - the result of the conversion
  */
  void GetV2Form( ON_Leader& leader);
  bool CreateFromV2(
      const ON_Annotation& v2_ann,
      const ON_3dmAnnotationSettings& settings,
      int dimstyle_index
      );
// April 22, 2010 Lowell - Added to support right justified text on left pointing leader tails rr64292
  bool GetTextDirection( ON_2dVector& text_dir ) const;

  bool GetArrowHeadDirection( ON_2dVector& arrowhead_dir ) const;
  bool GetArrowHeadTip( ON_2dPoint& arrowhead_tip ) const;
};


/*
  A simple dot with text that doesn't rotate witn the world axes
*/
class ON_CLASS ON_TextDot : public ON_Geometry
{
  ON_OBJECT_DECLARE(ON_TextDot);

public:
  ON_TextDot();
  ~ON_TextDot();
  // C++ automatically provides the correct copy constructor and operator= .
  //ON_TextDot( const ON_TextDot& src);
  //ON_TextDot& operator=( const ON_TextDot& src);

  void EmergencyDestroy();

  //---------------------------
  // ON_Object overrides

  /*
  Description:
    Tests an object to see if its data members are correctly
    initialized.
  Paramters:
    text_log - [in] if the object is not valid and text_log
        is not NULL, then a brief english description of the
        reason the object is not valid is appended to the log.
        The information appended to text_log is suitable for
        low-level debugging purposes by programmers and is
        not intended to be useful as a high level user
        interface tool.
  Returns:
    @untitled table
    true     object is valid
    false    object is invalid, uninitialized, etc.
  Remarks:
    Overrides virtual ON_Object::IsValid
  */
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  /*
    Description: Write data values to a text file for debugging
  */
  void Dump( ON_TextLog& log) const;

  /*
    Description: Writes the object to a file

    Returns:
      @untitled Table
      true     Success
      false    Failure
  */
  ON_BOOL32 Write( ON_BinaryArchive& ar) const;

  /*
    Description: Reads the object from a file

    Returns:
      @untitled Table
      true     Success
      false    Failure
  */
  ON_BOOL32 Read( ON_BinaryArchive& ar);

  /*
    Returns: The Object Type of this object
  */
  ON::object_type ObjectType() const;

  //---------------------------
  // ON_Geometry overrides

  /*
    Returns the geometric dimension of the object ( usually 3)
  */
  int Dimension() const;

  /*
    Description:
      Get a bounding 3d WCS box of the object
    Parameters:
      [in/out] double* boxmin - pointer to dim doubles for min box corner
      [in/out] double* boxmax - pointer to dim doubles for max box corner
      [in] ON_BOOL32 growbox   - true to grow the existing box,
                            false ( the default) to reset the box
    Returns:
      true = Success
      false = Failure
    Remarks:
      Since the bounding box of this entity changes size at different
      zoom levels, the bounding box is a point at the definition point
  */
  ON_BOOL32 GetBBox( double* box_min, double* box_max, ON_BOOL32 grow_box = false) const;

  /*
    Description:
      Transform the object by a 4x4 xform matrix
    Parameters:
      [in] xform  - An ON_Xform with the transformation information
    Returns:
      true = Success
      false = Failure
    Remarks:
      The object has been transformed when the function returns
  */
  ON_BOOL32 Transform( const ON_Xform& xform);

  // virtual ON_Geometry::IsDeformable() override
  bool IsDeformable() const;

  // virtual ON_Geometry::MakeDeformable() override
  bool MakeDeformable();

  const ON_3dPoint& Point() const;
  void SetPoint( const ON_3dPoint& point);

  int Height() const;
  void SetHeight( int);

  const wchar_t* TextString() const;
  void SetTextString( const wchar_t* string);

  const wchar_t* FontFace() const;
  void SetFontFace( const wchar_t* face);


  /*
    Description:
      Get or Set whether the dot is drawn "On Top" of other geometry
    Parameters:
      [in] bTop  bool - It is or isn't on top
    Returns:
      @untitled table
      true - on top
      false - not on top
  */
  void SetAlwaysOnTop(bool bTop);
  bool AlwaysOnTop() const;

  /*
    Description:
      Get or Set whether the dot is drawn with a transparent background
    Parameters:
      [in] bTransparent  bool - It is or isn't transparent
    Returns:
      @untitled table
      true - transparent
      false - not transparent
  */
  void SetTransparent(bool bTransparent);
  bool Transparent() const;

  /*
    Description:
      Get or Set whether the dot is drawn with Bold text
    Parameters:
      [in] bBold  bool - It is or isn't Bold
    Returns:
      @untitled table
      true - Bold
      false - not Bold
  */
  void SetBold(bool bBold);
  bool Bold() const;

  /*
    Description:
      Get or Set whether the dot is drawn with Italic text
    Parameters:
      [in] bItalic  bool - It is or isn't Italic
    Returns:
      @untitled table
      true - Italic
      false - not Italic
  */
  void SetItalic(bool bItalic);
  bool Italic() const;


  ON_3dPoint m_point;
  int m_height;        // in points
  ON_wString m_text;
  ON_wString m_fontface;
  int m_display;       // some future display flags -
};



#endif


/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#ifndef OPENNURBS_HATCH_H_INCLUDED
#define OPENNURBS_HATCH_H_INCLUDED

/*
  class ON_HatchLoop
  /////////////////////////////////////////////////////////////////
  Represents a 3d boundary loop curve
*/
class ON_CLASS ON_HatchLoop
{
public:
#if defined(ON_DLL_EXPORTS) || defined(ON_DLL_IMPORTS)
  // When the Microsoft CRT(s) is/are used, this is the best
  // way to prevent crashes that happen when a hatch loop is
  // allocated with new in one DLL and deallocated with
  // delete in another DLL.

  // new/delete
  void* operator new(size_t);
  void  operator delete(void*);

  // array new/delete
  void* operator new[] (size_t);
  void  operator delete[] (void*);

  // in place new/delete
  void* operator new(size_t,void*);
  void  operator delete(void*,void*);
#endif

  enum eLoopType
  {
    ltOuter = 0,
    ltInner = 1
  };

  ON_HatchLoop();
  ON_HatchLoop( ON_Curve* pCurve2d, eLoopType type = ltOuter);
  ON_HatchLoop( const ON_HatchLoop& src);
  ~ON_HatchLoop();

  ON_HatchLoop& operator=( const ON_HatchLoop& src);

  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;
  void Dump( ON_TextLog& ) const; // for debugging
  ON_BOOL32 Write( ON_BinaryArchive&) const;
  ON_BOOL32 Read( ON_BinaryArchive&);

  // Interface
  /////////////////////////////////////////////////////////////////

  /*
  Description:
    Get a closed 2d curve boundary loop
  Parameters:
  Return:
    Pointer to loop's 2d curve
  */
  const ON_Curve* Curve() const;
 
  /*
  Description:
    Specify the 2d loop curve in the hatch's plane coordinates
  Parameters:
    curve - [in] 2d input curve
  Return:
    true: success, false, curve couldn't be duplicated
  Remarks:
    The curve is copied
  */
  bool SetCurve( const ON_Curve& curve);

  /*
  Description:
    Get the type flag of the loop
  Returns:
    eLoopType::ltInner or eLoopType::ltOuter
  */
  eLoopType Type() const;

  /*
  Description:
    Specify the type flag of the loop
  Parameters:
    type - [in] ltInner or ltOuter
  */
  void SetType( eLoopType type);

protected:
  friend class ON_Hatch;
  eLoopType m_type;         // loop type flag - inner or outer
  ON_Curve* m_p2dCurve;     // 2d closed curve bounding the hatch
                            // This is really a 3d curve with z coordinates = 0
};


/*
  class ON_HatchLine
  /////////////////////////////////////////////////////////////////
  Represents one line of a hatch pattern
  Similar to AutoCAD's .pat file definition
  ON_HatchLine's are used by ON_HatchPattern
    to specify the dashes and offset patterns of the lines.

  Each line has the following information:
  Angle is the direction of the line CCW from the x axis
  The first line origin is at base
  Each line repetition is offset by offset from the previous line
    offset.x is parallel to the line and 
    offset.y is perpendicular to the line
  The base and offset values are rotated by the line's angle to 
    produce a location in the hatch pattern's coordinate system
  There can be gaps and dashes specified for drawing the line

  If there are no dashes, the line is solid
  Negative length dashes are gaps
  Positive length dashes are drawn as line segments
*/

class ON_CLASS ON_HatchLine
{
public:
  ON_HatchLine();
  // C++ default copy construction and operator= work fine.

  ON_HatchLine( 
    double angle, 
    const ON_2dPoint& base, 
    const ON_2dVector& offset,
    const ON_SimpleArray<double> dashes);

  bool operator==( const ON_HatchLine&) const;
  bool operator!=( const ON_HatchLine&) const;

  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;
  void Dump( ON_TextLog& ) const; // for debugging
  ON_BOOL32 Write( ON_BinaryArchive&) const;  // serialize definition to binary archive
  ON_BOOL32 Read( ON_BinaryArchive&);  // restore definition from binary archive

  // Interface
  /////////////////////////////////////////////////////////////////

  /*
  Description:
    Get angle of the hatch line.
    CCW from x-axis
  Parameters:
  Return:
    The angle in radians
  */
  double Angle() const;

  /*
  Description:
    Set angle of the hatch line.
    CCW from x-axis
  Parameters:
    angle - [in] angle in radians
  Return:
  */
  void SetAngle( double angle);
  
  /*
  Description:
    Get this line's 2d basepoint
  Parameters:
  Return:
    the base point
  */
  ON_2dPoint Base() const;
  /*
  Description:
    Set this line's 2d basepoint
  Parameters:
    base - [in] the basepoint
  Return:
  */
  void SetBase( const ON_2dPoint& base);
  
  /*
  Description:
    Get this line's 2d offset for line repetitions
    Offset().x is shift parallel to line
    Offset().y is spacing perpendicular to line
  Parameters:
  Return:
    the offset
  */
  ON_2dVector Offset() const;

  /*
  Description:
    Get this line's 2d offset for line repetitions
    Offset().x is shift parallel to line
    Offset().y is spacing perpendicular to line
  Parameters:
    offset - [in] the shift,spacing for repeated lines
  Return:
  */
  void SetOffset( const ON_2dVector& offset);

  /*
  Description:
    Get the number of gaps + dashes in the line
  Parameters:
  Return:
    nummber of dashes in the line
  */
  int DashCount() const;

  /*
  Description:
    Get the dash length at index
  Parameters:
    index - [in] the dash to get
  Return:
    the length of the dash ( gap if negative)
  */
  double Dash( int) const;

  /*
  Description:
    Add a dash to the pattern
  Parameters:
    dash - [in] length to append - < 0 for a gap
  */
  void AppendDash( double dash);

  /*
  Description:
    Specify a new dash array
  Parameters:
    dashes - [in] array of dash lengths
  */
  void SetPattern( const ON_SimpleArray<double>& dashes);

  /*
  Description:
    Get the line's angle, base, offset and dashes 
    in one function call
  Parameters:
    angle  - [out] angle in radians CCW from x-axis
    base   - [out] origin of the master line
    offset - [out] offset for line replications
    dashes - [out] the dash array for the line
  Return:
  */
  void GetLineData(
    double& angle, 
    ON_2dPoint& base, 
    ON_2dVector& offset, 
    ON_SimpleArray<double>& dashes) const;

  /*
  Description:
    Get the total length of a pattern repeat
  Parameters:
  Return:
    Pattern length
  */
  double GetPatternLength() const;

public:
  double m_angle;
  ON_2dPoint m_base;
  ON_2dVector m_offset;
  ON_SimpleArray< double> m_dashes;
};




#if defined(ON_DLL_TEMPLATE)
// This stuff is here because of a limitation in the way Microsoft
// handles templates and DLLs.  See Microsoft's knowledge base 
// article ID Q168958 for details.
#pragma warning( push )
#pragma warning( disable : 4231 )
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_HatchLoop*>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ON_HatchLine>;
#pragma warning( pop )
#endif


/*
  class ON_HatchPattern
  /////////////////////////////////////////////////////////////////
  Fill definition for a hatch

  The hatch  will be one of 
    ON_Hatch::ftLines     - pat file style definition
    ON_Hatch::ftGradient  - uses a color function
    ON_Hatch::ftSolid     - uses entity color

*/
class ON_CLASS ON_HatchPattern : public ON_Object
{
  ON_OBJECT_DECLARE( ON_HatchPattern);

public:

  enum eFillType
  {
    ftSolid    = 0,  // uses entity color
    ftLines    = 1,  // pat file definition
    ftGradient = 2,  // uses a fill color function
    ftLast     = 3
  };

  ON_HatchPattern();
  ~ON_HatchPattern();
  // C++ default copy construction and operator= work fine.

 // ON_Object overrides
  /////////////////////////////////////////////////////////////////
   ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;
  void Dump( ON_TextLog& ) const; // for debugging
  ON_BOOL32 Write( ON_BinaryArchive&) const;
  ON_BOOL32 Read( ON_BinaryArchive&);

  // virtual
  ON_UUID ModelObjectId() const;


  //////////////////////////////////////////////////////////////////////
  // Interface

  /*
  Description:
    Return the pattern's fill type
  Parameters:
  */
  eFillType FillType() const;

  /*
  Description:
    Set the pattern's fill type
  Parameters:
    type - [in] the new filltype
  */
  void SetFillType( eFillType type);

  /*
  Description:
    Set the name of the pattern
  Parameters:
    pName - [in] the new name
  Returns:
  */
  void SetName( const wchar_t* pName);
  void SetName( const char* pName);
  
  /*
  Description:
    Get the name of the pattern
  Parameters:
    string - [out] The name is returned here
  */
  void GetName( ON_wString& string) const;

  /*
  Description:
    Get the name of the pattern
  Returns:
    The name string
  */
  const wchar_t* Name() const;

  /*
  Description:
    Set the name of the pattern
  Parameters:
    pDescription - [in] the new description
  Returns:
  */
  void SetDescription( const wchar_t* pDescription);
  void SetDescription( const char* pDescription);
  
  /*
  Description:
    Get a short description of the pattern
  Parameters:
    string - [out] The string is returned here
  */
  void GetDescription( ON_wString& string) const;

  /*
  Description:
    Return a short text description of the pattern type
  Parameters:
  Returns:
    The description string
  */
  const wchar_t* Description() const;

  /*
  Description:
    Set the table index of the pattern
  Parameters:
    index - [in] the new index
  Returns:
  */
  void SetIndex( int index);

  /*
  Description:
    Return the table index of the pattern
  Parameters:
  Returns:
    The table index
  */
  int Index() const;

  // Interface functions for line hatches
  /////////////////////////////////////////////////////////////////
  /*
  Description:
    Get the number of ON_HatchLines in the pattern
  Parameters:
  Return:
    number of lines
  */
  int HatchLineCount() const;

  /*
  Description:
    Add an ON_HatchLine to the pattern
  Parameters:
    line - [in] the line to add
  Return:
    >= 0 index of the new line
    -1 on failure
  */
  int AddHatchLine( const ON_HatchLine& line);

  /*
  Description:
    Get the ON_HatchLine at index
  Parameters:
    index - [in] Index of the line to get
  Return:
    the hatch line
    NULL if index is out of range
  */
  const ON_HatchLine* HatchLine( int index) const;

  /*
  Description:
    Remove a hatch line from the pattern
  Parameters:
    index - [in] Index of the line to remove
  Return:
    true - success
    false - index out of range
  */
  bool RemoveHatchLine( int index);

  /*
  Description:
    Remove all of the hatch line from the pattern
  Parameters:

  Return:
    true - success
    false - index out of range
  */
  void RemoveAllHatchLines();

  /*
  Description:
    Set all of the hatch lines at once. 
    Existing hatchlines are deleted.
  Parameters:
    lines - [in] Array of lines to add.  Lines are copied
  Return:
    number of lines added
  */
  int SetHatchLines( const ON_ClassArray<ON_HatchLine> lines);

public:
  int m_hatchpattern_index;         // Index in the hatch pattern table
  ON_wString m_hatchpattern_name;   // String name of the pattern
  ON_UUID m_hatchpattern_id;
  
  eFillType m_type;
  
  ON_wString m_description;  // String description of the pattern

  // Represents a collection of ON_HatchLine's to make a complete pattern
  // This is the definition of a hatch pattern.
  // Simple solid line hatches with fixed angle and spacing are also 
  // represented with this type of hatch
  ON_ClassArray<ON_HatchLine> m_lines; // used by line hatches
};

/*
  class ON_Hatch
  /////////////////////////////////////////////////////////////////
  Represents a hatch in planar boundary loop or loops 
  This is a 2d entity with a plane defining a local coordinate system
  The loops, patterns, angles, etc are all in this local coordinate system

  The ON_Hatch object manages the plane and loop array
  Fill definitions are in the ON_HatchPattern or class derived from ON_HatchPattern
  ON_Hatch has an index to get the pattern definition from the pattern table

*/
class ON_CLASS ON_Hatch : public ON_Geometry
{
  ON_OBJECT_DECLARE( ON_Hatch);

public:
  // Default constructor
  ON_Hatch();
  ON_Hatch( const ON_Hatch&);
  ON_Hatch& operator=(const ON_Hatch&);
  ~ON_Hatch();

  virtual ON_Hatch* DuplicateHatch() const;

  // ON_Object overrides
  /////////////////////////////////////////////////////////////////
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;
  void Dump( ON_TextLog& ) const; // for debugging
  ON_BOOL32 Write( ON_BinaryArchive&) const;
  ON_BOOL32 Read( ON_BinaryArchive&);
  ON::object_type ObjectType() const;

  // ON_Geometry overrides
  /////////////////////////////////////////////////////////////////
  /*
    Returns the geometric dimension of the object ( usually 3)
  */
  int Dimension() const;

  /*
    Description:
      Get a bounding 3d WCS box of the object
      This is a bounding box of the boundary loops
    Parameters:
      [in/out] double* boxmin - pointer to dim doubles for min box corner
      [in/out] double* boxmax - pointer to dim doubles for max box corner
      [in] ON_BOOL32 growbox   - true to grow the existing box,
                            false ( the default) to reset the box
    Returns:
      true = Success
      false = Failure
    Remarks:
  */
  ON_BOOL32 GetBBox( double*, double*, ON_BOOL32 = false) const;

  /*
	Description:
    Get tight bounding box of the hatch.
	Parameters:
		tight_bbox - [in/out] tight bounding box
		bGrowBox -[in]	(default=false)			
      If true and the input tight_bbox is valid, then returned
      tight_bbox is the union of the input tight_bbox and the 
      tight bounding box of the hatch.
		xform -[in] (default=NULL)
      If not NULL, the tight bounding box of the transformed
      hatch is calculated.  The hatch is not modified.
	Returns:
    True if the returned tight_bbox is set to a valid 
    bounding box.
  */
	bool GetTightBoundingBox( 
			ON_BoundingBox& tight_bbox, 
      int bGrowBox = false,
			const ON_Xform* xform = 0
      ) const;


  /*
    Description:
      Transform the object by a 4x4 xform matrix

    Parameters:
      [in] xform  - An ON_Xform with the transformation information
    Returns:
      true = Success
      false = Failure
    Remarks:
      The object has been transformed when the function returns.
  */
  ON_BOOL32 Transform( const ON_Xform&);

  // Interface
  /////////////////////////////////////////////////////////////////

  /*
  Description:
    Create a hatch from input geometry and parameters
  Parameters:
    plane [I] - ON_Plane to make the hatch on
    loops [I] - Array of boundary loops with the outer one first
    pattern_index [I] - Index into the hatch table
    pattern_rotation [I] - ccw in radians about plane origin
    pattern_scale [I] - Scale factor for pattern definition
  Returns:
    true = success, false = failure
  */
  bool Create( const ON_Plane& plane,
               const ON_SimpleArray<const ON_Curve*> loops, 
               int pattern_index, 
               double pattern_rotation, 
               double pattern_scale);

  /*
  Description:
    Get the plane defining the hatch's coordinate system
  Parameters:
  Returns:
    the plane
  */
  const ON_Plane& Plane() const;

  /*
  Description:
    Set the plane defining the hatch's coordinate system
  Parameters:
    plane - [in] the plane to set
  Returns:
  */
  void SetPlane( const ON_Plane& plane);
  
  /*
  Description:
    Gets the rotation applied to the hatch pattern 
    when it is mapped to the hatch's plane
  Returns:
    The rotation in radians
  Remarks:
    The pattern is rotated counter-clockwise around
    the hatch's plane origin by this value
  */
  double PatternRotation() const;

/*
  Description:
    Sets the rotation applied to the hatch pattern 
    when it is mapped to the hatch's plane
  Parameters:
    rotation - [in] The rotation in radians
  Remarks:
    The pattern is rotated counter-clockwise around
    the hatch's plane origin by this value
  */
  void SetPatternRotation( double rotation);
  
  /*
  Description:
    Gets the scale applied to the hatch pattern 
    when it is mapped to the hatch's plane
  Returns:
    The scale
  Remarks:
    The pattern is scaled around
    the hatch's plane origin by this value
  */
  double PatternScale() const;

/*
  Description:
    Sets the scale applied to the hatch pattern 
    when it is mapped to the hatch's plane
  Parameters:
    scale - [in] The scale
  Remarks:
    The pattern is scaled around
    the hatch's plane origin by this value
  */
  void SetPatternScale( double scale);
  
  /*
  Description:
    Get the number of loops used by this hatch
  Parameters:
  Returns:
    the number of loops
  */
  int LoopCount() const;

  /*
  Description:
    Add a loop to the hatch
  Parameters:
    loop - [in] the loop to add. Memory management for the loop is managed
           by this class.
  Returns:
  */
  void AddLoop( ON_HatchLoop* loop);

  /*
  Description:
    Insert a loop to the hatch at the specified index
  Parameters:
    index - [in] zero based index of the position where insert the loop to.
    loop - [in] the loop to insert. Memory management for the loop is managed
                by this class on success.
  Returns:
    true if success
	  false if index is lower than 0 or greater than current loop count.
  */
  bool InsertLoop( int index,
                   ON_HatchLoop* loop);

  /*
  Description:
    Remove a loop in the hatch
  Parameters:
    loop - [in] zero based index of the loop to remove.
  Returns:
    true if success
  */
  bool RemoveLoop( int index);

  /*
  Description:
    Get the loop at index
  Parameters:
    index - [in] which loop to get
  Returns:
    pointer to loop at index
    NULL if index is out of range
  */
  const ON_HatchLoop* Loop( int index) const;

  /*
  Description:
    Get the 3d curve corresponding to loop[index]
  Parameters:
    index - [in] which loop to get
  Returns:
    pointer to 3d curve of loop at index
    NULL if index is out of range or curve can't be made
    Caller deletes the returned curve
  */
  ON_Curve* LoopCurve3d( int index) const;

  /*
  Description:
    Get the index of the hatch's pattern
  Parameters:
  Returns:
    index of the pattern
  */
  int PatternIndex() const;

/*
  Description:
    Set the index of the hatch's pattern
  Parameters:
    index - [in] pattern index to set
  Returns:
  */
  void SetPatternIndex( int index);

  // Basepoint functions added March 23, 2008 -LW
  /*
  Description:
    Set 2d Base point for hatch pattern alignment.
  Parameters:
    basepoint - 2d point in hatch's ECS
  */
  void SetBasePoint(ON_2dPoint basepoint);

  /*
  Description:
    Set 3d Base point for hatch pattern alignment.
  Parameters:
    point - 3d WCS point
  Remarks:
    Projects point to hatch's plane and sets 2d point
  */
  void SetBasePoint(ON_3dPoint point);

  /*
  Description:
    Return 3d WCS point that lies on hatch's plane used for pattern origin.
  */
  ON_3dPoint BasePoint() const;

  /*
  Description:
    Return 2d ECS point used for pattern origin.
  */
  ON_2dPoint BasePoint2d() const;

  /*
  Function added June 12 2008 LW
  Description:
    Remove all of the loops on the hatch and add the curves in 'loops' as new loops
  Parameters:
    loops - [in] An array of pointers to 2d or 3d curves
                 If the curves are 2d, add them to the hatch directly
                 If they are 3d, project them to the hatch's plane first
  Returns:
    true  - success
    false - no loops in input array or an error adding them
  */
  bool ReplaceLoops(ON_SimpleArray<const ON_Curve*> loops);

protected:
  ON_Plane m_plane;
  double m_pattern_scale;
  double m_pattern_rotation;
  ON_SimpleArray<ON_HatchLoop*> m_loops;
  int m_pattern_index;

    // This function is temporary and will be removed next time the SDK can be modified.
  class ON_HatchExtra* HatchExtension();

};

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_DIMSTYLE_INC_)
#define OPENNURBS_DIMSTYLE_INC_

class ON_CLASS ON_DimStyle : public ON_Object
{
  ON_OBJECT_DECLARE(ON_DimStyle);

public:
  enum eArrowType
  {
    solidtriangle = 0,    // 2:1
    dot = 1,
    tick = 2,
    shorttriangle = 3,    // 1:1
    arrow = 4,
    rectangle = 5,
    longtriangle = 6,     // 4:1
    longertriangle = 7    // 6:1
  };

  ON_DimStyle();
  ~ON_DimStyle();
  // C++ default copy construction and operator= work fine.-

  ON_DimStyle& operator=( const ON_3dmAnnotationSettings& src);

  //////////////////////////////////////////////////////////////////////
  //
  // ON_Object overrides

  /*
  Description:
    Tests an object to see if its data members are correctly
    initialized.
  Parameters:
    text_log - [in] if the object is not valid and text_log
        is not NULL, then a brief englis description of the
        reason the object is not valid is appened to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     object is valid
    false    object is invalid, uninitialized, etc.
  Remarks:
    Overrides virtual ON_Object::IsValid
  */
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  // virtual
  void Dump( ON_TextLog& ) const; // for debugging

  // virtual
  ON_BOOL32 Write(
         ON_BinaryArchive&  // serialize definition to binary archive
       ) const;

  // virtual
  ON_BOOL32 Read(
         ON_BinaryArchive&  // restore definition from binary archive
       );

  void EmergencyDestroy();

  // virtual
  ON_UUID ModelObjectId() const;


  //////////////////////////////////////////////////////////////////////
  //
  // Interface

  void SetName( const wchar_t* );
  void SetName( const char* );

  void GetName( ON_wString& ) const;
  const wchar_t* Name() const;

  void SetIndex(int);
  int Index() const;

  void SetDefaults();
  void SetDefaultsNoExtension();


  double ExtExtension() const;
  void SetExtExtension( const double);

  double ExtOffset() const;
  void SetExtOffset( const double);

  double ArrowSize() const;
  void SetArrowSize( const double);

  double LeaderArrowSize() const;
  void SetLeaderArrowSize( const double);

  double CenterMark() const;
  void SetCenterMark( const double);

  int TextAlignment() const;
  void SetTextAlignment( ON::eTextDisplayMode);

  int ArrowType() const;
  void SetArrowType( eArrowType);

  int LeaderArrowType() const;
  void SetLeaderArrowType( eArrowType);

  int AngularUnits() const;
  void SetAngularUnits( int);

  int LengthFormat() const;
  void SetLengthFormat( int);

  int AngleFormat() const;
  void SetAngleFormat( int);

  int LengthResolution() const;
  void SetLengthResolution( int);

  int AngleResolution() const;
  void SetAngleResolution( int);

  int FontIndex() const;
  virtual void SetFontIndex( int index);

  double TextGap() const;
  void SetTextGap( double gap);

  double TextHeight() const;
  void SetTextHeight( double height);

  // added at ver 1.3
  double LengthFactor() const;
  ON_DEPRECATED void SetLengthactor( double);
  void SetLengthFactor( double); // added 6/24/07 because of typo

  bool Alternate() const;
  void SetAlternate( bool);

  double AlternateLengthFactor() const;
  ON_DEPRECATED void SetAlternateLengthactor( double);
  void SetAlternateLengthFactor( double); // added 6/24/07 because of typo

  int AlternateLengthFormat() const;
  void SetAlternateLengthFormat( int);

  int AlternateLengthResolution() const;
  void SetAlternateLengthResolution( int);

  int AlternateAngleFormat() const;
  void SetAlternateAngleFormat( int);

  int AlternateAngleResolution() const;
  void SetAlternateAngleResolution( int);

  void GetPrefix( ON_wString& ) const;
  const wchar_t* Prefix() const;
  void SetPrefix( const wchar_t*);
  void SetPrefix( wchar_t*);

  void GetSuffix( ON_wString& ) const;
  const wchar_t* Suffix() const;
  void SetSuffix( const wchar_t*);
  void SetSuffix( wchar_t*);

  void GetAlternatePrefix( ON_wString& ) const;
  const wchar_t* AlternatePrefix() const;
  void SetAlternatePrefix( const wchar_t*);
  void SetAlternatePrefix( wchar_t*);

  void GetAlternateSuffix( ON_wString& ) const;
  const wchar_t* AlternateSuffix() const;
  void SetAlternateSuffix( const wchar_t*);
  void SetAlternateSuffix( wchar_t*);

  bool SuppressExtension1() const;
  void SetSuppressExtension1( bool);

  bool SuppressExtension2() const;
  void SetSuppressExtension2( bool);

  // obsolete
  ON_DEPRECATED void Composite( const ON_DimStyle& override);

  // Don't change these enum values
  // They are used in file reading & writing
  enum eField
  {
    fn_name                        = 0,
    fn_index                       = 1,
    fn_extextension                = 2,
    fn_extoffset                   = 3,
    fn_arrowsize                   = 4,
    fn_centermark                  = 5,
    fn_textgap                     = 6,
    fn_textheight                  = 7,
    fn_textalign                   = 8,
    fn_arrowtype                   = 9,
    fn_angularunits                = 10,
    fn_lengthformat                = 11,
    fn_angleformat                 = 12,
    fn_angleresolution             = 13,
    fn_lengthresolution            = 14,
    fn_fontindex                   = 15,
    fn_lengthfactor                = 16,
    fn_bAlternate                  = 17,
    fn_alternate_lengthfactor      = 18,
    fn_alternate_lengthformat      = 19, 
    fn_alternate_lengthresolution  = 20,
    fn_alternate_angleformat       = 21, 
    fn_alternate_angleresolution   = 22,
    fn_prefix                      = 23,
    fn_suffix                      = 24,
    fn_alternate_prefix            = 25,
    fn_alternate_suffix            = 26,
    fn_dimextension                = 27,
    fn_leaderarrowsize             = 28,
    fn_leaderarrowtype             = 29,
    fn_suppressextension1          = 30,
    fn_suppressextension2          = 31,
    fn_last                        = 32, // not used - left here for sdk
                   
  // Added for v5 - 5/01/07 LW    
  // version 1.6
    fn_overall_scale               = 33,
    fn_ext_line_color_source       = 34,
    fn_dim_line_color_source       = 35,
    fn_arrow_color_source          = 36,
    fn_text_color_source           = 37,
    fn_ext_line_color              = 38,
    fn_dim_line_color              = 39,
    fn_arrow_color                 = 40,
    fn_text_color                  = 41,
    fn_ext_line_plot_color_source  = 42,
    fn_dim_line_plot_color_source  = 43,
    fn_arrow_plot_color_source     = 44,
    fn_text_plot_color_source      = 45,
    fn_ext_line_plot_color         = 46,
    fn_dim_line_plot_color         = 47,
    fn_arrow_plot_color            = 48,
    fn_text_plot_color             = 49,
    fn_ext_line_plot_weight_source = 50,
    fn_dim_line_plot_weight_source = 51,
    fn_ext_line_plot_weight_mm     = 52,
    fn_dim_line_plot_weight_mm     = 53,
    fn_tolerance_style             = 54,
    fn_tolerance_resolution        = 55,
    fn_tolerance_upper_value       = 56,
    fn_tolerance_lower_value       = 57,
    fn_tolerance_height_scale      = 58,
    fn_baseline_spacing            = 59,

  // Added for v5 - 12/15/09 LW    
  // version 1.7
    fn_draw_mask                   = 60,
    fn_mask_color_source           = 61,
    fn_mask_color                  = 62,
    fn_mask_border                 = 63,

  // Added for v5 - 12/17/09 LW    
  // version 1.8
    fn_dimscale                    = 64,
    fn_dimscale_source             = 65,

    //When fields are added to ON_DimStyleExtra,
    //   enum { eFieldCount = 64 }; in opennurbs_dimstyle.cpp
    // needs to be changed.
    fn_really_last                 = 0xFFFF
  };

  // These are obsolete - don't use
  // 5/01/07 - LW
  ON_DEPRECATED void InvalidateField( eField field);
  ON_DEPRECATED void InvalidateAllFields();
  ON_DEPRECATED void ValidateField( eField field);
  ON_DEPRECATED bool IsFieldValid( eField) const;

  // added version 1.3
  double DimExtension() const;
  void SetDimExtension( const double);

  // This section Added for v5 - 4-24-07 LW
  // version 1.6

  // Test if a specific field has been set in this dimstyle
  // and not inherited from its parent.
  bool IsFieldOverride( eField field_id) const;
  // Set a field to be overridden or not
  // Fields that aren't overrides inherit from their parent dimstyle
  void SetFieldOverride(  ON_DimStyle::eField field_id, bool bOverride);

  // Test if the dimstyle has any field override flags set
  bool HasOverrides() const;

  // Change the fields in this dimstyle to match the fields of the 
  // source dimstyle for all of the fields that are marked overridden in the source
  // and to match the parent for all of the fields not marked overriden.
  // Returns true if any overrides were set.
  bool OverrideFields( const ON_DimStyle& source, const ON_DimStyle& parent);

  // 
  // Change the fields in this dimstyle to match the fields of the 
  // parent dimstyle for all of the fields that are not marked overridden in the 
  // target dimstyle.
  // This is the complement of OverrideFields()
  bool InheritFields( const ON_DimStyle& parent);

  // Test if this dimstyle is the child of any other dimstyle
  bool IsChildDimstyle() const;

  // Test if this dimstyle is the child of a given dimstyle
  // A dimstyle may have several child dimstyles, but only one parent
  bool IsChildOf( const ON_UUID& parent_uuid) const;
  bool IsChildOf( ON_UUID& parent_uuid) const; // decl error - const forgotten

  ON_UUID ParentId() const;

  // Set the parent of this dimstyle
  void SetParentId( ON_UUID parent_uuid);
  ON_DEPRECATED void SetParent( ON_UUID& parent_uuid); // use set parent id

  // Tolerances
  // Tolerance style
  //  0: None
  //  1: Symmetrical
  //  2: Deviation
  //  3: Limits
  //  4: Basic
  int  ToleranceStyle() const;
  int  ToleranceResolution() const;
  double ToleranceUpperValue() const;
  double ToleranceLowerValue() const;
  double ToleranceHeightScale() const;

  double BaselineSpacing() const;

  void SetToleranceStyle( int style);
  void SetToleranceResolution( int resolution);
  void SetToleranceUpperValue( double upper_value);
  void SetToleranceLowerValue( double lower_value);
  void SetToleranceHeightScale( double scale);
  
  void SetBaselineSpacing( double spacing = false);

    // Determines whether or not to draw a Text Mask
  bool DrawTextMask() const;
  void SetDrawTextMask(bool bDraw);

  // Determines where to get the color to draw a Text Mask
  // 0: Use background color of the viewport.  Initially, gradient backgrounds will not be supported
  // 1: Use the ON_Color returned by MaskColor()
  int MaskColorSource() const;
  void SetMaskColorSource(int source);

  ON_Color MaskColor() const;  // Only works right if MaskColorSource returns 1.
                               // Does not return viewport background color
  void SetMaskColor(ON_Color color);

  // Per DimStyle DimScale
  void SetDimScaleSource(int source);
  int DimScaleSource() const;          // 0: Global DimScale, 1: DimStyle DimScale
  void SetDimScale(double scale);
  double DimScale() const;

  // Offset for the border around text to the rectangle used to draw the mask
  // This number * CRhinoAnnotation::TextHeight() for the text is the offset 
  // on each side of the tight rectangle around the text characters to the mask rectangle.
  double MaskOffsetFactor() const;

  void Scale( double scale);

  // UUID of the dimstyle this was originally copied from
  // so Restore Defaults has some place to look
  void SetSourceDimstyle(ON_UUID source_uuid);
  ON_UUID SourceDimstyle() const;

  // Defaults for values stored in Userdata extension
  static int      DefaultToleranceStyle();
  static int      DefaultToleranceResolution();
  static double   DefaultToleranceUpperValue();
  static double   DefaultToleranceLowerValue();
  static double   DefaultToleranceHeightScale();
  static double   DefaultBaselineSpacing();
  static bool     DefaultDrawTextMask(); // false
  static int      DefaultMaskColorSource(); // 0;
  static ON_Color DefaultMaskColor(); // .SetRGB(255,255,255);
  static double   DefaultDimScale(); // 1.0;
  static int      DefaultDimScaleSource(); // 0;

  bool CompareFields(const ON_DimStyle& other) const;

public:
  ON_wString m_dimstyle_name;   // String name of the style
  int m_dimstyle_index;         // Index in the dimstyle table
  ON_UUID m_dimstyle_id;

  double m_extextension; // extension line extension
  double m_extoffset;    // extension line offset
  double m_arrowsize;  // length of an arrow - may mean different things to different arrows
  double m_centermark; // size of the + at circle centers
  double m_textgap;    // gap around the text for clipping dim line
  double m_textheight; // model unit height of dimension text before applying dimscale
  int m_textalign;     // text alignment relative to the dimension line
  int m_arrowtype;     // 0: filled narrow triangular arrow
  int m_angularunits;  // 0: degrees, 1: radians
  int m_lengthformat;  // 0: decimal, 1: feet, 2: feet & inches
  int m_angleformat;   // 0: decimal degrees, ...
  int m_angleresolution;    // for decimal degrees, digits past decimal
  int m_lengthresolution;   // depends on m_lengthformat
                            // for decimal, digits past the decimal point
  int m_fontindex;     // index of the ON_Font used by this dimstyle

  // added fields version 1.2, Jan 13, 05
  double m_lengthfactor;  // (dimlfac) model units multiplier for length display
  bool m_bAlternate;      // (dimalt) display alternate dimension string (or not)
                          // using m_alternate_xxx values
  double m_alternate_lengthfactor;  // (dimaltf) model units multiplier for alternate length display
  int m_alternate_lengthformat;     // 0: decimal, 1: feet, 2: feet & inches
  int m_alternate_lengthresolution; // depends on m_lengthformat
                                    // for decimal, digits past the decimal point
  int m_alternate_angleformat;      // 0: decimal degrees, ...
  int m_alternate_angleresolution;  // for decimal degrees, digits past decimal
  ON_wString m_prefix;              // string preceding dimension value string
  ON_wString m_suffix;              // string following dimension value string
  ON_wString m_alternate_prefix;    // string preceding alternate value string
  ON_wString m_alternate_suffix;    // string following alternate value string

private:
  unsigned int m_valid;        // Obsolete deprecated field to be removed - Do not use
public:

  // field added version 1.4, Dec 28, 05
  double m_dimextension;  // (dimdle) dimension line extension past the "tip" location

  // fields added version 1.5 Mar 23 06
  double m_leaderarrowsize;       // Like dimension arrow size but applies to leaders
  int    m_leaderarrowtype;       // Like dimension arrow type but applies to leaders
  bool   m_bSuppressExtension1;   // flag to not draw extension lines
  bool   m_bSuppressExtension2;   // flag to not draw extension lines


  // Added March 23, 2008 -LW
  // This function is temporary and will be removed next time the SDK can be modified.
  class ON_DimStyleExtra* DimStyleExtension(); // can return null
  const class ON_DimStyleExtra* DimStyleExtension() const; // can return null
};

#endif

/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#ifndef OPENNURBS_HATCH_H_INCLUDED
#define OPENNURBS_HATCH_H_INCLUDED

/*
  class ON_HatchLoop
  /////////////////////////////////////////////////////////////////
  Represents a 3d boundary loop curve
*/
class ON_CLASS ON_HatchLoop
{
public:
#if defined(ON_DLL_EXPORTS) || defined(ON_DLL_IMPORTS)
  // When the Microsoft CRT(s) is/are used, this is the best
  // way to prevent crashes that happen when a hatch loop is
  // allocated with new in one DLL and deallocated with
  // delete in another DLL.

  // new/delete
  void* operator new(size_t);
  void  operator delete(void*);

  // array new/delete
  void* operator new[] (size_t);
  void  operator delete[] (void*);

  // in place new/delete
  void* operator new(size_t,void*);
  void  operator delete(void*,void*);
#endif

  enum eLoopType
  {
    ltOuter = 0,
    ltInner = 1
  };

  ON_HatchLoop();
  ON_HatchLoop( ON_Curve* pCurve2d, eLoopType type = ltOuter);
  ON_HatchLoop( const ON_HatchLoop& src);
  ~ON_HatchLoop();

  ON_HatchLoop& operator=( const ON_HatchLoop& src);

  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;
  void Dump( ON_TextLog& ) const; // for debugging
  ON_BOOL32 Write( ON_BinaryArchive&) const;
  ON_BOOL32 Read( ON_BinaryArchive&);

  // Interface
  /////////////////////////////////////////////////////////////////

  /*
  Description:
    Get a closed 2d curve boundary loop
  Parameters:
  Return:
    Pointer to loop's 2d curve
  */
  const ON_Curve* Curve() const;
 
  /*
  Description:
    Specify the 2d loop curve in the hatch's plane coordinates
  Parameters:
    curve - [in] 2d input curve
  Return:
    true: success, false, curve couldn't be duplicated
  Remarks:
    The curve is copied
  */
  bool SetCurve( const ON_Curve& curve);

  /*
  Description:
    Get the type flag of the loop
  Returns:
    eLoopType::ltInner or eLoopType::ltOuter
  */
  eLoopType Type() const;

  /*
  Description:
    Specify the type flag of the loop
  Parameters:
    type - [in] ltInner or ltOuter
  */
  void SetType( eLoopType type);

protected:
  friend class ON_Hatch;
  eLoopType m_type;         // loop type flag - inner or outer
  ON_Curve* m_p2dCurve;     // 2d closed curve bounding the hatch
                            // This is really a 3d curve with z coordinates = 0
};


/*
  class ON_HatchLine
  /////////////////////////////////////////////////////////////////
  Represents one line of a hatch pattern
  Similar to AutoCAD's .pat file definition
  ON_HatchLine's are used by ON_HatchPattern
    to specify the dashes and offset patterns of the lines.

  Each line has the following information:
  Angle is the direction of the line CCW from the x axis
  The first line origin is at base
  Each line repetition is offset by offset from the previous line
    offset.x is parallel to the line and 
    offset.y is perpendicular to the line
  The base and offset values are rotated by the line's angle to 
    produce a location in the hatch pattern's coordinate system
  There can be gaps and dashes specified for drawing the line

  If there are no dashes, the line is solid
  Negative length dashes are gaps
  Positive length dashes are drawn as line segments
*/

class ON_CLASS ON_HatchLine
{
public:
  ON_HatchLine();
  // C++ default copy construction and operator= work fine.

  ON_HatchLine( 
    double angle, 
    const ON_2dPoint& base, 
    const ON_2dVector& offset,
    const ON_SimpleArray<double> dashes);

  bool operator==( const ON_HatchLine&) const;
  bool operator!=( const ON_HatchLine&) const;

  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;
  void Dump( ON_TextLog& ) const; // for debugging
  ON_BOOL32 Write( ON_BinaryArchive&) const;  // serialize definition to binary archive
  ON_BOOL32 Read( ON_BinaryArchive&);  // restore definition from binary archive

  // Interface
  /////////////////////////////////////////////////////////////////

  /*
  Description:
    Get angle of the hatch line.
    CCW from x-axis
  Parameters:
  Return:
    The angle in radians
  */
  double Angle() const;

  /*
  Description:
    Set angle of the hatch line.
    CCW from x-axis
  Parameters:
    angle - [in] angle in radians
  Return:
  */
  void SetAngle( double angle);
  
  /*
  Description:
    Get this line's 2d basepoint
  Parameters:
  Return:
    the base point
  */
  ON_2dPoint Base() const;
  /*
  Description:
    Set this line's 2d basepoint
  Parameters:
    base - [in] the basepoint
  Return:
  */
  void SetBase( const ON_2dPoint& base);
  
  /*
  Description:
    Get this line's 2d offset for line repetitions
    Offset().x is shift parallel to line
    Offset().y is spacing perpendicular to line
  Parameters:
  Return:
    the offset
  */
  ON_2dVector Offset() const;

  /*
  Description:
    Get this line's 2d offset for line repetitions
    Offset().x is shift parallel to line
    Offset().y is spacing perpendicular to line
  Parameters:
    offset - [in] the shift,spacing for repeated lines
  Return:
  */
  void SetOffset( const ON_2dVector& offset);

  /*
  Description:
    Get the number of gaps + dashes in the line
  Parameters:
  Return:
    nummber of dashes in the line
  */
  int DashCount() const;

  /*
  Description:
    Get the dash length at index
  Parameters:
    index - [in] the dash to get
  Return:
    the length of the dash ( gap if negative)
  */
  double Dash( int) const;

  /*
  Description:
    Add a dash to the pattern
  Parameters:
    dash - [in] length to append - < 0 for a gap
  */
  void AppendDash( double dash);

  /*
  Description:
    Specify a new dash array
  Parameters:
    dashes - [in] array of dash lengths
  */
  void SetPattern( const ON_SimpleArray<double>& dashes);

  /*
  Description:
    Get the line's angle, base, offset and dashes 
    in one function call
  Parameters:
    angle  - [out] angle in radians CCW from x-axis
    base   - [out] origin of the master line
    offset - [out] offset for line replications
    dashes - [out] the dash array for the line
  Return:
  */
  void GetLineData(
    double& angle, 
    ON_2dPoint& base, 
    ON_2dVector& offset, 
    ON_SimpleArray<double>& dashes) const;

  /*
  Description:
    Get the total length of a pattern repeat
  Parameters:
  Return:
    Pattern length
  */
  double GetPatternLength() const;

public:
  double m_angle;
  ON_2dPoint m_base;
  ON_2dVector m_offset;
  ON_SimpleArray< double> m_dashes;
};




#if defined(ON_DLL_TEMPLATE)
// This stuff is here because of a limitation in the way Microsoft
// handles templates and DLLs.  See Microsoft's knowledge base 
// article ID Q168958 for details.
#pragma warning( push )
#pragma warning( disable : 4231 )
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_HatchLoop*>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ON_HatchLine>;
#pragma warning( pop )
#endif


/*
  class ON_HatchPattern
  /////////////////////////////////////////////////////////////////
  Fill definition for a hatch

  The hatch  will be one of 
    ON_Hatch::ftLines     - pat file style definition
    ON_Hatch::ftGradient  - uses a color function
    ON_Hatch::ftSolid     - uses entity color

*/
class ON_CLASS ON_HatchPattern : public ON_Object
{
  ON_OBJECT_DECLARE( ON_HatchPattern);

public:

  enum eFillType
  {
    ftSolid    = 0,  // uses entity color
    ftLines    = 1,  // pat file definition
    ftGradient = 2,  // uses a fill color function
    ftLast     = 3
  };

  ON_HatchPattern();
  ~ON_HatchPattern();
  // C++ default copy construction and operator= work fine.

 // ON_Object overrides
  /////////////////////////////////////////////////////////////////
   ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;
  void Dump( ON_TextLog& ) const; // for debugging
  ON_BOOL32 Write( ON_BinaryArchive&) const;
  ON_BOOL32 Read( ON_BinaryArchive&);

  // virtual
  ON_UUID ModelObjectId() const;


  //////////////////////////////////////////////////////////////////////
  // Interface

  /*
  Description:
    Return the pattern's fill type
  Parameters:
  */
  eFillType FillType() const;

  /*
  Description:
    Set the pattern's fill type
  Parameters:
    type - [in] the new filltype
  */
  void SetFillType( eFillType type);

  /*
  Description:
    Set the name of the pattern
  Parameters:
    pName - [in] the new name
  Returns:
  */
  void SetName( const wchar_t* pName);
  void SetName( const char* pName);
  
  /*
  Description:
    Get the name of the pattern
  Parameters:
    string - [out] The name is returned here
  */
  void GetName( ON_wString& string) const;

  /*
  Description:
    Get the name of the pattern
  Returns:
    The name string
  */
  const wchar_t* Name() const;

  /*
  Description:
    Set the name of the pattern
  Parameters:
    pDescription - [in] the new description
  Returns:
  */
  void SetDescription( const wchar_t* pDescription);
  void SetDescription( const char* pDescription);
  
  /*
  Description:
    Get a short description of the pattern
  Parameters:
    string - [out] The string is returned here
  */
  void GetDescription( ON_wString& string) const;

  /*
  Description:
    Return a short text description of the pattern type
  Parameters:
  Returns:
    The description string
  */
  const wchar_t* Description() const;

  /*
  Description:
    Set the table index of the pattern
  Parameters:
    index - [in] the new index
  Returns:
  */
  void SetIndex( int index);

  /*
  Description:
    Return the table index of the pattern
  Parameters:
  Returns:
    The table index
  */
  int Index() const;

  // Interface functions for line hatches
  /////////////////////////////////////////////////////////////////
  /*
  Description:
    Get the number of ON_HatchLines in the pattern
  Parameters:
  Return:
    number of lines
  */
  int HatchLineCount() const;

  /*
  Description:
    Add an ON_HatchLine to the pattern
  Parameters:
    line - [in] the line to add
  Return:
    >= 0 index of the new line
    -1 on failure
  */
  int AddHatchLine( const ON_HatchLine& line);

  /*
  Description:
    Get the ON_HatchLine at index
  Parameters:
    index - [in] Index of the line to get
  Return:
    the hatch line
    NULL if index is out of range
  */
  const ON_HatchLine* HatchLine( int index) const;

  /*
  Description:
    Remove a hatch line from the pattern
  Parameters:
    index - [in] Index of the line to remove
  Return:
    true - success
    false - index out of range
  */
  bool RemoveHatchLine( int index);

  /*
  Description:
    Remove all of the hatch line from the pattern
  Parameters:

  Return:
    true - success
    false - index out of range
  */
  void RemoveAllHatchLines();

  /*
  Description:
    Set all of the hatch lines at once. 
    Existing hatchlines are deleted.
  Parameters:
    lines - [in] Array of lines to add.  Lines are copied
  Return:
    number of lines added
  */
  int SetHatchLines( const ON_ClassArray<ON_HatchLine> lines);

public:
  int m_hatchpattern_index;         // Index in the hatch pattern table
  ON_wString m_hatchpattern_name;   // String name of the pattern
  ON_UUID m_hatchpattern_id;
  
  eFillType m_type;
  
  ON_wString m_description;  // String description of the pattern

  // Represents a collection of ON_HatchLine's to make a complete pattern
  // This is the definition of a hatch pattern.
  // Simple solid line hatches with fixed angle and spacing are also 
  // represented with this type of hatch
  ON_ClassArray<ON_HatchLine> m_lines; // used by line hatches
};

/*
  class ON_Hatch
  /////////////////////////////////////////////////////////////////
  Represents a hatch in planar boundary loop or loops 
  This is a 2d entity with a plane defining a local coordinate system
  The loops, patterns, angles, etc are all in this local coordinate system

  The ON_Hatch object manages the plane and loop array
  Fill definitions are in the ON_HatchPattern or class derived from ON_HatchPattern
  ON_Hatch has an index to get the pattern definition from the pattern table

*/
class ON_CLASS ON_Hatch : public ON_Geometry
{
  ON_OBJECT_DECLARE( ON_Hatch);

public:
  // Default constructor
  ON_Hatch();
  ON_Hatch( const ON_Hatch&);
  ON_Hatch& operator=(const ON_Hatch&);
  ~ON_Hatch();

  virtual ON_Hatch* DuplicateHatch() const;

  // ON_Object overrides
  /////////////////////////////////////////////////////////////////
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;
  void Dump( ON_TextLog& ) const; // for debugging
  ON_BOOL32 Write( ON_BinaryArchive&) const;
  ON_BOOL32 Read( ON_BinaryArchive&);
  ON::object_type ObjectType() const;

  // ON_Geometry overrides
  /////////////////////////////////////////////////////////////////
  /*
    Returns the geometric dimension of the object ( usually 3)
  */
  int Dimension() const;

  /*
    Description:
      Get a bounding 3d WCS box of the object
      This is a bounding box of the boundary loops
    Parameters:
      [in/out] double* boxmin - pointer to dim doubles for min box corner
      [in/out] double* boxmax - pointer to dim doubles for max box corner
      [in] ON_BOOL32 growbox   - true to grow the existing box,
                            false ( the default) to reset the box
    Returns:
      true = Success
      false = Failure
    Remarks:
  */
  ON_BOOL32 GetBBox( double*, double*, ON_BOOL32 = false) const;

  /*
	Description:
    Get tight bounding box of the hatch.
	Parameters:
		tight_bbox - [in/out] tight bounding box
		bGrowBox -[in]	(default=false)			
      If true and the input tight_bbox is valid, then returned
      tight_bbox is the union of the input tight_bbox and the 
      tight bounding box of the hatch.
		xform -[in] (default=NULL)
      If not NULL, the tight bounding box of the transformed
      hatch is calculated.  The hatch is not modified.
	Returns:
    True if the returned tight_bbox is set to a valid 
    bounding box.
  */
	bool GetTightBoundingBox( 
			ON_BoundingBox& tight_bbox, 
      int bGrowBox = false,
			const ON_Xform* xform = 0
      ) const;


  /*
    Description:
      Transform the object by a 4x4 xform matrix

    Parameters:
      [in] xform  - An ON_Xform with the transformation information
    Returns:
      true = Success
      false = Failure
    Remarks:
      The object has been transformed when the function returns.
  */
  ON_BOOL32 Transform( const ON_Xform&);

  // Interface
  /////////////////////////////////////////////////////////////////

  /*
  Description:
    Create a hatch from input geometry and parameters
  Parameters:
    plane [I] - ON_Plane to make the hatch on
    loops [I] - Array of boundary loops with the outer one first
    pattern_index [I] - Index into the hatch table
    pattern_rotation [I] - ccw in radians about plane origin
    pattern_scale [I] - Scale factor for pattern definition
  Returns:
    true = success, false = failure
  */
  bool Create( const ON_Plane& plane,
               const ON_SimpleArray<const ON_Curve*> loops, 
               int pattern_index, 
               double pattern_rotation, 
               double pattern_scale);

  /*
  Description:
    Get the plane defining the hatch's coordinate system
  Parameters:
  Returns:
    the plane
  */
  const ON_Plane& Plane() const;

  /*
  Description:
    Set the plane defining the hatch's coordinate system
  Parameters:
    plane - [in] the plane to set
  Returns:
  */
  void SetPlane( const ON_Plane& plane);
  
  /*
  Description:
    Gets the rotation applied to the hatch pattern 
    when it is mapped to the hatch's plane
  Returns:
    The rotation in radians
  Remarks:
    The pattern is rotated counter-clockwise around
    the hatch's plane origin by this value
  */
  double PatternRotation() const;

/*
  Description:
    Sets the rotation applied to the hatch pattern 
    when it is mapped to the hatch's plane
  Parameters:
    rotation - [in] The rotation in radians
  Remarks:
    The pattern is rotated counter-clockwise around
    the hatch's plane origin by this value
  */
  void SetPatternRotation( double rotation);
  
  /*
  Description:
    Gets the scale applied to the hatch pattern 
    when it is mapped to the hatch's plane
  Returns:
    The scale
  Remarks:
    The pattern is scaled around
    the hatch's plane origin by this value
  */
  double PatternScale() const;

/*
  Description:
    Sets the scale applied to the hatch pattern 
    when it is mapped to the hatch's plane
  Parameters:
    scale - [in] The scale
  Remarks:
    The pattern is scaled around
    the hatch's plane origin by this value
  */
  void SetPatternScale( double scale);
  
  /*
  Description:
    Get the number of loops used by this hatch
  Parameters:
  Returns:
    the number of loops
  */
  int LoopCount() const;

  /*
  Description:
    Add a loop to the hatch
  Parameters:
    loop - [in] the loop to add. Memory management for the loop is managed
           by this class.
  Returns:
  */
  void AddLoop( ON_HatchLoop* loop);

  /*
  Description:
    Insert a loop to the hatch at the specified index
  Parameters:
    index - [in] zero based index of the position where insert the loop to.
    loop - [in] the loop to insert. Memory management for the loop is managed
                by this class on success.
  Returns:
    true if success
	  false if index is lower than 0 or greater than current loop count.
  */
  bool InsertLoop( int index,
                   ON_HatchLoop* loop);

  /*
  Description:
    Remove a loop in the hatch
  Parameters:
    loop - [in] zero based index of the loop to remove.
  Returns:
    true if success
  */
  bool RemoveLoop( int index);

  /*
  Description:
    Get the loop at index
  Parameters:
    index - [in] which loop to get
  Returns:
    pointer to loop at index
    NULL if index is out of range
  */
  const ON_HatchLoop* Loop( int index) const;

  /*
  Description:
    Get the 3d curve corresponding to loop[index]
  Parameters:
    index - [in] which loop to get
  Returns:
    pointer to 3d curve of loop at index
    NULL if index is out of range or curve can't be made
    Caller deletes the returned curve
  */
  ON_Curve* LoopCurve3d( int index) const;

  /*
  Description:
    Get the index of the hatch's pattern
  Parameters:
  Returns:
    index of the pattern
  */
  int PatternIndex() const;

/*
  Description:
    Set the index of the hatch's pattern
  Parameters:
    index - [in] pattern index to set
  Returns:
  */
  void SetPatternIndex( int index);

  // Basepoint functions added March 23, 2008 -LW
  /*
  Description:
    Set 2d Base point for hatch pattern alignment.
  Parameters:
    basepoint - 2d point in hatch's ECS
  */
  void SetBasePoint(ON_2dPoint basepoint);

  /*
  Description:
    Set 3d Base point for hatch pattern alignment.
  Parameters:
    point - 3d WCS point
  Remarks:
    Projects point to hatch's plane and sets 2d point
  */
  void SetBasePoint(ON_3dPoint point);

  /*
  Description:
    Return 3d WCS point that lies on hatch's plane used for pattern origin.
  */
  ON_3dPoint BasePoint() const;

  /*
  Description:
    Return 2d ECS point used for pattern origin.
  */
  ON_2dPoint BasePoint2d() const;

  /*
  Function added June 12 2008 LW
  Description:
    Remove all of the loops on the hatch and add the curves in 'loops' as new loops
  Parameters:
    loops - [in] An array of pointers to 2d or 3d curves
                 If the curves are 2d, add them to the hatch directly
                 If they are 3d, project them to the hatch's plane first
  Returns:
    true  - success
    false - no loops in input array or an error adding them
  */
  bool ReplaceLoops(ON_SimpleArray<const ON_Curve*> loops);

protected:
  ON_Plane m_plane;
  double m_pattern_scale;
  double m_pattern_rotation;
  ON_SimpleArray<ON_HatchLoop*> m_loops;
  int m_pattern_index;

    // This function is temporary and will be removed next time the SDK can be modified.
  class ON_HatchExtra* HatchExtension();

};

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_LINETYPE_INC_)
#define OPENNURBS_LINETYPE_INC_


// Description:
//   Determine if a line width is deemed to be a "hairline width" in Rhino
//   Any width that is >0 and < 0.001 mm is a hairline width for printing
// Parameters:
//   width_mm: [in] the width to examine in millimeters
// Returns:
//   true if this is a hairline width
ON_DECL bool ON_IsHairlinePrintWidth( double width_mm );

// Description:
//   Return a width in millimeters that is a valid hairline width in rhino
ON_DECL double ON_HairlinePrintWidth();




//////////////////////////////////////////////////////////////////////
// class ON_Linetype

class ON_CLASS ON_Linetype : public ON_Object
{
  ON_OBJECT_DECLARE(ON_Linetype);

public:

  /*
  Description:
    Sets index = -1.
  */
  ON_Linetype();

  ~ON_Linetype();


  /*
  Description:
    Sets index = -1 and emptys name and segment list.
  */
  void Default();

  /*
    Description:
      Tests that name is set and there is at least one non-zero length segment
  */
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  void Dump( ON_TextLog& ) const; // for debugging

  /*
    Description:
      Write to file
  */
  ON_BOOL32 Write(
         ON_BinaryArchive&  // serialize definition to binary archive
       ) const;

  /*
    Description:
      Read from file
  */
  ON_BOOL32 Read(
         ON_BinaryArchive&  // restore definition from binary archive
       );

  // virtual
  ON_UUID ModelObjectId() const;


  //////////////////////////////////////////////////////////////////////
  //
  // Interface

  /*
    Unique name for each linetype
  */
  bool SetLinetypeName( const char*);
  bool SetLinetypeName( const wchar_t*);
	const wchar_t* LinetypeName() const;

  /*
    Index of each linetype
    This index is used by geometry objects to 
    reference a specific linetype
  */
  bool SetLinetypeIndex( int);
  int LinetypeIndex() const;

  /*
    Description:
      Returns the total length of one repeat of the pattern
  */
  double PatternLength() const;


  /*
    Description:
      Returns the number of segments in the pattern
  */
  int SegmentCount() const;

  /*
  Description:
    Adds a segment to the pattern
  Returns:
    Index of the added segment.
  */
  int AppendSegment( const ON_LinetypeSegment& segment);

  /*
  Description:
    Removes a segment in the linetype.
  Parameters:
    index - [in]
      Zero based index of the segment to remove.
  Returns:
    True if the segment index was removed.
  */
  bool RemoveSegment( int index );

  /*
    Description:
      Sets the segment at index to match segment
  */
  bool SetSegment( int index, const ON_LinetypeSegment& segment);

  /*
    Description:
      Sets the length and type of the segment at index
  */
  bool SetSegment( int index, double length, ON_LinetypeSegment::eSegType type);

  /*
    Description:
      Returns a copy of the segment at index
  */
  ON_LinetypeSegment Segment( int index) const;

  /*
    Description:
      Expert user function to get access to the segment array
      for rapid calculations.
  */
  ON_SimpleArray<ON_LinetypeSegment>& Segments();
  const ON_SimpleArray<ON_LinetypeSegment>& Segments() const;

public:
  int m_linetype_index;
  ON_UUID m_linetype_id;    // Set by Rhino - unique id of this linetype
  ON_wString m_linetype_name;

private:
  ON_SimpleArray<ON_LinetypeSegment> m_segments;
};

#endif

/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(ON_OBJREF_INC_)
#define ON_OBJREF_INC_

class ON_CLASS ON_ObjRefEvaluationParameter
{
public:
  ON_ObjRefEvaluationParameter();
  ~ON_ObjRefEvaluationParameter();

  void Default();

  bool Write( ON_BinaryArchive& ) const;
  bool Read( ON_BinaryArchive& );


  // If m_point != ON_UNSET_POINT and m_t_type != 0, then
  // m_t_type, m_t, and m_t_ci record the m_geometry evaluation
  // parameters of the m_point.
  //
  //  m_t_type values
  //
  //  0: no parameter values; m_t_ci and m_t[] have no meaning.
  //
  //  1: m_geometry points to a curve, m_t[0] is a curve
  //     parameter for m_point, and m_t_ci has no meaning.
  //
  //  2: m_geometry points to surface or single faced brep,
  //     (m_t[0],m_t[1]) is a surface parameter for m_point,
  //     and m_t_ci has no meaning.
  //     In this case, m_component_index may not be set or,
  //     if m_geometry points to a brep face, m_component_index
  //     may identify the face in the parent brep.
  //
  //  3: m_geometry points to a brep edge with an associated
  //     trim and m_t[0] is the edge parameter for m_point.
  //     m_t_ci is the ON_BrepTrim component index and m_t[1]
  //     is the ON_BrepTrim parameter that corresponds to the
  //     edge point.  m_s[0] and m_s[1] are normalized parameters.
  //     In this case m_component_index identifies the
  //     the edge in the brep and m_t_ci identifies a trim.
  //
  //  4: m_geometry points to a mesh or mesh face and 
  //     m_t_ci identifies the mesh face.
  //     If the face is a triangle, the barycentric coordinates
  //     of m_point are(m_t[0], m_t[1], m_t[2]) and m_t[3] is zero. 
  //     If the mesh face is a quadrangle, the barycentric coordinates
  //     of m_point are (m_t[0], m_t[1], m_t[2], m_t[3]) and at least 
  //     one of the coordinates is zero.  In both cases, the point
  //     can be evaluated using the formula
  //     m_t[0]*mesh.m_V[f.vi[0]] + ... + m_t[3]*mesh.m_V[f.vi[3]],
  //     where f = mesh.m_F[m_component_index.m_index].
  //     In this case, if m_geometry points to a mesh, then
  //     m_component_index !=  m_t_ci.
  //
  //  5: m_geometry points to a mesh or mesh edge and m_t_ci
  //     identifies the mesh edge. The normalized coordinate of
  //     the point on the mesh edge is m_t[0].  The point can be evaluated
  //     using the formula
  //     m_t[0]*mesh.m_V[v0] + (1.0-m_t[0])*mesh.m_V[v1],
  //     where v0 and v1 are the indices of the mesh vertices at
  //     the edge's ends.
  //     In this case, if m_geometry points to a mesh, then
  //     m_component_index !=  m_t_ci.
  //
  //  6: m_geometry points to a NURBS cage and (m_t[0],m_t[1],m_t[2])
  //     are cage evaluation parameters.
  //
  //  7: m_geometry points to an annotation object and m_t_ci identifies
  //     a point on the annotation object.
  //
  //  8: m_geometry points to a mesh or mesh vertex object and m_t_ci
  //     identifies a vertex on the mesh object.
  //
  int m_t_type;
private:
  int m_reserved; // for future use to record snap info.
public:
  double m_t[4];
  ON_Interval m_s[3]; // curve/surface/cage domains
  ON_COMPONENT_INDEX m_t_ci; // Not necesarily the same as m_component_index
                             // See comment above for details.
};

class ON_CLASS ON_ObjRef_IRefID
{
public:
  ON_ObjRef_IRefID();
  ~ON_ObjRef_IRefID();

  bool Write(ON_BinaryArchive&) const;
  bool Read(ON_BinaryArchive&);

  void Default();

  // m_iref_uuid is the CRhinoInstanceObject's uuid stored
  // in its ON_3dmObjectAttributes.m_uuid.
  ON_UUID  m_iref_uuid;

  // m_iref_xform is the value stored in ON_InstanceRef.m_xform.
  ON_Xform m_iref_xform;

  // m_idef_uuid is the instance definition id stored in
  // ON_InstanceRef.m_instance_definition_uuid and
  // ON_InstanceDefinition.m_uuid.
  ON_UUID  m_idef_uuid;

  // m_geometry_index is the index of the uuid of the pertinant
  // piece of geometry in the ON_InstanceRef.m_object_uuid[] 
  // array.  This index is identical to the index of the
  // geometry's CRhinoObject in the
  // CRhinoInstanceDefinition.m_objects[] array.
  int m_idef_geometry_index;

  // m_geometry_xform is the transformation to map the
  // base geometry to world coordinates.  If the
  // instance reference is not nested, then
  // m_geometry_xform = m_iref_xform.  If the instance
  // reference is nested, then
  //   m_geometry_xform = m_iref_xform * .... * T1
  // where the Ts are the transformations from the children.
  ON_Xform m_geometry_xform;

  // If this ON_ObjRef_IRefID is the first entry in the 
  // ON_ObjRef.m__iref[] array, then it references a "real"
  // piece of geometry (not a nested instance reference).  
  // If the reference is to a subobject of the real piece
  // of geometry, then m_component_index records
  // the subobject index.
  // In all other cases, m_component_index is not set.
  ON_COMPONENT_INDEX m_component_index;

  // If this ON_ObjRef_IRefID is the first entry in the 
  // ON_ObjRef.m__iref[] array, then it references a "real"
  // piece of geometry (not a nested instance reference).  
  // If there is an evaluation parameter for the geometry,
  // it is saved in m_evp.
  // In all other cases, m_evp is not set.
  ON_ObjRefEvaluationParameter m_evp;
};

#if defined(ON_DLL_TEMPLATE)
// This stuff is here because of a limitation in the way Microsoft
// handles templates and DLLs.  See Microsoft's knowledge base 
// article ID Q168958 for details.
#pragma warning( push )
#pragma warning( disable : 4231 )
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_ObjRef_IRefID>;
#pragma warning( pop )
#endif

class ON_CLASS ON_ObjRef
{
public:
  ON_ObjRef();
  ON_ObjRef(const ON_ObjRef& src);
  ON_ObjRef& operator=(const ON_ObjRef& src);
  ~ON_ObjRef();

  void Destroy();
  bool Write( ON_BinaryArchive& ) const;
  bool Read( ON_BinaryArchive& );

  // In Rhino, this uuid is the persistent id of the CRhinoObject
  // that owns the referenced geometry.  The value of the
  // CRhinoObject id is stored on ON_3dmObjectAttributes.m_uuid.
  ON_UUID m_uuid;

  // The m_geometry and m_parent_geometry pointers are runtime values
  // that point to the object being referenced.  The destructor 
  // ~ON_ObjRef  does not delete the objects these pointers reference.
  //
  // m_geometry_type records the type of geometry m_geometry points to.
  //
  // When the referenced object is a subobject, like a part of a brep 
  // or mesh, m_geometry points to the subobject and m_parent_geometry 
  // points to the parent object, like the brep or mesh.  In this case
  // m_component_index records the location of the subobject.
  //
  // Parts of instance reference objects:
  //   When the geometry belongs to an instance reference
  //   m_uuid is the id of the CRhinoInstanceObject,
  //   m_parent_geometry points to the instance definition
  //   geometry or a transformed proxy, and m_geometry points
  //   to the piece of m_geometry.  The m__iref[] array records
  //   the connection between the instance reference and the
  //   geometry the ON_ObjRef refers to.
  //
  //   For example if the ON_ObjRef is to an edge of a brep in
  //   and instance reference, m_uuid would be the Rhino id of
  //   the CRhinoInstanceObject, m_parent_geometry would point
  //   to a, possibly proxy, ON_Brep object, m_geometry would point
  //   to the ON_BrepEdge in the ON_Brep, m_component_index would
  //   record the edge's index in the ON_Brep.m_E[] array and 
  //   m_geometry_type would be ON::curve_object or ON::brep_edge.
  //   m__iref->Last() would contain the information about the
  //   top level instance reference.  If the brep was at the bottom
  //   of a chain of instance references, m__iref[0] would be the
  //   reference that immediately used the brep.
  const ON_Geometry* m_geometry;
  const ON_Geometry* m_parent_geometry;
  ON_COMPONENT_INDEX m_component_index;
  int m_geometry_type;

  // If m_runtime_sn > 0, then it is the value of a Rhino object's
  // CRhinoObject::m_runtime_object_serial_number field.
  // The serial number is used instead of the pointer to
  // prevent crashes in cases when the CRhinoObject is deleted
  // but an ON_ObjRef continues to reference the Rhino object.
  // The value of m_runtime_sn is not saved in archives because
  // it generally changes if you save and reload an archive.
  unsigned int m_runtime_sn;

  // If m_point != ON_UNSET_POINT, then the ObjRef resolves to 
  // a point location.  The point location is saved here so the
  // information can persist if the object itself vanishes.
  ON_3dPoint m_point;

  // If the point was the result of some type of object snap, then
  // the object snap is recorded here. 
  ON::osnap_mode m_osnap_mode;

  // If m_point != ON_UNSET_POINT and m_evp.m_t_type != 0, then
  // m_evp records the records the m_geometry evaluation
  // parameters for the m_point.
  ON_ObjRefEvaluationParameter m_evp;

  // If m__iref[] is not empty, then m_uuid identifies
  // and instance reference (ON_InstanceRef/CRhinoInstanceObject)
  // and m__iref[] records the chain of instance references from
  // the base piece of geometry to the instance reference.
  // The top level instance reference is last in the list.
  ON_SimpleArray<ON_ObjRef_IRefID> m__iref;

  /*
  Description:
    Expert user tool to decrement reference counts.  Most
    users will never need to call this tool.  It is called
    by ~ON_ObjRef and used in rare cases when a
    ON_ObjRef needs to reference an object only by uuid
    and component index.
  */
  void DecrementProxyReferenceCount();

  /*
  Description:
    Expert user tool to initialize the ON_ObjRef 
    m__proxy1, m__proxy2, and m__proxy_ref_count fields.
  */
  void SetProxy( 
          ON_Object* proxy1, 
          ON_Object* proxy2, 
          bool bCountReferences 
          );

  bool SetParentIRef( const ON_InstanceRef& iref,
                      ON_UUID iref_id,
                      int idef_geometry_index
                      );

  /*
  Returns:
     0:  This ON_ObjRef is not counting references.
    >0:  Number of references.
  */
  int ProxyReferenceCount() const;

  /*
  Parameters:
    proxy_object_index - [in] 1 or 2.
  Returns:
    A pointer to the requested proxy object.
  */
  const ON_Object* ProxyObject(int proxy_object_index) const;

  /*
  Description:
    This tool is used in rare situations when the object ids 
    stored in the uuid list need to be remapped.
  Parameters:
    uuid_remap - [in]
      Is it critical that uuid_remap[] be sorted with respect
      to ON_UuidPair::CompareFirstUuid.
  */
  void RemapObjectId( const ON_SimpleArray<ON_UuidPair>& uuid_remap );

private:
  // In simple (and the most common) cases where m_geometry
  // is managed by something outside of the ON_ObjRef class,
  // m__proxy_ref_count is NULL.  In this case, the m__proxy1
  // and m__proxy2 pointers may still be used to store 
  // references to a parent object.
  //
  // In cases when the referenced geometry pointed at by
  // m_geometry is not being managed by another class,
  // m_proxy1 and m_proxy2 are not NULL and *m_proxy_ref_count 
  // counts the number of ON_ObjRef classes that refer to m__proxy1/2.
  // When the last ON_ObjRef is destroyed, m__proxy1/2 is deleted.
  // When the ON_ObjRef is using reference counting and managing
  // m__proxy1/2, m_geometry points to some part of m__proxy1/2 and
  // m_geometry is destroyed when m__proxy1/2 is destroyed.
  //
  // The convention is to use m__proxy1 to store
  // ON_MeshVertex/Edge/FaceRefs and CRhinoPolyEdges
  // and m__proxy2 to store transformed copies if instance
  // definition geometry.  
  ON_Object* m__proxy1;
  ON_Object* m__proxy2;
  int* m__proxy_ref_count;
  //ON__INT_PTR m_reserved;
};

#if defined(ON_DLL_TEMPLATE)
// This stuff is here because of a limitation in the way Microsoft
// handles templates and DLLs.  See Microsoft's knowledge base 
// article ID Q168958 for details.
#pragma warning( push )
#pragma warning( disable : 4231 )
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ON_ObjRef>;
#pragma warning( pop )
#endif

#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(ON_OFFSETSURFACE_INC_)
#define ON_OFFSETSURFACE_INC_

// This file is to be used in V3 plug-ins.  
// In V4, this will be included as part of opennurbs.
// Ask Dale Lear if you have any questions.

class ON_BumpFunction
{
public:
  ON_BumpFunction();

  bool operator==(const ON_BumpFunction& other) const;
  bool operator<(const ON_BumpFunction& other) const;
  bool operator>(const ON_BumpFunction& other) const;

  double ValueAt(
    double s,
    double t
    ) const;

  void Evaluate(
    double s,
    double t,
    int der_count,
    double* value
    ) const;

  ON_2dPoint m_point; // center of bump
  int m_type[2];      // 1 = linear, 5 = quintic;

  // numbers used in evaluation
  double m_x0;
  double m_y0;
  double m_sx[2];      // 1/(suppor radius)
  double m_sy[2];      // 1/(suppor radius)
  double m_a;         // evaluation coefficient

  void EvaluateHelperLinearBump(double t, double dt, int der_count, double* value) const;
  void EvaluateHelperQuinticBump(double t, double dt, int der_count, double* value) const;
};


class ON_OffsetSurfaceValue
{
public:
  double m_s;
  double m_t;
  double m_distance;
  double m_radius;
  int m_index;
};


#if defined(ON_DLL_TEMPLATE)
// This stuff is here because of a limitation in the way Microsoft
// handles templates and DLLs.  See Microsoft's knowledge base 
// article ID Q168958 for details.
#pragma warning( push )
#pragma warning( disable : 4231 )
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_BumpFunction>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_OffsetSurfaceValue>;
#pragma warning( pop )
#endif


class ON_CLASS ON_OffsetSurfaceFunction
{
public:
  ON_OffsetSurfaceFunction();
  ~ON_OffsetSurfaceFunction();

  /*
  Description:
    Sets base surface for the offset function.
  Parameters:
    srf - [in] pointer to the base surface.
               This surface must remain valid while
               the ON_OffsetSurfaceFunction class is used.
  Returns:
    True if successful.
  */
  bool SetBaseSurface(
    const ON_Surface* srf 
    );

  /*
  Returns:
    Base surface specified SetBaseSurface().
  */
  const ON_Surface* BaseSurface() const;

  /*
  Description:
    Use set SetSideTangency if you want the offset 
    surface and base surface to have the same unit
    normals along a side of the surfaces's parameter
    spaces.
  Parameters:
    side - [in]
               0 = south side
               1 = east side
               2 = north side
               3 = west side
    bEnable - [in] true to enable tangency,
                   false to disable tangency
  Returns:
    True if successful.
  */
  bool SetSideTangency(
    int side,
    bool bEnable
    );

  /*
  Parameters:
    side - [in]
               0 = south side
               1 = east side
               2 = north side
               3 = west side
  Returns:
    True if side tangency is enabled.
  */
  bool SideTangency(int side) const;

  /*
  Description:
    Sets the offset distance at a point.  Call this function
    once for each point wher the user specifies an offset.
  Parameters:
    s - [in]
    t - [in] (s,t) is a base surface evaluation parameter
    distance - [in] distance is the offset distance.
    radius - [in] if radius>0, then this value will be the
                  the approximate radius of the offset "bump".
  */
  bool SetOffsetPoint(
    double s,
    double t,
    double distance,
    double radius = 0.0
    );

  /*
  Description:
    Sets the surface parameters of an existing offset point.
  Parameters:
    index - [in] index of the point to set
    s - [in]
    t - [in] (s,t) is a base surface evaluation parameter
  */
  bool SetPoint( 
    int index, 
    double s, 
    double t
    );


  /*
  Description: 
    Set the offset distance for an existing point
  Parameters:
    index - [in] index of the point to set
    distance - [in] new distance
  */
  bool SetDistance( 
    int index, 
    double distance);


  /*
  Returns:
    Number of points specified using SetOffsetPoint().
  */
  int OffsetPointCount() const;

  /*
  Parameters:
    i - [in] an index >= 0 and < OffsetPointCount()
  Returns:
    Surface parameter specified using SetOffsetPoint().
  */
  ON_2dPoint OffsetSurfaceParameter(int i) const;

  /*
  Parameters:
    i - [in] an index >= 0 and < OffsetPointCount()
  Returns:
    Offset distance specified using SetOffsetPoint().
  */
  double OffsetDistance(int i) const;

  /*
  Description:
    Value of the offset distance at any surface parameter.
  Parameters:
    s - [in]
    t - [in] (s,t) is a base surface evaluation parameter
  Returns:
    offset distance at the surface parameter
  */
  double DistanceAt(
    double s,
    double t
    ) const;

  /*
  Description:
    Value of the offset distance at any surface parameter.
  Parameters:
    s - [in]
    t - [in] (s,t) is a base surface evaluation parameter
    num_der - [in] number of derivatives
    value - [out] value and derivatives of distance function
                  value[0] = distance, value[1] = 1rst derivative,
                  value[2] = 2nd derivative, ...
  Returns:
    True if successful
  */
  bool EvaluateDistance(
        double s,
        double t,
        int num_der,
        double* value
        ) const;

  /*
  Description:
    Value of the offset function at any surface parameter.
  Parameters:
    s - [in]
    t - [in] (s,t) is a base surface evaluation parameter
  Returns:
    Point on the offset surface.
  */
  ON_3dPoint PointAt(
    double s,
    double t
    ) const;

  /*
  Description:
    Resets this class if you want to reuse it.
  */
  void Destroy();

private:
  friend class ON_OffsetSurface;
  bool Initialize();

  const ON_Surface* m_srf;

  ON_Interval m_domain[2];

  bool m_bZeroSideDerivative[4];   // S,E,N,W side

  ON_SimpleArray<ON_OffsetSurfaceValue> m_offset_value;


  ON_SimpleArray<class ON_BumpFunction> m_bumps;

  bool m_bValid;
};

class ON_CLASS ON_OffsetSurface : public ON_SurfaceProxy
{
  // This is still a work in progress.  In particular,
  // this surface class can not be saved in files, used
  // as a brep surface, added to Rhino, etc.
  //
  // As of January 2004, it is useful for calculating
  // offset meshes and any other fitting and approximation
  // tools that requires a surface evaluator but do not need
  // NURBS forms, isocurves, and so on.
  ON_OBJECT_DECLARE(ON_OffsetSurface);
public:
  ON_OffsetSurface();
  ~ON_OffsetSurface();
  ON_OffsetSurface( const ON_OffsetSurface& src);
  ON_OffsetSurface& operator=(const ON_OffsetSurface& src);

  ON_BOOL32 GetBBox(
         double* bbox_min,
         double* bbox_max,
         int bGrowBox = false
         ) const;

  ON_BOOL32 Evaluate( // returns false if unable to evaluate
         double, double, // evaluation parameters
         int,            // number of derivatives (>=0)
         int,            // array stride (>=Dimension())
         double*,        // array of length stride*(ndir+1)*(ndir+2)/2
         int = 0,        // optional - determines which quadrant to evaluate from
                         //         0 = default
                         //         1 from NE quadrant
                         //         2 from NW quadrant
                         //         3 from SW quadrant
                         //         4 from SE quadrant
         int* = 0        // optional - evaluation hint (int[2]) used to speed
                         //            repeated evaluations
         ) const;

  /*
  Description:
    Sets base surface to a surface that is not managed
    by the ON_OffsetSurface class.
  Parameters:
    base_surface - [in] points to a base surface the
       caller insures will exist for the lifetimes
       of the ON_OffsetSurface class.
  Returns:
    True if successful.
  */
  bool SetBaseSurface(
    const ON_Surface* base_surface
    );

  /*
  Description:
    Sets base surface to a surface that is optionally managed
    by the ON_OffsetSurface class.
  Parameters:
    base_surface - [in] points to a base surface the
       caller insures will exist for the lifetimes
       of the ON_OffsetSurface class.
    bManage - [in] if true, the base_surface must point
       to a surface that is on the heap and the surface
       will be deleted by ~ON_OffsetSurface.
  Returns:
    True if successful.
  */
  bool SetBaseSurface(
        ON_Surface* base_surface, 
        bool bManage
        );

  /*
  Returns:
    Base surface;
  */
  const ON_Surface* BaseSurface() const;

  ON_OffsetSurfaceFunction& OffsetFunction();
  const ON_OffsetSurfaceFunction& OffsetFunction() const;

private:
  // If not NULL, this points to the base surface
  ON_Surface* m__pSrf;
  ON_OffsetSurfaceFunction m_offset_function;
};


#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(ON_DETAIL_OBJECTY_INC_)
#define ON_DETAIL_OBJECTY_INC_

class ON_CLASS ON_DetailView : public ON_Geometry
{
  ON_OBJECT_DECLARE(ON_DetailView);

public:
  ON_DetailView();
  ~ON_DetailView();

  // C++ defaults for copy constructor and
  // operator= work fine.

  //////////////////////////////////////////////////////
  //
  // virtual ON_Object overrides
  //
  void MemoryRelocate();

  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  void Dump( ON_TextLog& ) const;

  unsigned int SizeOf() const;

  ON_BOOL32 Write(
         ON_BinaryArchive& binary_archive
       ) const;

  ON_BOOL32 Read(
         ON_BinaryArchive& binary_archive
       );

  ON::object_type ObjectType() const; // returns ON::detail_object

  //////////////////////////////////////////////////////
  //
  // virtual ON_Geometry overrides
  // The m_boundary determines all bounding boxes 
  //
  int Dimension() const;

  ON_BOOL32 GetBBox(
         double* boxmin,
         double* boxmax,
         int bGrowBox = false
         ) const;

	bool GetTightBoundingBox( 
			ON_BoundingBox& tight_bbox, 
      int bGrowBox = false,
			const ON_Xform* xform = 0
      ) const;

  ON_BOOL32 Transform( const ON_Xform& xform );

  // m_page_per_model_ratio is the ratio of page length / model length
  // where both lengths are in the same unit system
  // (ex. 1/4" on page = 1' in model = 0.25/12 = 0.02083)
  // (    1mm on page  = 1m in model = 1/1000  = 0.001)
  // If m_page_per_model_ratio > 0.0, then the detail
  // is drawn using the specified scale.
  double m_page_per_model_ratio;

  // A view with ON_3dmView::m_view_type = ON::nested_view_type
  // This field is used for IO purposes only.  Runtime detail
  // view projection information is on CRhDetailViewObject.
  ON_3dmView m_view;

  // 2d curve in page layout coordinates in mm
  // (0,0) = lower left corner of page
  ON_NurbsCurve m_boundary;
};



#endif

/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(OPENNURBS_MAP_INC_)
#define OPENNURBS_MAP_INC_

/*
Description:
  ON_SerialNumberMap provides a way to map set of unique 
  serial number - uuid pairs to application defined values
  so that adding, finding and removing serial numbers is 
  fast and efficient.  The class is designed to handle
  several millions of unique serial numbers.  There are no
  restrictions on what order numbers are added and removed.
  The minimum memory footprint is less than 150KB and doesn't
  increase until you have more than 8000 serial numbers.
  It is possible to have an active serial number and an
  inactive id.
*/
class ON_CLASS ON_SerialNumberMap
{
public:
  ON_SerialNumberMap( ON_MEMORY_POOL* pool = 0 );
  ~ON_SerialNumberMap();

  struct MAP_VALUE
  {
    ON__UINT32 m_u_type;
    union
    {
      void* ptr;
      unsigned int ui;
      int i;
    } m_u;
  };

  struct SN_ELEMENT
  {
    ////////////////////////////////////////////////////////////
    //
    // ID
    //
    ON_UUID m_id;
    struct SN_ELEMENT* m_next; // id hash table linked list

    ////////////////////////////////////////////////////////////
    //
    // Serial number:
    //
    unsigned int m_sn;

    ////////////////////////////////////////////////////////////
    //
    // Status flags:
    //
    // If m_id_active is 1, then m_sn_active must be 1.
    // If m_sn_active = 1, then m_id_active can be 0 or 1.
    //
    unsigned char m_sn_active; // 1 = serial number is active
    unsigned char m_id_active; // 1 = id is active
    unsigned char m_reserved1;
    unsigned char m_reserved2;

    ////////////////////////////////////////////////////////////
    //
    // User information:
    //
    //   ON_SerialNumberMap does not use the m_value field.
    //   When a new element is added, m_value is memset to
    //   zero.  Other than that, m_value is not changed by
    //   this class.  The location of m_value in memory,
    //   (&m_value) may change at any time.
    struct MAP_VALUE m_value;

    void Dump(ON_TextLog&) const;
  };

  /*
  Returns:
    Number of active serial numbers in the list.
  */
  size_t ActiveSerialNumberCount() const;

  /*
  Returns:
    Number of active ids in the list.  This number
    is less than or equal to ActiveSerialNumberCount().
  */
  size_t ActiveIdCount() const;

  /*
  Returns:
    The active element with the smallest serial number, 
    or null if the list is empty.
  Restrictions:
    The returned pointer may become invalid after any
    subsequent calls to any function in this class.  
    If you need to save information in the returned
    SN_ELEMENT for future use, you must copy the 
    information into storage you are managing.

    You may change the value of the SN_ELEMENT's m_value
    field.  You must NEVER change any other SN_ELEMENT
    fields or you will break searching and possibly cause
    crashes.
  */
  struct SN_ELEMENT* FirstElement() const;

  /*
  Returns:
    The active element with the biggest serial number,
    or null if the list is empty.
  Restrictions:
    The returned pointer may become invalid after any
    subsequent calls to any function in this class.  
    If you need to save information in the returned
    SN_ELEMENT for future use, you must copy the 
    information into storage you are managing.

    You may change the value of the SN_ELEMENT's m_value
    field.  You must NEVER change any other SN_ELEMENT
    fields or you will break searching and possibly cause
    crashes.
  */
  struct SN_ELEMENT* LastElement() const;

  /*
  Parameters:
    sn - [in] serial number to search for.
  Returns:
    If the serial number is active, a pointer to
    its element is returned.
  Restrictions:
    The returned pointer may become invalid after any
    subsequent calls to any function in this class.  
    If you need to save information in the returned
    SN_ELEMENT for future use, you must copy the 
    information into storage you are managing.

    You may change the value of the SN_ELEMENT's m_value
    field.  You must NEVER change any other SN_ELEMENT
    fields or you will break searching and possibly cause
    crashes.
  */
  struct SN_ELEMENT* FindSerialNumber(unsigned int sn) const;

  /*
  Parameters:
    id - [in] id number to search for.
  Returns:
    If the id is active, a pointer to
    its element is returned.
  Restrictions:
    The returned pointer may become invalid after any
    subsequent calls to any function in this class.  
    If you need to save information in the returned
    SN_ELEMENT for future use, you must copy the 
    information into storage you are managing.

    You may change the value of the SN_ELEMENT's m_value
    field.  You must NEVER change any other SN_ELEMENT
    fields or you will break searching and possibly cause
    crashes.
  */
  struct SN_ELEMENT* FindId(ON_UUID) const;

  /*
  Description:
    Add a serial number to the map.
  Parameters:
    sn - [in] serial number to add.
  Returns:
    If the serial number is valid (>0), a pointer to its
    element is returned.  When a new element is added, 
    every byte of the m_value field is set to 0.
    If the serial number was already active, its element is
    also returned.  If you need to distinguish between new
    and previously existing elements, then change  
    m_value.m_u_type to something besides 0 after you add
    a new serial number.  The id associated with this
    serial number will be zero and cannot be found using
    FindId().
  Restrictions:
    The returned pointer may become invalid after any
    subsequent calls to any function in this class.  
    If you need to save information in the returned
    SN_ELEMENT for future use, you must copy the 
    information into storage you are managing.

    You may change the value of the SN_ELEMENT's m_value
    field.  You must NEVER change any other SN_ELEMENT
    fields or you will break searching and possibly cause
    crashes.
  */
  struct SN_ELEMENT* AddSerialNumber(unsigned int sn);

  /*
  Parameters:
    sn - [in] serial number to add.
    id - [in] suggested id to add. If id is zero or
              already in use, another id will be assigned
              to the element.
  Returns:
    If the serial number is valid (>0), a pointer to its
    element is returned.  When a new element is added, 
    every byte of the m_value field is set to 0.
    If the serial number was already active, its element is
    also returned.  If you need to distinguish between new
    and previously existing elements, then change  
    m_value.m_u_type to something besides 0 after you add
    a new serial number. 
    If the id parameter is zero, then a new uuid is created
    and added. If the id parameter is non zero but is active
    on another element, a new uuid is created and added.
    You can inspect the value of m_id on the returned element
    to determine the id AddSerialNumberAndId() assigned to
    the element.
  Restrictions:
    The returned pointer may become invalid after any
    subsequent calls to any function in this class.  
    If you need to save information in the returned
    SN_ELEMENT for future use, you must copy the 
    information into storage you are managing.

    You may change the value of the SN_ELEMENT's m_value
    field.  You must NEVER change any other SN_ELEMENT
    fields or you will break searching and possibly cause
    crashes.
  */
  struct SN_ELEMENT* AddSerialNumberAndId(unsigned int sn, ON_UUID id);

  /*
  Parameters:
    sn - [in] serial number of the element to remove.
  Returns:
    If the serial number was active, it is removed
    and a pointer to its element is returned.  If
    the element's id was active, the id is also removed.
  Restrictions:
    The returned pointer may become invalid after any
    subsequent calls to any function in this class.  
    If you need to save information in the returned
    SN_ELEMENT for future use, you must copy the 
    information into storage you are managing.

    You may change the value of the SN_ELEMENT's m_value
    field.  You must NEVER change any other SN_ELEMENT
    fields or you will break searching and possibly cause
    crashes.
  */
  struct SN_ELEMENT* RemoveSerialNumberAndId(unsigned int sn);

  /*
  Parameters:
    sn - [in] If > 0, this is the serial number
              of the element with the id. If 0, the
              field is ignored.
    id - [in] id to search for.
  Returns:
    If the id was active, it is removed and a pointer
    to its element is returned.  The element's serial
    remains active. To remove both the id and serial number,
    use RemoveSerialNumberAndId().
  Restrictions:
    The returned pointer may become invalid after any
    subsequent calls to any function in this class.  
    If you need to save information in the returned
    SN_ELEMENT for future use, you must copy the 
    information into storage you are managing.

    You may change the value of the SN_ELEMENT's m_value
    field.  You must NEVER change any other SN_ELEMENT
    fields or you will break searching and possibly cause
    crashes.
  */
  struct SN_ELEMENT* RemoveId(unsigned int sn, ON_UUID id);

  /*
  Description:
    Finds all the elements whose serial numbers are
    in the range sn0 <= sn <= sn1 and appends them
    to the elements[] array.  If max_count > 0, it
    specifies the maximum number of elements to append.
  Parameters:
    sn0 - [in]
      Minimum serial number.
    sn1 - [in]
      Maximum serial number
    max_count - [in]
      If max_count > 0, this parameter specifies the
      maximum number of elements to append.
    elements - [out]
      Elements are appended to this array
  Returns:
    Number of elements appended to elements[] array.
  Remarks:
    When many elements are returned, GetElements() can be
    substantially faster than repeated calls to FindElement().
  */
  size_t GetElements(
          unsigned int sn0,
          unsigned int sn1, 
          size_t max_count,
          ON_SimpleArray<SN_ELEMENT>& elements
          ) const;

  /*
  Description:
    Empties the list.
  */
  void EmptyList();

  /*
  Description:
    Returns true if the map is valid.  Returns false if the
    map is not valid.  If an error is found and textlog
    is not null, then a description of the problem is sent
    to textlog.
  Returns:
    true if the list if valid.
  */
  bool IsValid(ON_TextLog* textlog) const;

  void Dump(ON_TextLog& text_log) const;

private:
  // prohibit copy construction and operator=
  // no implementation
  ON_SerialNumberMap(const ON_SerialNumberMap&);
  ON_SerialNumberMap& operator=(const ON_SerialNumberMap&);

  enum
  {
    // These numbers are chosen so the ON_SerialNumberMap
    // will be computationally efficient for up to
    // 10 million entries.
    SN_BLOCK_CAPACITY = 8192,
    SN_PURGE_RATIO = 16,
    ID_HASH_TABLE_COUNT = 8192
  };

  struct SN_BLOCK
  {
    size_t m_count;  // used elements in m_sn[]
    size_t m_purged; // number of purged elements in m_sn[]
    unsigned int m_sorted; // 0 = no, 1 = yes
    unsigned int m_sn0; // minimum sn in m_sn[]
    unsigned int m_sn1; // maximum sn in m_sn[]
    struct SN_ELEMENT m_sn[SN_BLOCK_CAPACITY];
    void EmptyBlock();
    void CullBlockHelper();
    void SortBlockHelper();
    bool IsValidBlock(ON_TextLog* textlog,struct SN_ELEMENT*const* hash_table,size_t* active_id_count) const;
    struct SN_ELEMENT* BinarySearchBlockHelper(unsigned int sn);
    static int CompareMaxSN(const void*,const void*);
    size_t ActiveElementEstimate(unsigned int sn0, unsigned int sn1) const;
    void Dump(ON_TextLog&) const;
  };

  unsigned int m_maxsn; // largest sn stored anywhere
  unsigned int m_reserved;

  // All heap used in this class is allocated from this pool.
  ON_MEMORY_POOL* m_pool;

  // Serial Number list counts
  size_t m_sn_count;   // total number of elements                       
  size_t m_sn_purged;  // total number of purged elements

  // ID hash table counts (all ids in the hash table are active)
  bool m_bHashTableIsValid; // true if m_hash_table[] is valid
  size_t m_active_id_count; // number of active ids in the hash table
  ON_UUID m_inactive_id;    // frequently and id is removed and
                            // then added back.  m_inactive_id
                            // records the most recently removed
                            // id so we don't have to waste time
                            // searching the hash table for
                            // an id that is not there.
                            

  // The blocks in m_sn_list[] are alwasy sorted, disjoint,
  // and in increasing order.  m_sn_list is used when
  // m_sn_block0.m_sn[] is not large enough.
  // The sn list is partitioned into blocks to avoid
  // requiring large amounts of contiguous memory for
  // situations with millions of serial numbers.
  struct SN_BLOCK** m_snblk_list;
  size_t m_snblk_list_capacity; // capacity of m_blk_list[]
  size_t m_snblk_list_count;    // used elements in m_snblk_list[]

  // If FindElementHelper() returns a non-null pointer
  // to an element, then m_e_blk points to the SN_BLOCK
  // that contains the returned element.  In all other
  // situations the value in m_e_blk is undefined and
  // m_e_blk must not be dereferenced.
  struct SN_BLOCK* m_e_blk;

  // m_sn_block0 is where the new additions are added.
  // When serial numbers are not added in increasing
  // order, m_sn_block0.m_sn[] may not be sorted.
  SN_BLOCK m_sn_block0;

  struct SN_ELEMENT* FindElementHelper(unsigned int sn);
  void UpdateMaxSNHelper();
  void GarbageCollectHelper();
  size_t GarbageCollectMoveHelper(SN_BLOCK* dst,SN_BLOCK* src);

  // When m_bHashTableIsValid is true, then m_hash_table[i] is 
  // a linked list of elements whose id satisfies 
  // i = HashIndex(&e->m_id).  When m_bHashTableIsValid is false,
  // m_hash_table[] is identically zero.
  struct SN_ELEMENT* m_hash_table[ID_HASH_TABLE_COUNT];
  size_t HashIndex(const ON_UUID*) const;
  void InvalidateHashTableHelper(); // marks table as dirty
  bool RemoveBlockFromHashTableHelper(const struct SN_BLOCK* blk);
  void AddBlockToHashTableHelper(struct SN_BLOCK* blk);
  void BuildHashTableHelper();      // prepares table for use
};


#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#if !defined(ON_OBJECT_HISTORY_INC_)
#define ON_OBJECT_HISTORY_INC_

#if defined(ON_DLL_TEMPLATE)
// This stuff is here because of a limitation in the way Microsoft
// handles templates and DLLs.  See Microsoft's knowledge base 
// article ID Q168958 for details.
#pragma warning( push )
#pragma warning( disable : 4231 )
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray< class ON_Value* >;
#pragma warning( pop )
#endif

class ON_CLASS ON_CurveProxyHistory
{
public:
  // Used to save information needed to create an ON_CurveProxy
  // reference in history records.
  ON_CurveProxyHistory();
  ~ON_CurveProxyHistory();

  ON_ObjRef m_curve_ref;                // from ON_CurveProxy.m_real_curve
  bool      m_bReversed;                // from ON_CurveProxy.m_bReversed
  ON_Interval m_full_real_curve_domain; // from ON_CurveProxy.m_real_curve.Domain()
  ON_Interval m_sub_real_curve_domain;  // from ON_CurveProxy.m_real_curve_domain
  ON_Interval m_proxy_curve_domain;     // from ON_CurveProxy.m_this_domain

  void Destroy();
  bool Write( ON_BinaryArchive& ) const;
  bool Read( ON_BinaryArchive& );
  void Dump( ON_TextLog& ) const;

private:
  ON__UINT8 m_reserved[64];
};

#if defined(ON_DLL_TEMPLATE)
// This stuff is here because of a limitation in the way Microsoft
// handles templates and DLLs.  See Microsoft's knowledge base 
// article ID Q168958 for details.
#pragma warning( push )
#pragma warning( disable : 4231 )
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ON_CurveProxyHistory>;
#pragma warning( pop )
#endif

class ON_CLASS ON_PolyEdgeHistory
{
public:
  // Used to save information needed to create an CRhinoPolyEdge
  // reference in history records.
  ON_PolyEdgeHistory();
  ~ON_PolyEdgeHistory();

  void Destroy();
  bool Write( ON_BinaryArchive& ) const;
  bool Read( ON_BinaryArchive& );
  void Dump( ON_TextLog& ) const;

  ON_ClassArray< ON_CurveProxyHistory > m_segment;
  ON_SimpleArray<double> m_t;
  int m_evaluation_mode;
private:
  ON__UINT8 m_reserved[64];
};

class ON_CLASS ON_HistoryRecord : public ON_Object
{
  ON_OBJECT_DECLARE(ON_HistoryRecord);
public:
  ON_HistoryRecord();
  ~ON_HistoryRecord();

  // The copy constructor and operator= create duplicates
  // of the linked list of ON_Value classes.
  ON_HistoryRecord(const ON_HistoryRecord& src);
  ON_HistoryRecord& operator=(const ON_HistoryRecord& src);

  // virtual ON_Object::IsValid override
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;
  // virtual ON_Object::Dump override
  void Dump( ON_TextLog& ) const;
  // virtual ON_Object::Write override
  ON_BOOL32 Write(ON_BinaryArchive& binary_archive) const;
  // virtual ON_Object::Read override
  ON_BOOL32 Read(ON_BinaryArchive& binary_archive);
  // virtual
  ON_UUID ModelObjectId() const;

  //////////
  // If history becomes invalid, call Destroy()
  void Destroy();

  void DestroyValue( int value_id );

  /*
  Description:
    For setting values.
  Parameters:
    value_id - [in]
      If there a value with the same input
      id exists, the old value is replaced.
    count - [in]
      Number of values
    b - [in]
      array of count bools
    i - [in]
      array of count ints
    x - [in]
      array of count doubles
    p - [in]
      array of count 3d points
    v - [in]
      array of count 3d vectors
    xform - [in]
      array of count xforms
    c - [in]
      array of count colors
    or - [in]
      array of count object references
    g - [in]
      array of count geometry pointers
    u - [in]
      array of uuids
    s - [in]
      string
  */
  bool SetBoolValue(     int value_id, bool b);
  bool SetIntValue(      int value_id, int i);
  bool SetDoubleValue(   int value_id, double x);
  bool SetPointValue(    int value_id, ON_3dPoint p);
  bool SetVectorValue(   int value_id, ON_3dVector v);
  bool SetXformValue(    int value_id, ON_Xform xform);
  bool SetColorValue(    int value_id, ON_Color c);
  bool SetObjRefValue(   int value_id, const ON_ObjRef& oref);
  bool SetPointOnObjectValue( int value_id, const ON_ObjRef& oref, ON_3dPoint point );
  bool SetUuidValue(     int value_id, ON_UUID uuid );
  bool SetStringValue(   int value_id, const wchar_t* s );
  bool SetGeometryValue( int value_id, ON_Geometry* g);
  bool SetPolyEdgeValue( int value_id, const ON_PolyEdgeHistory& polyedge );

  /*
  Description:
    For setting values.
  Parameters:
    value_id - [in]
      If there a value with the same input
      id exists, the old value is replaced.
    count - [in]
      Number of values
    b - [in]
      array of count bools
    i - [in]
      array of count ints
    x - [in]
      array of count doubles
    P - [in]
      array of count 3d points
    V - [in]
      array of count 3d vectors
    xform - [in]
      array of count xforms
    c - [in]
      array of count colors
    or - [in]
      array of count object references
    g - [in]
      array of count geometry pointers
    u - [in]
      array of uuids
    s - [in]
      array of strings
  */
  bool SetBoolValues(     int value_id, int count, const bool* b);
  bool SetIntValues(      int value_id, int count, const int* i);
  bool SetDoubleValues(   int value_id, int count, const double* x);
  bool SetPointValues(    int value_id, int count, const ON_3dPoint* P);
  bool SetVectorValues(   int value_id, int count, const ON_3dVector* V);
  bool SetXformValues(    int value_id, int count, const ON_Xform* xform);
  bool SetColorValues(    int value_id, int count, const ON_Color* c);
  bool SetObjRefValues(   int value_id, int count, const ON_ObjRef* oref);
  bool SetUuidValues(     int value_id, int count, const ON_UUID* u );
  bool SetStringValues(   int value_id, int count, const wchar_t* const* s );
  bool SetStringValues(   int value_id, const ON_ClassArray<ON_wString>& s );
  bool SetGeometryValues( int value_id, const ON_SimpleArray<ON_Geometry*> a);
  bool SetPolyEdgeValues( int value_id, int count, const ON_PolyEdgeHistory* a );

  /*
  Description:
    For retrieving values.
  */
  bool GetStringValue( int value_id, ON_wString& str ) const;
  bool GetBoolValue( int value_id, bool* b ) const;
  bool GetIntValue( int value_id, int* i ) const;
  bool GetDoubleValue( int value_id, double* number ) const;
  bool GetPointValue( int value_id, ON_3dPoint& point ) const;
  bool GetVectorValue( int value_id, ON_3dVector& point ) const;
  bool GetXformValue( int value_id, ON_Xform& point ) const;
  bool GetColorValue( int value_id, ON_Color* color ) const;
  bool GetObjRefValue( int value_id, ON_ObjRef& oref ) const;
  bool GetPointOnObjectValue( int value_id, ON_ObjRef& oref ) const;
  bool GetCurveValue( int value_id, const ON_Curve*& ) const;
  bool GetSurfaceValue( int value_id, const ON_Surface*& ) const;
  bool GetBrepValue( int value_id, const ON_Brep*& ) const;
  bool GetMeshValue( int value_id, const ON_Mesh*& ) const;
  bool GetGeometryValue( int value_id, const ON_Geometry*& ) const;
  bool GetUuidValue( int value_id, ON_UUID* uuid ) const;
  bool GetPolyEdgeValue( int value_id, const ON_PolyEdgeHistory*& polyedge ) const;

  int GetStringValues( int value_id, ON_ClassArray<ON_wString>& string ) const;
  int GetBoolValues( int value_id, ON_SimpleArray<bool>& ) const;
  int GetIntValues( int value_id, ON_SimpleArray<int>& ) const;
  int GetDoubleValues( int value_id, ON_SimpleArray<double>& ) const;
  int GetPointValues( int value_id, ON_SimpleArray<ON_3dPoint>& ) const;
  int GetVectorValues( int value_id, ON_SimpleArray<ON_3dVector>& ) const;
  int GetXformValues( int value_id, ON_SimpleArray<ON_Xform>& ) const;
  int GetColorValues( int value_id, ON_SimpleArray<ON_Color>& ) const;
  int GetObjRefValues( int value_id, ON_ClassArray<ON_ObjRef>& objects ) const;
  int GetGeometryValues( int value_id, ON_SimpleArray<const ON_Geometry*>& ) const;
  int GetUuidValues( int value_id, ON_SimpleArray<ON_UUID>& ) const;
  int GetPolyEdgeValues( int value_id, ON_SimpleArray<const ON_PolyEdgeHistory*>& ) const;

  /*
  Desccription:
    Determine if object is an antecedent (input) in this
    history record.
  Parameters:
    object_uuid - [in] 
  Returns:
    Returns true if object_uuid is the id of an input
    object.
  */
  bool IsAntecedent( ON_UUID object_uuid ) const;


  /*
  Description:
    Print a list of the values in text_log.
  Parameters:
    text_log - [in]
  Returns:
    Number of values listed.
  */
  int ValueReport( ON_TextLog& text_log ) const;

  // CRhinoCommand::CommandId() value of the command that
  // created this history record.  Each time the command
  // is run, it can create a history record.
  ON_UUID m_command_id;

  // A YYYYMMDDn version number that gets updated when
  // a command changes.  This version is checked so that
  // new versions of a command's ReplayHistory don't 
  // attempt to use information saved in old files.
  int m_version;

  enum RECORD_TYPE
  {
    history_parameters = 0, // parameters for UpdateHistory
    feature_parameters = 1, // parameters for a feature
    force_32bit_record_type = 0xFFFFFFFF
  };

  RECORD_TYPE m_record_type;

  /*
  Description:
    Convert integer into an ON_HistoryRecord::RECORD_TYPE.
  Parameters:
    i - [in]
  Returns:
    ON_HistoryRecord::RECORD_TYPE enum with same value as i.
  */
  static
  RECORD_TYPE RecordType(int i);

  // Each history record has a unique id that is assigned
  // when the record is added to Rhino's history record table.
  ON_UUID m_record_id;

  // List of object id values of antecedent objects that 
  // are referenced in the list of input events in m_value[].
  // These were the command's "input" objects.
  ON_UuidList m_antecedents;

  // List of object id values of descendant objects that 
  // were created.  These were the command's "output" objects 
  ON_UuidList m_descendants;

  // Information needed to update the descendant objects
  // when an antecedent object is modified.
  ON_SimpleArray< class ON_Value* > m_value;

  /*
  Description:
    This tool is used in rare situations when the object ids 
    stored in the uuid list need to be remapped.
  Parameters:
    uuid_remap - [in]
      Is it critical that uuid_remap[] be sorted with respect
      to ON_UuidPair::CompareFirstUuid.
  */
  void RemapObjectIds( const ON_SimpleArray<ON_UuidPair>& uuid_remap );

private:
  bool m_bValuesSorted;
  ON_Value* FindValueHelper( int, int, bool ) const;
  void CopyHelper( const ON_HistoryRecord&);
};


#endif
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/


#if !defined(OPENNURBS_EXTENSIONS_INC_)
#define OPENNURBS_EXTENSIONS_INC_

/*
Description:
  Used to store user data information in an ONX_Model.
*/
class ON_CLASS ONX_Model_UserData
{
public:
#if defined(ON_DLL_EXPORTS) || defined(ON_DLL_IMPORTS)
  // See comments at the top of opennurbs_extensions.cpp for details.

  // new/delete
  void* operator new(size_t);
  void  operator delete(void*);

  // array new/delete
  void* operator new[] (size_t);
  void  operator delete[] (void*);

  // in place new/delete
  void* operator new(size_t,void*);
  void  operator delete(void*,void*);
#endif

  ONX_Model_UserData();
  ~ONX_Model_UserData();
  ONX_Model_UserData(const ONX_Model_UserData&);
  ONX_Model_UserData& operator=(const ONX_Model_UserData&);

  ON_UUID  m_uuid;
  ON_3dmGoo m_goo;

private:
  void Destroy();
  unsigned int* m_ref_count; // reference counts used to avoid expensive object copying

public:
  int m_usertable_3dm_version ;
  int m_usertable_opennurbs_version;
};

/*
Description:
  Used to store geometry table object definition and attributes in an ONX_Model.
*/
class ON_CLASS ONX_Model_Object
{
public:
#if defined(ON_DLL_EXPORTS) || defined(ON_DLL_IMPORTS)
  // See comments at the top of opennurbs_extensions.cpp for details.

  // new/delete
  void* operator new(size_t);
  void  operator delete(void*);

  // array new/delete
  void* operator new[] (size_t);
  void  operator delete[] (void*);

  // in place new/delete
  void* operator new(size_t,void*);
  void  operator delete(void*,void*);
#endif

  ONX_Model_Object();
  ~ONX_Model_Object();
  ONX_Model_Object(const ONX_Model_Object&);
  ONX_Model_Object& operator=(const ONX_Model_Object&);

  void Dump( ON_TextLog& ) const;

  // If m_bDeleteObject is true, then m_object will be deleted when
  // the last ONX_Model_Object that refers to it is destroyed.  The
  // default value of m_bDeleteObject is false.
  bool m_bDeleteObject;
  const ON_Object* m_object;
  ON_3dmObjectAttributes m_attributes;

private:
  void Destroy();
  unsigned int* m_ref_count; // reference counts used to avoid expensive object copying
};

/*
Description:
  Used to store render light table light definition and attributes in an ONX_Model.
*/
class ON_CLASS ONX_Model_RenderLight
{
public:
#if defined(ON_DLL_EXPORTS) || defined(ON_DLL_IMPORTS)
  // See comments at the top of opennurbs_extensions.cpp for details.

  // new/delete
  void* operator new(size_t);
  void  operator delete(void*);

  // array new/delete
  void* operator new[] (size_t);
  void  operator delete[] (void*);

  // in place new/delete
  void* operator new(size_t,void*);
  void  operator delete(void*,void*);
#endif

  ONX_Model_RenderLight();
  ~ONX_Model_RenderLight();
  ONX_Model_RenderLight(const ONX_Model_RenderLight&);
  ONX_Model_RenderLight& operator=(const ONX_Model_RenderLight&);

  ON_Light m_light;
  ON_3dmObjectAttributes m_attributes;
};

#if defined(ON_DLL_TEMPLATE)
// This stuff is here because of a limitation in the way Microsoft
// handles templates and DLLs.  See Microsoft's knowledge base 
// article ID Q168958 for details.
#pragma warning( push )
#pragma warning( disable : 4231 )

ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_Bitmap*>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ON_Linetype>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ObjectArray<ON_Linetype>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ON_Layer>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ObjectArray<ON_Layer>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ON_Group>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ObjectArray<ON_Group>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ON_Font>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ObjectArray<ON_Font>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ON_DimStyle>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ObjectArray<ON_DimStyle>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ONX_Model_RenderLight>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ON_HatchPattern>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ObjectArray<ON_HatchPattern>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ON_InstanceDefinition>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ObjectArray<ON_InstanceDefinition>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ONX_Model_Object>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ONX_Model_UserData>;
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_HistoryRecord*>;

#pragma warning( pop )
#endif


/*
Description:
  Pedegodgical example of all the things in an OpenNURBS 3dm archive.
  The openNURBS examples use ONX_Model to store the information
  read from 3dm archives.  Please study example_read.cpp for
  details.
*/
class ON_CLASS ONX_Model
{
public:
#if defined(ON_DLL_EXPORTS) || defined(ON_DLL_IMPORTS)
  // See comments at the top of opennurbs_extensions.cpp for details.

  // new/delete
  void* operator new(size_t);
  void  operator delete(void*);

  // array new/delete
  void* operator new[] (size_t);
  void  operator delete[] (void*);

  // in place new/delete
  void* operator new(size_t,void*);
  void  operator delete(void*,void*);
#endif

  ONX_Model();
  virtual ~ONX_Model();

  /*
  Description:
    Destroys contents of this model and leaves it ready to be reused.
  */
  void Destroy();

  /*
  Description:
    Reads an openNURBS archive and saves the information in this model
  Parameters:
    archive - [in] archive to read from
    error_log - [out] any archive reading errors are logged here.
  Returns:
    true if archive is read with no error.  False if errors occur.
    Error details are logged in error_log.  If crc errors are in
    the archive, then m_crc_error_count is set to the number of
    errors.
  Example:

            // for ASCII file names
            const char* sFileName = ....;
            FILE* fp = ON::OpenFile( sFileName, "rb");

            // for UNICODE file names
            const wchar_t* wsFileName = ....;
            FILE* fp = ON::OpenFile( wsFileName, L"rb");

            bool bModelRead = false;
            bool bModelIsValid = false;

            ON_TextLog error_log;
            ONX_Model model;

            if ( 0 != fp )
            {
              ON_BinaryFile archive( ON::read3dm, fp );
              bModelRead = model.read( archive, error_log );
              ON::CloseFile( fp );
            }

            if ( bModelRead )
            {
              bModelIsValid = model.Validate(error_log);
            }

  See Also:
    ONX_Model::IsValid
    ONX_Model::Write
    ONX_Model::m_crc_error_count
  */
  bool Read( 
         ON_BinaryArchive& archive,
         ON_TextLog* error_log = NULL
         );

  bool Read( 
         const char* filename,
         ON_TextLog* error_log = NULL
         );

  bool Read( 
         const wchar_t* filename,
         ON_TextLog* error_log = NULL
         );

  /*
  Description:
    Writes contents of this model to an openNURBS archive.
    It is a good practice to call Polish() before calling 
    Write so that your file has all the "fluff" that makes it
    complete.  If the model is not valid, then Write will refuse
    to write it.

  Parameters:
    archive - [in]
      archive to write to

    version - [in] 
      Version of the openNURBS archive to write.
        0 default value and suggested.
           When 0 is passed in, the value of ON_BinaryArchive::CurrentArchiveVersion()
           is used.
        2, 3, 4
          If you pass in one of these values, some information 
          in current data structures will not be saved in the
          file. 
          Rhino 2.x can read version 2 files.
          Rhino 3.x can read version 2 and 3 files.
          Rhino 4.x can read version 2, 3 and 4 files.
          Rhino 5.x can read version 2, 3, 4, 5 and 50 files.
          Rhino 5.x writes version 50 files.

    sStartSectionComment - [in] 
      Brief desciption of your app, today's date, etc.

    error_log - [out]
      any archive writing errors are logged here.

  Returns:
    True if archive is written with no error. 
    False if errors occur.
    Error details are logged in error_log.

  Example:

            model = ...;

            model.Polish(); // fill in defaults as needed.

            ON_TextLog error_log;
            if ( !model.IsValid( error_log ) )
            {
              // try to repair the model
              model.Audit(true);
            }

            if ( model.IsValid( error_log ) )
            {

              // for ASCII file names
              const char* sFileName = ....;
              FILE* fp = ON::OpenFile( sFileName, "wb");

              // for UNICODE file names
              const wchar_t* wsFileName = ....;
              FILE* fp = ON::OpenFile( wsFileName, L"wb");

              bool ok = false;
              if ( 0 != fp )
              {
                const char* sStartSectionComment = "...";
                int version = 5; // 2, 3, 4 or 5 are valid
                ON_BinaryFile archive( ON::write3dm, fp );
                ok = model.write( archive, 
                                  version, 
                                  sStartSectionComment, 
                                  error_log );
                ON::CloseFile( fp );
              }
           }

  See Also:
    ONX_Model::Polish
    ONX_Model::IsValid
    ONX_Model::Read
  */
  bool Write( 
         ON_BinaryArchive& archive,
         int version = 0,
         const char* sStartSectionComment = NULL,
         ON_TextLog* error_log = NULL
         );

  bool Write( 
         const char* filename,
         int version = 0,
         const char* sStartSectionComment = NULL,
         ON_TextLog* error_log = NULL
         );

  bool Write( 
         const wchar_t* filename,
         int version = 0,
         const char* sStartSectionComment = NULL,
         ON_TextLog* error_log = NULL
         );

  /*
  Description:
    Check a model to make sure it is valid.
  Parameters:
    text_log - [in] if not NULL and errors are found,
                    a description of the problem is put in
                    this text_log.
  Returns:
    True if the model is valid.
  */
  bool IsValid( ON_TextLog* text_log = NULL ) const;

  /*
  Description:
    Quickly fills in the little details, like making sure there is 
    at least one layer and table indices make sense.  
    For a full blown check and repair, call Audit(true).
  See Also:
    ONX_Model::Audit
  */
  virtual
  void Polish();

  /*
  Description:
    Check a model to make sure it is valid and, if possible
    and requrested, attempt to repair.
  Parameters:
    bAttemptRepair - [in] if true and a problem is found,
         the problem is repaired.
    repair_count - [out] number of successful repairs.
    text_log - [in] if not NULL and errors are found,
                    a description of the problem is put in
                    this text_log.
    warnings - [out]
        If problems were found, warning ids are appended to this list.
          @untitled table
           1      m_material_table[] flaws
           2      layer table is not perfect.
           3      some m_object_table[].m_attributes.m_uuid was nil or not unique.
           4      some m_object_table[].IsValid() is false
           5      some m_idef_table[] has an invalid or duplicate name
           6      warning some m_idef_table[].m_object_uuid[] is not valid
           7      warning some m_object_table[].m_object is null
           8      warning some m_object_table[].m_object->IsValid() is false
           9      warning some m_object_table[].m_attributes is not valid
          10      linetype table is not perfect.
          11      lineset table is not perfect.
          12      some m_idef_table[].m_uuid was nil or not unique.
          13      some m_texture_mapping_table[i].m_mapping_id was nil or not unique.
          14      some m_material_table[i].m_material_id was nil or not unique.
          15      some m_light_table[i].m_light_id was nil or not unique.
  Returns:
    True if model is valid and false if the model has serious 
    @untitled table
    <0      model has serious errors
    =0      model is ok
    >0      number of problems that were found.
  */
  virtual
  int Audit( 
        bool bAttemptRepair,
        int* repair_count,
        ON_TextLog* text_log,
        ON_SimpleArray<int>* warnings
        );

  /////////////////////////////////////////////////////////////////////
  //
  // BEGIN model definitions
  //

  // start section information
  int m_3dm_file_version;
  int m_3dm_opennurbs_version;
  ON_String m_sStartSectionComments;

  // Properties include revision history, notes, information about
  // the applicaton that created the file, and an option preview image.
  ON_3dmProperties m_properties;

  // Settings include tolerance, and unit system, and defaults used
  // for creating views and objects.
  ON_3dmSettings   m_settings;

  // Tables in an openNURBS archive
  ON_SimpleArray<ON_Bitmap*>            m_bitmap_table;
  ON_ObjectArray<ON_TextureMapping>     m_mapping_table;
  ON_ObjectArray<ON_Material>           m_material_table;
  ON_ObjectArray<ON_Linetype>           m_linetype_table;
  ON_ObjectArray<ON_Layer>              m_layer_table;
  ON_ObjectArray<ON_Group>              m_group_table;
  ON_ObjectArray<ON_Font>               m_font_table;
  ON_ObjectArray<ON_DimStyle>           m_dimstyle_table;
  ON_ClassArray<ONX_Model_RenderLight>  m_light_table;
  ON_ObjectArray<ON_HatchPattern>       m_hatch_pattern_table;
  ON_ObjectArray<ON_InstanceDefinition> m_idef_table;
  ON_ClassArray<ONX_Model_Object>       m_object_table;
  ON_SimpleArray<ON_HistoryRecord*>     m_history_record_table;
  ON_ClassArray<ONX_Model_UserData>     m_userdata_table;

  // The id index fields are used to lookup objects by id
  ON_UuidIndexList m_mapping_id_index;
  ON_UuidIndexList m_material_id_index;
  ON_UuidIndexList m_object_id_index;
  ON_UuidIndexList m_idef_id_index;

  // length of archive returned by ON_BinaryArchive::Read3dmEndMark()
  size_t m_file_length;

  // Number of crc errors found during archive reading.
  // If > 0, then the archive is corrupt.
  int m_crc_error_count;

  //
  // END model definitions
  //
  /////////////////////////////////////////////////////////////////////

  /*
  Returns:
    Bounding box of every object in m_object_table[].
  */
  ON_BoundingBox BoundingBox() const;

  /*
  Description:
    Get render material from object attributes.
  Parameters:
    attributes - [in] object attributes.
    material - [out] render material
  */
  void GetRenderMaterial( 
        const ON_3dmObjectAttributes& attributes,
        ON_Material& material 
        ) const;

  /*
  Description:
    Get render material from object_index.
  Parameters:
    object_index - [in] m_object_table[] index
    material - [out] render material
  */
  void GetRenderMaterial( 
        int object_index,
        ON_Material& material 
        ) const;

  /*
  Description:
    Get linetype from object attributes.
  Parameters:
    attributes - [in] object attributes.
    linetype - [out] linetype
  */
  void GetLinetype( 
        const ON_3dmObjectAttributes& attributes,
        ON_Linetype& linetype 
        ) const;

  /*
  Description:
    Get linetype from object_index.
  Parameters:
    object_index - [in] m_object_table[] index
    linetype - [out] linetype
  */
  void GetLinetype(
        int object_index,
        ON_Linetype& linetype 
        ) const;

  /*
  Description:
    Get wireframe drawing color from object attributes.
  Parameters:
    attributes - [in] object attributes.
  Returns:
    Wireframe drawing color.
  */
  ON_Color WireframeColor(const ON_3dmObjectAttributes& attributes) const;

  /*
  Description:
    Get wireframe drawing color from object attributes.
  Parameters:
    object_index - [in] m_object_table[] index
  Returns:
    Wireframe drawing color.
  */
  ON_Color WireframeColor(int object_index) const;

  /* 
  Description:
    Get index of object in m_object_table from object_uuid.
  Parameters:
    object_uuid - [in] object uuid.
  Returns:
    Index of the object or -1 if it is not found.
  */
  virtual
  int ObjectIndex( 
    ON_UUID object_uuid 
    ) const;

  /* 
  Description:
    Get instance definition from instance definition table.
  Parameters:
    idef_uuid - [in] instance definition uuid.
  Example:

          ON_XModel model = ...;
          ..
          ON_InstanceRef* pIRef = ..;
          ON_UUID idef_uuid = pIRef->m_instance_definition_uuid;
          int idef_index = model.IDefIndex( idef_uuid );
          if ( idef_index >= 0 )
          {
            const ON_InstanceDefinition& idef = model.m_idef_table[idef_index];
            ...
          }

  Returns:
    Index of the instance definition or -1 if it is not found.
  */
  virtual
  int IDefIndex( 
    ON_UUID idef_uuid 
    ) const;

  /* 
  Description:
    Get instance definition index from instance definition name.
  Parameters:
    idef_name - [in] name to search for
  Returns:
    Index of the instance definition or -1 if it is not found.
  */
  virtual
  int IDefIndex( 
    const wchar_t* idef_name
    ) const;

  /* 
  Description:
    Get instance definition name that is not currently in use.
  */
  virtual
  void GetUnusedIDefName( ON_wString& idef_name ) const;

  /* 
  Description:
    See if the instance reference iref refers to an instance
    definition.
  Parameters:
    iref - [in]
    idef_uuid - [in] id of idef we are looking for
  Returns:
    @untitled table
     0         iref does not use idef
     1         iref directly references idef
    >1         iref has a nested reference to idef (nesting depth returned)
    -1         iref.m_instance_definition_uuid is not valid
    -2         invalid idef found
  */
  virtual
  int UsesIDef( 
        const ON_InstanceRef& iref,
        ON_UUID idef_uuid
        ) const;

  /* 
  Description:
    Get layer definition from layer table.
  Parameters:
    layer_name - [in] name to search for
  Example:

          ON_XModel model = ...;
          ..
          ON_InstanceRef* pIRef = ..;
          ON_UUID idef_uuid = pIRef->m_instance_definition_uuid;
          int layer_index = model.IDefIndex( idef_uuid );
          if ( idef_index >= 0 )
          {
            const ON_InstanceDefinition& idef = model.m_idef_table[idef_index];
            ...
          }

  Returns:
    Index of the layer or -1 if it is not found.
  */
  virtual
  int LayerIndex( 
    const wchar_t* layer_name
    ) const;

  /* 
  Description:
    Get layer name that is not currently in use.
  */
  virtual
  void GetUnusedLayerName( ON_wString& layer_name ) const;

  /////////////////////////////////////////////////////////////////////
  //
  // BEGIN model document level user string tools
  //

  /*
  Description:
    Attach a user string to the document.
  Parameters:
    key - [in] id used to retrieve this string.
    string_value - [in] 
      If NULL, the string with this id will be removed.
  Returns:
    True if successful.
  */
  bool SetDocumentUserString( 
    const wchar_t* key, 
    const wchar_t* string_value 
    );

  /*
  Description:
    Get user string from the document.
  Parameters:
    key - [in] id used to retrieve the string.
    string_value - [out]
  Returns:
    True if a string with id was found.
  */
  bool GetDocumentUserString( 
    const wchar_t* key, 
    ON_wString& string_value 
    ) const;

  /*
  Description:
    Get a list of all user strings in the document.
  Parameters:
    user_strings - [out]
      user strings are appended to this list.
  Returns:
    Number of elements appended to the user_strings list.
  */
  int GetDocumentUserStrings( ON_ClassArray<ON_UserString>& user_strings ) const;

  //
  // END model document level user string tools
  //
  /////////////////////////////////////////////////////////////////////


  /////////////////////////////////////////////////////////////////////
  //
  // BEGIN model text dump tools
  //

  // text dump of entire model
  void Dump( ON_TextLog& ) const;
  
  // text dump of model properties and settings
  void DumpSummary( ON_TextLog& ) const;

  // text dump of bitmap table
  void DumpBitmapTable( ON_TextLog& ) const; 

  // text dump of texture mapping table
  void DumpTextureMappingTable( ON_TextLog& ) const; 

  // text dump of render material table
  void DumpMaterialTable( ON_TextLog& ) const; 

  // text dump of line type table
  void DumpLinetypeTable( ON_TextLog& ) const; 

  // text dump of layer table
  void DumpLayerTable( ON_TextLog& ) const;

  // text dump of light table
  void DumpLightTable( ON_TextLog& ) const;

  // text dump of group table
  void DumpGroupTable( ON_TextLog& ) const;

  // text dump of font table
  void DumpFontTable( ON_TextLog& ) const;

  // text dump of dimstyle table
  void DumpDimStyleTable( ON_TextLog& ) const;

  // text dump of hatch pattern table
  void DumpHatchPatternTable( ON_TextLog& ) const;

  // text dump of instance definition table
  void DumpIDefTable( ON_TextLog& ) const;

  // text dump of object table
  void DumpObjectTable( ON_TextLog& ) const;

  // text dump of object table
  void DumpHistoryRecordTable( ON_TextLog& ) const;

  // text dump of user data table
  void DumpUserDataTable( ON_TextLog& ) const;

  //
  // END model text dump tools
  //
  /////////////////////////////////////////////////////////////////////

  /*
  Description:
    Destroys cached searching and bounding box information.  Call
    if you modify the m_object_table or m_idef_table.
  */
  void DestroyCache();

  /////////////////////////////////////////////////////////////////////
  //
  // BEGIN Render Development Toolkit (RDK) information
  //
  static bool IsRDKDocumentInformation(const ONX_Model_UserData& docud);
  static bool GetRDKDocumentInformation(const ONX_Model_UserData& docud,ON_wString& rdk_xml_document_data);

  static bool IsRDKObjectInformation(const ON_UserData& objectud);
  static bool GetRDKObjectInformation(const ON_Object& object,ON_wString& rdk_xml_object_data);
  //
  // END Render Development Toolkit (RDK) information
  //
  /////////////////////////////////////////////////////////////////////


private:
  // prohibit use of copy construction and operator=
  ONX_Model(const ONX_Model&);
  ONX_Model& operator=(const ONX_Model&);

private:

  // This bounding box contains all objects in the object table.
  ON_BoundingBox m__object_table_bbox;
};

/*
Description:
  Tests a string to see if it is valid as a name for a layer,
  object, material, linetype, instance definition, etc.
Parameters:
  name - [in] string to test
Returns:
  True if the string is a valid name.
*/
ON_DECL
bool ONX_IsValidName( 
          const wchar_t* name 
          );

#endif
#endif
